# example.com/pgo/devirtualize.test
_testmain.go:59:24: PGO devirtualize considering call testing.MainStart(testdeps.TestDeps{}, tests, benchmarks, fuzzTargets, examples)
{"Pkg":"main","Pos":"_testmain.go:59:24","Caller":"main.main","Direct":true,"Interface":false,"Weight":0,"Hottest":"testing.MainStart","HottestWeight":0,"Devirtualized":"","DevirtualizedWeight":0}
_testmain.go:61:15: PGO devirtualize considering call (*testing.M).Run(m)
{"Pkg":"main","Pos":"_testmain.go:61:15","Caller":"main.main","Direct":true,"Interface":false,"Weight":0,"Hottest":"os.Exit","HottestWeight":0,"Devirtualized":"","DevirtualizedWeight":0}
_testmain.go:61:9: PGO devirtualize considering call os.Exit((*testing.M).Run(m))
{"Pkg":"main","Pos":"_testmain.go:61:9","Caller":"main.main","Direct":true,"Interface":false,"Weight":0,"Hottest":"os.Exit","HottestWeight":0,"Devirtualized":"","DevirtualizedWeight":0}
hot-callsite-thres-from-CDF=0.6765899864682002
hot-cg before inline in dot format:
digraph G {
forcelabels=true;
"main.init" [color=black, style=solid, label="main.init"];
"main.init.0" [color=black, style=solid, label="main.init.0"];
"main.main" [color=black, style=solid, label="main.main"];
"testing.MainStart" [color=black, style=solid, label="testing.MainStart,inl_cost=72"];
"os.Exit" [color=black, style=solid, label="os.Exit"];
"testing.(*M).Run" [color=black, style=solid, label="testing.(*M).Run"];
edge [color=black, style=solid];
"main.main" -> "testing.MainStart" [label="0.00"];
edge [color=black, style=solid];
"main.main" -> "os.Exit" [label="0.00"];
edge [color=black, style=solid];
"main.main" -> "testing.(*M).Run" [label="0.00"];
}
_testmain.go:51:6: can inline init.0 with cost 3 as: func() { testdeps.ImportPath = "example.com/pgo/devirtualize" }
_testmain.go:57:6: cannot inline main: function too complex: cost 202 exceeds budget 80
_testmain.go:59:24: inlining call to testing.MainStart
_testmain.go:59:24: &testing.M{...} escapes to heap:
_testmain.go:59:24:   flow: ~r0 = &{storage for &testing.M{...}}:
_testmain.go:59:24:     from &testing.M{...} (spill) at _testmain.go:59:24
_testmain.go:59:24:     from ~r0 = &testing.M{...} (assign-pair) at _testmain.go:59:24
_testmain.go:59:24:   flow: m = ~r0:
_testmain.go:59:24:     from m := ~r0 (assign) at _testmain.go:59:4
_testmain.go:59:24:   flow: {heap} = m:
_testmain.go:59:24:     from (*testing.M).Run(m) (call parameter) at _testmain.go:61:15
_testmain.go:59:42: testdeps.TestDeps{} escapes to heap:
_testmain.go:59:42:   flow: testing.deps = &{storage for testdeps.TestDeps{}}:
_testmain.go:59:42:     from testdeps.TestDeps{} (spill) at _testmain.go:59:42
_testmain.go:59:42:     from testing.deps, testing.tests, testing.benchmarks, testing.fuzzTargets, testing.examples := testdeps.TestDeps{}, tests, benchmarks, fuzzTargets, examples (assign-pair) at _testmain.go:59:24
_testmain.go:59:42:   flow: {storage for &testing.M{...}} = testing.deps:
_testmain.go:59:42:     from testing.M{...} (struct literal element) at _testmain.go:59:24
_testmain.go:59:42: testdeps.TestDeps{} escapes to heap
_testmain.go:59:24: &testing.M{...} escapes to heap
