// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/xzl/work/golang-1.22/golang-1.22/src/runtime/testdata/testprogcgo/cgonoescape.go:1:1
// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

// #cgo noescape annotations for a C function means its arguments won't escape to heap.

// We assume that there won't be 100 new allocated heap objects in other places,
// i.e. runtime.ReadMemStats or other runtime background works.
// So, the tests are:
// 1. at least 100 new allocated heap objects after invoking withoutNoEscape 100 times.
// 2. less than 100 new allocated heap objects after invoking withoutNoEscape 100 times.

/*
// TODO(#56378): #cgo noescape runCWithNoEscape

void runCWithNoEscape(void *p) {
}
void runCWithoutNoEscape(void *p) {
}
*/
import _ "unsafe"

import (
	"fmt"
	"runtime"
	"runtime/debug"
	"unsafe"
)

const num = 100

func init() {
	register("CgoNoEscape", CgoNoEscape)
}

//go:noinline
func withNoEscape() {
	var str string
	func() { _cgoBase0 := /*line :41:36*/&str; _cgo0 := /*line :41:21*/unsafe.Pointer(_cgoBase0); _cgoCheckPointer(_cgoBase0, 0 == 0); /*line :41:42*/_Cfunc_runCWithNoEscape(_cgo0); }()
}

//go:noinline
func withoutNoEscape() {
	var str string
	func() { _cgoBase0 := /*line :47:39*/&str; _cgo0 := /*line :47:24*/unsafe.Pointer(_cgoBase0); _cgoCheckPointer(_cgoBase0, 0 == 0); /*line :47:45*/_Cfunc_runCWithoutNoEscape(_cgo0); }()
}

func CgoNoEscape() {
	// make GC stop to see the heap objects allocated
	debug.SetGCPercent(-1)

	var stats runtime.MemStats
	runtime.ReadMemStats(&stats)
	preHeapObjects := stats.HeapObjects

	for i := 0; i < num; i++ {
		withNoEscape()
	}

	runtime.ReadMemStats(&stats)
	nowHeapObjects := stats.HeapObjects

	if nowHeapObjects-preHeapObjects >= num {
		fmt.Printf("too many heap objects allocated, pre: %v, now: %v\n", preHeapObjects, nowHeapObjects)
	}

	runtime.ReadMemStats(&stats)
	preHeapObjects = stats.HeapObjects

	for i := 0; i < num; i++ {
		withoutNoEscape()
	}

	runtime.ReadMemStats(&stats)
	nowHeapObjects = stats.HeapObjects

	if nowHeapObjects-preHeapObjects < num {
		fmt.Printf("too few heap objects allocated, pre: %v, now: %v\n", preHeapObjects, nowHeapObjects)
	}

	fmt.Println("OK")
}
