From f532bd01e923fb88267190345217371b84d8c3e5 Mon Sep 17 00:00:00 2001
From: hudeng <hudeng@deepin.org>
Date: Tue, 19 Aug 2025 20:03:15 +0800
Subject: [PATCH] feat: deepin add sw64 support

---
 api/go1.16.txt                                |   93 +
 api/go1.18.txt                                |    8 +
 src/cmd/asm/internal/arch/arch.go             |    2 +
 src/cmd/asm/internal/arch/sw64.go             |   95 +
 src/cmd/asm/internal/asm/asm.go               |   20 +
 src/cmd/asm/internal/asm/testdata/sw64.s      |   21 +
 .../cgo/internal/test/issue9400/asm_sw64.s    |   30 +
 .../cgo/internal/testsanitizers/cc_test.go    |    4 +
 src/cmd/cgo/main.go                           |    2 +
 src/cmd/compile/internal/base/flag.go         |    2 +-
 src/cmd/compile/internal/ssa/_gen/SW64.rules  |  815 ++
 src/cmd/compile/internal/ssa/_gen/SW64Ops.go  |  521 +
 src/cmd/compile/internal/ssa/config.go        |   15 +
 .../compile/internal/ssa/debug_lines_test.go  |    2 +-
 src/cmd/compile/internal/ssa/opGen.go         | 3012 +++++-
 src/cmd/compile/internal/ssa/regalloc.go      |    2 +
 src/cmd/compile/internal/ssa/rewriteSW64.go   | 8827 +++++++++++++++++
 src/cmd/compile/internal/ssa/schedule.go      |    2 +-
 src/cmd/compile/internal/ssagen/ssa.go        |   36 +-
 src/cmd/compile/internal/sw64/galign.go       |   28 +
 src/cmd/compile/internal/sw64/ggen.go         |   33 +
 src/cmd/compile/internal/sw64/ssa.go          | 1140 +++
 src/cmd/compile/internal/test/inl_test.go     |    2 +-
 src/cmd/compile/internal/types2/gccgosizes.go |    1 +
 src/cmd/compile/internal/types2/sizes.go      |    3 +-
 src/cmd/compile/main.go                       |    2 +
 src/cmd/dist/build.go                         |   15 +-
 src/cmd/dist/buildruntime.go                  |    1 +
 src/cmd/dist/main.go                          |    8 +
 src/cmd/dist/test.go                          |    8 +-
 src/cmd/dist/udiv_default.s                   |   10 +
 src/cmd/dist/udiv_sw64.s                      |   12 +
 src/cmd/dist/util.go                          |   17 +
 src/cmd/dist/util_gc.go                       |    5 +
 src/cmd/go/internal/cfg/cfg.go                |    1 +
 src/cmd/go/internal/imports/build.go          |    1 +
 src/cmd/go/internal/modindex/syslist.go       |    1 +
 ...chain_v0.0.1-go1.999testmod.linux-sw64.txt |   14 +
 src/cmd/internal/obj/link.go                  |   14 +
 src/cmd/internal/obj/stringer_sw64.go         |  104 +
 src/cmd/internal/obj/sw64/a.out.go            |  502 +
 src/cmd/internal/obj/sw64/anames.go           |  273 +
 src/cmd/internal/obj/sw64/anames77.go         |   30 +
 src/cmd/internal/obj/sw64/asm77.go            | 2179 ++++
 src/cmd/internal/obj/sw64/list77.go           |   89 +
 src/cmd/internal/obj/sw64/obj77.go            | 1075 ++
 src/cmd/internal/obj/util.go                  |    1 +
 src/cmd/internal/objabi/reloctype.go          |   32 +-
 src/cmd/internal/objabi/reloctype_string.go   |   27 +-
 src/cmd/internal/objfile/disasm.go            |   17 +
 src/cmd/internal/objfile/elf.go               |    4 +-
 src/cmd/internal/sys/arch.go                  |   16 +
 src/cmd/link/internal/ld/data.go              |   20 +-
 src/cmd/link/internal/ld/deadcode.go          |   16 +-
 src/cmd/link/internal/ld/elf.go               |   18 +-
 src/cmd/link/internal/ld/pcln.go              |    2 +
 src/cmd/link/internal/ld/target.go            |    4 +
 src/cmd/link/internal/loadelf/ldelf.go        |   20 +
 src/cmd/link/internal/sw64/asm.go             |  712 ++
 src/cmd/link/internal/sw64/l.go               |   17 +
 src/cmd/link/internal/sw64/obj.go             |   62 +
 src/cmd/link/internal/sym/reloc.go            |    2 +
 src/cmd/link/main.go                          |    3 +
 .../golang.org/x/arch/sw64/sw64asm/gnu.go     |   35 +
 .../golang.org/x/arch/sw64/sw64asm/main.go    |  101 +
 .../golang.org/x/arch/sw64/sw64asm/op2str.go  |  377 +
 .../golang.org/x/arch/sw64/sw64asm/rawinst.go |   88 +
 .../golang.org/x/sys/unix/asm_linux_sw64.s    |   55 +
 .../golang.org/x/sys/unix/endian_little.go    |    2 +-
 .../x/sys/unix/syscall_linux_sw64.go          |  158 +
 .../golang.org/x/sys/unix/zerrors_linux.go    |    2 +-
 .../x/sys/unix/zerrors_linux_sw64.go          | 4367 ++++++++
 .../golang.org/x/sys/unix/zsyscall_linux.go   |    2 +-
 .../x/sys/unix/zsyscall_linux_sw64.go         | 2812 ++++++
 .../x/sys/unix/zsysnum_linux_sw64.go          |  383 +
 .../golang.org/x/sys/unix/ztypes_linux.go     |    2 +-
 .../x/sys/unix/ztypes_linux_sw64.go           | 6496 ++++++++++++
 .../go/analysis/passes/asmdecl/asmdecl.go     |   23 +
 src/crypto/cipher/xor_sw64_test.s             |   69 +
 src/crypto/subtle/xor_generic.go              |    2 +-
 src/crypto/subtle/xor_sw64.go                 |   10 +
 src/crypto/subtle/xor_sw64.s                  |   55 +
 src/debug/elf/elf.go                          |  109 +
 src/debug/elf/elf_test.go                     |    1 +
 src/debug/elf/file.go                         |   50 +
 src/encoding/binary/native_endian_little.go   |    2 +-
 src/go/build/syslist.go                       |    1 +
 src/go/types/gccgosizes.go                    |    1 +
 src/go/types/sizes.go                         |    3 +-
 src/hash/crc32/crc32_otherarch.go             |    2 +-
 src/hash/crc32/crc32_sw64.go                  |   50 +
 src/hash/crc32/crc32_sw64.s                   |  103 +
 src/internal/abi/abi_sw64.go                  |   19 +
 src/internal/abi/switch.go                    |    2 +-
 src/internal/buildcfg/cfg.go                  |   14 +
 src/internal/buildcfg/exp.go                  |    2 +-
 src/internal/bytealg/compare_generic.go       |    2 +-
 src/internal/bytealg/compare_native.go        |    2 +-
 src/internal/bytealg/compare_sw64.s           |   93 +
 src/internal/bytealg/count_generic.go         |    2 +-
 src/internal/bytealg/count_native.go          |    2 +-
 src/internal/bytealg/count_sw64.s             |  112 +
 src/internal/bytealg/count_sw64_test.s        |   88 +
 src/internal/bytealg/equal_sw64.s             |   70 +
 src/internal/bytealg/indexbyte_generic.go     |    2 +-
 src/internal/bytealg/indexbyte_native.go      |    2 +-
 src/internal/bytealg/indexbyte_sw64.s         |   63 +
 .../bytealg/indexbyte_sw64_prototype.s        |  130 +
 src/internal/bytealg/indexbyte_sw64_test.s    |  109 +
 src/internal/cfg/cfg.go                       |    1 +
 src/internal/cpu/cpu.go                       |   11 +
 src/internal/cpu/cpu_sw64.go                  |   17 +
 src/internal/goarch/goarch.go                 |    1 +
 src/internal/goarch/goarch_sw64.go            |   16 +
 src/internal/goarch/zgoarch_386.go            |    1 +
 src/internal/goarch/zgoarch_amd64.go          |    1 +
 src/internal/goarch/zgoarch_arm.go            |    1 +
 src/internal/goarch/zgoarch_arm64.go          |    1 +
 src/internal/goarch/zgoarch_arm64be.go        |    1 +
 src/internal/goarch/zgoarch_armbe.go          |    1 +
 src/internal/goarch/zgoarch_loong64.go        |    1 +
 src/internal/goarch/zgoarch_mips.go           |    1 +
 src/internal/goarch/zgoarch_mips64.go         |    1 +
 src/internal/goarch/zgoarch_mips64le.go       |    1 +
 src/internal/goarch/zgoarch_mips64p32.go      |    1 +
 src/internal/goarch/zgoarch_mips64p32le.go    |    1 +
 src/internal/goarch/zgoarch_mipsle.go         |    1 +
 src/internal/goarch/zgoarch_ppc.go            |    1 +
 src/internal/goarch/zgoarch_ppc64.go          |    1 +
 src/internal/goarch/zgoarch_ppc64le.go        |    1 +
 src/internal/goarch/zgoarch_riscv.go          |    1 +
 src/internal/goarch/zgoarch_riscv64.go        |    1 +
 src/internal/goarch/zgoarch_s390.go           |    1 +
 src/internal/goarch/zgoarch_s390x.go          |    1 +
 src/internal/goarch/zgoarch_sparc.go          |    1 +
 src/internal/goarch/zgoarch_sparc64.go        |    1 +
 src/internal/goarch/zgoarch_sw64.go           |   33 +
 src/internal/goarch/zgoarch_wasm.go           |    1 +
 src/internal/platform/supported.go            |    9 +-
 src/internal/platform/zosarch.go              |    2 +
 .../syscall/unix/at_sysnum_fstatat64_linux.go |    2 +-
 .../syscall/unix/getrandom_linux_sw64.go      |    9 +
 .../syscall/unix/sysnum_linux_sw64.go         |   13 +
 src/math/big/arith_sw64.s                     |   35 +
 src/os/endian_little.go                       |    2 +-
 src/reflect/asm_sw64.s                        |   77 +
 src/reflect/float32reg_generic.go             |    2 +-
 src/reflect/float32reg_sw64.s                 |   28 +
 src/reflect/stubs_sw64.go                     |    8 +
 src/runtime/asm_sw64.s                        | 1139 +++
 src/runtime/atomic_sw64.s                     |   13 +
 src/runtime/cgo/asm_sw64.s                    |   80 +
 src/runtime/cgo/gcc_linux_sw64.c              |   82 +
 src/runtime/cgo/gcc_sw64.S                    |  106 +
 src/runtime/cpuflags_sw64.go                  |   17 +
 src/runtime/cputicks.go                       |    2 +-
 src/runtime/defs_linux_amd64.h                |    0
 src/runtime/defs_linux_sw64.go                |  225 +
 src/runtime/duff_sw64.s                       |  909 ++
 src/runtime/gcinfo_test.go                    |    2 +-
 src/runtime/hash64.go                         |    2 +-
 src/runtime/internal/atomic/atomic_sw64.go    |  102 +
 src/runtime/internal/atomic/atomic_sw64.s     |  393 +
 src/runtime/internal/sys/zversion.go          |    3 +
 src/runtime/internal/syscall/asm_linux_sw64.s |   32 +
 .../internal/syscall/defs_linux_sw64.go       |   33 +
 src/runtime/malloc.go                         |    2 +
 src/runtime/memclr_sw64.s                     |   49 +
 src/runtime/memmove_sw64.s                    |  114 +
 src/runtime/memmove_sw64_test.s               |  221 +
 src/runtime/mkduff.go                         |   32 +
 src/runtime/mkpreempt.go                      |   48 +
 src/runtime/mpagealloc_64bit.go               |    2 +-
 src/runtime/os_linux_generic.go               |    2 +-
 src/runtime/os_linux_noauxv.go                |    2 +-
 src/runtime/os_linux_novdso.go                |    2 +-
 src/runtime/os_linux_sw64.go                  |   56 +
 src/runtime/pprof/testdata/test32             |  Bin
 src/runtime/pprof/testdata/test32be           |  Bin
 src/runtime/pprof/testdata/test64             |  Bin
 src/runtime/pprof/testdata/test64be           |  Bin
 src/runtime/preempt_sw64.s                    |  131 +
 src/runtime/rand.go                           |    2 +-
 src/runtime/rt0_linux_sw64.s                  |   16 +
 src/runtime/runtime_test.go                   |    3 +
 src/runtime/signal_linux_sw64.go              |   67 +
 src/runtime/signal_sw64.go                    |   97 +
 src/runtime/signal_unix.go                    |    2 +-
 src/runtime/sigtab_linux_generic.go           |    2 +-
 src/runtime/sigtab_linux_sw64.go              |   75 +
 src/runtime/stubs_sw64.go                     |   30 +
 src/runtime/sys_linux_sw64.s                  |  615 ++
 src/runtime/sys_sw64.go                       |   23 +
 src/runtime/tagptr_64bit.go                   |    2 +-
 src/runtime/tls_sw64.s                        |   34 +
 src/runtime/vdso_elf64.go                     |    2 +-
 src/runtime/vdso_in_none.go                   |    2 +-
 src/runtime/vdso_linux.go                     |    2 +-
 src/runtime/vdso_linux_sw64.go                |   28 +
 src/runtime/vlrt.go                           |    2 +-
 src/syscall/asm_linux_sw64.s                  |   49 +
 src/syscall/endian_little.go                  |    2 +-
 src/syscall/export_linux_sw64_test.go         |   14 +
 src/syscall/export_linux_test.go              |    2 +
 src/syscall/mkall.sh                          |    7 +
 src/syscall/mkerrors_sw64.sh                  |  462 +
 src/syscall/setuidgid_linux.go                |    2 +-
 src/syscall/setuidgid_linux_sw64.go           |   22 +
 src/syscall/syscall_linux_sw64.go             |  188 +
 src/syscall/zerrors_linux_sw64.go             | 2100 ++++
 src/syscall/zsyscall_linux_sw64.go            | 1652 +++
 src/syscall/zsysnum_linux_sw64.go             |  370 +
 src/syscall/ztypes_linux_sw64.go              |  628 ++
 src/vendor/golang.org/x/sys/cpu/byteorder.go  |    3 +-
 .../golang.org/x/sys/cpu/cpu_linux_noinit.go  |    2 +-
 .../golang.org/x/sys/cpu/cpu_linux_sw64.go    |   12 +
 src/vendor/golang.org/x/sys/cpu/cpu_sw64.go   |   13 +
 .../golang.org/x/sys/cpu/endian_little.go     |    2 +-
 test/nosplit.go                               |    5 +-
 220 files changed, 46308 insertions(+), 448 deletions(-)
 create mode 100644 src/cmd/asm/internal/arch/sw64.go
 create mode 100644 src/cmd/asm/internal/asm/testdata/sw64.s
 create mode 100644 src/cmd/cgo/internal/test/issue9400/asm_sw64.s
 create mode 100644 src/cmd/compile/internal/ssa/_gen/SW64.rules
 create mode 100644 src/cmd/compile/internal/ssa/_gen/SW64Ops.go
 create mode 100644 src/cmd/compile/internal/ssa/rewriteSW64.go
 create mode 100644 src/cmd/compile/internal/sw64/galign.go
 create mode 100644 src/cmd/compile/internal/sw64/ggen.go
 create mode 100644 src/cmd/compile/internal/sw64/ssa.go
 create mode 100644 src/cmd/dist/udiv_default.s
 create mode 100644 src/cmd/dist/udiv_sw64.s
 create mode 100644 src/cmd/go/testdata/mod/golang.org_toolchain_v0.0.1-go1.999testmod.linux-sw64.txt
 create mode 100644 src/cmd/internal/obj/stringer_sw64.go
 create mode 100644 src/cmd/internal/obj/sw64/a.out.go
 create mode 100644 src/cmd/internal/obj/sw64/anames.go
 create mode 100644 src/cmd/internal/obj/sw64/anames77.go
 create mode 100644 src/cmd/internal/obj/sw64/asm77.go
 create mode 100644 src/cmd/internal/obj/sw64/list77.go
 create mode 100644 src/cmd/internal/obj/sw64/obj77.go
 create mode 100644 src/cmd/link/internal/sw64/asm.go
 create mode 100644 src/cmd/link/internal/sw64/l.go
 create mode 100644 src/cmd/link/internal/sw64/obj.go
 create mode 100644 src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/gnu.go
 create mode 100644 src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/main.go
 create mode 100644 src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/op2str.go
 create mode 100644 src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/rawinst.go
 create mode 100644 src/cmd/vendor/golang.org/x/sys/unix/asm_linux_sw64.s
 create mode 100644 src/cmd/vendor/golang.org/x/sys/unix/syscall_linux_sw64.go
 create mode 100644 src/cmd/vendor/golang.org/x/sys/unix/zerrors_linux_sw64.go
 create mode 100644 src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_sw64.go
 create mode 100644 src/cmd/vendor/golang.org/x/sys/unix/zsysnum_linux_sw64.go
 create mode 100644 src/cmd/vendor/golang.org/x/sys/unix/ztypes_linux_sw64.go
 create mode 100644 src/crypto/cipher/xor_sw64_test.s
 create mode 100644 src/crypto/subtle/xor_sw64.go
 create mode 100644 src/crypto/subtle/xor_sw64.s
 create mode 100644 src/hash/crc32/crc32_sw64.go
 create mode 100644 src/hash/crc32/crc32_sw64.s
 create mode 100644 src/internal/abi/abi_sw64.go
 create mode 100644 src/internal/bytealg/compare_sw64.s
 create mode 100644 src/internal/bytealg/count_sw64.s
 create mode 100644 src/internal/bytealg/count_sw64_test.s
 create mode 100644 src/internal/bytealg/equal_sw64.s
 create mode 100644 src/internal/bytealg/indexbyte_sw64.s
 create mode 100644 src/internal/bytealg/indexbyte_sw64_prototype.s
 create mode 100644 src/internal/bytealg/indexbyte_sw64_test.s
 create mode 100644 src/internal/cpu/cpu_sw64.go
 create mode 100644 src/internal/goarch/goarch_sw64.go
 create mode 100644 src/internal/goarch/zgoarch_sw64.go
 create mode 100644 src/internal/syscall/unix/getrandom_linux_sw64.go
 create mode 100644 src/internal/syscall/unix/sysnum_linux_sw64.go
 create mode 100644 src/math/big/arith_sw64.s
 create mode 100644 src/reflect/asm_sw64.s
 create mode 100644 src/reflect/float32reg_sw64.s
 create mode 100644 src/reflect/stubs_sw64.go
 create mode 100644 src/runtime/asm_sw64.s
 create mode 100644 src/runtime/atomic_sw64.s
 create mode 100644 src/runtime/cgo/asm_sw64.s
 create mode 100644 src/runtime/cgo/gcc_linux_sw64.c
 create mode 100644 src/runtime/cgo/gcc_sw64.S
 create mode 100644 src/runtime/cpuflags_sw64.go
 create mode 100644 src/runtime/defs_linux_amd64.h
 create mode 100644 src/runtime/defs_linux_sw64.go
 create mode 100644 src/runtime/duff_sw64.s
 create mode 100644 src/runtime/internal/atomic/atomic_sw64.go
 create mode 100644 src/runtime/internal/atomic/atomic_sw64.s
 create mode 100644 src/runtime/internal/sys/zversion.go
 create mode 100644 src/runtime/internal/syscall/asm_linux_sw64.s
 create mode 100644 src/runtime/internal/syscall/defs_linux_sw64.go
 create mode 100644 src/runtime/memclr_sw64.s
 create mode 100644 src/runtime/memmove_sw64.s
 create mode 100644 src/runtime/memmove_sw64_test.s
 create mode 100644 src/runtime/os_linux_sw64.go
 mode change 100644 => 100755 src/runtime/pprof/testdata/test32
 mode change 100644 => 100755 src/runtime/pprof/testdata/test32be
 mode change 100644 => 100755 src/runtime/pprof/testdata/test64
 mode change 100644 => 100755 src/runtime/pprof/testdata/test64be
 create mode 100644 src/runtime/preempt_sw64.s
 create mode 100644 src/runtime/rt0_linux_sw64.s
 create mode 100644 src/runtime/signal_linux_sw64.go
 create mode 100644 src/runtime/signal_sw64.go
 create mode 100644 src/runtime/sigtab_linux_sw64.go
 create mode 100644 src/runtime/stubs_sw64.go
 create mode 100644 src/runtime/sys_linux_sw64.s
 create mode 100644 src/runtime/sys_sw64.go
 create mode 100644 src/runtime/tls_sw64.s
 create mode 100644 src/runtime/vdso_linux_sw64.go
 create mode 100644 src/syscall/asm_linux_sw64.s
 create mode 100644 src/syscall/export_linux_sw64_test.go
 create mode 100755 src/syscall/mkerrors_sw64.sh
 create mode 100644 src/syscall/setuidgid_linux_sw64.go
 create mode 100644 src/syscall/syscall_linux_sw64.go
 create mode 100644 src/syscall/zerrors_linux_sw64.go
 create mode 100644 src/syscall/zsyscall_linux_sw64.go
 create mode 100644 src/syscall/zsysnum_linux_sw64.go
 create mode 100644 src/syscall/ztypes_linux_sw64.go
 create mode 100644 src/vendor/golang.org/x/sys/cpu/cpu_linux_sw64.go
 create mode 100644 src/vendor/golang.org/x/sys/cpu/cpu_sw64.go

diff --git a/api/go1.16.txt b/api/go1.16.txt
index e12a0509..ea2e0227 100644
--- a/api/go1.16.txt
+++ b/api/go1.16.txt
@@ -219,6 +219,99 @@ pkg debug/elf, const PT_SUNWSTACK = 1879048187
 pkg debug/elf, const PT_SUNWSTACK ProgType
 pkg debug/elf, const PT_SUNW_EH_FRAME = 1685382480
 pkg debug/elf, const PT_SUNW_EH_FRAME ProgType
+pkg debug/elf, const EM_SW64 = 39190
+pkg debug/elf, const EM_SW64 Machine
+pkg debug/elf, const R_SW64_BR26ADDR = 42
+pkg debug/elf, const R_SW64_BR26ADDR R_SW64
+pkg debug/elf, const R_SW64_BRADDR = 7
+pkg debug/elf, const R_SW64_BRADDR R_SW64
+pkg debug/elf, const R_SW64_BRSGP = 28
+pkg debug/elf, const R_SW64_BRSGP R_SW64
+pkg debug/elf, const R_SW64_COPY = 24
+pkg debug/elf, const R_SW64_COPY R_SW64
+pkg debug/elf, const R_SW64_DTPMOD64 = 31
+pkg debug/elf, const R_SW64_DTPMOD64 R_SW64
+pkg debug/elf, const R_SW64_DTPREL16 = 36
+pkg debug/elf, const R_SW64_DTPREL16 R_SW64
+pkg debug/elf, const R_SW64_DTPREL64 = 33
+pkg debug/elf, const R_SW64_DTPREL64 R_SW64
+pkg debug/elf, const R_SW64_DTPRELHI = 34
+pkg debug/elf, const R_SW64_DTPRELHI R_SW64
+pkg debug/elf, const R_SW64_DTPRELLO = 35
+pkg debug/elf, const R_SW64_DTPRELLO R_SW64
+pkg debug/elf, const R_SW64_GLOB_DAT = 25
+pkg debug/elf, const R_SW64_GLOB_DAT R_SW64
+pkg debug/elf, const R_SW64_GOTDTPREL = 32
+pkg debug/elf, const R_SW64_GOTDTPREL R_SW64
+pkg debug/elf, const R_SW64_GOTTPREL = 37
+pkg debug/elf, const R_SW64_GOTTPREL R_SW64
+pkg debug/elf, const R_SW64_GPDISP = 6
+pkg debug/elf, const R_SW64_GPDISP R_SW64
+pkg debug/elf, const R_SW64_GPREL16 = 19
+pkg debug/elf, const R_SW64_GPREL16 R_SW64
+pkg debug/elf, const R_SW64_GPREL32 = 3
+pkg debug/elf, const R_SW64_GPREL32 R_SW64
+pkg debug/elf, const R_SW64_GPRELHIGH = 17
+pkg debug/elf, const R_SW64_GPRELHIGH R_SW64
+pkg debug/elf, const R_SW64_GPRELLOW = 18
+pkg debug/elf, const R_SW64_GPRELLOW R_SW64
+pkg debug/elf, const R_SW64_GPVALUE = 16
+pkg debug/elf, const R_SW64_GPVALUE R_SW64
+pkg debug/elf, const R_SW64_HINT = 8
+pkg debug/elf, const R_SW64_HINT R_SW64
+pkg debug/elf, const R_SW64_IMMED_BR_HI32 = 22
+pkg debug/elf, const R_SW64_IMMED_BR_HI32 R_SW64
+pkg debug/elf, const R_SW64_IMMED_GP_HI32 = 20
+pkg debug/elf, const R_SW64_IMMED_GP_HI32 R_SW64
+pkg debug/elf, const R_SW64_IMMED_LO32 = 23
+pkg debug/elf, const R_SW64_IMMED_LO32 R_SW64
+pkg debug/elf, const R_SW64_IMMED_SCN_HI32 = 21
+pkg debug/elf, const R_SW64_IMMED_SCN_HI32 R_SW64
+pkg debug/elf, const R_SW64_JMP_SLOT = 26
+pkg debug/elf, const R_SW64_JMP_SLOT R_SW64
+pkg debug/elf, const R_SW64_LITERAL = 4
+pkg debug/elf, const R_SW64_LITERAL R_SW64
+pkg debug/elf, const R_SW64_LITERAL_GOT = 43
+pkg debug/elf, const R_SW64_LITERAL_GOT R_SW64
+pkg debug/elf, const R_SW64_LITUSE = 5
+pkg debug/elf, const R_SW64_LITUSE R_SW64
+pkg debug/elf, const R_SW64_NONE = 0
+pkg debug/elf, const R_SW64_NONE R_SW64
+pkg debug/elf, const R_SW64_OP_PRSHIFT = 15
+pkg debug/elf, const R_SW64_OP_PRSHIFT R_SW64
+pkg debug/elf, const R_SW64_OP_PSUB = 14
+pkg debug/elf, const R_SW64_OP_PSUB R_SW64
+pkg debug/elf, const R_SW64_OP_PUSH = 12
+pkg debug/elf, const R_SW64_OP_PUSH R_SW64
+pkg debug/elf, const R_SW64_OP_STORE = 13
+pkg debug/elf, const R_SW64_OP_STORE R_SW64
+pkg debug/elf, const R_SW64_REFLONG = 1
+pkg debug/elf, const R_SW64_REFLONG R_SW64
+pkg debug/elf, const R_SW64_REFQUAD = 2
+pkg debug/elf, const R_SW64_REFQUAD R_SW64
+pkg debug/elf, const R_SW64_RELATIVE = 27
+pkg debug/elf, const R_SW64_RELATIVE R_SW64
+pkg debug/elf, const R_SW64_SREL16 = 9
+pkg debug/elf, const R_SW64_SREL16 R_SW64
+pkg debug/elf, const R_SW64_SREL32 = 10
+pkg debug/elf, const R_SW64_SREL32 R_SW64
+pkg debug/elf, const R_SW64_SREL64 = 11
+pkg debug/elf, const R_SW64_SREL64 R_SW64
+pkg debug/elf, const R_SW64_TLSGD = 29
+pkg debug/elf, const R_SW64_TLSGD R_SW64
+pkg debug/elf, const R_SW64_TLSLDM = 30
+pkg debug/elf, const R_SW64_TLSLDM R_SW64
+pkg debug/elf, const R_SW64_TPREL16 = 41
+pkg debug/elf, const R_SW64_TPREL16 R_SW64
+pkg debug/elf, const R_SW64_TPREL64 = 38
+pkg debug/elf, const R_SW64_TPREL64 R_SW64
+pkg debug/elf, const R_SW64_TPRELHI = 39
+pkg debug/elf, const R_SW64_TPRELHI R_SW64
+pkg debug/elf, const R_SW64_TPRELLO = 40
+pkg debug/elf, const R_SW64_TPRELLO R_SW64
+pkg debug/elf, method (R_SW64) GoString() string
+pkg debug/elf, method (R_SW64) String() string
+pkg debug/elf, type R_SW64 int
 pkg embed, method (FS) Open(string) (fs.File, error)
 pkg embed, method (FS) ReadDir(string) ([]fs.DirEntry, error)
 pkg embed, method (FS) ReadFile(string) ([]uint8, error)
diff --git a/api/go1.18.txt b/api/go1.18.txt
index 5040c95d..9f4fc91f 100644
--- a/api/go1.18.txt
+++ b/api/go1.18.txt
@@ -251,3 +251,11 @@ pkg text/template/parse, type ContinueNode struct, Line int
 pkg text/template/parse, type ContinueNode struct, embedded NodeType
 pkg text/template/parse, type ContinueNode struct, embedded Pos
 pkg unicode/utf8, func AppendRune([]uint8, int32) []uint8
+pkg debug/elf, const R_SW64_ADD_ABS_LO_16 = 47
+pkg debug/elf, const R_SW64_ADD_ABS_LO_16 R_SW64
+pkg debug/elf, const R_SW64_ADD_PCREL_HI_13 = 45
+pkg debug/elf, const R_SW64_ADD_PCREL_HI_13 R_SW64
+pkg debug/elf, const R_SW64_ADD_PCREL_LO_13 = 46
+pkg debug/elf, const R_SW64_ADD_PCREL_LO_13 R_SW64
+pkg debug/elf, const R_SW64_CALL26 = 48
+pkg debug/elf, const R_SW64_CALL26 R_SW64
diff --git a/src/cmd/asm/internal/arch/arch.go b/src/cmd/asm/internal/arch/arch.go
index 11bb7af8..ee220169 100644
--- a/src/cmd/asm/internal/arch/arch.go
+++ b/src/cmd/asm/internal/arch/arch.go
@@ -81,6 +81,8 @@ func Set(GOARCH string, shared bool) *Arch {
 		return archS390x()
 	case "wasm":
 		return archWasm()
+	case "sw64":
+		return archSW64()
 	}
 	return nil
 }
diff --git a/src/cmd/asm/internal/arch/sw64.go b/src/cmd/asm/internal/arch/sw64.go
new file mode 100644
index 00000000..3857b4e0
--- /dev/null
+++ b/src/cmd/asm/internal/arch/sw64.go
@@ -0,0 +1,95 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// This file encapsulates some of the odd characteristics of the
+// sw64 instruction set, to minimize its interaction
+// with the core of the assembler.
+
+package arch
+
+import (
+	"cmd/internal/obj"
+	"cmd/internal/obj/sw64"
+	"fmt"
+)
+
+func jumpSW64(word string) bool {
+	switch word {
+	case "CALL", "JMP",
+		"BR", "BSR",
+		"BEQ", "BNE", "BLT", "BLE", "BGT", "BGE",
+		"BLBC", "BLBS", "FBEQ", "FBNE", "FBLT",
+		"FBGT", "FBGE":
+		return true
+	}
+	return false
+}
+
+func sw64RegisterNumber(name string, n int16) (int16, bool) {
+	//snyh_TODO: update by cmd/internal/obj/sw64/a.out.go
+	switch name {
+	case "R":
+		if 0 <= n && n <= 32 {
+			return sw64.REG_R0 + n, true
+		}
+	case "F":
+		if 0 <= n && n <= 32 {
+			return sw64.REG_F0 + n, true
+		}
+	case "V":
+		if 0 <= n && n <= 32 {
+			return sw64.REG_V0 + n, true
+		}
+	}
+	return 0, false
+}
+
+func archSW64() *Arch {
+	register := make(map[string]int16)
+	for i := sw64.REG_R0; i <= sw64.REG_R31; i++ {
+		register[obj.Rconv(i)] = int16(i)
+	}
+	for i := sw64.REG_R0; i <= sw64.REG_R31; i++ {
+		register[fmt.Sprintf("R%d", i-sw64.REG_R0)] = int16(i)
+	}
+	for i := sw64.REG_F0; i <= sw64.REG_F31; i++ {
+		register[obj.Rconv(i)] = int16(i)
+	}
+	for i := sw64.REG_V0; i <= sw64.REG_V31; i++ {
+		register[obj.Rconv(i)] = int16(i)
+	}
+
+	// Pseudo-registers.
+	register["SB"] = RSB
+	register["FP"] = RFP
+	register["PC"] = RPC
+
+	registerPrefix := map[string]bool{
+		"T": true,
+		"S": true,
+		"A": true,
+		"F": true,
+		"R": true,
+		"V": true,
+	}
+
+	instructions := make(map[string]obj.As)
+	for i, s := range obj.Anames {
+		instructions[s] = obj.As(i)
+	}
+	for i, s := range sw64.Anames {
+		if obj.As(i) >= obj.A_ARCHSPECIFIC {
+			instructions[s] = obj.As(i) + obj.ABaseSW64
+		}
+	}
+
+	return &Arch{
+		LinkArch:       &sw64.LinkSW64,
+		Instructions:   instructions,
+		Register:       register,
+		RegisterPrefix: registerPrefix,
+		RegisterNumber: sw64RegisterNumber,
+		IsJump:         jumpSW64,
+	}
+}
diff --git a/src/cmd/asm/internal/asm/asm.go b/src/cmd/asm/internal/asm/asm.go
index 375ef803..c5b49b79 100644
--- a/src/cmd/asm/internal/asm/asm.go
+++ b/src/cmd/asm/internal/asm/asm.go
@@ -557,6 +557,9 @@ func (p *Parser) asmJump(op obj.As, cond string, a []obj.Addr) {
 	case target.Type == obj.TYPE_CONST:
 		// JMP $4
 		*targetAddr = a[0]
+		if p.arch.Family == sys.SW64 {
+			*targetAddr = a[1]
+		}
 	case target.Type == obj.TYPE_NONE:
 		// JMP
 	default:
@@ -774,6 +777,17 @@ func (p *Parser) asmInstruction(op obj.As, cond string, a []obj.Addr) {
 				prog.AddRestSource(a[1])
 			}
 			prog.To = a[2]
+		case sys.SW64:
+			prog.From = a[0]
+
+			if a[1].Type == obj.TYPE_REG {
+				prog.Reg = p.getRegister(prog, op, &a[1])
+			} else {
+				prog.AddRestSourceArgs([]obj.Addr{a[1]})
+			}
+
+			prog.To = a[2]
+
 		default:
 			p.errorf("TODO: implement three-operand instructions for this architecture")
 			return
@@ -808,6 +822,12 @@ func (p *Parser) asmInstruction(op obj.As, cond string, a []obj.Addr) {
 			prog.To = a[3]
 			break
 		}
+		if p.arch.Family == sys.SW64 {
+			prog.From = a[0]
+			prog.AddRestSourceArgs([]obj.Addr{a[1], a[2]})
+			prog.To = a[3]
+			break
+		}
 		if p.arch.Family == sys.ARM64 {
 			prog.From = a[0]
 			prog.Reg = p.getRegister(prog, op, &a[1])
diff --git a/src/cmd/asm/internal/asm/testdata/sw64.s b/src/cmd/asm/internal/asm/testdata/sw64.s
new file mode 100644
index 00000000..0ce54734
--- /dev/null
+++ b/src/cmd/asm/internal/asm/testdata/sw64.s
@@ -0,0 +1,21 @@
+#include "../../../../../runtime/textflag.h"
+TEXT foo(SB), NOSPLIT, $0
+	ADDW	R17, $0x4d, R0 //00 a0 29 4a
+	S4ADDW	R17, R3, R1 // 41 00 23 42
+	S4SUBL	R3, R9, R11 // 6b 01 69 40
+	S8SUBL	R3, $0, R11 // 6b 01 60 48
+	STB	R3, 4(R0)     // 04 00 60 a0
+	SYS_CALL	$1      // 01 00 00 02
+	BSR	R2, $52   // 0d 00 40 14
+	DIVW R1, R2, R3
+	UDIVW R1, R2, R3
+	REMW R1, R2, R3
+	UREMW R1, R2, R3
+	DIVL R1, R2, R3
+	UDIVL R1, R2, R3
+	REML R1, R2, R3
+	UREML R1, R2, R3
+	ADDPI $_rt0_sw64_lib_go(SB), R1
+	ADDPIS $_rt0_sw64_lib_go(SB), R1
+	SBT R1, R2, R3
+	CBT R1, R2, R3
diff --git a/src/cmd/cgo/internal/test/issue9400/asm_sw64.s b/src/cmd/cgo/internal/test/issue9400/asm_sw64.s
new file mode 100644
index 00000000..05eab553
--- /dev/null
+++ b/src/cmd/cgo/internal/test/issue9400/asm_sw64.s
@@ -0,0 +1,30 @@
+// Copyright 2016 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build sw64
+// +build !gccgo
+
+#include "textflag.h"
+
+TEXT ·RewindAndSetgid(SB), NOSPLIT|NOFRAME, $0-0
+	// Rewind stack pointer so anything that happens on the stack
+	// will clobber the test pattern created by the caller
+	LDI	SP, $(1024*8)(SP)
+
+	// Ask signaller to setgid
+	LDI	R1, $1
+	MEMB
+	STW	R1, ·Baton(SB)
+	MEMB
+
+	// Wait for setgid completion
+loop:
+	MEMB
+	LDW	R1, ·Baton(SB)
+	NOOP  // hint that we're in a spin loop
+	BNE    R1, loop
+	MEMB
+
+	LDI	SP, $-(1024*8)(SP)
+	RET
diff --git a/src/cmd/cgo/internal/testsanitizers/cc_test.go b/src/cmd/cgo/internal/testsanitizers/cc_test.go
index e650de83..bbc94b67 100644
--- a/src/cmd/cgo/internal/testsanitizers/cc_test.go
+++ b/src/cmd/cgo/internal/testsanitizers/cc_test.go
@@ -22,6 +22,7 @@ import (
 	"os/user"
 	"path/filepath"
 	"regexp"
+	"runtime"
 	"strconv"
 	"strings"
 	"sync"
@@ -445,6 +446,9 @@ int LLVMFuzzerTestOneInput(char *data, size_t size) {
 `)
 
 func (c *config) checkCSanitizer() (skip bool, err error) {
+	if runtime.GOARCH == "sw64" {
+		return true, fmt.Errorf("skip sw64 gcc sanitizer because of some known issue")
+	}
 	dir, err := os.MkdirTemp("", c.sanitizer)
 	if err != nil {
 		return false, fmt.Errorf("failed to create temp directory: %v", err)
diff --git a/src/cmd/cgo/main.go b/src/cmd/cgo/main.go
index fce2671c..90cdd024 100644
--- a/src/cmd/cgo/main.go
+++ b/src/cmd/cgo/main.go
@@ -195,6 +195,7 @@ var ptrSizeMap = map[string]int64{
 	"shbe":     4,
 	"sparc":    4,
 	"sparc64":  8,
+	"sw64":     8,
 }
 
 var intSizeMap = map[string]int64{
@@ -221,6 +222,7 @@ var intSizeMap = map[string]int64{
 	"shbe":     4,
 	"sparc":    4,
 	"sparc64":  8,
+	"sw64":     8,
 }
 
 var cPrefix string
diff --git a/src/cmd/compile/internal/base/flag.go b/src/cmd/compile/internal/base/flag.go
index a3144f8f..77dde7e3 100644
--- a/src/cmd/compile/internal/base/flag.go
+++ b/src/cmd/compile/internal/base/flag.go
@@ -270,7 +270,7 @@ func ParseFlags() {
 	if Flag.Race && !platform.RaceDetectorSupported(buildcfg.GOOS, buildcfg.GOARCH) {
 		log.Fatalf("%s/%s does not support -race", buildcfg.GOOS, buildcfg.GOARCH)
 	}
-	if (*Flag.Shared || *Flag.Dynlink || *Flag.LinkShared) && !Ctxt.Arch.InFamily(sys.AMD64, sys.ARM, sys.ARM64, sys.I386, sys.Loong64, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X) {
+	if (*Flag.Shared || *Flag.Dynlink || *Flag.LinkShared) && !Ctxt.Arch.InFamily(sys.AMD64, sys.ARM, sys.ARM64, sys.I386, sys.Loong64, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.SW64) {
 		log.Fatalf("%s/%s does not support -shared", buildcfg.GOOS, buildcfg.GOARCH)
 	}
 	parseSpectre(Flag.Spectre) // left as string for RecordFlags
diff --git a/src/cmd/compile/internal/ssa/_gen/SW64.rules b/src/cmd/compile/internal/ssa/_gen/SW64.rules
new file mode 100644
index 00000000..31a54032
--- /dev/null
+++ b/src/cmd/compile/internal/ssa/_gen/SW64.rules
@@ -0,0 +1,815 @@
+// Copyright 2016 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Lowering arithmetic
+(Add(Ptr|64|32|16|8) ...) => (ADDV ...)
+(Add(32|64)F ...) => (FADD(S|D) ...)
+
+(Sub(Ptr|64|32|16|8) ...) => (SUBV ...)
+(Sub(32|64)F ...) => (FSUB(S|D) ...)
+
+// (x + y) / 2 with x>=y => (x - y) / 2 + y
+(Avg64u <t> x y) => (ADDV (SRLconst <t> (SUBV <t> x y) [1]) y)
+
+(Mul(64|32|16|8) ...) => (MUL(L|W|W|W) ...)
+(Mul(32|64)F ...) => (FMUL(S|D) ...)
+
+(Hmul64  x y) => ( SUBV <typ.Int64> (SUBV <typ.Int64> (UMULH  <typ.Int64> x y) (MULL <typ.Int64> (SRLconst x [63]) y)) (MULL <typ.Int64> (SRLconst y [63]) x) )
+(Hmul64u  ...) => (UMULH  ...)
+(Hmul32 x y) => (SRAconst (MULL <typ.Int64> (SignExt32to64 x) (SignExt32to64 y)) [32])
+(Hmul32u x y) => (SRLconst (MULL <typ.UInt64> (ZeroExt32to64 x) (ZeroExt32to64 y)) [32])
+
+
+(Convert ...) => (MOVVconvert ...)
+(GetClosurePtr ...) => (LoweredGetClosurePtr ...)
+(GetCallerSP ...) => (LoweredGetCallerSP ...)
+(GetCallerPC ...) => (LoweredGetCallerPC ...)
+// Write barrier.
+(WB ...) => (LoweredWB ...)
+
+(Signmask x) => (SRAconst x [63])
+(Div64 x y) && buildcfg.GOSW64 <=3 =>
+        (SUBV (XOR <typ.UInt64>                                                        // negate the result if one operand is negative
+                (Select0 <typ.UInt64> (CALLudiv
+
+                        (SUBV <typ.UInt64> (XOR x <typ.UInt64> (Signmask x)) (Signmask x))   // negate x if negative
+                        (SUBV <typ.UInt64> (XOR y <typ.UInt64> (Signmask y)) (Signmask y)))) // negate y if negative
+                (Signmask (XOR <typ.UInt64> x y))) (Signmask (XOR <typ.UInt64> x y)))
+(Div64 [false] x y) && buildcfg.GOSW64 >=4 => (DIVV x y)
+(Div64u x y) && buildcfg.GOSW64 <=3 => (Select0 <typ.UInt64> (CALLudiv x y))
+(Div64u x y) && buildcfg.GOSW64 >=4 => (UDIVV x y)
+(Div32 x y) && buildcfg.GOSW64 <=3 => (Div64 (SignExt32to64 x) (SignExt32to64 y))
+(Div32 x y) && buildcfg.GOSW64 >=4 => (DIVW x y)
+(Div32u x y) && buildcfg.GOSW64 <=3 => (Div64u (ZeroExt32to64 x) (ZeroExt32to64 y))
+(Div32u x y) && buildcfg.GOSW64 >=4 => (UDIVW x y)
+(Div16 x y) => (Div64 (SignExt16to64 x) (SignExt16to64 y))
+(Div16u x y) => (Div64u (ZeroExt16to64 x) (ZeroExt16to64 y))
+(Div8 x y) => (Div64 (SignExt8to64 x) (SignExt8to64 y))
+(Div8u x y) => (Div64u (ZeroExt8to64 x) (ZeroExt8to64 y))
+(Div(32|64)F ...) => (FDIV(S|D) ...)
+
+
+(Mod64 x y) =>
+        (SUBV (XOR <typ.UInt64>                                                        // negate the result if x is negative
+                (Select1 <typ.UInt64> (CALLudiv
+                        (SUBV <typ.UInt64> (XOR <typ.UInt64> x (Signmask x)) (Signmask x))   // negate x if negative
+                        (SUBV <typ.UInt64> (XOR <typ.UInt64> y (Signmask y)) (Signmask y)))) // negate y if negative
+                (Signmask x)) (Signmask x))
+(Mod64u x y) => (Select1 <typ.UInt64> (CALLudiv x y))
+(Mod32 x y) => (Mod64 (SignExt32to64 x) (SignExt32to64 y))
+(Mod32u x y) => (Mod64u (ZeroExt32to64 x) (ZeroExt32to64 y))
+(Mod16 x y) => (Mod64 (SignExt16to64 x) (SignExt16to64 y))
+(Mod16u x y) => (Mod64u (ZeroExt16to64 x) (ZeroExt16to64 y))
+(Mod8 x y) => (Mod64 (SignExt8to64 x) (SignExt8to64 y))
+(Mod8u x y) => (Mod64u (ZeroExt8to64 x) (ZeroExt8to64 y))
+
+
+// Lowering float <=> int
+(Cvt32to32F x) => (FCVTLS (IFMOVD x))
+(Cvt32to64F x) => (FCVTLD (IFMOVD (SignExt32to64 x)))
+(Cvt64to32F ...) => (FCVTLS ...)
+(Cvt64to64F ...) => (FCVTLD ...)
+(Cvt32Fto32 x) => (FIMOVS (FCVTLW (FCVTDL_Z (FCVTSD x))))
+(Cvt64Fto32 x) => (FIMOVS (FCVTLW (FCVTDL_Z x)))
+(Cvt32Fto64 x) => (FIMOVD (FCVTDL_Z (FCVTSD x)))
+(Cvt64Fto64 x) => (FIMOVD (FCVTDL_Z x))
+(Cvt32Fto64F ...) => (FCVTSD ...)
+(Cvt64Fto32F ...) => (FCVTDS ...)
+
+(CvtBoolToUint8 ...) => (Copy ...)
+
+(Round(32|64)F ...) => (Copy ...)
+
+// count trailing zero
+// 64 - CLZ(x&-x - 1)
+(Ctz64 ...) => (CTTZ ...)
+(Ctz32 <t> x) => (SUBV (CTTZ (ZeroExt32to64 x)) (MULLconst <t> (CMPEQ  (ZeroExt32to64 x)  (MOVVconst [0]) ) [32]))
+
+//count bits
+(PopCount64 ...) => (CTPOP ...)
+(PopCount32 x) => (CTPOP (ZeroExt32to64 x))
+(PopCount16 x) => (CTPOP (ZeroExt16to64 x))
+(PopCount8 x) => (CTPOP (ZeroExt8to64 x))
+
+(Floor ...) => (FCVTDL_N ...)
+(Ceil ...) => (FCVTDL_P ...)
+(Trunc ...) => (FCVTDL_Z ...)
+(Round ...) => (FCVTDL_G ...)
+(Abs ...) => (FABS ...)
+(Copysign x y) => (FCPYS y x)
+(Sqrt ...) => (FSQRTD ...)
+(Sqrt32 ...) => (FSQRTS ...)
+
+// Lowering constants
+(Const(64|32|16|8) [val]) => (MOVVconst [int64(val)])
+(Const(32|64)F [val]) => (MOV(F|D)const [float64(val)])
+(ConstNil) => (MOVVconst [0])
+(ConstBool [t]) => (MOVVconst [b2i(t)])
+
+(Slicemask <t> x) => (SRAconst (NEGV <t> x) [63])
+
+// Lowering boolean ops
+(AndB ...) => (AND ...)
+(OrB ...) => (BIS ...)
+(EqB x y) => (XOR (MOVVconst [1]) (XOR <typ.Bool> x y) )
+(NeqB ...) => (XOR ...)
+(Not x) => (XORconst x [1])
+
+(And(64|32|16|8) ...) => (AND ...)
+
+(Or(64|32|16|8) ...) => (BIS ...)
+
+(Xor(64|32|16|8) ...) => (XOR ...)
+
+// unary ops
+(Neg(64|32|16|8) ...) => (NEGV ...)
+(Neg(32|64)F ...) => (NEG(F|D) ...)
+
+(Com(64|32|16|8)  x) => (ORNOT (MOVVconst [0]) x)
+
+
+// shifts
+// hardware instruction uses only the low 6 bits of the shift
+// we compare to 64 to ensure Go semantics for large shifts
+//shifts constant
+(Lsh64x64  x (Const64 [c])) && uint64(c) < 64 => (SLLconst x [c])
+(Rsh64x64  x (Const64 [c])) && uint64(c) < 64 => (SRAconst x [c])
+(Rsh64Ux64 x (Const64 [c])) && uint64(c) < 64 => (SRLconst x [c])
+(Lsh32x64  x (Const64 [c])) && uint64(c) < 32 => (SLLconst (ZeroExt32to64 x) [c])
+(Rsh32x64  x (Const64 [c])) && uint64(c) < 32 => (SRAconst (SignExt32to64 x) [c])
+(Rsh32Ux64 x (Const64 [c])) && uint64(c) < 32 => (SRLconst (ZeroExt32to64 x) [c])
+(Lsh16x64  x (Const64 [c])) && uint64(c) < 16 => (SLLconst (ZeroExt16to64 x) [c])
+(Rsh16x64  x (Const64 [c])) && uint64(c) < 16 => (SRAconst (SignExt16to64 x) [c])
+(Rsh16Ux64 x (Const64 [c])) && uint64(c) < 16 => (SRLconst (ZeroExt16to64 x) [c])
+(Lsh8x64   x (Const64 [c])) && uint64(c) < 8  => (SLLconst (ZeroExt8to64 x) [c])
+(Rsh8x64   x (Const64 [c])) && uint64(c) < 8  => (SRAconst (SignExt8to64  x) [c])
+(Rsh8Ux64  x (Const64 [c])) && uint64(c) < 8  => (SRLconst (ZeroExt8to64  x) [c])
+
+// large constant signed right shift, we leave the sign bit
+(Rsh64x64 x (Const64 [c])) && uint64(c) >= 64 => (SRAconst x [63])
+(Rsh32x64 x (Const64 [c])) && uint64(c) >= 32 => (SRAconst (SignExt32to64 x) [63])
+(Rsh16x64 x (Const64 [c])) && uint64(c) >= 16 => (SRAconst (SignExt16to64 x) [63])
+(Rsh8x64  x (Const64 [c])) && uint64(c) >= 8  => (SRAconst (SignExt8to64  x) [63])
+
+// constant shifts
+(Rsh64x64 x (MOVVconst [c])) && uint64(c) >= 64 => (SRAconst x [63])
+(Rsh32x64 x (MOVVconst [c])) && uint64(c) >= 32 => (SRAconst (SignExt32to64 x) [63])
+(Rsh16x64 x (MOVVconst [c])) && uint64(c) >= 16 => (SRAconst (SignExt16to64 x) [63])
+(Rsh8x64  x (MOVVconst [c])) && uint64(c) >= 8  => (SRAconst (SignExt8to64  x) [63])
+
+(Lsh64x64  x (MOVVconst [c])) && uint64(c) < 64 => (SLLconst x [c])
+(Rsh64x64  x (MOVVconst [c])) && uint64(c) < 64 => (SRAconst x [c])
+(Rsh64Ux64 x (MOVVconst [c])) && uint64(c) < 64 => (SRLconst x [c])
+(Lsh32x64  x (MOVVconst [c])) && uint64(c) < 32 => (SLLconst (ZeroExt32to64 x) [c])
+(Rsh32x64  x (MOVVconst [c])) && uint64(c) < 32 => (SRAconst (SignExt32to64 x) [c])
+(Rsh32Ux64 x (MOVVconst [c])) && uint64(c) < 32 => (SRLconst (ZeroExt32to64 x) [c])
+(Lsh16x64  x (MOVVconst [c])) && uint64(c) < 16 => (SLLconst (ZeroExt16to64 x) [c])
+(Rsh16x64  x (MOVVconst [c])) && uint64(c) < 16 => (SRAconst (SignExt16to64 x) [c])
+(Rsh16Ux64 x (MOVVconst [c])) && uint64(c) < 16 => (SRLconst (ZeroExt16to64 x) [c])
+(Lsh8x64   x (MOVVconst [c])) && uint64(c) < 8  => (SLLconst (ZeroExt8to64  x) [c])
+(Rsh8x64   x (MOVVconst [c])) && uint64(c) < 8  => (SRAconst (SignExt8to64  x) [c])
+(Rsh8Ux64  x (MOVVconst [c])) && uint64(c) < 8  => (SRLconst (ZeroExt8to64  x) [c])
+
+(Lsh64x64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SLL <t> x y))
+(Lsh64x32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt32to64 y)))
+(Lsh64x16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt16to64 y)))
+(Lsh64x8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt8to64  y)))
+
+(Lsh32x64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SLL <t> x y))
+(Lsh32x32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt32to64 y)))
+(Lsh32x16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt16to64 y)))
+(Lsh32x8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt8to64  y)))
+
+(Lsh16x64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SLL <t> x y))
+(Lsh16x32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt32to64 y)))
+(Lsh16x16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt16to64 y)))
+(Lsh16x8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt8to64  y)))
+
+(Lsh8x64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SLL <t> x y))
+(Lsh8x32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt32to64 y)))
+(Lsh8x16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt16to64 y)))
+(Lsh8x8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt8to64  y)))
+
+(Rsh64Ux64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SRL <t> x y))
+(Rsh64Ux32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> x (ZeroExt32to64 y)))
+(Rsh64Ux16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> x (ZeroExt16to64 y)))
+(Rsh64Ux8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> x (ZeroExt8to64  y)))
+
+(Rsh32Ux64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt32to64 x) y))
+(Rsh32Ux32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt32to64 x) (ZeroExt32to64 y)))
+(Rsh32Ux16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt32to64 x) (ZeroExt16to64 y)))
+(Rsh32Ux8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt32to64 x) (ZeroExt8to64  y)))
+
+(Rsh16Ux64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt16to64 x) y))
+(Rsh16Ux32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt16to64 x) (ZeroExt32to64 y)))
+(Rsh16Ux16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt16to64 x) (ZeroExt16to64 y)))
+(Rsh16Ux8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt16to64 x) (ZeroExt8to64  y)))
+
+(Rsh8Ux64 <t> x y) => (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt8to64 x) y))
+(Rsh8Ux32 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt8to64 x) (ZeroExt32to64 y)))
+(Rsh8Ux16 <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt8to64 x) (ZeroExt16to64 y)))
+(Rsh8Ux8  <t> x y) => (AND (NEGV <t> (CMPULT (ZeroExt8to64  y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt8to64 x) (ZeroExt8to64  y)))
+
+(Rsh64x64 <t> x y) => (SRA x (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) y)) y))
+(Rsh64x32 <t> x y) => (SRA x (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt32to64 y))) (ZeroExt32to64 y)))
+(Rsh64x16 <t> x y) => (SRA x (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt16to64 y))) (ZeroExt16to64 y)))
+(Rsh64x8  <t> x y) => (SRA x (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt8to64  y))) (ZeroExt8to64  y)))
+
+(Rsh32x64 <t> x y) => (SRA (SignExt32to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) y)) y))
+(Rsh32x32 <t> x y) => (SRA (SignExt32to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt32to64 y))) (ZeroExt32to64 y)))
+(Rsh32x16 <t> x y) => (SRA (SignExt32to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt16to64 y))) (ZeroExt16to64 y)))
+(Rsh32x8  <t> x y) => (SRA (SignExt32to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt8to64  y))) (ZeroExt8to64  y)))
+
+
+(Rsh16x64 <t> x y) => (SRA (SignExt16to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) y)) y))
+(Rsh16x32 <t> x y) => (SRA (SignExt16to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt32to64 y))) (ZeroExt32to64 y)))
+(Rsh16x16 <t> x y) => (SRA (SignExt16to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt16to64 y))) (ZeroExt16to64 y)))
+(Rsh16x8  <t> x y) => (SRA (SignExt16to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt8to64  y))) (ZeroExt8to64  y)))
+
+(Rsh8x64 <t> x y) => (SRA (SignExt8to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) y)) y))
+(Rsh8x32 <t> x y) => (SRA (SignExt8to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt32to64 y))) (ZeroExt32to64 y)))
+(Rsh8x16 <t> x y) => (SRA (SignExt8to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt16to64 y))) (ZeroExt16to64 y)))
+(Rsh8x8  <t> x y) => (SRA (SignExt8to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt8to64  y))) (ZeroExt8to64  y)))
+
+//absorb shifts into ops
+//(ADDV x0:(SLLconst x [2]) y) && clobberIfDead(x0) => (S4ADDV x y)
+//(ADDV x0:(SLLconst x [3]) y) && clobberIfDead(x0) => (S8ADDV x y)
+
+// truncations
+// Because we ignore high parts of registers, truncates are just copies.
+(Trunc16to8 ...) => (Copy ...)
+(Trunc32to8 ...) => (Copy ...)
+(Trunc32to16 ...) => (Copy ...)
+(Trunc64to8 ...) => (Copy ...)
+(Trunc64to16 ...) => (Copy ...)
+(Trunc64to32 ...) => (Copy ...)
+
+// Zero-/Sign-extensions
+(ZeroExt8to16 ...) => (MOVBUreg ...)
+(ZeroExt8to32 ...) => (MOVBUreg ...)
+(ZeroExt16to32 ...) => (MOVHUreg ...)
+(ZeroExt8to64 ...) => (MOVBUreg ...)
+(ZeroExt16to64 ...) => (MOVHUreg ...)
+(ZeroExt32to64 ...) => (MOVWUreg ...)
+
+
+(SignExt8to16 ...) => (MOVBreg ...)
+(SignExt8to32 ...) => (MOVBreg ...)
+(SignExt16to32 ...) => (MOVHreg ...)
+(SignExt8to64 ...) => (MOVBreg ...)
+(SignExt16to64 ...) => (MOVHreg ...)
+(SignExt32to64 ...) => (MOVWreg ...)
+
+// Lowering comparisons
+//(Greater8U x y)  => (CMPULT (ZeroExt8to64 y) (ZeroExt8to64 x))
+//(Greater16U x y) => (CMPULT (ZeroExt16to64 y) (ZeroExt16to64 x))
+//(Greater32U x y) => (CMPULT (ZeroExt32to64 y) (ZeroExt32to64 x))
+//(Greater64U x y) => (CMPULT y x)
+//
+//(Greater8 x y)  => (CMPLT (SignExt8to64 y) (SignExt8to64 x))
+//(Greater16 x y) => (CMPLT (SignExt16to64 y) (SignExt16to64 x))
+//(Greater32 x y) => (CMPLT (SignExt32to64 y) (SignExt32to64 x))
+//(Greater64 x y) => (CMPLT y x)
+//(Greater(32|64)F x y) => (FEqual  (FCMPLT y x))
+//
+//(Geq8 x y)  => (CMPLE (SignExt8to64 y) (SignExt8to64 x))
+//(Geq16 x y) => (CMPLE (SignExt16to64 y) (SignExt16to64 x))
+//(Geq32 x y) => (CMPLE (SignExt32to64 y) (SignExt32to64 x))
+//(Geq64 x y) => (CMPLE  y x)
+//(Geq(32|64)F x y) => (FEqual (FCMPLE y x))
+//
+//(Geq8U x y)  => (CMPULE (ZeroExt8to64 y) (ZeroExt8to64 x))
+//(Geq16U x y) => (CMPULE (ZeroExt16to64 y) (ZeroExt16to64 x))
+//(Geq32U x y) => (CMPULE (ZeroExt32to64 y) (ZeroExt32to64 x))
+//(Geq64U x y) => (CMPULE y x)
+
+
+(Eq8 x y)  => (CMPEQ (ZeroExt8to64 x) (ZeroExt8to64 y))
+(Eq16 x y) => (CMPEQ (ZeroExt16to64 x) (ZeroExt16to64 y))
+(Eq32 x y) => (CMPEQ (ZeroExt32to64 x) (ZeroExt32to64 y))
+(Eq64 ...) => (CMPEQ ...)
+(EqPtr ...) => (CMPEQ ...)
+(Eq(32|64)F x y) => (FEqual (FCMPEQ x y))
+
+(Neq8 x y)  => (Not (CMPEQ (ZeroExt8to64 x) (ZeroExt8to64 y)))
+(Neq16 x y) => (Not (CMPEQ (ZeroExt16to64 x) (ZeroExt16to64 y)))
+(Neq32 x y) => (Not (CMPEQ (ZeroExt32to64 x) (ZeroExt32to64 y)))
+(Neq64 x y) => (Not (CMPEQ x y))
+(NeqPtr x y) => (Not (CMPEQ x y))
+(Neq(32|64)F x y) => (FNotEqual (FCMPEQ x y))
+
+(Less8 x y)  => (CMPLT (SignExt8to64 x) (SignExt8to64 y))
+(Less16 x y) => (CMPLT (SignExt16to64 x) (SignExt16to64 y))
+(Less32 x y) => (CMPLT (SignExt32to64 x) (SignExt32to64 y))
+(Less64 ...) => (CMPLT ...)
+(Less(32|64)F x y) => (FEqual (FCMPLT x y))
+
+(Less8U x y)  => (CMPULT (ZeroExt8to64 x) (ZeroExt8to64 y))
+(Less16U x y) => (CMPULT (ZeroExt16to64 x) (ZeroExt16to64 y))
+(Less32U x y) => (CMPULT (ZeroExt32to64 x) (ZeroExt32to64 y))
+(Less64U ...) => (CMPULT ...)
+
+(Leq8 x y)  =>  (CMPLE (SignExt8to64 x) (SignExt8to64 y))
+(Leq16 x y) => (CMPLE (SignExt16to64 x) (SignExt16to64 y))
+(Leq32 x y) =>  (CMPLE (SignExt32to64 x) (SignExt32to64 y))
+(Leq64 ...) =>  (CMPLE ...)
+(Leq(32|64)F x y) => (FEqual (FCMPLE x y))
+
+(Leq8U x y)  => (CMPULE (ZeroExt8to64 x) (ZeroExt8to64 y))
+(Leq16U x y) => (CMPULE (ZeroExt16to64 x) (ZeroExt16to64 y))
+(Leq32U x y) => (CMPULE (ZeroExt32to64 x) (ZeroExt32to64 y))
+(Leq64U ...) => (CMPULE ...)
+
+
+(OffPtr [off] ptr:(SP)) && is32Bit(off) => (SYMADDR [int32(off)] ptr)
+(OffPtr [off] ptr) => (ADDVconst [off] ptr)
+
+(Addr {sym} base) => (SYMADDR {sym} base)
+(LocalAddr <t> {sym} base mem) && t.Elem().HasPointers() => (SYMADDR {sym} (SPanchored base mem))
+(LocalAddr <t> {sym} base _)  && !t.Elem().HasPointers() => (SYMADDR {sym} base)
+
+// loads
+(Load <t> ptr mem) && t.IsBoolean() => (MOVBUload ptr mem)
+(Load <t> ptr mem) && (is8BitInt(t) &&  t.IsSigned()) => (MOVBload ptr mem)
+(Load <t> ptr mem) && (is8BitInt(t) && !t.IsSigned()) => (MOVBUload ptr mem)
+(Load <t> ptr mem) && (is16BitInt(t) &&  t.IsSigned()) => (MOVHload ptr mem)
+(Load <t> ptr mem) && (is16BitInt(t) && !t.IsSigned()) => (MOVHUload ptr mem)
+(Load <t> ptr mem) && (is32BitInt(t) &&  t.IsSigned()) => (MOVWload ptr mem)
+(Load <t> ptr mem) && (is32BitInt(t) && !t.IsSigned()) => (MOVWUload ptr mem)
+(Load <t> ptr mem) && (is64BitInt(t) || isPtr(t)) => (MOVVload ptr mem)
+(Load <t> ptr mem) && is32BitFloat(t) => (MOVFload ptr mem)
+(Load <t> ptr mem) && is64BitFloat(t) => (MOVDload ptr mem)
+
+// fold address into load/store
+(MOVBload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(int64(off1)+off2) => (MOVBload  [off1+int32(off2)] {sym} ptr mem)
+(MOVBUload [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(int64(off1)+off2) => (MOVBUload [off1+int32(off2)] {sym} ptr mem)
+(MOVHload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(int64(off1)+off2) => (MOVHload  [off1+int32(off2)] {sym} ptr mem)
+(MOVHUload [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(int64(off1)+off2) => (MOVHUload [off1+int32(off2)] {sym} ptr mem)
+(MOVWload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(int64(off1)+off2) => (MOVWload  [off1+int32(off2)] {sym} ptr mem)
+(MOVWUload [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(int64(off1)+off2) => (MOVWUload [off1+int32(off2)] {sym} ptr mem)
+(MOVVload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(int64(off1)+off2) => (MOVVload  [off1+int32(off2)] {sym} ptr mem)
+(MOVFload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(int64(off1)+off2) => (MOVFload  [off1+int32(off2)] {sym} ptr mem)
+(MOVDload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(int64(off1)+off2) => (MOVDload  [off1+int32(off2)] {sym} ptr mem)
+
+(MOVBstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is16Bit(int64(off1)+off2) => (MOVBstore [off1+int32(off2)] {sym} ptr val mem)
+(MOVHstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is16Bit(int64(off1)+off2) => (MOVHstore [off1+int32(off2)] {sym} ptr val mem)
+(MOVWstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is16Bit(int64(off1)+off2) => (MOVWstore [off1+int32(off2)] {sym} ptr val mem)
+(MOVVstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is16Bit(int64(off1)+off2) => (MOVVstore [off1+int32(off2)] {sym} ptr val mem)
+(MOVFstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is16Bit(int64(off1)+off2) => (MOVFstore [off1+int32(off2)] {sym} ptr val mem)
+(MOVDstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is16Bit(int64(off1)+off2) => (MOVDstore [off1+int32(off2)] {sym} ptr val mem)
+(MOVBstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(int64(off1)+off2) => (MOVBstorezero [off1+int32(off2)] {sym} ptr mem)
+(MOVHstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(int64(off1)+off2) => (MOVHstorezero [off1+int32(off2)] {sym} ptr mem)
+(MOVWstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(int64(off1)+off2) => (MOVWstorezero [off1+int32(off2)] {sym} ptr mem)
+(MOVVstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is16Bit(int64(off1)+off2) => (MOVVstorezero [off1+int32(off2)] {sym} ptr mem)
+
+// stores
+(Store {t} ptr val mem) && t.Size() == 1 => (MOVBstore ptr val mem)
+(Store {t} ptr val mem) && t.Size() == 2 => (MOVHstore ptr val mem)
+(Store {t} ptr val mem) && t.Size() == 4 && !is32BitFloat(val.Type) => (MOVWstore ptr val mem)
+(Store {t} ptr val mem) && t.Size() == 8 && !is64BitFloat(val.Type) => (MOVVstore ptr val mem)
+(Store {t} ptr val mem) && t.Size() == 4 && is32BitFloat(val.Type) => (MOVFstore ptr val mem)
+(Store {t} ptr val mem) && t.Size() == 8 && is64BitFloat(val.Type) => (MOVDstore ptr val mem)
+
+// zeroing
+(Zero [0] _ mem) => mem
+(Zero [1] ptr mem) => (MOVBstore ptr (MOVVconst [0]) mem)
+(Zero [2] {t} ptr mem) && t.Alignment()%2 == 0 =>
+        (MOVHstore ptr (MOVVconst [0]) mem)
+(Zero [2] ptr mem) =>
+        (MOVBstore [1] ptr (MOVVconst [0])
+                (MOVBstore [0] ptr (MOVVconst [0]) mem))
+(Zero [4] {t} ptr mem) && t.Alignment()%4 == 0 =>
+        (MOVWstore ptr (MOVVconst [0]) mem)
+(Zero [4] {t} ptr mem) && t.Alignment()%2 == 0 =>
+        (MOVHstore [2] ptr (MOVVconst [0])
+                (MOVHstore [0] ptr (MOVVconst [0]) mem))
+
+(Zero [4] ptr mem) =>
+        (MOVBstore [3] ptr (MOVVconst [0])
+                (MOVBstore [2] ptr (MOVVconst [0])
+                        (MOVBstore [1] ptr (MOVVconst [0])
+                                (MOVBstore [0] ptr (MOVVconst [0]) mem))))
+(Zero [8] {t} ptr mem) && t.Alignment()%8 == 0 =>
+        (MOVVstore ptr (MOVVconst [0]) mem)
+(Zero [8] {t} ptr mem) && t.Alignment()%4 == 0 =>
+        (MOVWstore [4] ptr (MOVVconst [0])
+                (MOVWstore [0] ptr (MOVVconst [0]) mem))
+(Zero [8] {t} ptr mem) && t.Alignment()%2 == 0 =>
+        (MOVHstore [6] ptr (MOVVconst [0])
+                (MOVHstore [4] ptr (MOVVconst [0])
+                        (MOVHstore [2] ptr (MOVVconst [0])
+                                (MOVHstore [0] ptr (MOVVconst [0]) mem))))
+
+(Zero [3] ptr mem) =>
+        (MOVBstore [2] ptr (MOVVconst [0])
+                (MOVBstore [1] ptr (MOVVconst [0])
+                        (MOVBstore [0] ptr (MOVVconst [0]) mem)))
+(Zero [6] {t} ptr mem) && t.Alignment()%2 == 0 =>
+        (MOVHstore [4] ptr (MOVVconst [0])
+                (MOVHstore [2] ptr (MOVVconst [0])
+                        (MOVHstore [0] ptr (MOVVconst [0]) mem)))
+(Zero [12] {t} ptr mem) && t.Alignment()%4 == 0 =>
+        (MOVWstore [8] ptr (MOVVconst [0])
+                (MOVWstore [4] ptr (MOVVconst [0])
+                        (MOVWstore [0] ptr (MOVVconst [0]) mem)))
+(Zero [16] {t} ptr mem) && t.Alignment()%8 == 0 =>
+        (MOVVstore [8] ptr (MOVVconst [0])
+                (MOVVstore [0] ptr (MOVVconst [0]) mem))
+(Zero [24] {t} ptr mem) && (t.Alignment()%8 == 0 || buildcfg.GOSW64 >=4) =>
+        (MOVVstore [16] ptr (MOVVconst [0])
+                (MOVVstore [8] ptr (MOVVconst [0])
+                        (MOVVstore [0] ptr (MOVVconst [0]) mem)))
+(Zero [32] {t} ptr mem) && (t.Alignment()%8 == 0 || buildcfg.GOSW64 >=4) =>
+        (MOVVstore [24] ptr (MOVVconst [0])
+                (MOVVstore [16] ptr (MOVVconst [0])
+                        (MOVVstore [8] ptr (MOVVconst [0])
+                               (MOVVstore [0] ptr (MOVVconst [0]) mem))))
+
+// medium zeroing uses a duff device
+// 8, and 128 are magic constants, see runtime/mkduff.go
+(Zero [s] {t} ptr mem)
+        && s%8 == 0 && s > 24 && s <= 8*128
+        && t.Alignment()%8 == 0 && !config.noDuffDevice =>
+        (DUFFZERO [8 * (128 - int64(s/8))] ptr mem)
+
+// large or unaligned zeroing uses a loop
+(Zero [s] {t} ptr mem)
+        && (s > 8*128 || config.noDuffDevice) || t.Alignment()%8 != 0 =>
+        (LoweredZero [t.Alignment()]
+                ptr
+                (ADDVconst <ptr.Type> ptr [s-moveSize(t.Alignment(), config)])
+                mem)
+
+// moves
+(Move [0] _ _ mem) => mem
+(Move [1] dst src mem) => (MOVBstore dst (MOVBload src mem) mem)
+(Move [2] {t} dst src mem) && t.Alignment()%2 == 0 =>
+        (MOVHstore dst (MOVHload src mem) mem)
+(Move [2] dst src mem) =>
+        (MOVBstore [1] dst (MOVBload [1] src mem)
+                (MOVBstore dst (MOVBload src mem) mem))
+(Move [4] {t} dst src mem) && t.Alignment()%4 == 0 =>
+        (MOVWstore dst (MOVWload src mem) mem)
+(Move [4] {t} dst src mem) && t.Alignment()%2 == 0 =>
+        (MOVHstore [2] dst (MOVHload [2] src mem)
+                (MOVHstore dst (MOVHload src mem) mem))
+
+(Move [4] dst src mem) =>
+        (MOVBstore [3] dst (MOVBload [3] src mem)
+                (MOVBstore [2] dst (MOVBload [2] src mem)
+                        (MOVBstore [1] dst (MOVBload [1] src mem)
+                                (MOVBstore dst (MOVBload src mem) mem))))
+(Move [8] {t} dst src mem) && t.Alignment()%8 == 0 =>
+        (MOVVstore dst (MOVVload src mem) mem)
+(Move [8] {t} dst src mem) && t.Alignment()%4 == 0 =>
+        (MOVWstore [4] dst (MOVWload [4] src mem)
+                (MOVWstore dst (MOVWload src mem) mem))
+(Move [8] {t} dst src mem) && t.Alignment()%2 == 0 =>
+        (MOVHstore [6] dst (MOVHload [6] src mem)
+                (MOVHstore [4] dst (MOVHload [4] src mem)
+                        (MOVHstore [2] dst (MOVHload [2] src mem)
+                                (MOVHstore dst (MOVHload src mem) mem))))
+
+(Move [3] dst src mem) =>
+        (MOVBstore [2] dst (MOVBload [2] src mem)
+                (MOVBstore [1] dst (MOVBload [1] src mem)
+                        (MOVBstore dst (MOVBload src mem) mem)))
+(Move [6] {t} dst src mem) && t.Alignment()%2 == 0 =>
+        (MOVHstore [4] dst (MOVHload [4] src mem)
+                (MOVHstore [2] dst (MOVHload [2] src mem)
+                        (MOVHstore dst (MOVHload src mem) mem)))
+(Move [12] {t} dst src mem) && t.Alignment()%4 == 0 =>
+        (MOVWstore [8] dst (MOVWload [8] src mem)
+                (MOVWstore [4] dst (MOVWload [4] src mem)
+                        (MOVWstore dst (MOVWload src mem) mem)))
+(Move [16] {t} dst src mem) && t.Alignment()%8 == 0 =>
+        (MOVVstore [8] dst (MOVVload [8] src mem)
+                (MOVVstore dst (MOVVload src mem) mem))
+(Move [24] {t} dst src mem) && t.Alignment()%8 == 0 =>
+        (MOVVstore [16] dst (MOVVload [16] src mem)
+                (MOVVstore [8] dst (MOVVload [8] src mem)
+                        (MOVVstore dst (MOVVload src mem) mem)))
+
+// large or unaligned move uses a loop
+(Move [s] {t} dst src mem)
+        && s > 24 && logLargeCopy(v, s) || t.Alignment()%8 != 0 =>
+        (LoweredMove [t.Alignment()]
+                dst
+                src
+                (ADDVconst <src.Type> src [s-moveSize(t.Alignment(), config)])
+                mem)
+
+
+// calls
+(StaticCall ...) => (CALLstatic ...)
+(ClosureCall ...) => (CALLclosure ...)
+(InterCall ...) => (CALLinter ...)
+(TailCall ...) => (CALLtail ...)
+
+// checks
+(NilCheck ...) => (LoweredNilCheck ...)
+//(IsNonNil ptr) => (Greater64U   ptr (MOVVconst [0]))
+(IsNonNil ptr) => (CMPULT (MOVVconst [0]) ptr)
+(IsInBounds ...) => (CMPULT ...)
+(IsSliceInBounds ...) => (CMPULE ...)
+
+// (If cond yes no) => (NE cond yes no)
+(If cond yes no) => (LBS cond yes no)
+
+(LBS (CMPEQ x y) yes no) => (NE (CMPEQ x y) yes no)
+(LBS (XORconst (CMPEQ x y) [1]) yes no) => (EQ (CMPEQ x y) yes no)
+(LBS (CMPLT x y) yes no) => (NE (CMPLT x y) yes no)
+(LBS (CMPULT x y) yes no) => (NE (CMPULT x y) yes no)
+(LBS (CMPLE x y) yes no) => (NE (CMPLE x y) yes no)
+(LBS (CMPULE x y) yes no) => (NE (CMPULE x y) yes no)
+(LBS (FEqual cc) yes no) => (FNE cc yes no)
+(LBS (FNotEqual cc) yes no) => (FEQ cc yes no)
+
+
+// fold address into load/store
+(MOVBload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(int64(off1)+off2) => (MOVBload  [off1+int32(off2)] {sym} ptr mem)
+(MOVBUload [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(int64(off1)+off2) => (MOVBUload [off1+int32(off2)] {sym} ptr mem)
+(MOVHload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(int64(off1)+off2) => (MOVHload  [off1+int32(off2)] {sym} ptr mem)
+(MOVHUload [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(int64(off1)+off2) => (MOVHUload [off1+int32(off2)] {sym} ptr mem)
+(MOVWload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(int64(off1)+off2) => (MOVWload  [off1+int32(off2)] {sym} ptr mem)
+(MOVWUload [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(int64(off1)+off2) => (MOVWUload [off1+int32(off2)] {sym} ptr mem)
+(MOVVload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(int64(off1)+off2) => (MOVVload  [off1+int32(off2)] {sym} ptr mem)
+(MOVFload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(int64(off1)+off2) => (MOVFload  [off1+int32(off2)] {sym} ptr mem)
+(MOVDload  [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(int64(off1)+off2) => (MOVDload  [off1+int32(off2)] {sym} ptr mem)
+
+(MOVBstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is32Bit(int64(off1)+off2) => (MOVBstore [off1+int32(off2)] {sym} ptr val mem)
+(MOVHstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is32Bit(int64(off1)+off2) => (MOVHstore [off1+int32(off2)] {sym} ptr val mem)
+(MOVWstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is32Bit(int64(off1)+off2) => (MOVWstore [off1+int32(off2)] {sym} ptr val mem)
+(MOVVstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is32Bit(int64(off1)+off2) => (MOVVstore [off1+int32(off2)] {sym} ptr val mem)
+(MOVFstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is32Bit(int64(off1)+off2) => (MOVFstore [off1+int32(off2)] {sym} ptr val mem)
+(MOVDstore [off1] {sym} (ADDVconst [off2] ptr) val mem) && is32Bit(int64(off1)+off2) => (MOVDstore [off1+int32(off2)] {sym} ptr val mem)
+(MOVBstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(int64(off1)+off2) => (MOVBstorezero [off1+int32(off2)] {sym} ptr mem)
+(MOVHstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(int64(off1)+off2) => (MOVHstorezero [off1+int32(off2)] {sym} ptr mem)
+(MOVWstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(int64(off1)+off2) => (MOVWstorezero [off1+int32(off2)] {sym} ptr mem)
+(MOVVstorezero [off1] {sym} (ADDVconst [off2] ptr) mem) && is32Bit(int64(off1)+off2) => (MOVVstorezero [off1+int32(off2)] {sym} ptr mem)
+
+(MOVBload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVBload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+(MOVBUload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVBUload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+(MOVHload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVHload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+(MOVHUload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVHUload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+(MOVWload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVWload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+(MOVWUload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVWUload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+(MOVVload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVVload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+(MOVFload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVFload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+(MOVDload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVDload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+
+
+(MOVBstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVBstore [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr val mem)
+(MOVHstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVHstore [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr val mem)
+(MOVWstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVWstore [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr val mem)
+(MOVVstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVVstore [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr val mem)
+(MOVFstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVFstore [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr val mem)
+(MOVDstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVDstore [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr val mem)
+(MOVBstorezero [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVBstorezero [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+(MOVHstorezero [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVHstorezero [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+(MOVWstorezero [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVWstorezero [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+(MOVVstorezero [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem) && canMergeSym(sym1,sym2) &&
+ is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared) =>
+        (MOVVstorezero [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+
+// store zero
+(MOVBstore [off] {sym} ptr (MOVVconst [0]) mem) => (MOVBstorezero [off] {sym} ptr mem)
+(MOVHstore [off] {sym} ptr (MOVVconst [0]) mem) => (MOVHstorezero [off] {sym} ptr mem)
+(MOVWstore [off] {sym} ptr (MOVVconst [0]) mem) => (MOVWstorezero [off] {sym} ptr mem)
+(MOVVstore [off] {sym} ptr (MOVVconst [0]) mem) => (MOVVstorezero [off] {sym} ptr mem)
+
+// don't extend after proper load
+(MOVBUreg x:(MOVBUload _ _)) => (MOVVreg x)
+(MOVHUreg x:(MOVBUload _ _)) => (MOVVreg x)
+(MOVHUreg x:(MOVHUload _ _)) => (MOVVreg x)
+(MOVWreg x:(MOVWload _ _)) => (MOVVreg x)
+(MOVWUreg x:(MOVBUload _ _)) => (MOVVreg x)
+(MOVWUreg x:(MOVHUload _ _)) => (MOVVreg x)
+
+// fold double extensions
+(MOVBreg x:(MOVBreg _)) => (MOVVreg x)
+(MOVBUreg x:(MOVBUreg _)) => (MOVVreg x)
+(MOVHreg x:(MOVBreg _)) => (MOVVreg x)
+(MOVHreg x:(MOVHreg _)) => (MOVVreg x)
+(MOVHUreg x:(MOVBUreg _)) => (MOVVreg x)
+(MOVHUreg x:(MOVHUreg _)) => (MOVVreg x)
+(MOVWreg x:(MOVBreg _)) => (MOVVreg x)
+(MOVWreg x:(MOVHreg _)) => (MOVVreg x)
+(MOVWreg x:(MOVWreg _)) => (MOVVreg x)
+(MOVWUreg x:(MOVBUreg _)) => (MOVVreg x)
+(MOVWUreg x:(MOVHUreg _)) => (MOVVreg x)
+(MOVWUreg x:(MOVWUreg _)) => (MOVVreg x)
+
+// don't extend before store
+(MOVBstore [off] {sym} ptr (MOVBreg x) mem) => (MOVBstore [off] {sym} ptr x mem)
+(MOVBstore [off] {sym} ptr (MOVBUreg x) mem) => (MOVBstore [off] {sym} ptr x mem)
+(MOVBstore [off] {sym} ptr (MOVHreg x) mem) => (MOVBstore [off] {sym} ptr x mem)
+(MOVBstore [off] {sym} ptr (MOVHUreg x) mem) => (MOVBstore [off] {sym} ptr x mem)
+(MOVBstore [off] {sym} ptr (MOVWreg x) mem) => (MOVBstore [off] {sym} ptr x mem)
+(MOVBstore [off] {sym} ptr (MOVWUreg x) mem) => (MOVBstore [off] {sym} ptr x mem)
+(MOVHstore [off] {sym} ptr (MOVHreg x) mem) => (MOVHstore [off] {sym} ptr x mem)
+(MOVHstore [off] {sym} ptr (MOVHUreg x) mem) => (MOVHstore [off] {sym} ptr x mem)
+(MOVHstore [off] {sym} ptr (MOVWreg x) mem) => (MOVHstore [off] {sym} ptr x mem)
+(MOVHstore [off] {sym} ptr (MOVWUreg x) mem) => (MOVHstore [off] {sym} ptr x mem)
+(MOVWstore [off] {sym} ptr (MOVWreg x) mem) => (MOVWstore [off] {sym} ptr x mem)
+(MOVWstore [off] {sym} ptr (MOVWUreg x) mem) => (MOVWstore [off] {sym} ptr x mem)
+
+// if a register move has only 1 use, just use the same register without emitting instruction
+// MOVVnop doesn't emit instruction, only for ensuring the type.
+(MOVVreg x) && x.Uses == 1 => (MOVVnop x)
+
+// TODO: we should be able to get rid of MOVVnop all together.
+// But for now, this is enough to get rid of lots of them.
+(MOVVnop (MOVVconst [c])) => (MOVVconst [c])
+
+// fold constant into arithmatic ops
+(ADDV x (MOVVconst <t> [c])) && is32Bit(c) && !t.IsPtr() => (ADDVconst [c] x)
+(SUBV x (MOVVconst [c])) && is32Bit(c) => (SUBVconst [c] x)
+(MULW x (MOVVconst [c])) && is32Bit(c) => (MULWconst [c] x)
+(MULL x (MOVVconst [c]))  => (MULLconst [c] x)
+(AND x (MOVVconst [c])) && is32Bit(c) => (ANDconst [c] x)
+(BIS  x (MOVVconst [c])) && is32Bit(c) => (BISconst  [c] x)
+(XOR x (MOVVconst [c])) && is32Bit(c) => (XORconst [c] x)
+(ORNOT x (MOVVconst [c])) && is32Bit(c) => (ORNOTconst [c] x)
+
+(CMPEQ x (MOVVconst [c])) && is32Bit(c) => (CMPEQconst [c] x)
+(CMPLT x (MOVVconst [c])) && is32Bit(c) => (CMPLTconst [c] x)
+(CMPLE x (MOVVconst [c])) && is32Bit(c) => (CMPLEconst [c] x)
+(CMPULT x (MOVVconst [c])) && is32Bit(c) => (CMPULTconst [c] x)
+(CMPULE x (MOVVconst [c])) && is32Bit(c) => (CMPULEconst [c] x)
+
+(SEXTB  (MOVVconst [c])) => (MOVVconst [int64(int8(c))])
+(ANDconst  (MOVVconst [c]) [255]) => (MOVVconst [int64(uint8(c))])
+(SEXTH  (MOVVconst [c])) => (MOVVconst [int64(int16(c))])
+(ANDconst (MOVVconst [c]) [65535]) => (MOVVconst [int64(uint16(c))])
+(ADDWconst  (MOVVconst [c]) [0]) => (MOVVconst [int64(int32(c))])
+(ANDconst (MOVVconst [c]) [0xffffffff])  => (MOVVconst [int64(uint32(c))])
+
+(MOVBreg  (MOVVconst [c])) => (MOVVconst [int64(int8(c))])
+(MOVBUreg (MOVVconst [c])) => (MOVVconst [int64(uint8(c))])
+(MOVHreg  (MOVVconst [c])) => (MOVVconst [int64(int16(c))])
+(MOVHUreg (MOVVconst [c])) => (MOVVconst [int64(uint16(c))])
+(MOVWreg  (MOVVconst [c])) => (MOVVconst [int64(int32(c))])
+(MOVWUreg (MOVVconst [c])) => (MOVVconst [int64(uint32(c))])
+(MOVVreg  (MOVVconst [c])) => (MOVVconst [c])
+
+// generic simplifications
+(ADDV x (NEGV y)) => (SUBV x y)
+(SUBV x x) => (MOVVconst [0])
+(SUBV (MOVVconst [0]) x) => (NEGV x)
+(AND x x) => x
+(BIS  x x) => x
+(XOR x x) => (MOVVconst [0])
+
+
+// remove redundant *const ops
+(ADDVconst [0]  x) => x
+(SUBVconst [0]  x) => x
+(ANDconst [0]  _) => (MOVVconst [0])
+(ANDconst [-1] x) => x
+(BISconst  [0]  x) => x
+(BISconst  [-1] _) => (MOVVconst [-1])
+(XORconst [0]  x) => x
+// (MULLconst [0] x) => (MOVVconst [0])
+// (MULLconst [-1] x) => (NEGV x)
+// (MULLconst [1] x) => x
+
+// generic constant folding
+(ADDVconst [c] (MOVVconst [d]))  => (MOVVconst [c+d])
+(ADDVconst [c] (ADDVconst [d] x)) && is32Bit(c+d) => (ADDVconst [c+d] x)
+(ADDVconst [c] (SUBVconst [d] x)) && is32Bit(c-d) => (ADDVconst [c-d] x)
+(SUBVconst [c] (MOVVconst [d]))  => (MOVVconst [d-c])
+(SUBVconst [c] (SUBVconst [d] x)) && is32Bit(-c-d) => (ADDVconst [-c-d] x)
+(SUBVconst [c] (ADDVconst [d] x)) && is32Bit(-c+d) => (ADDVconst [-c+d] x)
+(SLLconst [c] (MOVVconst [d]))  => (MOVVconst [int64(d)<<uint64(c)])
+(SRLconst [c] (MOVVconst [d]))  => (MOVVconst [int64(uint64(d)>>uint64(c))])
+(SRAconst [c] (MOVVconst [d]))  => (MOVVconst [int64(d)>>uint64(c)])
+(ANDconst [c] (MOVVconst [d])) => (MOVVconst [c&d])
+(ANDconst [c] (ANDconst [d] x)) => (ANDconst [c&d] x)
+(BISconst [c] (MOVVconst [d])) => (MOVVconst [c|d])
+(BISconst [c] (BISconst [d] x)) && is32Bit(c|d) => (BISconst [c|d] x)
+(XORconst [c] (MOVVconst [d])) => (MOVVconst [c^d])
+(XORconst [c] (XORconst [d] x)) && is32Bit(c^d) => (XORconst [c^d] x)
+(NEGV (MOVVconst [c])) => (MOVVconst [-c])
+
+// mul by specific constant
+(MULLconst [c] x) && isPowerOfTwo64(c-1) && c>=3 => (ADDV (SLLconst <x.Type> x [log64(c-1)]) x)
+(MULLconst [c] x) && isPowerOfTwo64(c+1) && c>=7 => (SUBV (SLLconst <x.Type> x [log64(c+1)]) x)
+(MULLconst [c] x) && c%3 == 0 && isPowerOfTwo64(c/3) => (SLLconst <x.Type> (ADDV <x.Type> (SLLconst <x.Type> x [1]) x) [log64(c/3)])
+(MULLconst [c] x) && c%5 == 0 && isPowerOfTwo64(c/5) => (SLLconst <x.Type> (S4ADDV <x.Type> x x) [log64(c/5)])
+(MULLconst [c] x) && c%7 == 0 && isPowerOfTwo64(c/7) => (SLLconst <x.Type> (S8SUBV <x.Type> x x) [log64(c/7)])
+(MULLconst [c] x) && c%9 == 0 && isPowerOfTwo64(c/9) => (SLLconst <x.Type> (S8ADDV <x.Type> x x) [log64(c/9)])
+
+// fold offset into address
+(ADDVconst [off1] (SYMADDR [off2] {sym} ptr)) && is32Bit(off1+int64(off2)) => (SYMADDR [int32(off1)+off2] {sym} ptr)
+
+(NE (XORconst cmp:(CMPEQ _ _) [1]) yes no) => (EQ cmp yes no)
+(EQ (XORconst cmp:(CMPEQ _ _) [1]) yes no) => (NE cmp yes no)
+(NE (XORconst cmp:(CMPEQconst _) [1]) yes no) => (EQ cmp yes no)
+(EQ (XORconst cmp:(CMPEQconst _) [1]) yes no) => (NE cmp yes no)
+
+(NE (CMPEQconst x [0]) yes no) => (EQ x yes no)
+(EQ (CMPEQconst x [0]) yes no) => (NE x yes no)
+(NE (CMPLTconst x [0]) yes no) => (LT x yes no)
+(EQ (CMPLTconst x [0]) yes no) => (GE x yes no)
+(NE (CMPLEconst x [0]) yes no) => (LE x yes no)
+(EQ (CMPLEconst x [0]) yes no) => (GT x yes no)
+(NE (CMPLTconst x [1]) yes no) => (LE x yes no)
+(EQ (CMPLTconst x [1]) yes no) => (GT x yes no)
+(NE (CMPULTconst x [1]) yes no) => (EQ x yes no)
+(EQ (CMPULTconst x [1]) yes no) => (NE x yes no)
+(NE (CMPULEconst x [0]) yes no) => (EQ x yes no)
+(EQ (CMPULEconst x [0]) yes no) => (NE x yes no)
+
+(NE (CMPEQ x (MOVVconst [0])) yes no) => (EQ x yes no)
+(EQ (CMPEQ x (MOVVconst [0])) yes no) => (NE x yes no)
+(NE (CMPLT x (MOVVconst [0])) yes no) => (LT x yes no)
+(EQ (CMPLT x (MOVVconst [0])) yes no) => (GE x yes no)
+(NE (CMPLT x (MOVVconst [1])) yes no) => (LE x yes no)
+(EQ (CMPLT x (MOVVconst [1])) yes no) => (GT x yes no)
+(NE (CMPLE x (MOVVconst [0])) yes no) => (LE x yes no)
+(EQ (CMPLE x (MOVVconst [0])) yes no) => (GT x yes no)
+(NE (CMPULT x (MOVVconst [1])) yes no) => (EQ x yes no)
+(EQ (CMPULT x (MOVVconst [1])) yes no) => (NE x yes no)
+(NE (CMPULE x (MOVVconst [0])) yes no) => (EQ x yes no)
+(EQ (CMPULE x (MOVVconst [0])) yes no) => (NE x yes no)
+(NE (CMPEQ (MOVVconst [0]) x) yes no) => (EQ x yes no)
+(EQ (CMPEQ (MOVVconst [0]) x) yes no) => (NE x yes no)
+(NE (CMPLT (MOVVconst [0]) x) yes no) => (GT x yes no)
+(EQ (CMPLT (MOVVconst [0]) x) yes no) => (LE x yes no)
+(NE (CMPLE (MOVVconst [0]) x) yes no) => (GE x yes no)
+(EQ (CMPLE (MOVVconst [0]) x) yes no) => (LT x yes no)
+(NE (CMPLE (MOVVconst [1]) x) yes no) => (GT x yes no)
+(EQ (CMPLE (MOVVconst [1]) x) yes no) => (LE x yes no)
+(NE (CMPULT (MOVVconst [0]) x) yes no) => (NE x yes no)
+(EQ (CMPULT (MOVVconst [0]) x) yes no) => (EQ x yes no)
+(NE (CMPULE (MOVVconst [1]) x) yes no) => (NE x yes no)
+(EQ (CMPULE (MOVVconst [1]) x) yes no) => (EQ x yes no)
+
+(NE (FNotEqual cmp) yes no) => (FEQ cmp yes no)
+(NE (FEqual cmp) yes no) => (FNE cmp yes no)
+(EQ (FNotEqual cmp) yes no) => (FNE cmp yes no)
+(EQ (FEqual cmp) yes no) => (FEQ cmp yes no)
+
+(JumpTable idx) => (JUMPTABLE {makeJumpTableSym(b)} idx (SYMADDR <typ.Uintptr> {makeJumpTableSym(b)} (SB)))
+
+(PanicBounds [kind] x y mem) && boundsABI(kind) == 0 => (LoweredPanicBoundsA [kind] x y mem)
+(PanicBounds [kind] x y mem) && boundsABI(kind) == 1 => (LoweredPanicBoundsB [kind] x y mem)
+(PanicBounds [kind] x y mem) && boundsABI(kind) == 2 => (LoweredPanicBoundsC [kind] x y mem)
+
+// rotates
+(RotateLeft8 <t> x (MOVVconst [c])) => (Or8 (Lsh8x64 <t> x (MOVVconst [c&7])) (Rsh8Ux64 <t> x (MOVVconst [-c&7])))
+(RotateLeft16 <t> x (MOVVconst [c])) => (Or16 (Lsh16x64 <t> x (MOVVconst [c&15])) (Rsh16Ux64 <t> x (MOVVconst [-c&15])))
+(RotateLeft32 <t> x (MOVVconst [c])) => (Or32 (Lsh32x64 <t> x (MOVVconst [c&31])) (Rsh32Ux64 <t> x (MOVVconst [-c&31])))
+(RotateLeft64 <t> x (MOVVconst [c])) => (Or64 (Lsh64x64 <t> x (MOVVconst [c&63])) (Rsh64Ux64 <t> x (MOVVconst [-c&63])))
+
+// atomic intrinsics
+(AtomicLoad(8|32|64) ...) => (LoweredAtomicLoad(8|32|64) ...)
+(AtomicLoadPtr ...) => (LoweredAtomicLoad64 ...)
+
+(AtomicStore(8|32|64) ...) => (LoweredAtomicStore(8|32|64) ...)
+(AtomicStorePtrNoWB ...) => (LoweredAtomicStore64 ...)
+
+(AtomicExchange(32|64) ...) => (LoweredAtomicExchange(32|64) ...)
+
+(AtomicAdd(32|64) ...) => (LoweredAtomicAdd(32|64) ...)
+
+(AtomicCompareAndSwap32 ptr old new mem) => (LoweredAtomicCas32 ptr (SignExt32to64 old) new mem)
+(AtomicCompareAndSwap64 ...) => (LoweredAtomicCas64 ...)
diff --git a/src/cmd/compile/internal/ssa/_gen/SW64Ops.go b/src/cmd/compile/internal/ssa/_gen/SW64Ops.go
new file mode 100644
index 00000000..daa562f5
--- /dev/null
+++ b/src/cmd/compile/internal/ssa/_gen/SW64Ops.go
@@ -0,0 +1,521 @@
+// Copyright 2016 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build ignore
+
+package main
+
+import "strings"
+
+// Notes:
+//  - Integer types live in the low portion of registers. Upper portions are junk.
+//  - Boolean types use the low-order byte of a register. 0=false, 1=true.
+//    Upper bytes are junk.
+//  - *const instructions may use a constant larger than the instruction can encode.
+//    In this case the assembler expands to multiple instructions and uses tmp
+//    register (R28).
+
+// Suffixes encode the bit width of various instructions.
+// V (vlong)     = 64 bit
+// WU (word)     = 32 bit unsigned
+// W (word)      = 32 bit
+// H (half word) = 16 bit
+// HU            = 16 bit unsigned
+// B (byte)      = 8 bit
+// BU            = 8 bit unsigned
+// F (float)     = 32 bit float
+// D (double)    = 64 bit float
+
+// Note: registers not used in regalloc are not included in this list,
+// so that regmask stays within int64
+// Be careful when hand coding regmasks.
+var regNamesSW64 = []string{
+	"R0",
+	"R1",
+	"R2",
+	"R3",
+	"R4",
+	"R5",
+	"R6",
+	"R7",
+	"R8",
+	"R9",
+	"R10",
+	"R11",
+	"R12",
+	"R13",
+	"R14",
+	"g", //R15
+	"R16",
+	"R17",
+	"R18",
+	"R19",
+	"R20",
+	"R21",
+	"R22",
+	"R23",
+	"R24",
+	"R25", //REGCTXT
+	"R26", //link register
+	//"R27", //PV
+	//"R28", REGTMP
+	//"R29", REGSB
+	"SP",  //R30
+	"R31", // REGZERO
+
+	"F0",
+	"F1",
+	"F2",
+	"F3",
+	"F4",
+	"F5",
+	"F6",
+	"F7",
+	"F8",
+	"F9",
+	"F10",
+	"F11",
+	"F12",
+	"F13",
+	"F14",
+	"F15",
+	"F16",
+	"F17",
+	"F18",
+	"F19",
+	"F20",
+	"F21",
+	"F22",
+	"F23",
+	"F24",
+	"F25",
+	"F26",
+	"F27",
+	"F28",
+	"F29",
+	"F30",
+	"F31",
+
+	// pseudo-registers
+	"SB",
+}
+
+func init() {
+	// Make map from reg names to reg integers.
+	if len(regNamesSW64) > 64 {
+		panic("too many registers")
+	}
+	num := map[string]int{}
+	for i, name := range regNamesSW64 {
+		num[name] = i
+	}
+	buildReg := func(s string) regMask {
+		m := regMask(0)
+		for _, r := range strings.Split(s, " ") {
+			if n, ok := num[r]; ok {
+				m |= regMask(1) << uint(n)
+				continue
+			}
+			panic("register " + r + " not found")
+		}
+		return m
+	}
+
+	// Common individual register masks
+	var (
+		gp         = buildReg("R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25")
+		gpg        = gp | buildReg("g")
+		gpsp       = gp | buildReg("SP")
+		gpspg      = gpg | buildReg("SP")
+		gpspsbg    = gpspg | buildReg("SB")
+		fp         = buildReg("F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30")
+		fp_src     = buildReg("F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20")
+		fp_dst     = buildReg("F21 F22 F23 F24 F25 F26 F27 F28 F29 F30")
+		callerSave = gp | fp | buildReg("g") // runtime.setg (and anything calling it) may clobber g
+
+    r1 = buildReg("R1")
+		r2 = buildReg("R2")
+		r3 = buildReg("R3")
+		r4 = buildReg("R4")
+	)
+	// Common regInfo
+	var (
+		gp01   = regInfo{inputs: nil, outputs: []regMask{gp}}
+		gp11   = regInfo{inputs: []regMask{gpg}, outputs: []regMask{gp}}
+		gp11sp = regInfo{inputs: []regMask{gpspg}, outputs: []regMask{gp}}
+		gp21   = regInfo{inputs: []regMask{gpg, gpg}, outputs: []regMask{gp}}
+		//gp2hilo  = regInfo{inputs: []regMask{gpg, gpg}, outputs: []regMask{hi, lo}}
+		gpload   = regInfo{inputs: []regMask{gpspsbg}, outputs: []regMask{gp}}
+		gpstore  = regInfo{inputs: []regMask{gpspsbg, gpg}}
+		gpstore0 = regInfo{inputs: []regMask{gpspsbg}}
+		gpxchg   = regInfo{inputs: []regMask{gpspsbg, gpg}, outputs: []regMask{gp}}
+		gpcas    = regInfo{inputs: []regMask{gpspsbg, gpg, gpg}, outputs: []regMask{gp}}
+		fp01     = regInfo{inputs: nil, outputs: []regMask{fp}}
+		fp11     = regInfo{inputs: []regMask{fp}, outputs: []regMask{fp}}
+		ffp11    = regInfo{inputs: []regMask{fp_src}, outputs: []regMask{fp_dst}}
+		//fp1flags  = regInfo{inputs: []regMask{fp}}
+		//fpgp      = regInfo{inputs: []regMask{fp}, outputs: []regMask{gp}}
+		//gpfp      = regInfo{inputs: []regMask{gp}, outputs: []regMask{fp}}
+		fp21  = regInfo{inputs: []regMask{fp, fp}, outputs: []regMask{fp}}
+		ffp21 = regInfo{inputs: []regMask{fp_src, fp_src}, outputs: []regMask{fp_dst}}
+		//fp31  = regInfo{inputs: []regMask{fp, fp, fp}, outputs: []regMask{fp}}
+		// fp2flags  = regInfo{inputs: []regMask{fp, fp}}
+		fpload    = regInfo{inputs: []regMask{gpspsbg}, outputs: []regMask{fp}}
+		fpstore   = regInfo{inputs: []regMask{gpspsbg, fp}}
+		readflags = regInfo{inputs: []regMask{fp}, outputs: []regMask{gp}}
+		ifp11     = regInfo{inputs: []regMask{gp}, outputs: []regMask{fp}}
+		fip11     = regInfo{inputs: []regMask{fp}, outputs: []regMask{gp}}
+	)
+	ops := []opData{
+		// binary ops
+		{name: "ADDV", argLength: 2, reg: gp21, asm: "ADDL", commutative: true},
+		{name: "ADDVconst", argLength: 1, reg: gp11sp, asm: "ADDL", aux: "Int64"},
+		{name: "ADDW", argLength: 2, reg: gp21, asm: "ADDW", commutative: true},
+		{name: "ADDWconst", argLength: 1, reg: gp11sp, asm: "ADDW", aux: "Int32"},
+		{name: "S4ADDV", argLength: 2, reg: gp21, asm: "S4ADDL"},
+		{name: "S8ADDV", argLength: 2, reg: gp21, asm: "S8ADDL"},
+		{name: "SUBV", argLength: 2, reg: gp21, asm: "SUBL"},
+		{name: "SUBVconst", argLength: 1, reg: gp11sp, asm: "SUBL", aux: "Int64"},
+		{name: "S4SUBV", argLength: 2, reg: gp21, asm: "S4SUBL"},
+		{name: "S8SUBV", argLength: 2, reg: gp21, asm: "S8SUBL"},
+		{name: "DIVV", argLength: 2, reg: gp21, asm: "DIVL"},
+		{name: "DIVVconst", argLength: 1, reg: gp11sp, asm: "DIVL", aux: "Int64"},
+		{name: "UDIVV", argLength: 2, reg: gp21, asm: "UDIVL"},
+		{name: "DIVW", argLength: 2, reg: gp21, asm: "DIVW"},
+		{name: "UDIVW", argLength: 2, reg: gp21, asm: "UDIVW"},
+		{name: "MULW", argLength: 2, reg: gp21, asm: "MULW", commutative: true},
+		{name: "MULWconst", argLength: 1, reg: gp11sp, asm: "MULW", aux: "Int64"},
+		{name: "MULL", argLength: 2, reg: gp21, asm: "MULL", commutative: true},
+		{name: "MULLconst", argLength: 1, reg: gp11sp, asm: "MULL", aux: "Int64"},
+		{name: "UMULH", argLength: 2, reg: gp21, asm: "UMULH", commutative: true},
+		{name: "UMULHconst", argLength: 1, reg: gp11sp, asm: "UMULH", aux: "Int64"},
+		// udiv runtime call for soft division
+		// output0 = arg0/arg1, output1 = arg0%arg1
+		// see ../../../../../runtime/vlop_arm.s
+		{
+			name:      "CALLudiv",
+			argLength: 2,
+			reg: regInfo{
+				inputs:   []regMask{buildReg("R1"), buildReg("R0")},
+				outputs:  []regMask{buildReg("R0"), buildReg("R1")},
+				clobbers: buildReg("R2 R3 R4 R5 R26"),
+			},
+			clobberFlags: true,
+			typ:          "(UInt64,UInt64)",
+			call:         false,
+		},
+
+		{name: "FADDD", argLength: 2, reg: ffp21, asm: "FADDD", commutative: true},
+		{name: "FADDS", argLength: 2, reg: ffp21, asm: "FADDS", commutative: true},
+		{name: "FSUBD", argLength: 2, reg: ffp21, asm: "FSUBD"},
+		{name: "FSUBS", argLength: 2, reg: ffp21, asm: "FSUBS"},
+		{name: "FMULD", argLength: 2, reg: ffp21, asm: "FMULD", commutative: true},
+		{name: "FMULS", argLength: 2, reg: ffp21, asm: "FMULS", commutative: true},
+		{name: "FDIVD", argLength: 2, reg: ffp21, asm: "FDIVD"},
+		{name: "FDIVS", argLength: 2, reg: ffp21, asm: "FDIVS"},
+		{name: "FCPYS", argLength: 2, reg: fp21, asm: "FCPYS"},
+		{name: "FABS", argLength: 1, reg: fp11, asm: "FCPYS"},
+		{name: "IFMOVD", argLength: 1, reg: ifp11, asm: "IFMOVD", typ: "Float64"},
+		{name: "IFMOVS", argLength: 1, reg: ifp11, asm: "IFMOVS", typ: "Float32"},
+		{name: "FIMOVD", argLength: 1, reg: fip11, asm: "FIMOVD", typ: "Int64"},
+		{name: "FIMOVS", argLength: 1, reg: fip11, asm: "FIMOVS", typ: "Int32"},
+		{name: "FCVTSD", argLength: 1, reg: ffp11, asm: "FCVTSD", typ: "Float64"},
+		{name: "FCVTDS", argLength: 1, reg: ffp11, asm: "FCVTDS"},
+		{name: "FCVTDL", argLength: 1, reg: fp11, asm: "FCVTDL"},
+		{name: "FCVTLS", argLength: 1, reg: fp11, asm: "FCVTLS"},
+		{name: "FCVTLD", argLength: 1, reg: fp11, asm: "FCVTLD"},
+		{name: "FCVTLW", argLength: 1, reg: fp11, asm: "FCVTLW", typ: "Float32"},
+		{name: "FCVTWL", argLength: 1, reg: fp11, asm: "FCVTWL", typ: "Float64"},
+
+		{name: "FSQRTS", argLength: 1, reg: fp11, asm: "FSQRTS"},
+		{name: "FSQRTD", argLength: 1, reg: ffp11, asm: "FSQRTD"},
+		{name: "FCVTDL_Z", argLength: 1, reg: fp11, typ: "Float64", asm: "FCVTDL_Z", resultNotInArgs: true},
+		{name: "FCVTDL_P", argLength: 1, reg: fp11, asm: "FCVTDL_P", resultNotInArgs: true},
+		{name: "FCVTDL_G", argLength: 1, reg: fp11, asm: "FCVTDL_G", resultNotInArgs: true},
+		{name: "FCVTDL_N", argLength: 1, reg: fp11, asm: "FCVTDL_N", resultNotInArgs: true},
+
+		{name: "AND", argLength: 2, reg: gp21, asm: "AND", commutative: true},
+		{name: "ANDconst", argLength: 1, reg: gp11, asm: "AND", aux: "Int64"},
+		{name: "BIS", argLength: 2, reg: gp21, asm: "BIS", commutative: true},
+		{name: "BISconst", argLength: 1, reg: gp11, asm: "BIS", aux: "Int64"},
+		{name: "XOR", argLength: 2, reg: gp21, asm: "XOR", commutative: true},
+		{name: "XORconst", argLength: 1, reg: gp11, asm: "XOR", aux: "Int64"},
+
+		{name: "ZAPNOTconst", argLength: 1, reg: gp11sp, asm: "ZAPNOT", aux: "Int64"},
+
+		{name: "ORNOT", argLength: 2, reg: gp21, asm: "ORNOT"},
+		{name: "ORNOTconst", argLength: 1, reg: gp11, asm: "ORNOT", aux: "Int64"},
+		{name: "NEGV", argLength: 1, reg: gp11, asm: "SUBL"},   // -arg0
+		{name: "NEGF", argLength: 1, reg: fp11, asm: "FCPYSN"}, // -arg0, float32
+		{name: "NEGD", argLength: 1, reg: fp11, asm: "FCPYSN"}, // -arg0, float64
+
+		// shifts
+		{name: "SLL", argLength: 2, reg: gp21, asm: "SLL"},                                   // arg0 << arg1, shift amount is mod 64
+		{name: "SLLconst", argLength: 1, reg: gp11, asm: "SLL", aux: "Int64"},                // arg0 << auxInt
+		{name: "SRL", argLength: 2, reg: gp21, asm: "SRL"},                                   // arg0 >> arg1, unsigned, shift amount is mod 64
+		{name: "SRLconst", argLength: 1, reg: gp11, asm: "SRL", typ: "UInt64", aux: "Int64"}, // arg0 >> auxInt, unsigned
+		{name: "SRA", argLength: 2, reg: gp21, asm: "SRA"},                                   // arg0 >> arg1, signed, shift amount is mod 64
+		{name: "SRAconst", argLength: 1, reg: gp11, asm: "SRA", aux: "Int64"},                // arg0 >> auxInt, signed
+
+		{name: "CTTZ", argLength: 1, reg: gp11, asm: "CTTZ", typ: "UInt64"},
+		{name: "CTLZ", argLength: 1, reg: gp11, asm: "CTLZ"},
+		{name: "CTPOP", argLength: 1, reg: gp11, asm: "CTPOP"},
+		{name: "SEXTB", argLength: 1, reg: gp11, asm: "SEXTB"},
+		{name: "SEXTBconst", argLength: 0, reg: gp01, aux: "Int64", asm: "SEXTB"},
+		{name: "SEXTH", argLength: 1, reg: gp11, asm: "SEXTH"},
+		{name: "SEXTHconst", argLength: 0, reg: gp01, aux: "Int64", asm: "SEXTH"},
+
+		// arg0 + auxInt + aux.(*gc.Sym), arg0=SP/SB
+		{name: "SYMADDR", argLength: 1, reg: regInfo{inputs: []regMask{buildReg("SP") | buildReg("SB")}, outputs: []regMask{gp}}, aux: "SymOff", asm: "SYMADDR", rematerializeable: true, symEffect: "Addr"},
+
+		{name: "MOVVconst", argLength: 0, reg: gp01, aux: "Int64", asm: "LDI", typ: "UInt64", rematerializeable: true},    // auxint
+		{name: "MOVFconst", argLength: 0, reg: fp01, aux: "Float64", asm: "LDF", typ: "Float32", rematerializeable: true}, // auxint as 32-bit float
+		{name: "MOVDconst", argLength: 0, reg: fp01, aux: "Float64", asm: "LDI", typ: "Float64", rematerializeable: true}, // auxint as 64-bit float
+
+		{name: "MOVBstorezero", argLength: 2, reg: gpstore0, asm: "STB", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store zero byte to arg0+aux.  arg1=mem
+		{name: "MOVHstorezero", argLength: 2, reg: gpstore0, asm: "STH", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store zero 2 bytes to ...
+		{name: "MOVWstorezero", argLength: 2, reg: gpstore0, asm: "STW", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store zero 4 bytes to ...
+		{name: "MOVVstorezero", argLength: 2, reg: gpstore0, asm: "STL", aux: "SymOff", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store zero 8 bytes to ...
+
+		{name: "MOVBload", argLength: 2, reg: gpload, aux: "SymOff", asm: "LDBU", typ: "Int8", faultOnNilArg0: true, symEffect: "Read"},    // load from arg0 + auxInt + aux.  arg1=mem.
+		{name: "MOVBUload", argLength: 2, reg: gpload, aux: "SymOff", asm: "LDBU", typ: "UInt8", faultOnNilArg0: true, symEffect: "Read"},  // load from arg0 + auxInt + aux.  arg1=mem.
+		{name: "MOVHload", argLength: 2, reg: gpload, aux: "SymOff", asm: "LDHU", typ: "Int16", faultOnNilArg0: true, symEffect: "Read"},   // load from arg0 + auxInt + aux.  arg1=mem.
+		{name: "MOVHUload", argLength: 2, reg: gpload, aux: "SymOff", asm: "LDHU", typ: "UInt16", faultOnNilArg0: true, symEffect: "Read"}, // load from arg0 + auxInt + aux.  arg1=mem.
+		{name: "MOVWload", argLength: 2, reg: gpload, aux: "SymOff", asm: "LDW", typ: "Int32", faultOnNilArg0: true, symEffect: "Read"},    // load from arg0 + auxInt + aux.  arg1=mem.
+		{name: "MOVWUload", argLength: 2, reg: gpload, aux: "SymOff", asm: "LDW", typ: "UInt32", faultOnNilArg0: true, symEffect: "Read"},  // load from arg0 + auxInt + aux.  arg1=mem.
+		{name: "MOVVload", argLength: 2, reg: gpload, aux: "SymOff", asm: "LDL", typ: "UInt64", faultOnNilArg0: true, symEffect: "Read"},   // load from arg0 + auxInt + aux.  arg1=mem.
+		{name: "MOVFload", argLength: 2, reg: fpload, aux: "SymOff", asm: "FLDS", typ: "Float32", faultOnNilArg0: true, symEffect: "Read"}, // load from arg0 + auxInt + aux.  arg1=mem.
+		{name: "MOVDload", argLength: 2, reg: fpload, aux: "SymOff", asm: "FLDD", typ: "Float64", faultOnNilArg0: true, symEffect: "Read"}, // load from arg0 + auxInt + aux.  arg1=mem.
+
+		{name: "MOVBstore", argLength: 3, reg: gpstore, aux: "SymOff", asm: "STB", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"},  // store 1 byte of arg1 to arg0 + auxInt + aux.  arg2=mem.
+		{name: "MOVHstore", argLength: 3, reg: gpstore, aux: "SymOff", asm: "STH", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"},  // store 2 bytes of arg1 to arg0 + auxInt + aux.  arg2=mem.
+		{name: "MOVWstore", argLength: 3, reg: gpstore, aux: "SymOff", asm: "STW", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"},  // store 4 bytes of arg1 to arg0 + auxInt + aux.  arg2=mem.
+		{name: "MOVVstore", argLength: 3, reg: gpstore, aux: "SymOff", asm: "STL", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"},  // store 8 bytes of arg1 to arg0 + auxInt + aux.  arg2=mem.
+		{name: "MOVFstore", argLength: 3, reg: fpstore, aux: "SymOff", asm: "FSTS", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 4 bytes of arg1 to arg0 + auxInt + aux.  arg2=mem.
+		{name: "MOVDstore", argLength: 3, reg: fpstore, aux: "SymOff", asm: "FSTD", typ: "Mem", faultOnNilArg0: true, symEffect: "Write"}, // store 8 bytes of arg1 to arg0 + auxInt + aux.  arg2=mem.
+
+		{name: "MOVBreg", argLength: 1, reg: gp11, asm: "MOVB"},   // move from arg0, sign-extended from byte
+		{name: "MOVBUreg", argLength: 1, reg: gp11, asm: "MOVBU"}, // move from arg0, unsign-extended from byte
+		{name: "MOVHreg", argLength: 1, reg: gp11, asm: "MOVH"},   // move from arg0, sign-extended from half
+		{name: "MOVHUreg", argLength: 1, reg: gp11, asm: "MOVHU"}, // move from arg0, unsign-extended from half
+		{name: "MOVWreg", argLength: 1, reg: gp11, asm: "MOVW"},   // move from arg0, sign-extended from word
+		{name: "MOVWUreg", argLength: 1, reg: gp11, asm: "MOVWU"}, // move from arg0, unsign-extended from word
+		{name: "MOVVreg", argLength: 1, reg: gp11, asm: "MOVV"},   // move from arg0
+
+		{name: "MOVVnop", argLength: 1, reg: regInfo{inputs: []regMask{gp}, outputs: []regMask{gp}}, resultInArg0: true}, // nop, return arg0 in same register
+
+		{name: "CMPULE", argLength: 2, reg: gp21, asm: "CMPULE", typ: "Bool"}, // 1 if arg
+		{name: "CMPULEconst", argLength: 1, typ: "Bool", reg: gp11, asm: "CMPULE", aux: "Int64"},
+		{name: "CMPULT", argLength: 2, reg: gp21, asm: "CMPULT", typ: "Bool"}, // 1 if arg
+		{name: "CMPULTconst", argLength: 1, typ: "Bool", reg: gp11, asm: "CMPULT", aux: "Int64"},
+		{name: "CMPLE", argLength: 2, reg: gp21, asm: "CMPLE", typ: "Bool"}, // 1 if arg
+		{name: "CMPLEconst", argLength: 1, typ: "Bool", reg: gp11, asm: "CMPLE", aux: "Int64"},
+		{name: "CMPLT", argLength: 2, reg: gp21, asm: "CMPLT", typ: "Bool"}, // 1 if arg
+		{name: "CMPLTconst", argLength: 1, typ: "Bool", reg: gp11, asm: "CMPLT", aux: "Int64"},
+		{name: "CMPEQ", argLength: 2, reg: gp21, asm: "CMPEQ", typ: "Bool"},
+		{name: "CMPEQconst", argLength: 1, typ: "Bool", reg: gp11, asm: "CMPEQ", aux: "Int64"},
+
+		{name: "FCMPLE", argLength: 2, reg: ffp21, asm: "FCMPLE", typ: "Float64"}, // 1 if arg
+		{name: "FCMPLT", argLength: 2, reg: ffp21, asm: "FCMPLT", typ: "Float64"}, // 1 if arg
+		{name: "FCMPEQ", argLength: 2, reg: ffp21, asm: "FCMPEQ", typ: "Float64"},
+		{name: "FCMPUN", argLength: 2, reg: ffp21, asm: "FCMPUN", typ: "Float64"},
+
+		{name: "CALLstatic", argLength: -1, reg: regInfo{clobbers: callerSave}, aux: "CallOff", clobberFlags: true, call: true},                                              // call static function aux.(*obj.LSym).  last arg=mem, auxint=argsize, returns mem
+		{name: "CALLtail", argLength: -1, reg: regInfo{clobbers: callerSave}, aux: "CallOff", clobberFlags: true, call: true, tailCall: true},                                // tail call static function aux.(*obj.LSym).  last arg=mem, auxint=argsize, returns mem
+		{name: "CALLclosure", argLength: -1, reg: regInfo{inputs: []regMask{gpsp, buildReg("R25"), 0}, clobbers: callerSave}, aux: "CallOff", clobberFlags: true, call: true},// call function via closure.  arg0=codeptr, arg1=closure, last arg=mem, auxint=argsize, returns mem
+		{name: "CALLinter", argLength: -1, reg: regInfo{inputs: []regMask{gp}, clobbers: callerSave}, aux: "CallOff", clobberFlags: true, call: true},                        // call fn by pointer.  arg0=codeptr, last arg=mem, auxint=argsize, returns mem
+
+		// duffzero
+		{
+			name:      "DUFFZERO",
+			aux:       "Int64",
+			argLength: 2,
+			reg: regInfo{
+				inputs:   []regMask{gp},
+				clobbers: buildReg("R1"),
+			},
+			faultOnNilArg0: true,
+		},
+
+		//LoweredZero
+		{
+			name:      "LoweredZero",
+			aux:       "Int64",
+			argLength: 3,
+			reg: regInfo{
+				inputs:   []regMask{buildReg("R1"), gp},
+				clobbers: buildReg("R1"),
+			},
+			clobberFlags:   true,
+			faultOnNilArg0: true,
+		},
+
+		//LoweredMove
+		{
+			name:      "LoweredMove",
+			aux:       "Int64",
+			argLength: 4,
+			reg: regInfo{
+				inputs:   []regMask{buildReg("R2"), buildReg("R1"), gp},
+				clobbers: buildReg("R1 R2"),
+			},
+			clobberFlags:   true,
+			faultOnNilArg0: true,
+			faultOnNilArg1: true,
+		},
+
+		// pseudo-ops
+		{name: "LoweredNilCheck", argLength: 2, reg: regInfo{inputs: []regMask{gpg}}, nilCheck: true, faultOnNilArg0: true}, // panic if arg0 is nil.  arg1=mem.
+
+		// Scheduler ensures LoweredGetClosurePtr occurs only in entry block,
+		// and sorts it to the very beginning of the block to prevent other
+		// use of R25 (sw64.REGCTXT, the closure pointer)
+		{name: "LoweredGetClosurePtr", reg: regInfo{outputs: []regMask{buildReg("R25")}}, zeroWidth: true},
+
+		// LoweredGetCallerSP returns the SP of the caller of the current function. arg0=mem
+		{name: "LoweredGetCallerSP", argLength: 1, reg: gp01, rematerializeable: true},
+
+		// LoweredGetCallerPC evaluates to the PC to which its "caller" will return.
+		// I.e., if f calls g "calls" getcallerpc,
+		// the result should be the PC within f that g will return to.
+		// See runtime/stubs.go for a more detailed discussion.
+		{name: "LoweredGetCallerPC", reg: gp01, rematerializeable: true},
+
+		// MOVDconvert converts between pointers and integers.
+		// We have a special op for this so as to not confuse GC
+		// (particularly stack maps).  It takes a memory arg so it
+		// gets correctly ordered with respect to GC safepoints.
+		// arg0=ptr/int arg1=mem, output=int/ptr
+		{name: "MOVVconvert", argLength: 2, reg: gp11, asm: "LDI"},
+
+//		{name: "Equal", argLength: 1, reg: readflags},            // bool, true flags encode x==y false otherwise.
+//		{name: "NotEqual", argLength: 1, reg: readflags},         // bool, true flags encode x!=y false otherwise.
+//		{name: "LessThan", argLength: 1, reg: readflags},         // bool, true flags encode signed x<y false otherwise.
+//		{name: "LessEqual", argLength: 1, reg: readflags},        // bool, true flags encode signed x<=y false otherwise.
+//		{name: "GreaterThan", argLength: 1, reg: readflags},      // bool, true flags encode signed x>y false otherwise.
+//		{name: "GreaterEqual", argLength: 1, reg: readflags},     // bool, true flags encode signed x>=y false otherwise.
+//		{name: "FLessThan", argLength: 1, reg: readflags},        // bool, true flags encode floating-point x<y false otherwise.
+//		{name: "FLessEqual", argLength: 1, reg: readflags},       // bool, true flags encode floating-point x<=y false otherwise.
+//		{name: "FGreaterThan", argLength: 1, reg: readflags},     // bool, true flags encode floating-point x>y false otherwise.
+//		{name: "FGreaterEqual", argLength: 1, reg: readflags},    // bool, true flags encode floating-point x>=y false otherwise.
+		{name: "FEqual", argLength: 1, reg: readflags},
+		{name: "FNotEqual", argLength: 1, reg: readflags},
+
+		// LoweredWB invokes runtime.gcWriteBarrier. arg0=mem, auxint=# of buffer entries needed
+		// It saves all GP registers if necessary,
+		// but clobbers R26 (LR) because it's a call
+		// and R28 (REGTMP).
+		{name: "LoweredWB", argLength: 1, reg: regInfo{clobbers: (callerSave &^ gpg) | buildReg("R26"), outputs: []regMask{buildReg("R14")}}, clobberFlags: true, aux: "Int64"},
+
+		// There are three of these functions so that they can have three different register inputs.
+		// When we check 0 <= c <= cap (A), then 0 <= b <= c (B), then 0 <= a <= b (C), we want the
+		// default registers to match so we don't need to copy registers around unnecessarily.
+		{name: "LoweredPanicBoundsA", argLength: 3, aux: "Int64", reg: regInfo{inputs: []regMask{r3, r4}}, typ: "Mem", call: true}, // arg0=idx, arg1=len, arg2=mem, returns memory. AuxInt contains report code (see PanicBounds in genericOps.go).
+		{name: "LoweredPanicBoundsB", argLength: 3, aux: "Int64", reg: regInfo{inputs: []regMask{r2, r3}}, typ: "Mem", call: true}, // arg0=idx, arg1=len, arg2=mem, returns memory. AuxInt contains report code (see PanicBounds in genericOps.go).
+		{name: "LoweredPanicBoundsC", argLength: 3, aux: "Int64", reg: regInfo{inputs: []regMask{r1, r2}}, typ: "Mem", call: true}, // arg0=idx, arg1=len, arg2=mem, returns memory. AuxInt contains report code (see PanicBounds in genericOps.go).
+
+		// atomic loads.
+		// load from arg0. arg1=mem.
+		// returns <value,memory> so they can be properly ordered with other loads.
+		{name: "LoweredAtomicLoad8", argLength: 2, reg: gpload, faultOnNilArg0: true},
+		{name: "LoweredAtomicLoad32", argLength: 2, reg: gpload, faultOnNilArg0: true},
+		{name: "LoweredAtomicLoad64", argLength: 2, reg: gpload, faultOnNilArg0: true},
+
+		// atomic stores.
+		// store arg1 to arg0. arg2=mem. returns memory.
+		{name: "LoweredAtomicStore8", argLength: 3, reg: gpstore, faultOnNilArg0: true, hasSideEffects: true},
+		{name: "LoweredAtomicStore32", argLength: 3, reg: gpstore, faultOnNilArg0: true, hasSideEffects: true},
+		{name: "LoweredAtomicStore64", argLength: 3, reg: gpstore, faultOnNilArg0: true, hasSideEffects: true},
+
+		// atomic exchange.
+		// store arg1 to arg0. arg2=mem. returns <old content of *arg0, memory>.
+		// MEMB
+		// LLDx Rout, (Rarg0)
+		// LDI	Rtmp, 1
+		// WR_F	Rtmp
+		// BIS  Rarg1, R31, Rtmp
+		// LSTx Rtmp, (Rarg0)
+		// RD_F	Rtmp
+		// BEQ  Rtmp, -6(PC)
+		// MEMB
+		{name: "LoweredAtomicExchange32", argLength: 3, reg: gpxchg, resultNotInArgs: true, faultOnNilArg0: true, hasSideEffects: true, unsafePoint: true},
+		{name: "LoweredAtomicExchange64", argLength: 3, reg: gpxchg, resultNotInArgs: true, faultOnNilArg0: true, hasSideEffects: true, unsafePoint: true},
+
+		// atomic add.
+		// *arg0 += arg1. arg2=mem. returns <new content of *arg0, memory>.
+		// MEMB
+		// LLDx	Rout, (Rarg0)
+		// LDI	Rtmp, 1
+		// WR_F	Rtmp
+		// ADDL Rarg1, Rout, Rtmp
+		// LSTx Rtmp, (Rarg0)
+		// RD_F	Rtmp
+		// BEQ  Rtmp, -6(PC)
+		// ADDL Rarg1, Rout, Rout
+		// MEMB
+		{name: "LoweredAtomicAdd32", argLength: 3, reg: gpxchg, resultNotInArgs: true, faultOnNilArg0: true, hasSideEffects: true, unsafePoint: true},
+		{name: "LoweredAtomicAdd64", argLength: 3, reg: gpxchg, resultNotInArgs: true, faultOnNilArg0: true, hasSideEffects: true, unsafePoint: true},
+
+		// atomic compare and swap.
+		// arg0 = pointer, arg1 = old value, arg2 = new value, arg3 = memory.
+		// if *arg0 == arg1 {
+		//   *arg0 = arg2
+		//   return (true, memory)
+		// } else {
+		//   return (false, memory)
+		// }
+		// MEMB
+		// LLDx  Rout, (Rarg0)
+		// CMPEQ Rout, Rarg1, Rout
+		// WR_F	 Rout
+		// BIS   Rarg2, R31, Rtmp
+		// LSTx  Rtmp, (Rarg0)
+		// RD_F  Rtmp
+		// BEQ   Rout, 2(PC)
+		// BEQ   Rtmp, -7(PC)
+		// MEMB
+		{name: "LoweredAtomicCas32", argLength: 4, reg: gpcas, resultNotInArgs: true, faultOnNilArg0: true, hasSideEffects: true, unsafePoint: true},
+		{name: "LoweredAtomicCas64", argLength: 4, reg: gpcas, resultNotInArgs: true, faultOnNilArg0: true, hasSideEffects: true, unsafePoint: true},
+	}
+
+	blocks := []blockData{
+		{name: "NE", controls: 1},
+		{name: "EQ", controls: 1},
+		{name: "LT", controls: 1},
+		{name: "LE", controls: 1},
+		{name: "GT", controls: 1},
+		{name: "GE", controls: 1},
+		{name: "FNE", controls: 1},
+		{name: "FEQ", controls: 1},
+		{name: "FLE", controls: 1},
+		{name: "FLT", controls: 1},
+		{name: "FGE", controls: 1},
+		{name: "FGT", controls: 1},
+		{name: "LBC", controls: 1},
+		{name: "LBS", controls: 1},
+		// JUMPTABLE implements jump tables.
+		// Aux is the symbol (an *obj.LSym) for the jump table.
+		// control[0] is the index into the jump table.
+		// control[1] is the address of the jump table (the address of the symbol stored in Aux).
+		{name: "JUMPTABLE", controls: 2, aux: "Sym"},
+
+	}
+
+	archs = append(archs, arch{
+		name:            "SW64",
+		pkg:             "cmd/internal/obj/sw64",
+		genfile:         "../../sw64/ssa.go",
+		ops:             ops,
+		blocks:          blocks,
+		regnames:        regNamesSW64,
+		gpregmask:       gp,
+		fpregmask:       fp,
+		// Integer parameters passed in register R16-R24
+		ParamIntRegNames: "R16 R17 R18 R19 R20 R21 R22 R23 R24",
+		// Float parameters passed in register F16-F24
+		ParamFloatRegNames: "F16 F17 F18 F19 F20 F21 F22 F23 F24",
+		framepointerreg: -1, // not used
+		linkreg:         int8(num["R26"]),
+	})
+}
diff --git a/src/cmd/compile/internal/ssa/config.go b/src/cmd/compile/internal/ssa/config.go
index debcf1a0..aa04dd6d 100644
--- a/src/cmd/compile/internal/ssa/config.go
+++ b/src/cmd/compile/internal/ssa/config.go
@@ -351,6 +351,21 @@ func NewConfig(arch string, types Types, ctxt *obj.Link, optimize, softfloat boo
 		c.noDuffDevice = true
 		c.useAvg = false
 		c.useHmul = false
+	case "sw64":
+		c.PtrSize = 8
+		c.RegSize = 8
+		c.lowerBlock = rewriteBlockSW64
+                c.lowerValue = rewriteValueSW64
+                c.registers = registersSW64[:]
+                c.gpRegMask = gpRegMaskSW64
+                c.fpRegMask = fpRegMaskSW64
+		c.intParamRegs = paramIntRegSW64
+		c.floatParamRegs = paramFloatRegSW64
+                c.FPReg = framepointerRegSW64
+                c.LinkReg = linkRegSW64
+                c.hasGReg = true
+                c.noDuffDevice = true
+                c.BigEndian = false
 	default:
 		ctxt.Diag("arch %s not implemented", arch)
 	}
diff --git a/src/cmd/compile/internal/ssa/debug_lines_test.go b/src/cmd/compile/internal/ssa/debug_lines_test.go
index af9e2a34..854f20ad 100644
--- a/src/cmd/compile/internal/ssa/debug_lines_test.go
+++ b/src/cmd/compile/internal/ssa/debug_lines_test.go
@@ -44,7 +44,7 @@ func testGoArch() string {
 
 func hasRegisterABI() bool {
 	switch testGoArch() {
-	case "amd64", "arm64", "loong64", "ppc64", "ppc64le", "riscv":
+	case "amd64", "arm64", "loong64", "ppc64", "ppc64le", "riscv", "sw64":
 		return true
 	}
 	return false
diff --git a/src/cmd/compile/internal/ssa/opGen.go b/src/cmd/compile/internal/ssa/opGen.go
index c5528325..3e272b53 100644
--- a/src/cmd/compile/internal/ssa/opGen.go
+++ b/src/cmd/compile/internal/ssa/opGen.go
@@ -11,6 +11,7 @@ import (
 	"cmd/internal/obj/ppc64"
 	"cmd/internal/obj/riscv"
 	"cmd/internal/obj/s390x"
+	"cmd/internal/obj/sw64"
 	"cmd/internal/obj/wasm"
 	"cmd/internal/obj/x86"
 )
@@ -155,6 +156,22 @@ const (
 	BlockS390XCLIJ
 	BlockS390XCLGIJ
 
+	BlockSW64NE
+	BlockSW64EQ
+	BlockSW64LT
+	BlockSW64LE
+	BlockSW64GT
+	BlockSW64GE
+	BlockSW64FNE
+	BlockSW64FEQ
+	BlockSW64FLE
+	BlockSW64FLT
+	BlockSW64FGE
+	BlockSW64FGT
+	BlockSW64LBC
+	BlockSW64LBS
+	BlockSW64JUMPTABLE
+
 	BlockPlain
 	BlockIf
 	BlockDefer
@@ -305,6 +322,22 @@ var blockString = [...]string{
 	BlockS390XCLIJ:  "CLIJ",
 	BlockS390XCLGIJ: "CLGIJ",
 
+	BlockSW64NE:        "NE",
+	BlockSW64EQ:        "EQ",
+	BlockSW64LT:        "LT",
+	BlockSW64LE:        "LE",
+	BlockSW64GT:        "GT",
+	BlockSW64GE:        "GE",
+	BlockSW64FNE:       "FNE",
+	BlockSW64FEQ:       "FEQ",
+	BlockSW64FLE:       "FLE",
+	BlockSW64FLT:       "FLT",
+	BlockSW64FGE:       "FGE",
+	BlockSW64FGT:       "FGT",
+	BlockSW64LBC:       "LBC",
+	BlockSW64LBS:       "LBS",
+	BlockSW64JUMPTABLE: "JUMPTABLE",
+
 	BlockPlain:     "Plain",
 	BlockIf:        "If",
 	BlockDefer:     "Defer",
@@ -2730,6 +2763,156 @@ const (
 	OpS390XLoweredMove
 	OpS390XLoweredZero
 
+	OpSW64ADDV
+	OpSW64ADDVconst
+	OpSW64ADDW
+	OpSW64ADDWconst
+	OpSW64S4ADDV
+	OpSW64S8ADDV
+	OpSW64SUBV
+	OpSW64SUBVconst
+	OpSW64S4SUBV
+	OpSW64S8SUBV
+	OpSW64DIVV
+	OpSW64DIVVconst
+	OpSW64UDIVV
+	OpSW64DIVW
+	OpSW64UDIVW
+	OpSW64MULW
+	OpSW64MULWconst
+	OpSW64MULL
+	OpSW64MULLconst
+	OpSW64UMULH
+	OpSW64UMULHconst
+	OpSW64CALLudiv
+	OpSW64FADDD
+	OpSW64FADDS
+	OpSW64FSUBD
+	OpSW64FSUBS
+	OpSW64FMULD
+	OpSW64FMULS
+	OpSW64FDIVD
+	OpSW64FDIVS
+	OpSW64FCPYS
+	OpSW64FABS
+	OpSW64IFMOVD
+	OpSW64IFMOVS
+	OpSW64FIMOVD
+	OpSW64FIMOVS
+	OpSW64FCVTSD
+	OpSW64FCVTDS
+	OpSW64FCVTDL
+	OpSW64FCVTLS
+	OpSW64FCVTLD
+	OpSW64FCVTLW
+	OpSW64FCVTWL
+	OpSW64FSQRTS
+	OpSW64FSQRTD
+	OpSW64FCVTDL_Z
+	OpSW64FCVTDL_P
+	OpSW64FCVTDL_G
+	OpSW64FCVTDL_N
+	OpSW64AND
+	OpSW64ANDconst
+	OpSW64BIS
+	OpSW64BISconst
+	OpSW64XOR
+	OpSW64XORconst
+	OpSW64ZAPNOTconst
+	OpSW64ORNOT
+	OpSW64ORNOTconst
+	OpSW64NEGV
+	OpSW64NEGF
+	OpSW64NEGD
+	OpSW64SLL
+	OpSW64SLLconst
+	OpSW64SRL
+	OpSW64SRLconst
+	OpSW64SRA
+	OpSW64SRAconst
+	OpSW64CTTZ
+	OpSW64CTLZ
+	OpSW64CTPOP
+	OpSW64SEXTB
+	OpSW64SEXTBconst
+	OpSW64SEXTH
+	OpSW64SEXTHconst
+	OpSW64SYMADDR
+	OpSW64MOVVconst
+	OpSW64MOVFconst
+	OpSW64MOVDconst
+	OpSW64MOVBstorezero
+	OpSW64MOVHstorezero
+	OpSW64MOVWstorezero
+	OpSW64MOVVstorezero
+	OpSW64MOVBload
+	OpSW64MOVBUload
+	OpSW64MOVHload
+	OpSW64MOVHUload
+	OpSW64MOVWload
+	OpSW64MOVWUload
+	OpSW64MOVVload
+	OpSW64MOVFload
+	OpSW64MOVDload
+	OpSW64MOVBstore
+	OpSW64MOVHstore
+	OpSW64MOVWstore
+	OpSW64MOVVstore
+	OpSW64MOVFstore
+	OpSW64MOVDstore
+	OpSW64MOVBreg
+	OpSW64MOVBUreg
+	OpSW64MOVHreg
+	OpSW64MOVHUreg
+	OpSW64MOVWreg
+	OpSW64MOVWUreg
+	OpSW64MOVVreg
+	OpSW64MOVVnop
+	OpSW64CMPULE
+	OpSW64CMPULEconst
+	OpSW64CMPULT
+	OpSW64CMPULTconst
+	OpSW64CMPLE
+	OpSW64CMPLEconst
+	OpSW64CMPLT
+	OpSW64CMPLTconst
+	OpSW64CMPEQ
+	OpSW64CMPEQconst
+	OpSW64FCMPLE
+	OpSW64FCMPLT
+	OpSW64FCMPEQ
+	OpSW64FCMPUN
+	OpSW64CALLstatic
+	OpSW64CALLtail
+	OpSW64CALLclosure
+	OpSW64CALLinter
+	OpSW64DUFFZERO
+	OpSW64LoweredZero
+	OpSW64LoweredMove
+	OpSW64LoweredNilCheck
+	OpSW64LoweredGetClosurePtr
+	OpSW64LoweredGetCallerSP
+	OpSW64LoweredGetCallerPC
+	OpSW64MOVVconvert
+	OpSW64FEqual
+	OpSW64FNotEqual
+	OpSW64LoweredWB
+	OpSW64LoweredPanicBoundsA
+	OpSW64LoweredPanicBoundsB
+	OpSW64LoweredPanicBoundsC
+	OpSW64LoweredAtomicLoad8
+	OpSW64LoweredAtomicLoad32
+	OpSW64LoweredAtomicLoad64
+	OpSW64LoweredAtomicStore8
+	OpSW64LoweredAtomicStore32
+	OpSW64LoweredAtomicStore64
+	OpSW64LoweredAtomicExchange32
+	OpSW64LoweredAtomicExchange64
+	OpSW64LoweredAtomicAdd32
+	OpSW64LoweredAtomicAdd64
+	OpSW64LoweredAtomicCas32
+	OpSW64LoweredAtomicCas64
+
 	OpWasmLoweredStaticCall
 	OpWasmLoweredTailCall
 	OpWasmLoweredClosureCall
@@ -36889,821 +37072,2871 @@ var opcodeTable = [...]opInfo{
 	},
 
 	{
-		name:    "LoweredStaticCall",
-		auxType: auxCallOff,
-		argLen:  1,
-		call:    true,
+		name:        "ADDV",
+		argLen:      2,
+		commutative: true,
+		asm:         sw64.AADDL,
 		reg: regInfo{
-			clobbers: 844424930131967, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31 g
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
 		},
 	},
 	{
-		name:     "LoweredTailCall",
-		auxType:  auxCallOff,
-		argLen:   1,
-		call:     true,
-		tailCall: true,
+		name:    "ADDVconst",
+		auxType: auxInt64,
+		argLen:  1,
+		asm:     sw64.AADDL,
 		reg: regInfo{
-			clobbers: 844424930131967, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31 g
+			inputs: []inputInfo{
+				{0, 201326591}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
 		},
 	},
 	{
-		name:    "LoweredClosureCall",
-		auxType: auxCallOff,
-		argLen:  3,
-		call:    true,
+		name:        "ADDW",
+		argLen:      2,
+		commutative: true,
+		asm:         sw64.AADDW,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
-				{1, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
-			clobbers: 844424930131967, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31 g
 		},
 	},
 	{
-		name:    "LoweredInterCall",
-		auxType: auxCallOff,
-		argLen:  2,
-		call:    true,
+		name:    "ADDWconst",
+		auxType: auxInt32,
+		argLen:  1,
+		asm:     sw64.AADDW,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 201326591}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
-			clobbers: 844424930131967, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31 g
 		},
 	},
 	{
-		name:              "LoweredAddr",
-		auxType:           auxSymOff,
-		argLen:            1,
-		rematerializeable: true,
-		symEffect:         SymAddr,
+		name:   "S4ADDV",
+		argLen: 2,
+		asm:    sw64.AS4ADDL,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:    "LoweredMove",
-		auxType: auxInt64,
-		argLen:  3,
+		name:   "S8ADDV",
+		argLen: 2,
+		asm:    sw64.AS8ADDL,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
-				{1, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:    "LoweredZero",
-		auxType: auxInt64,
-		argLen:  2,
+		name:   "SUBV",
+		argLen: 2,
+		asm:    sw64.ASUBL,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:   "LoweredGetClosurePtr",
-		argLen: 0,
+		name:    "SUBVconst",
+		auxType: auxInt64,
+		argLen:  1,
+		asm:     sw64.ASUBL,
 		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 201326591}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP
+			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:              "LoweredGetCallerPC",
-		argLen:            0,
-		rematerializeable: true,
+		name:   "S4SUBV",
+		argLen: 2,
+		asm:    sw64.AS4SUBL,
 		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:              "LoweredGetCallerSP",
-		argLen:            1,
-		rematerializeable: true,
+		name:   "S8SUBV",
+		argLen: 2,
+		asm:    sw64.AS8SUBL,
 		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:           "LoweredNilCheck",
-		argLen:         2,
-		nilCheck:       true,
-		faultOnNilArg0: true,
+		name:   "DIVV",
+		argLen: 2,
+		asm:    sw64.ADIVL,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:    "LoweredWB",
+		name:    "DIVVconst",
 		auxType: auxInt64,
 		argLen:  1,
+		asm:     sw64.ADIVL,
 		reg: regInfo{
-			clobbers: 844424930131967, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31 g
+			inputs: []inputInfo{
+				{0, 201326591}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP
+			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:   "LoweredConvert",
+		name:   "UDIVV",
 		argLen: 2,
+		asm:    sw64.AUDIVL,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:   "Select",
-		argLen: 3,
-		asm:    wasm.ASelect,
+		name:   "DIVW",
+		argLen: 2,
+		asm:    sw64.ADIVW,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{2, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:    "I64Load8U",
-		auxType: auxInt64,
-		argLen:  2,
-		asm:     wasm.AI64Load8U,
+		name:   "UDIVW",
+		argLen: 2,
+		asm:    sw64.AUDIVW,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:    "I64Load8S",
-		auxType: auxInt64,
-		argLen:  2,
-		asm:     wasm.AI64Load8S,
+		name:        "MULW",
+		argLen:      2,
+		commutative: true,
+		asm:         sw64.AMULW,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:    "I64Load16U",
+		name:    "MULWconst",
 		auxType: auxInt64,
-		argLen:  2,
-		asm:     wasm.AI64Load16U,
+		argLen:  1,
+		asm:     sw64.AMULW,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+				{0, 201326591}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:    "I64Load16S",
-		auxType: auxInt64,
-		argLen:  2,
-		asm:     wasm.AI64Load16S,
+		name:        "MULL",
+		argLen:      2,
+		commutative: true,
+		asm:         sw64.AMULL,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:    "I64Load32U",
+		name:    "MULLconst",
 		auxType: auxInt64,
-		argLen:  2,
-		asm:     wasm.AI64Load32U,
+		argLen:  1,
+		asm:     sw64.AMULL,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+				{0, 201326591}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:    "I64Load32S",
-		auxType: auxInt64,
-		argLen:  2,
-		asm:     wasm.AI64Load32S,
+		name:        "UMULH",
+		argLen:      2,
+		commutative: true,
+		asm:         sw64.AUMULH,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:    "I64Load",
+		name:    "UMULHconst",
 		auxType: auxInt64,
-		argLen:  2,
-		asm:     wasm.AI64Load,
+		argLen:  1,
+		asm:     sw64.AUMULH,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+				{0, 201326591}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:    "I64Store8",
-		auxType: auxInt64,
-		argLen:  3,
-		asm:     wasm.AI64Store8,
+		name:         "CALLudiv",
+		argLen:       2,
+		clobberFlags: true,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{1, 281474976776191},  // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+				{0, 2}, // R1
+				{1, 1}, // R0
+			},
+			clobbers: 67108924, // R2 R3 R4 R5 R26
+			outputs: []outputInfo{
+				{0, 1}, // R0
+				{1, 2}, // R1
 			},
 		},
 	},
 	{
-		name:    "I64Store16",
-		auxType: auxInt64,
-		argLen:  3,
-		asm:     wasm.AI64Store16,
+		name:        "FADDD",
+		argLen:      2,
+		commutative: true,
+		asm:         sw64.AFADDD,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{1, 281474976776191},  // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+				{0, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+				{1, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+			},
+			outputs: []outputInfo{
+				{0, 1151795604700004352}, // F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:    "I64Store32",
-		auxType: auxInt64,
-		argLen:  3,
-		asm:     wasm.AI64Store32,
+		name:        "FADDS",
+		argLen:      2,
+		commutative: true,
+		asm:         sw64.AFADDS,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{1, 281474976776191},  // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+				{0, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+				{1, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+			},
+			outputs: []outputInfo{
+				{0, 1151795604700004352}, // F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:    "I64Store",
-		auxType: auxInt64,
-		argLen:  3,
-		asm:     wasm.AI64Store,
+		name:   "FSUBD",
+		argLen: 2,
+		asm:    sw64.AFSUBD,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{1, 281474976776191},  // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+				{0, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+				{1, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+			},
+			outputs: []outputInfo{
+				{0, 1151795604700004352}, // F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:    "F32Load",
-		auxType: auxInt64,
-		argLen:  2,
-		asm:     wasm.AF32Load,
+		name:   "FSUBS",
+		argLen: 2,
+		asm:    sw64.AFSUBS,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+				{0, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+				{1, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
 			},
 			outputs: []outputInfo{
-				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+				{0, 1151795604700004352}, // F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:    "F64Load",
-		auxType: auxInt64,
-		argLen:  2,
-		asm:     wasm.AF64Load,
+		name:        "FMULD",
+		argLen:      2,
+		commutative: true,
+		asm:         sw64.AFMULD,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+				{0, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+				{1, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
 			},
 			outputs: []outputInfo{
-				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+				{0, 1151795604700004352}, // F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:    "F32Store",
-		auxType: auxInt64,
-		argLen:  3,
-		asm:     wasm.AF32Store,
+		name:        "FMULS",
+		argLen:      2,
+		commutative: true,
+		asm:         sw64.AFMULS,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{1, 4294901760},       // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
-				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+				{0, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+				{1, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+			},
+			outputs: []outputInfo{
+				{0, 1151795604700004352}, // F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:    "F64Store",
-		auxType: auxInt64,
-		argLen:  3,
-		asm:     wasm.AF64Store,
+		name:   "FDIVD",
+		argLen: 2,
+		asm:    sw64.AFDIVD,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{1, 281470681743360},  // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
-				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+				{0, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+				{1, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
 			},
-		},
-	},
-	{
-		name:              "I64Const",
-		auxType:           auxInt64,
-		argLen:            0,
-		rematerializeable: true,
-		reg: regInfo{
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1151795604700004352}, // F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:              "F32Const",
-		auxType:           auxFloat32,
-		argLen:            0,
-		rematerializeable: true,
+		name:   "FDIVS",
+		argLen: 2,
+		asm:    sw64.AFDIVS,
 		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+				{1, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+			},
 			outputs: []outputInfo{
-				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+				{0, 1151795604700004352}, // F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:              "F64Const",
-		auxType:           auxFloat64,
-		argLen:            0,
-		rematerializeable: true,
+		name:   "FCPYS",
+		argLen: 2,
+		asm:    sw64.AFCPYS,
 		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+				{1, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+			},
 			outputs: []outputInfo{
-				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "I64Eqz",
+		name:   "FABS",
 		argLen: 1,
-		asm:    wasm.AI64Eqz,
+		asm:    sw64.AFCPYS,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "I64Eq",
-		argLen: 2,
-		asm:    wasm.AI64Eq,
+		name:   "IFMOVD",
+		argLen: 1,
+		asm:    sw64.AIFMOVD,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "I64Ne",
-		argLen: 2,
-		asm:    wasm.AI64Ne,
+		name:   "IFMOVS",
+		argLen: 1,
+		asm:    sw64.AIFMOVS,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "I64LtS",
-		argLen: 2,
-		asm:    wasm.AI64LtS,
+		name:   "FIMOVD",
+		argLen: 1,
+		asm:    sw64.AFIMOVD,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:   "I64LtU",
-		argLen: 2,
-		asm:    wasm.AI64LtU,
+		name:   "FIMOVS",
+		argLen: 1,
+		asm:    sw64.AFIMOVS,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:   "I64GtS",
-		argLen: 2,
-		asm:    wasm.AI64GtS,
+		name:   "FCVTSD",
+		argLen: 1,
+		asm:    sw64.AFCVTSD,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1151795604700004352}, // F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "I64GtU",
-		argLen: 2,
-		asm:    wasm.AI64GtU,
+		name:   "FCVTDS",
+		argLen: 1,
+		asm:    sw64.AFCVTDS,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1151795604700004352}, // F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "I64LeS",
-		argLen: 2,
-		asm:    wasm.AI64LeS,
+		name:   "FCVTDL",
+		argLen: 1,
+		asm:    sw64.AFCVTDL,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "I64LeU",
-		argLen: 2,
-		asm:    wasm.AI64LeU,
+		name:   "FCVTLS",
+		argLen: 1,
+		asm:    sw64.AFCVTLS,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "I64GeS",
-		argLen: 2,
-		asm:    wasm.AI64GeS,
+		name:   "FCVTLD",
+		argLen: 1,
+		asm:    sw64.AFCVTLD,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "I64GeU",
-		argLen: 2,
-		asm:    wasm.AI64GeU,
+		name:   "FCVTLW",
+		argLen: 1,
+		asm:    sw64.AFCVTLW,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "F32Eq",
-		argLen: 2,
-		asm:    wasm.AF32Eq,
+		name:   "FCVTWL",
+		argLen: 1,
+		asm:    sw64.AFCVTWL,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
-				{1, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "F32Ne",
-		argLen: 2,
-		asm:    wasm.AF32Ne,
+		name:   "FSQRTS",
+		argLen: 1,
+		asm:    sw64.AFSQRTS,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
-				{1, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "F32Lt",
-		argLen: 2,
-		asm:    wasm.AF32Lt,
+		name:   "FSQRTD",
+		argLen: 1,
+		asm:    sw64.AFSQRTD,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
-				{1, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+				{0, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1151795604700004352}, // F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "F32Gt",
-		argLen: 2,
-		asm:    wasm.AF32Gt,
+		name:            "FCVTDL_Z",
+		argLen:          1,
+		resultNotInArgs: true,
+		asm:             sw64.AFCVTDL_Z,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
-				{1, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "F32Le",
-		argLen: 2,
-		asm:    wasm.AF32Le,
+		name:            "FCVTDL_P",
+		argLen:          1,
+		resultNotInArgs: true,
+		asm:             sw64.AFCVTDL_P,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
-				{1, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "F32Ge",
-		argLen: 2,
-		asm:    wasm.AF32Ge,
+		name:            "FCVTDL_G",
+		argLen:          1,
+		resultNotInArgs: true,
+		asm:             sw64.AFCVTDL_G,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
-				{1, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "F64Eq",
-		argLen: 2,
-		asm:    wasm.AF64Eq,
+		name:            "FCVTDL_N",
+		argLen:          1,
+		resultNotInArgs: true,
+		asm:             sw64.AFCVTDL_N,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
-				{1, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "F64Ne",
-		argLen: 2,
-		asm:    wasm.AF64Ne,
+		name:        "AND",
+		argLen:      2,
+		commutative: true,
+		asm:         sw64.AAND,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
-				{1, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:   "F64Lt",
-		argLen: 2,
-		asm:    wasm.AF64Lt,
+		name:    "ANDconst",
+		auxType: auxInt64,
+		argLen:  1,
+		asm:     sw64.AAND,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
-				{1, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:   "F64Gt",
-		argLen: 2,
-		asm:    wasm.AF64Gt,
+		name:        "BIS",
+		argLen:      2,
+		commutative: true,
+		asm:         sw64.ABIS,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
-				{1, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:   "F64Le",
-		argLen: 2,
-		asm:    wasm.AF64Le,
+		name:    "BISconst",
+		auxType: auxInt64,
+		argLen:  1,
+		asm:     sw64.ABIS,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
-				{1, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:   "F64Ge",
-		argLen: 2,
-		asm:    wasm.AF64Ge,
+		name:        "XOR",
+		argLen:      2,
+		commutative: true,
+		asm:         sw64.AXOR,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
-				{1, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:   "I64Add",
-		argLen: 2,
-		asm:    wasm.AI64Add,
+		name:    "XORconst",
+		auxType: auxInt64,
+		argLen:  1,
+		asm:     sw64.AXOR,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:    "I64AddConst",
+		name:    "ZAPNOTconst",
 		auxType: auxInt64,
 		argLen:  1,
-		asm:     wasm.AI64Add,
+		asm:     sw64.AZAPNOT,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 201326591}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:   "I64Sub",
+		name:   "ORNOT",
 		argLen: 2,
-		asm:    wasm.AI64Sub,
+		asm:    sw64.AORNOT,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:   "I64Mul",
-		argLen: 2,
-		asm:    wasm.AI64Mul,
+		name:    "ORNOTconst",
+		auxType: auxInt64,
+		argLen:  1,
+		asm:     sw64.AORNOT,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:   "I64DivS",
-		argLen: 2,
-		asm:    wasm.AI64DivS,
+		name:   "NEGV",
+		argLen: 1,
+		asm:    sw64.ASUBL,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
 			},
 		},
 	},
 	{
-		name:   "I64DivU",
-		argLen: 2,
-		asm:    wasm.AI64DivU,
+		name:   "NEGF",
+		argLen: 1,
+		asm:    sw64.AFCPYSN,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "I64RemS",
-		argLen: 2,
-		asm:    wasm.AI64RemS,
+		name:   "NEGD",
+		argLen: 1,
+		asm:    sw64.AFCPYSN,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 			outputs: []outputInfo{
-				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
 			},
 		},
 	},
 	{
-		name:   "I64RemU",
+		name:   "SLL",
 		argLen: 2,
-		asm:    wasm.AI64RemU,
+		asm:    sw64.ASLL,
 		reg: regInfo{
 			inputs: []inputInfo{
-				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
-				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:    "SLLconst",
+		auxType: auxInt64,
+		argLen:  1,
+		asm:     sw64.ASLL,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "SRL",
+		argLen: 2,
+		asm:    sw64.ASRL,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:    "SRLconst",
+		auxType: auxInt64,
+		argLen:  1,
+		asm:     sw64.ASRL,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "SRA",
+		argLen: 2,
+		asm:    sw64.ASRA,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:    "SRAconst",
+		auxType: auxInt64,
+		argLen:  1,
+		asm:     sw64.ASRA,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "CTTZ",
+		argLen: 1,
+		asm:    sw64.ACTTZ,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "CTLZ",
+		argLen: 1,
+		asm:    sw64.ACTLZ,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "CTPOP",
+		argLen: 1,
+		asm:    sw64.ACTPOP,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "SEXTB",
+		argLen: 1,
+		asm:    sw64.ASEXTB,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:    "SEXTBconst",
+		auxType: auxInt64,
+		argLen:  0,
+		asm:     sw64.ASEXTB,
+		reg: regInfo{
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "SEXTH",
+		argLen: 1,
+		asm:    sw64.ASEXTH,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:    "SEXTHconst",
+		auxType: auxInt64,
+		argLen:  0,
+		asm:     sw64.ASEXTH,
+		reg: regInfo{
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:              "SYMADDR",
+		auxType:           auxSymOff,
+		argLen:            1,
+		rematerializeable: true,
+		symEffect:         SymAddr,
+		asm:               sw64.ASYMADDR,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009347911680}, // SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:              "MOVVconst",
+		auxType:           auxInt64,
+		argLen:            0,
+		rematerializeable: true,
+		asm:               sw64.ALDI,
+		reg: regInfo{
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:              "MOVFconst",
+		auxType:           auxFloat64,
+		argLen:            0,
+		rematerializeable: true,
+		asm:               sw64.ALDF,
+		reg: regInfo{
+			outputs: []outputInfo{
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+			},
+		},
+	},
+	{
+		name:              "MOVDconst",
+		auxType:           auxFloat64,
+		argLen:            0,
+		rematerializeable: true,
+		asm:               sw64.ALDI,
+		reg: regInfo{
+			outputs: []outputInfo{
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+			},
+		},
+	},
+	{
+		name:           "MOVBstorezero",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymWrite,
+		asm:            sw64.ASTB,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+		},
+	},
+	{
+		name:           "MOVHstorezero",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymWrite,
+		asm:            sw64.ASTH,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+		},
+	},
+	{
+		name:           "MOVWstorezero",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymWrite,
+		asm:            sw64.ASTW,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+		},
+	},
+	{
+		name:           "MOVVstorezero",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymWrite,
+		asm:            sw64.ASTL,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+		},
+	},
+	{
+		name:           "MOVBload",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymRead,
+		asm:            sw64.ALDBU,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:           "MOVBUload",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymRead,
+		asm:            sw64.ALDBU,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:           "MOVHload",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymRead,
+		asm:            sw64.ALDHU,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:           "MOVHUload",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymRead,
+		asm:            sw64.ALDHU,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:           "MOVWload",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymRead,
+		asm:            sw64.ALDW,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:           "MOVWUload",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymRead,
+		asm:            sw64.ALDW,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:           "MOVVload",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymRead,
+		asm:            sw64.ALDL,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:           "MOVFload",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymRead,
+		asm:            sw64.AFLDS,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+			},
+		},
+	},
+	{
+		name:           "MOVDload",
+		auxType:        auxSymOff,
+		argLen:         2,
+		faultOnNilArg0: true,
+		symEffect:      SymRead,
+		asm:            sw64.AFLDD,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+			},
+		},
+	},
+	{
+		name:           "MOVBstore",
+		auxType:        auxSymOff,
+		argLen:         3,
+		faultOnNilArg0: true,
+		symEffect:      SymWrite,
+		asm:            sw64.ASTB,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 67108863},            // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+		},
+	},
+	{
+		name:           "MOVHstore",
+		auxType:        auxSymOff,
+		argLen:         3,
+		faultOnNilArg0: true,
+		symEffect:      SymWrite,
+		asm:            sw64.ASTH,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 67108863},            // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+		},
+	},
+	{
+		name:           "MOVWstore",
+		auxType:        auxSymOff,
+		argLen:         3,
+		faultOnNilArg0: true,
+		symEffect:      SymWrite,
+		asm:            sw64.ASTW,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 67108863},            // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+		},
+	},
+	{
+		name:           "MOVVstore",
+		auxType:        auxSymOff,
+		argLen:         3,
+		faultOnNilArg0: true,
+		symEffect:      SymWrite,
+		asm:            sw64.ASTL,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 67108863},            // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+		},
+	},
+	{
+		name:           "MOVFstore",
+		auxType:        auxSymOff,
+		argLen:         3,
+		faultOnNilArg0: true,
+		symEffect:      SymWrite,
+		asm:            sw64.AFSTS,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+				{1, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+			},
+		},
+	},
+	{
+		name:           "MOVDstore",
+		auxType:        auxSymOff,
+		argLen:         3,
+		faultOnNilArg0: true,
+		symEffect:      SymWrite,
+		asm:            sw64.AFSTD,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+				{1, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+			},
+		},
+	},
+	{
+		name:   "MOVBreg",
+		argLen: 1,
+		asm:    sw64.AMOVB,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "MOVBUreg",
+		argLen: 1,
+		asm:    sw64.AMOVBU,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "MOVHreg",
+		argLen: 1,
+		asm:    sw64.AMOVH,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "MOVHUreg",
+		argLen: 1,
+		asm:    sw64.AMOVHU,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "MOVWreg",
+		argLen: 1,
+		asm:    sw64.AMOVW,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "MOVWUreg",
+		argLen: 1,
+		asm:    sw64.AMOVWU,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "MOVVreg",
+		argLen: 1,
+		asm:    sw64.AMOVV,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:         "MOVVnop",
+		argLen:       1,
+		resultInArg0: true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "CMPULE",
+		argLen: 2,
+		asm:    sw64.ACMPULE,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:    "CMPULEconst",
+		auxType: auxInt64,
+		argLen:  1,
+		asm:     sw64.ACMPULE,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "CMPULT",
+		argLen: 2,
+		asm:    sw64.ACMPULT,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:    "CMPULTconst",
+		auxType: auxInt64,
+		argLen:  1,
+		asm:     sw64.ACMPULT,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "CMPLE",
+		argLen: 2,
+		asm:    sw64.ACMPLE,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:    "CMPLEconst",
+		auxType: auxInt64,
+		argLen:  1,
+		asm:     sw64.ACMPLE,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "CMPLT",
+		argLen: 2,
+		asm:    sw64.ACMPLT,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:    "CMPLTconst",
+		auxType: auxInt64,
+		argLen:  1,
+		asm:     sw64.ACMPLT,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "CMPEQ",
+		argLen: 2,
+		asm:    sw64.ACMPEQ,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{1, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:    "CMPEQconst",
+		auxType: auxInt64,
+		argLen:  1,
+		asm:     sw64.ACMPEQ,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "FCMPLE",
+		argLen: 2,
+		asm:    sw64.AFCMPLE,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+				{1, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+			},
+			outputs: []outputInfo{
+				{0, 1151795604700004352}, // F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+			},
+		},
+	},
+	{
+		name:   "FCMPLT",
+		argLen: 2,
+		asm:    sw64.AFCMPLT,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+				{1, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+			},
+			outputs: []outputInfo{
+				{0, 1151795604700004352}, // F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+			},
+		},
+	},
+	{
+		name:   "FCMPEQ",
+		argLen: 2,
+		asm:    sw64.AFCMPEQ,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+				{1, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+			},
+			outputs: []outputInfo{
+				{0, 1151795604700004352}, // F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+			},
+		},
+	},
+	{
+		name:   "FCMPUN",
+		argLen: 2,
+		asm:    sw64.AFCMPUN,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+				{1, 1125899369971712}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20
+			},
+			outputs: []outputInfo{
+				{0, 1151795604700004352}, // F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+			},
+		},
+	},
+	{
+		name:         "CALLstatic",
+		auxType:      auxCallOff,
+		argLen:       -1,
+		clobberFlags: true,
+		call:         true,
+		reg: regInfo{
+			clobbers: 1152921504137084927, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+		},
+	},
+	{
+		name:         "CALLtail",
+		auxType:      auxCallOff,
+		argLen:       -1,
+		clobberFlags: true,
+		call:         true,
+		tailCall:     true,
+		reg: regInfo{
+			clobbers: 1152921504137084927, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+		},
+	},
+	{
+		name:         "CALLclosure",
+		auxType:      auxCallOff,
+		argLen:       -1,
+		clobberFlags: true,
+		call:         true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 33554432},  // R25
+				{0, 201293823}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP
+			},
+			clobbers: 1152921504137084927, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+		},
+	},
+	{
+		name:         "CALLinter",
+		auxType:      auxCallOff,
+		argLen:       -1,
+		clobberFlags: true,
+		call:         true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			clobbers: 1152921504137084927, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+		},
+	},
+	{
+		name:           "DUFFZERO",
+		auxType:        auxInt64,
+		argLen:         2,
+		faultOnNilArg0: true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			clobbers: 2, // R1
+		},
+	},
+	{
+		name:           "LoweredZero",
+		auxType:        auxInt64,
+		argLen:         3,
+		clobberFlags:   true,
+		faultOnNilArg0: true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2},        // R1
+				{1, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			clobbers: 2, // R1
+		},
+	},
+	{
+		name:           "LoweredMove",
+		auxType:        auxInt64,
+		argLen:         4,
+		clobberFlags:   true,
+		faultOnNilArg0: true,
+		faultOnNilArg1: true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 4},        // R2
+				{1, 2},        // R1
+				{2, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			clobbers: 6, // R1 R2
+		},
+	},
+	{
+		name:           "LoweredNilCheck",
+		argLen:         2,
+		nilCheck:       true,
+		faultOnNilArg0: true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:      "LoweredGetClosurePtr",
+		argLen:    0,
+		zeroWidth: true,
+		reg: regInfo{
+			outputs: []outputInfo{
+				{0, 33554432}, // R25
+			},
+		},
+	},
+	{
+		name:              "LoweredGetCallerSP",
+		argLen:            1,
+		rematerializeable: true,
+		reg: regInfo{
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:              "LoweredGetCallerPC",
+		argLen:            0,
+		rematerializeable: true,
+		reg: regInfo{
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "MOVVconvert",
+		argLen: 2,
+		asm:    sw64.ALDI,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 67108863}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "FEqual",
+		argLen: 1,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:   "FNotEqual",
+		argLen: 1,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1152921504069976064}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:         "LoweredWB",
+		auxType:      auxInt64,
+		argLen:       1,
+		clobberFlags: true,
+		reg: regInfo{
+			clobbers: 1152921504137084928, // R26 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30
+			outputs: []outputInfo{
+				{0, 16384}, // R14
+			},
+		},
+	},
+	{
+		name:    "LoweredPanicBoundsA",
+		auxType: auxInt64,
+		argLen:  3,
+		call:    true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 8},  // R3
+				{1, 16}, // R4
+			},
+		},
+	},
+	{
+		name:    "LoweredPanicBoundsB",
+		auxType: auxInt64,
+		argLen:  3,
+		call:    true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 4}, // R2
+				{1, 8}, // R3
+			},
+		},
+	},
+	{
+		name:    "LoweredPanicBoundsC",
+		auxType: auxInt64,
+		argLen:  3,
+		call:    true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2}, // R1
+				{1, 4}, // R2
+			},
+		},
+	},
+	{
+		name:           "LoweredAtomicLoad8",
+		argLen:         2,
+		faultOnNilArg0: true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:           "LoweredAtomicLoad32",
+		argLen:         2,
+		faultOnNilArg0: true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:           "LoweredAtomicLoad64",
+		argLen:         2,
+		faultOnNilArg0: true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:           "LoweredAtomicStore8",
+		argLen:         3,
+		faultOnNilArg0: true,
+		hasSideEffects: true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 67108863},            // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+		},
+	},
+	{
+		name:           "LoweredAtomicStore32",
+		argLen:         3,
+		faultOnNilArg0: true,
+		hasSideEffects: true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 67108863},            // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+		},
+	},
+	{
+		name:           "LoweredAtomicStore64",
+		argLen:         3,
+		faultOnNilArg0: true,
+		hasSideEffects: true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 67108863},            // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+		},
+	},
+	{
+		name:            "LoweredAtomicExchange32",
+		argLen:          3,
+		resultNotInArgs: true,
+		faultOnNilArg0:  true,
+		hasSideEffects:  true,
+		unsafePoint:     true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 67108863},            // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:            "LoweredAtomicExchange64",
+		argLen:          3,
+		resultNotInArgs: true,
+		faultOnNilArg0:  true,
+		hasSideEffects:  true,
+		unsafePoint:     true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 67108863},            // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:            "LoweredAtomicAdd32",
+		argLen:          3,
+		resultNotInArgs: true,
+		faultOnNilArg0:  true,
+		hasSideEffects:  true,
+		unsafePoint:     true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 67108863},            // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:            "LoweredAtomicAdd64",
+		argLen:          3,
+		resultNotInArgs: true,
+		faultOnNilArg0:  true,
+		hasSideEffects:  true,
+		unsafePoint:     true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 67108863},            // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:            "LoweredAtomicCas32",
+		argLen:          4,
+		resultNotInArgs: true,
+		faultOnNilArg0:  true,
+		hasSideEffects:  true,
+		unsafePoint:     true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 67108863},            // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{2, 67108863},            // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+	{
+		name:            "LoweredAtomicCas64",
+		argLen:          4,
+		resultNotInArgs: true,
+		faultOnNilArg0:  true,
+		hasSideEffects:  true,
+		unsafePoint:     true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 67108863},            // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{2, 67108863},            // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+				{0, 2305843009415020543}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 g R16 R17 R18 R19 R20 R21 R22 R23 R24 R25 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 67076095}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R16 R17 R18 R19 R20 R21 R22 R23 R24 R25
+			},
+		},
+	},
+
+	{
+		name:    "LoweredStaticCall",
+		auxType: auxCallOff,
+		argLen:  1,
+		call:    true,
+		reg: regInfo{
+			clobbers: 844424930131967, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31 g
+		},
+	},
+	{
+		name:     "LoweredTailCall",
+		auxType:  auxCallOff,
+		argLen:   1,
+		call:     true,
+		tailCall: true,
+		reg: regInfo{
+			clobbers: 844424930131967, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31 g
+		},
+	},
+	{
+		name:    "LoweredClosureCall",
+		auxType: auxCallOff,
+		argLen:  3,
+		call:    true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{1, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+			clobbers: 844424930131967, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31 g
+		},
+	},
+	{
+		name:    "LoweredInterCall",
+		auxType: auxCallOff,
+		argLen:  2,
+		call:    true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+			clobbers: 844424930131967, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31 g
+		},
+	},
+	{
+		name:              "LoweredAddr",
+		auxType:           auxSymOff,
+		argLen:            1,
+		rematerializeable: true,
+		symEffect:         SymAddr,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:    "LoweredMove",
+		auxType: auxInt64,
+		argLen:  3,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+				{1, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:    "LoweredZero",
+		auxType: auxInt64,
+		argLen:  2,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "LoweredGetClosurePtr",
+		argLen: 0,
+		reg: regInfo{
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:              "LoweredGetCallerPC",
+		argLen:            0,
+		rematerializeable: true,
+		reg: regInfo{
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:              "LoweredGetCallerSP",
+		argLen:            1,
+		rematerializeable: true,
+		reg: regInfo{
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:           "LoweredNilCheck",
+		argLen:         2,
+		nilCheck:       true,
+		faultOnNilArg0: true,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:    "LoweredWB",
+		auxType: auxInt64,
+		argLen:  1,
+		reg: regInfo{
+			clobbers: 844424930131967, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31 g
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "LoweredConvert",
+		argLen: 2,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "Select",
+		argLen: 3,
+		asm:    wasm.ASelect,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{2, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:    "I64Load8U",
+		auxType: auxInt64,
+		argLen:  2,
+		asm:     wasm.AI64Load8U,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:    "I64Load8S",
+		auxType: auxInt64,
+		argLen:  2,
+		asm:     wasm.AI64Load8S,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:    "I64Load16U",
+		auxType: auxInt64,
+		argLen:  2,
+		asm:     wasm.AI64Load16U,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:    "I64Load16S",
+		auxType: auxInt64,
+		argLen:  2,
+		asm:     wasm.AI64Load16S,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:    "I64Load32U",
+		auxType: auxInt64,
+		argLen:  2,
+		asm:     wasm.AI64Load32U,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:    "I64Load32S",
+		auxType: auxInt64,
+		argLen:  2,
+		asm:     wasm.AI64Load32S,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:    "I64Load",
+		auxType: auxInt64,
+		argLen:  2,
+		asm:     wasm.AI64Load,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:    "I64Store8",
+		auxType: auxInt64,
+		argLen:  3,
+		asm:     wasm.AI64Store8,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 281474976776191},  // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+			},
+		},
+	},
+	{
+		name:    "I64Store16",
+		auxType: auxInt64,
+		argLen:  3,
+		asm:     wasm.AI64Store16,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 281474976776191},  // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+			},
+		},
+	},
+	{
+		name:    "I64Store32",
+		auxType: auxInt64,
+		argLen:  3,
+		asm:     wasm.AI64Store32,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 281474976776191},  // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+			},
+		},
+	},
+	{
+		name:    "I64Store",
+		auxType: auxInt64,
+		argLen:  3,
+		asm:     wasm.AI64Store,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 281474976776191},  // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+			},
+		},
+	},
+	{
+		name:    "F32Load",
+		auxType: auxInt64,
+		argLen:  2,
+		asm:     wasm.AF32Load,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+			},
+		},
+	},
+	{
+		name:    "F64Load",
+		auxType: auxInt64,
+		argLen:  2,
+		asm:     wasm.AF64Load,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+			},
+			outputs: []outputInfo{
+				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+			},
+		},
+	},
+	{
+		name:    "F32Store",
+		auxType: auxInt64,
+		argLen:  3,
+		asm:     wasm.AF32Store,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 4294901760},       // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+			},
+		},
+	},
+	{
+		name:    "F64Store",
+		auxType: auxInt64,
+		argLen:  3,
+		asm:     wasm.AF64Store,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{1, 281470681743360},  // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+				{0, 1407374883618815}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP SB
+			},
+		},
+	},
+	{
+		name:              "I64Const",
+		auxType:           auxInt64,
+		argLen:            0,
+		rematerializeable: true,
+		reg: regInfo{
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:              "F32Const",
+		auxType:           auxFloat32,
+		argLen:            0,
+		rematerializeable: true,
+		reg: regInfo{
+			outputs: []outputInfo{
+				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+			},
+		},
+	},
+	{
+		name:              "F64Const",
+		auxType:           auxFloat64,
+		argLen:            0,
+		rematerializeable: true,
+		reg: regInfo{
+			outputs: []outputInfo{
+				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+			},
+		},
+	},
+	{
+		name:   "I64Eqz",
+		argLen: 1,
+		asm:    wasm.AI64Eqz,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64Eq",
+		argLen: 2,
+		asm:    wasm.AI64Eq,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64Ne",
+		argLen: 2,
+		asm:    wasm.AI64Ne,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64LtS",
+		argLen: 2,
+		asm:    wasm.AI64LtS,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64LtU",
+		argLen: 2,
+		asm:    wasm.AI64LtU,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64GtS",
+		argLen: 2,
+		asm:    wasm.AI64GtS,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64GtU",
+		argLen: 2,
+		asm:    wasm.AI64GtU,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64LeS",
+		argLen: 2,
+		asm:    wasm.AI64LeS,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64LeU",
+		argLen: 2,
+		asm:    wasm.AI64LeU,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64GeS",
+		argLen: 2,
+		asm:    wasm.AI64GeS,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64GeU",
+		argLen: 2,
+		asm:    wasm.AI64GeU,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "F32Eq",
+		argLen: 2,
+		asm:    wasm.AF32Eq,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+				{1, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "F32Ne",
+		argLen: 2,
+		asm:    wasm.AF32Ne,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+				{1, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "F32Lt",
+		argLen: 2,
+		asm:    wasm.AF32Lt,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+				{1, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "F32Gt",
+		argLen: 2,
+		asm:    wasm.AF32Gt,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+				{1, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "F32Le",
+		argLen: 2,
+		asm:    wasm.AF32Le,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+				{1, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "F32Ge",
+		argLen: 2,
+		asm:    wasm.AF32Ge,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+				{1, 4294901760}, // F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "F64Eq",
+		argLen: 2,
+		asm:    wasm.AF64Eq,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+				{1, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "F64Ne",
+		argLen: 2,
+		asm:    wasm.AF64Ne,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+				{1, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "F64Lt",
+		argLen: 2,
+		asm:    wasm.AF64Lt,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+				{1, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "F64Gt",
+		argLen: 2,
+		asm:    wasm.AF64Gt,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+				{1, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "F64Le",
+		argLen: 2,
+		asm:    wasm.AF64Le,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+				{1, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "F64Ge",
+		argLen: 2,
+		asm:    wasm.AF64Ge,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+				{1, 281470681743360}, // F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 F26 F27 F28 F29 F30 F31
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64Add",
+		argLen: 2,
+		asm:    wasm.AI64Add,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:    "I64AddConst",
+		auxType: auxInt64,
+		argLen:  1,
+		asm:     wasm.AI64Add,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64Sub",
+		argLen: 2,
+		asm:    wasm.AI64Sub,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64Mul",
+		argLen: 2,
+		asm:    wasm.AI64Mul,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64DivS",
+		argLen: 2,
+		asm:    wasm.AI64DivS,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64DivU",
+		argLen: 2,
+		asm:    wasm.AI64DivU,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64RemS",
+		argLen: 2,
+		asm:    wasm.AI64RemS,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+			},
+			outputs: []outputInfo{
+				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
+			},
+		},
+	},
+	{
+		name:   "I64RemU",
+		argLen: 2,
+		asm:    wasm.AI64RemU,
+		reg: regInfo{
+			inputs: []inputInfo{
+				{0, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
+				{1, 281474976776191}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15 SP
 			},
 			outputs: []outputInfo{
 				{0, 65535}, // R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15
@@ -41075,6 +43308,77 @@ var fpRegMaskS390X = regMask(4294901760)
 var specialRegMaskS390X = regMask(0)
 var framepointerRegS390X = int8(-1)
 var linkRegS390X = int8(14)
+var registersSW64 = [...]Register{
+	{0, sw64.REG_R0, 0, "R0"},
+	{1, sw64.REG_R1, 1, "R1"},
+	{2, sw64.REG_R2, 2, "R2"},
+	{3, sw64.REG_R3, 3, "R3"},
+	{4, sw64.REG_R4, 4, "R4"},
+	{5, sw64.REG_R5, 5, "R5"},
+	{6, sw64.REG_R6, 6, "R6"},
+	{7, sw64.REG_R7, 7, "R7"},
+	{8, sw64.REG_R8, 8, "R8"},
+	{9, sw64.REG_R9, 9, "R9"},
+	{10, sw64.REG_R10, 10, "R10"},
+	{11, sw64.REG_R11, 11, "R11"},
+	{12, sw64.REG_R12, 12, "R12"},
+	{13, sw64.REG_R13, 13, "R13"},
+	{14, sw64.REG_R14, 14, "R14"},
+	{15, sw64.REGG, -1, "g"},
+	{16, sw64.REG_R16, 15, "R16"},
+	{17, sw64.REG_R17, 16, "R17"},
+	{18, sw64.REG_R18, 17, "R18"},
+	{19, sw64.REG_R19, 18, "R19"},
+	{20, sw64.REG_R20, 19, "R20"},
+	{21, sw64.REG_R21, 20, "R21"},
+	{22, sw64.REG_R22, 21, "R22"},
+	{23, sw64.REG_R23, 22, "R23"},
+	{24, sw64.REG_R24, 23, "R24"},
+	{25, sw64.REG_R25, 24, "R25"},
+	{26, sw64.REG_R26, -1, "R26"},
+	{27, sw64.REGSP, -1, "SP"},
+	{28, sw64.REG_R31, -1, "R31"},
+	{29, sw64.REG_F0, -1, "F0"},
+	{30, sw64.REG_F1, -1, "F1"},
+	{31, sw64.REG_F2, -1, "F2"},
+	{32, sw64.REG_F3, -1, "F3"},
+	{33, sw64.REG_F4, -1, "F4"},
+	{34, sw64.REG_F5, -1, "F5"},
+	{35, sw64.REG_F6, -1, "F6"},
+	{36, sw64.REG_F7, -1, "F7"},
+	{37, sw64.REG_F8, -1, "F8"},
+	{38, sw64.REG_F9, -1, "F9"},
+	{39, sw64.REG_F10, -1, "F10"},
+	{40, sw64.REG_F11, -1, "F11"},
+	{41, sw64.REG_F12, -1, "F12"},
+	{42, sw64.REG_F13, -1, "F13"},
+	{43, sw64.REG_F14, -1, "F14"},
+	{44, sw64.REG_F15, -1, "F15"},
+	{45, sw64.REG_F16, -1, "F16"},
+	{46, sw64.REG_F17, -1, "F17"},
+	{47, sw64.REG_F18, -1, "F18"},
+	{48, sw64.REG_F19, -1, "F19"},
+	{49, sw64.REG_F20, -1, "F20"},
+	{50, sw64.REG_F21, -1, "F21"},
+	{51, sw64.REG_F22, -1, "F22"},
+	{52, sw64.REG_F23, -1, "F23"},
+	{53, sw64.REG_F24, -1, "F24"},
+	{54, sw64.REG_F25, -1, "F25"},
+	{55, sw64.REG_F26, -1, "F26"},
+	{56, sw64.REG_F27, -1, "F27"},
+	{57, sw64.REG_F28, -1, "F28"},
+	{58, sw64.REG_F29, -1, "F29"},
+	{59, sw64.REG_F30, -1, "F30"},
+	{60, sw64.REG_F31, -1, "F31"},
+	{61, 0, -1, "SB"},
+}
+var paramIntRegSW64 = []int8{16, 17, 18, 19, 20, 21, 22, 23, 24}
+var paramFloatRegSW64 = []int8{45, 46, 47, 48, 49, 50, 51, 52, 53}
+var gpRegMaskSW64 = regMask(67076095)
+var fpRegMaskSW64 = regMask(1152921504069976064)
+var specialRegMaskSW64 = regMask(0)
+var framepointerRegSW64 = int8(-1)
+var linkRegSW64 = int8(26)
 var registersWasm = [...]Register{
 	{0, wasm.REG_R0, 0, "R0"},
 	{1, wasm.REG_R1, 1, "R1"},
diff --git a/src/cmd/compile/internal/ssa/regalloc.go b/src/cmd/compile/internal/ssa/regalloc.go
index 2325b9ee..004aedfb 100644
--- a/src/cmd/compile/internal/ssa/regalloc.go
+++ b/src/cmd/compile/internal/ssa/regalloc.go
@@ -674,6 +674,8 @@ func (s *regAllocState) init(f *Func) {
 			// nothing to do
 		case "loong64": // R2 (aka TP) already reserved.
 			// nothing to do
+		case "sw64":
+                        // nothing to do
 		case "ppc64le": // R2 already reserved.
 			// nothing to do
 		case "riscv64": // X3 (aka GP) and X4 (aka TP) already reserved.
diff --git a/src/cmd/compile/internal/ssa/rewriteSW64.go b/src/cmd/compile/internal/ssa/rewriteSW64.go
new file mode 100644
index 00000000..2ceff0df
--- /dev/null
+++ b/src/cmd/compile/internal/ssa/rewriteSW64.go
@@ -0,0 +1,8827 @@
+// Code generated from _gen/SW64.rules using 'go generate'; DO NOT EDIT.
+
+package ssa
+
+import "internal/buildcfg"
+import "cmd/compile/internal/types"
+
+func rewriteValueSW64(v *Value) bool {
+	switch v.Op {
+	case OpAbs:
+		v.Op = OpSW64FABS
+		return true
+	case OpAdd16:
+		v.Op = OpSW64ADDV
+		return true
+	case OpAdd32:
+		v.Op = OpSW64ADDV
+		return true
+	case OpAdd32F:
+		v.Op = OpSW64FADDS
+		return true
+	case OpAdd64:
+		v.Op = OpSW64ADDV
+		return true
+	case OpAdd64F:
+		v.Op = OpSW64FADDD
+		return true
+	case OpAdd8:
+		v.Op = OpSW64ADDV
+		return true
+	case OpAddPtr:
+		v.Op = OpSW64ADDV
+		return true
+	case OpAddr:
+		return rewriteValueSW64_OpAddr(v)
+	case OpAnd16:
+		v.Op = OpSW64AND
+		return true
+	case OpAnd32:
+		v.Op = OpSW64AND
+		return true
+	case OpAnd64:
+		v.Op = OpSW64AND
+		return true
+	case OpAnd8:
+		v.Op = OpSW64AND
+		return true
+	case OpAndB:
+		v.Op = OpSW64AND
+		return true
+	case OpAtomicAdd32:
+		v.Op = OpSW64LoweredAtomicAdd32
+		return true
+	case OpAtomicAdd64:
+		v.Op = OpSW64LoweredAtomicAdd64
+		return true
+	case OpAtomicCompareAndSwap32:
+		return rewriteValueSW64_OpAtomicCompareAndSwap32(v)
+	case OpAtomicCompareAndSwap64:
+		v.Op = OpSW64LoweredAtomicCas64
+		return true
+	case OpAtomicExchange32:
+		v.Op = OpSW64LoweredAtomicExchange32
+		return true
+	case OpAtomicExchange64:
+		v.Op = OpSW64LoweredAtomicExchange64
+		return true
+	case OpAtomicLoad32:
+		v.Op = OpSW64LoweredAtomicLoad32
+		return true
+	case OpAtomicLoad64:
+		v.Op = OpSW64LoweredAtomicLoad64
+		return true
+	case OpAtomicLoad8:
+		v.Op = OpSW64LoweredAtomicLoad8
+		return true
+	case OpAtomicLoadPtr:
+		v.Op = OpSW64LoweredAtomicLoad64
+		return true
+	case OpAtomicStore32:
+		v.Op = OpSW64LoweredAtomicStore32
+		return true
+	case OpAtomicStore64:
+		v.Op = OpSW64LoweredAtomicStore64
+		return true
+	case OpAtomicStore8:
+		v.Op = OpSW64LoweredAtomicStore8
+		return true
+	case OpAtomicStorePtrNoWB:
+		v.Op = OpSW64LoweredAtomicStore64
+		return true
+	case OpAvg64u:
+		return rewriteValueSW64_OpAvg64u(v)
+	case OpCeil:
+		v.Op = OpSW64FCVTDL_P
+		return true
+	case OpClosureCall:
+		v.Op = OpSW64CALLclosure
+		return true
+	case OpCom16:
+		return rewriteValueSW64_OpCom16(v)
+	case OpCom32:
+		return rewriteValueSW64_OpCom32(v)
+	case OpCom64:
+		return rewriteValueSW64_OpCom64(v)
+	case OpCom8:
+		return rewriteValueSW64_OpCom8(v)
+	case OpConst16:
+		return rewriteValueSW64_OpConst16(v)
+	case OpConst32:
+		return rewriteValueSW64_OpConst32(v)
+	case OpConst32F:
+		return rewriteValueSW64_OpConst32F(v)
+	case OpConst64:
+		return rewriteValueSW64_OpConst64(v)
+	case OpConst64F:
+		return rewriteValueSW64_OpConst64F(v)
+	case OpConst8:
+		return rewriteValueSW64_OpConst8(v)
+	case OpConstBool:
+		return rewriteValueSW64_OpConstBool(v)
+	case OpConstNil:
+		return rewriteValueSW64_OpConstNil(v)
+	case OpConvert:
+		v.Op = OpSW64MOVVconvert
+		return true
+	case OpCopysign:
+		return rewriteValueSW64_OpCopysign(v)
+	case OpCtz32:
+		return rewriteValueSW64_OpCtz32(v)
+	case OpCtz64:
+		v.Op = OpSW64CTTZ
+		return true
+	case OpCvt32Fto32:
+		return rewriteValueSW64_OpCvt32Fto32(v)
+	case OpCvt32Fto64:
+		return rewriteValueSW64_OpCvt32Fto64(v)
+	case OpCvt32Fto64F:
+		v.Op = OpSW64FCVTSD
+		return true
+	case OpCvt32to32F:
+		return rewriteValueSW64_OpCvt32to32F(v)
+	case OpCvt32to64F:
+		return rewriteValueSW64_OpCvt32to64F(v)
+	case OpCvt64Fto32:
+		return rewriteValueSW64_OpCvt64Fto32(v)
+	case OpCvt64Fto32F:
+		v.Op = OpSW64FCVTDS
+		return true
+	case OpCvt64Fto64:
+		return rewriteValueSW64_OpCvt64Fto64(v)
+	case OpCvt64to32F:
+		v.Op = OpSW64FCVTLS
+		return true
+	case OpCvt64to64F:
+		v.Op = OpSW64FCVTLD
+		return true
+	case OpCvtBoolToUint8:
+		v.Op = OpCopy
+		return true
+	case OpDiv16:
+		return rewriteValueSW64_OpDiv16(v)
+	case OpDiv16u:
+		return rewriteValueSW64_OpDiv16u(v)
+	case OpDiv32:
+		return rewriteValueSW64_OpDiv32(v)
+	case OpDiv32F:
+		v.Op = OpSW64FDIVS
+		return true
+	case OpDiv32u:
+		return rewriteValueSW64_OpDiv32u(v)
+	case OpDiv64:
+		return rewriteValueSW64_OpDiv64(v)
+	case OpDiv64F:
+		v.Op = OpSW64FDIVD
+		return true
+	case OpDiv64u:
+		return rewriteValueSW64_OpDiv64u(v)
+	case OpDiv8:
+		return rewriteValueSW64_OpDiv8(v)
+	case OpDiv8u:
+		return rewriteValueSW64_OpDiv8u(v)
+	case OpEq16:
+		return rewriteValueSW64_OpEq16(v)
+	case OpEq32:
+		return rewriteValueSW64_OpEq32(v)
+	case OpEq32F:
+		return rewriteValueSW64_OpEq32F(v)
+	case OpEq64:
+		v.Op = OpSW64CMPEQ
+		return true
+	case OpEq64F:
+		return rewriteValueSW64_OpEq64F(v)
+	case OpEq8:
+		return rewriteValueSW64_OpEq8(v)
+	case OpEqB:
+		return rewriteValueSW64_OpEqB(v)
+	case OpEqPtr:
+		v.Op = OpSW64CMPEQ
+		return true
+	case OpFloor:
+		v.Op = OpSW64FCVTDL_N
+		return true
+	case OpGetCallerPC:
+		v.Op = OpSW64LoweredGetCallerPC
+		return true
+	case OpGetCallerSP:
+		v.Op = OpSW64LoweredGetCallerSP
+		return true
+	case OpGetClosurePtr:
+		v.Op = OpSW64LoweredGetClosurePtr
+		return true
+	case OpHmul32:
+		return rewriteValueSW64_OpHmul32(v)
+	case OpHmul32u:
+		return rewriteValueSW64_OpHmul32u(v)
+	case OpHmul64:
+		return rewriteValueSW64_OpHmul64(v)
+	case OpHmul64u:
+		v.Op = OpSW64UMULH
+		return true
+	case OpInterCall:
+		v.Op = OpSW64CALLinter
+		return true
+	case OpIsInBounds:
+		v.Op = OpSW64CMPULT
+		return true
+	case OpIsNonNil:
+		return rewriteValueSW64_OpIsNonNil(v)
+	case OpIsSliceInBounds:
+		v.Op = OpSW64CMPULE
+		return true
+	case OpLeq16:
+		return rewriteValueSW64_OpLeq16(v)
+	case OpLeq16U:
+		return rewriteValueSW64_OpLeq16U(v)
+	case OpLeq32:
+		return rewriteValueSW64_OpLeq32(v)
+	case OpLeq32F:
+		return rewriteValueSW64_OpLeq32F(v)
+	case OpLeq32U:
+		return rewriteValueSW64_OpLeq32U(v)
+	case OpLeq64:
+		v.Op = OpSW64CMPLE
+		return true
+	case OpLeq64F:
+		return rewriteValueSW64_OpLeq64F(v)
+	case OpLeq64U:
+		v.Op = OpSW64CMPULE
+		return true
+	case OpLeq8:
+		return rewriteValueSW64_OpLeq8(v)
+	case OpLeq8U:
+		return rewriteValueSW64_OpLeq8U(v)
+	case OpLess16:
+		return rewriteValueSW64_OpLess16(v)
+	case OpLess16U:
+		return rewriteValueSW64_OpLess16U(v)
+	case OpLess32:
+		return rewriteValueSW64_OpLess32(v)
+	case OpLess32F:
+		return rewriteValueSW64_OpLess32F(v)
+	case OpLess32U:
+		return rewriteValueSW64_OpLess32U(v)
+	case OpLess64:
+		v.Op = OpSW64CMPLT
+		return true
+	case OpLess64F:
+		return rewriteValueSW64_OpLess64F(v)
+	case OpLess64U:
+		v.Op = OpSW64CMPULT
+		return true
+	case OpLess8:
+		return rewriteValueSW64_OpLess8(v)
+	case OpLess8U:
+		return rewriteValueSW64_OpLess8U(v)
+	case OpLoad:
+		return rewriteValueSW64_OpLoad(v)
+	case OpLocalAddr:
+		return rewriteValueSW64_OpLocalAddr(v)
+	case OpLsh16x16:
+		return rewriteValueSW64_OpLsh16x16(v)
+	case OpLsh16x32:
+		return rewriteValueSW64_OpLsh16x32(v)
+	case OpLsh16x64:
+		return rewriteValueSW64_OpLsh16x64(v)
+	case OpLsh16x8:
+		return rewriteValueSW64_OpLsh16x8(v)
+	case OpLsh32x16:
+		return rewriteValueSW64_OpLsh32x16(v)
+	case OpLsh32x32:
+		return rewriteValueSW64_OpLsh32x32(v)
+	case OpLsh32x64:
+		return rewriteValueSW64_OpLsh32x64(v)
+	case OpLsh32x8:
+		return rewriteValueSW64_OpLsh32x8(v)
+	case OpLsh64x16:
+		return rewriteValueSW64_OpLsh64x16(v)
+	case OpLsh64x32:
+		return rewriteValueSW64_OpLsh64x32(v)
+	case OpLsh64x64:
+		return rewriteValueSW64_OpLsh64x64(v)
+	case OpLsh64x8:
+		return rewriteValueSW64_OpLsh64x8(v)
+	case OpLsh8x16:
+		return rewriteValueSW64_OpLsh8x16(v)
+	case OpLsh8x32:
+		return rewriteValueSW64_OpLsh8x32(v)
+	case OpLsh8x64:
+		return rewriteValueSW64_OpLsh8x64(v)
+	case OpLsh8x8:
+		return rewriteValueSW64_OpLsh8x8(v)
+	case OpMod16:
+		return rewriteValueSW64_OpMod16(v)
+	case OpMod16u:
+		return rewriteValueSW64_OpMod16u(v)
+	case OpMod32:
+		return rewriteValueSW64_OpMod32(v)
+	case OpMod32u:
+		return rewriteValueSW64_OpMod32u(v)
+	case OpMod64:
+		return rewriteValueSW64_OpMod64(v)
+	case OpMod64u:
+		return rewriteValueSW64_OpMod64u(v)
+	case OpMod8:
+		return rewriteValueSW64_OpMod8(v)
+	case OpMod8u:
+		return rewriteValueSW64_OpMod8u(v)
+	case OpMove:
+		return rewriteValueSW64_OpMove(v)
+	case OpMul16:
+		v.Op = OpSW64MULW
+		return true
+	case OpMul32:
+		v.Op = OpSW64MULW
+		return true
+	case OpMul32F:
+		v.Op = OpSW64FMULS
+		return true
+	case OpMul64:
+		v.Op = OpSW64MULL
+		return true
+	case OpMul64F:
+		v.Op = OpSW64FMULD
+		return true
+	case OpMul8:
+		v.Op = OpSW64MULW
+		return true
+	case OpNeg16:
+		v.Op = OpSW64NEGV
+		return true
+	case OpNeg32:
+		v.Op = OpSW64NEGV
+		return true
+	case OpNeg32F:
+		v.Op = OpSW64NEGF
+		return true
+	case OpNeg64:
+		v.Op = OpSW64NEGV
+		return true
+	case OpNeg64F:
+		v.Op = OpSW64NEGD
+		return true
+	case OpNeg8:
+		v.Op = OpSW64NEGV
+		return true
+	case OpNeq16:
+		return rewriteValueSW64_OpNeq16(v)
+	case OpNeq32:
+		return rewriteValueSW64_OpNeq32(v)
+	case OpNeq32F:
+		return rewriteValueSW64_OpNeq32F(v)
+	case OpNeq64:
+		return rewriteValueSW64_OpNeq64(v)
+	case OpNeq64F:
+		return rewriteValueSW64_OpNeq64F(v)
+	case OpNeq8:
+		return rewriteValueSW64_OpNeq8(v)
+	case OpNeqB:
+		v.Op = OpSW64XOR
+		return true
+	case OpNeqPtr:
+		return rewriteValueSW64_OpNeqPtr(v)
+	case OpNilCheck:
+		v.Op = OpSW64LoweredNilCheck
+		return true
+	case OpNot:
+		return rewriteValueSW64_OpNot(v)
+	case OpOffPtr:
+		return rewriteValueSW64_OpOffPtr(v)
+	case OpOr16:
+		v.Op = OpSW64BIS
+		return true
+	case OpOr32:
+		v.Op = OpSW64BIS
+		return true
+	case OpOr64:
+		v.Op = OpSW64BIS
+		return true
+	case OpOr8:
+		v.Op = OpSW64BIS
+		return true
+	case OpOrB:
+		v.Op = OpSW64BIS
+		return true
+	case OpPanicBounds:
+		return rewriteValueSW64_OpPanicBounds(v)
+	case OpPopCount16:
+		return rewriteValueSW64_OpPopCount16(v)
+	case OpPopCount32:
+		return rewriteValueSW64_OpPopCount32(v)
+	case OpPopCount64:
+		v.Op = OpSW64CTPOP
+		return true
+	case OpPopCount8:
+		return rewriteValueSW64_OpPopCount8(v)
+	case OpRotateLeft16:
+		return rewriteValueSW64_OpRotateLeft16(v)
+	case OpRotateLeft32:
+		return rewriteValueSW64_OpRotateLeft32(v)
+	case OpRotateLeft64:
+		return rewriteValueSW64_OpRotateLeft64(v)
+	case OpRotateLeft8:
+		return rewriteValueSW64_OpRotateLeft8(v)
+	case OpRound:
+		v.Op = OpSW64FCVTDL_G
+		return true
+	case OpRound32F:
+		v.Op = OpCopy
+		return true
+	case OpRound64F:
+		v.Op = OpCopy
+		return true
+	case OpRsh16Ux16:
+		return rewriteValueSW64_OpRsh16Ux16(v)
+	case OpRsh16Ux32:
+		return rewriteValueSW64_OpRsh16Ux32(v)
+	case OpRsh16Ux64:
+		return rewriteValueSW64_OpRsh16Ux64(v)
+	case OpRsh16Ux8:
+		return rewriteValueSW64_OpRsh16Ux8(v)
+	case OpRsh16x16:
+		return rewriteValueSW64_OpRsh16x16(v)
+	case OpRsh16x32:
+		return rewriteValueSW64_OpRsh16x32(v)
+	case OpRsh16x64:
+		return rewriteValueSW64_OpRsh16x64(v)
+	case OpRsh16x8:
+		return rewriteValueSW64_OpRsh16x8(v)
+	case OpRsh32Ux16:
+		return rewriteValueSW64_OpRsh32Ux16(v)
+	case OpRsh32Ux32:
+		return rewriteValueSW64_OpRsh32Ux32(v)
+	case OpRsh32Ux64:
+		return rewriteValueSW64_OpRsh32Ux64(v)
+	case OpRsh32Ux8:
+		return rewriteValueSW64_OpRsh32Ux8(v)
+	case OpRsh32x16:
+		return rewriteValueSW64_OpRsh32x16(v)
+	case OpRsh32x32:
+		return rewriteValueSW64_OpRsh32x32(v)
+	case OpRsh32x64:
+		return rewriteValueSW64_OpRsh32x64(v)
+	case OpRsh32x8:
+		return rewriteValueSW64_OpRsh32x8(v)
+	case OpRsh64Ux16:
+		return rewriteValueSW64_OpRsh64Ux16(v)
+	case OpRsh64Ux32:
+		return rewriteValueSW64_OpRsh64Ux32(v)
+	case OpRsh64Ux64:
+		return rewriteValueSW64_OpRsh64Ux64(v)
+	case OpRsh64Ux8:
+		return rewriteValueSW64_OpRsh64Ux8(v)
+	case OpRsh64x16:
+		return rewriteValueSW64_OpRsh64x16(v)
+	case OpRsh64x32:
+		return rewriteValueSW64_OpRsh64x32(v)
+	case OpRsh64x64:
+		return rewriteValueSW64_OpRsh64x64(v)
+	case OpRsh64x8:
+		return rewriteValueSW64_OpRsh64x8(v)
+	case OpRsh8Ux16:
+		return rewriteValueSW64_OpRsh8Ux16(v)
+	case OpRsh8Ux32:
+		return rewriteValueSW64_OpRsh8Ux32(v)
+	case OpRsh8Ux64:
+		return rewriteValueSW64_OpRsh8Ux64(v)
+	case OpRsh8Ux8:
+		return rewriteValueSW64_OpRsh8Ux8(v)
+	case OpRsh8x16:
+		return rewriteValueSW64_OpRsh8x16(v)
+	case OpRsh8x32:
+		return rewriteValueSW64_OpRsh8x32(v)
+	case OpRsh8x64:
+		return rewriteValueSW64_OpRsh8x64(v)
+	case OpRsh8x8:
+		return rewriteValueSW64_OpRsh8x8(v)
+	case OpSW64ADDV:
+		return rewriteValueSW64_OpSW64ADDV(v)
+	case OpSW64ADDVconst:
+		return rewriteValueSW64_OpSW64ADDVconst(v)
+	case OpSW64ADDWconst:
+		return rewriteValueSW64_OpSW64ADDWconst(v)
+	case OpSW64AND:
+		return rewriteValueSW64_OpSW64AND(v)
+	case OpSW64ANDconst:
+		return rewriteValueSW64_OpSW64ANDconst(v)
+	case OpSW64BIS:
+		return rewriteValueSW64_OpSW64BIS(v)
+	case OpSW64BISconst:
+		return rewriteValueSW64_OpSW64BISconst(v)
+	case OpSW64CMPEQ:
+		return rewriteValueSW64_OpSW64CMPEQ(v)
+	case OpSW64CMPLE:
+		return rewriteValueSW64_OpSW64CMPLE(v)
+	case OpSW64CMPLT:
+		return rewriteValueSW64_OpSW64CMPLT(v)
+	case OpSW64CMPULE:
+		return rewriteValueSW64_OpSW64CMPULE(v)
+	case OpSW64CMPULT:
+		return rewriteValueSW64_OpSW64CMPULT(v)
+	case OpSW64MOVBUload:
+		return rewriteValueSW64_OpSW64MOVBUload(v)
+	case OpSW64MOVBUreg:
+		return rewriteValueSW64_OpSW64MOVBUreg(v)
+	case OpSW64MOVBload:
+		return rewriteValueSW64_OpSW64MOVBload(v)
+	case OpSW64MOVBreg:
+		return rewriteValueSW64_OpSW64MOVBreg(v)
+	case OpSW64MOVBstore:
+		return rewriteValueSW64_OpSW64MOVBstore(v)
+	case OpSW64MOVBstorezero:
+		return rewriteValueSW64_OpSW64MOVBstorezero(v)
+	case OpSW64MOVDload:
+		return rewriteValueSW64_OpSW64MOVDload(v)
+	case OpSW64MOVDstore:
+		return rewriteValueSW64_OpSW64MOVDstore(v)
+	case OpSW64MOVFload:
+		return rewriteValueSW64_OpSW64MOVFload(v)
+	case OpSW64MOVFstore:
+		return rewriteValueSW64_OpSW64MOVFstore(v)
+	case OpSW64MOVHUload:
+		return rewriteValueSW64_OpSW64MOVHUload(v)
+	case OpSW64MOVHUreg:
+		return rewriteValueSW64_OpSW64MOVHUreg(v)
+	case OpSW64MOVHload:
+		return rewriteValueSW64_OpSW64MOVHload(v)
+	case OpSW64MOVHreg:
+		return rewriteValueSW64_OpSW64MOVHreg(v)
+	case OpSW64MOVHstore:
+		return rewriteValueSW64_OpSW64MOVHstore(v)
+	case OpSW64MOVHstorezero:
+		return rewriteValueSW64_OpSW64MOVHstorezero(v)
+	case OpSW64MOVVload:
+		return rewriteValueSW64_OpSW64MOVVload(v)
+	case OpSW64MOVVnop:
+		return rewriteValueSW64_OpSW64MOVVnop(v)
+	case OpSW64MOVVreg:
+		return rewriteValueSW64_OpSW64MOVVreg(v)
+	case OpSW64MOVVstore:
+		return rewriteValueSW64_OpSW64MOVVstore(v)
+	case OpSW64MOVVstorezero:
+		return rewriteValueSW64_OpSW64MOVVstorezero(v)
+	case OpSW64MOVWUload:
+		return rewriteValueSW64_OpSW64MOVWUload(v)
+	case OpSW64MOVWUreg:
+		return rewriteValueSW64_OpSW64MOVWUreg(v)
+	case OpSW64MOVWload:
+		return rewriteValueSW64_OpSW64MOVWload(v)
+	case OpSW64MOVWreg:
+		return rewriteValueSW64_OpSW64MOVWreg(v)
+	case OpSW64MOVWstore:
+		return rewriteValueSW64_OpSW64MOVWstore(v)
+	case OpSW64MOVWstorezero:
+		return rewriteValueSW64_OpSW64MOVWstorezero(v)
+	case OpSW64MULL:
+		return rewriteValueSW64_OpSW64MULL(v)
+	case OpSW64MULLconst:
+		return rewriteValueSW64_OpSW64MULLconst(v)
+	case OpSW64MULW:
+		return rewriteValueSW64_OpSW64MULW(v)
+	case OpSW64NEGV:
+		return rewriteValueSW64_OpSW64NEGV(v)
+	case OpSW64ORNOT:
+		return rewriteValueSW64_OpSW64ORNOT(v)
+	case OpSW64SEXTB:
+		return rewriteValueSW64_OpSW64SEXTB(v)
+	case OpSW64SEXTH:
+		return rewriteValueSW64_OpSW64SEXTH(v)
+	case OpSW64SLLconst:
+		return rewriteValueSW64_OpSW64SLLconst(v)
+	case OpSW64SRAconst:
+		return rewriteValueSW64_OpSW64SRAconst(v)
+	case OpSW64SRLconst:
+		return rewriteValueSW64_OpSW64SRLconst(v)
+	case OpSW64SUBV:
+		return rewriteValueSW64_OpSW64SUBV(v)
+	case OpSW64SUBVconst:
+		return rewriteValueSW64_OpSW64SUBVconst(v)
+	case OpSW64XOR:
+		return rewriteValueSW64_OpSW64XOR(v)
+	case OpSW64XORconst:
+		return rewriteValueSW64_OpSW64XORconst(v)
+	case OpSignExt16to32:
+		v.Op = OpSW64MOVHreg
+		return true
+	case OpSignExt16to64:
+		v.Op = OpSW64MOVHreg
+		return true
+	case OpSignExt32to64:
+		v.Op = OpSW64MOVWreg
+		return true
+	case OpSignExt8to16:
+		v.Op = OpSW64MOVBreg
+		return true
+	case OpSignExt8to32:
+		v.Op = OpSW64MOVBreg
+		return true
+	case OpSignExt8to64:
+		v.Op = OpSW64MOVBreg
+		return true
+	case OpSignmask:
+		return rewriteValueSW64_OpSignmask(v)
+	case OpSlicemask:
+		return rewriteValueSW64_OpSlicemask(v)
+	case OpSqrt:
+		v.Op = OpSW64FSQRTD
+		return true
+	case OpSqrt32:
+		v.Op = OpSW64FSQRTS
+		return true
+	case OpStaticCall:
+		v.Op = OpSW64CALLstatic
+		return true
+	case OpStore:
+		return rewriteValueSW64_OpStore(v)
+	case OpSub16:
+		v.Op = OpSW64SUBV
+		return true
+	case OpSub32:
+		v.Op = OpSW64SUBV
+		return true
+	case OpSub32F:
+		v.Op = OpSW64FSUBS
+		return true
+	case OpSub64:
+		v.Op = OpSW64SUBV
+		return true
+	case OpSub64F:
+		v.Op = OpSW64FSUBD
+		return true
+	case OpSub8:
+		v.Op = OpSW64SUBV
+		return true
+	case OpSubPtr:
+		v.Op = OpSW64SUBV
+		return true
+	case OpTailCall:
+		v.Op = OpSW64CALLtail
+		return true
+	case OpTrunc:
+		v.Op = OpSW64FCVTDL_Z
+		return true
+	case OpTrunc16to8:
+		v.Op = OpCopy
+		return true
+	case OpTrunc32to16:
+		v.Op = OpCopy
+		return true
+	case OpTrunc32to8:
+		v.Op = OpCopy
+		return true
+	case OpTrunc64to16:
+		v.Op = OpCopy
+		return true
+	case OpTrunc64to32:
+		v.Op = OpCopy
+		return true
+	case OpTrunc64to8:
+		v.Op = OpCopy
+		return true
+	case OpWB:
+		v.Op = OpSW64LoweredWB
+		return true
+	case OpXor16:
+		v.Op = OpSW64XOR
+		return true
+	case OpXor32:
+		v.Op = OpSW64XOR
+		return true
+	case OpXor64:
+		v.Op = OpSW64XOR
+		return true
+	case OpXor8:
+		v.Op = OpSW64XOR
+		return true
+	case OpZero:
+		return rewriteValueSW64_OpZero(v)
+	case OpZeroExt16to32:
+		v.Op = OpSW64MOVHUreg
+		return true
+	case OpZeroExt16to64:
+		v.Op = OpSW64MOVHUreg
+		return true
+	case OpZeroExt32to64:
+		v.Op = OpSW64MOVWUreg
+		return true
+	case OpZeroExt8to16:
+		v.Op = OpSW64MOVBUreg
+		return true
+	case OpZeroExt8to32:
+		v.Op = OpSW64MOVBUreg
+		return true
+	case OpZeroExt8to64:
+		v.Op = OpSW64MOVBUreg
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpAddr(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (Addr {sym} base)
+	// result: (SYMADDR {sym} base)
+	for {
+		sym := auxToSym(v.Aux)
+		base := v_0
+		v.reset(OpSW64SYMADDR)
+		v.Aux = symToAux(sym)
+		v.AddArg(base)
+		return true
+	}
+}
+func rewriteValueSW64_OpAtomicCompareAndSwap32(v *Value) bool {
+	v_3 := v.Args[3]
+	v_2 := v.Args[2]
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (AtomicCompareAndSwap32 ptr old new mem)
+	// result: (LoweredAtomicCas32 ptr (SignExt32to64 old) new mem)
+	for {
+		ptr := v_0
+		old := v_1
+		new := v_2
+		mem := v_3
+		v.reset(OpSW64LoweredAtomicCas32)
+		v0 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v0.AddArg(old)
+		v.AddArg4(ptr, v0, new, mem)
+		return true
+	}
+}
+func rewriteValueSW64_OpAvg64u(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	// match: (Avg64u <t> x y)
+	// result: (ADDV (SRLconst <t> (SUBV <t> x y) [1]) y)
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64ADDV)
+		v0 := b.NewValue0(v.Pos, OpSW64SRLconst, t)
+		v0.AuxInt = int64ToAuxInt(1)
+		v1 := b.NewValue0(v.Pos, OpSW64SUBV, t)
+		v1.AddArg2(x, y)
+		v0.AddArg(v1)
+		v.AddArg2(v0, y)
+		return true
+	}
+}
+func rewriteValueSW64_OpCom16(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Com16 x)
+	// result: (ORNOT (MOVVconst [0]) x)
+	for {
+		x := v_0
+		v.reset(OpSW64ORNOT)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v.AddArg2(v0, x)
+		return true
+	}
+}
+func rewriteValueSW64_OpCom32(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Com32 x)
+	// result: (ORNOT (MOVVconst [0]) x)
+	for {
+		x := v_0
+		v.reset(OpSW64ORNOT)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v.AddArg2(v0, x)
+		return true
+	}
+}
+func rewriteValueSW64_OpCom64(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Com64 x)
+	// result: (ORNOT (MOVVconst [0]) x)
+	for {
+		x := v_0
+		v.reset(OpSW64ORNOT)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v.AddArg2(v0, x)
+		return true
+	}
+}
+func rewriteValueSW64_OpCom8(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Com8 x)
+	// result: (ORNOT (MOVVconst [0]) x)
+	for {
+		x := v_0
+		v.reset(OpSW64ORNOT)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v.AddArg2(v0, x)
+		return true
+	}
+}
+func rewriteValueSW64_OpConst16(v *Value) bool {
+	// match: (Const16 [val])
+	// result: (MOVVconst [int64(val)])
+	for {
+		val := auxIntToInt16(v.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(val))
+		return true
+	}
+}
+func rewriteValueSW64_OpConst32(v *Value) bool {
+	// match: (Const32 [val])
+	// result: (MOVVconst [int64(val)])
+	for {
+		val := auxIntToInt32(v.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(val))
+		return true
+	}
+}
+func rewriteValueSW64_OpConst32F(v *Value) bool {
+	// match: (Const32F [val])
+	// result: (MOVFconst [float64(val)])
+	for {
+		val := auxIntToFloat32(v.AuxInt)
+		v.reset(OpSW64MOVFconst)
+		v.AuxInt = float64ToAuxInt(float64(val))
+		return true
+	}
+}
+func rewriteValueSW64_OpConst64(v *Value) bool {
+	// match: (Const64 [val])
+	// result: (MOVVconst [int64(val)])
+	for {
+		val := auxIntToInt64(v.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(val))
+		return true
+	}
+}
+func rewriteValueSW64_OpConst64F(v *Value) bool {
+	// match: (Const64F [val])
+	// result: (MOVDconst [float64(val)])
+	for {
+		val := auxIntToFloat64(v.AuxInt)
+		v.reset(OpSW64MOVDconst)
+		v.AuxInt = float64ToAuxInt(float64(val))
+		return true
+	}
+}
+func rewriteValueSW64_OpConst8(v *Value) bool {
+	// match: (Const8 [val])
+	// result: (MOVVconst [int64(val)])
+	for {
+		val := auxIntToInt8(v.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(val))
+		return true
+	}
+}
+func rewriteValueSW64_OpConstBool(v *Value) bool {
+	// match: (ConstBool [t])
+	// result: (MOVVconst [b2i(t)])
+	for {
+		t := auxIntToBool(v.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(b2i(t))
+		return true
+	}
+}
+func rewriteValueSW64_OpConstNil(v *Value) bool {
+	// match: (ConstNil)
+	// result: (MOVVconst [0])
+	for {
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(0)
+		return true
+	}
+}
+func rewriteValueSW64_OpCopysign(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (Copysign x y)
+	// result: (FCPYS y x)
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64FCPYS)
+		v.AddArg2(y, x)
+		return true
+	}
+}
+func rewriteValueSW64_OpCtz32(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Ctz32 <t> x)
+	// result: (SUBV (CTTZ (ZeroExt32to64 x)) (MULLconst <t> (CMPEQ (ZeroExt32to64 x) (MOVVconst [0]) ) [32]))
+	for {
+		t := v.Type
+		x := v_0
+		v.reset(OpSW64SUBV)
+		v0 := b.NewValue0(v.Pos, OpSW64CTTZ, typ.UInt64)
+		v1 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v1.AddArg(x)
+		v0.AddArg(v1)
+		v2 := b.NewValue0(v.Pos, OpSW64MULLconst, t)
+		v2.AuxInt = int64ToAuxInt(32)
+		v3 := b.NewValue0(v.Pos, OpSW64CMPEQ, typ.Bool)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v4.AuxInt = int64ToAuxInt(0)
+		v3.AddArg2(v1, v4)
+		v2.AddArg(v3)
+		v.AddArg2(v0, v2)
+		return true
+	}
+}
+func rewriteValueSW64_OpCvt32Fto32(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Cvt32Fto32 x)
+	// result: (FIMOVS (FCVTLW (FCVTDL_Z (FCVTSD x))))
+	for {
+		x := v_0
+		v.reset(OpSW64FIMOVS)
+		v0 := b.NewValue0(v.Pos, OpSW64FCVTLW, typ.Float32)
+		v1 := b.NewValue0(v.Pos, OpSW64FCVTDL_Z, typ.Float64)
+		v2 := b.NewValue0(v.Pos, OpSW64FCVTSD, typ.Float64)
+		v2.AddArg(x)
+		v1.AddArg(v2)
+		v0.AddArg(v1)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpCvt32Fto64(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Cvt32Fto64 x)
+	// result: (FIMOVD (FCVTDL_Z (FCVTSD x)))
+	for {
+		x := v_0
+		v.reset(OpSW64FIMOVD)
+		v0 := b.NewValue0(v.Pos, OpSW64FCVTDL_Z, typ.Float64)
+		v1 := b.NewValue0(v.Pos, OpSW64FCVTSD, typ.Float64)
+		v1.AddArg(x)
+		v0.AddArg(v1)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpCvt32to32F(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Cvt32to32F x)
+	// result: (FCVTLS (IFMOVD x))
+	for {
+		x := v_0
+		v.reset(OpSW64FCVTLS)
+		v0 := b.NewValue0(v.Pos, OpSW64IFMOVD, typ.Float64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpCvt32to64F(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Cvt32to64F x)
+	// result: (FCVTLD (IFMOVD (SignExt32to64 x)))
+	for {
+		x := v_0
+		v.reset(OpSW64FCVTLD)
+		v0 := b.NewValue0(v.Pos, OpSW64IFMOVD, typ.Float64)
+		v1 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v1.AddArg(x)
+		v0.AddArg(v1)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpCvt64Fto32(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Cvt64Fto32 x)
+	// result: (FIMOVS (FCVTLW (FCVTDL_Z x)))
+	for {
+		x := v_0
+		v.reset(OpSW64FIMOVS)
+		v0 := b.NewValue0(v.Pos, OpSW64FCVTLW, typ.Float32)
+		v1 := b.NewValue0(v.Pos, OpSW64FCVTDL_Z, typ.Float64)
+		v1.AddArg(x)
+		v0.AddArg(v1)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpCvt64Fto64(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Cvt64Fto64 x)
+	// result: (FIMOVD (FCVTDL_Z x))
+	for {
+		x := v_0
+		v.reset(OpSW64FIMOVD)
+		v0 := b.NewValue0(v.Pos, OpSW64FCVTDL_Z, typ.Float64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpDiv16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Div16 x y)
+	// result: (Div64 (SignExt16to64 x) (SignExt16to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpDiv64)
+		v0 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpDiv16u(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Div16u x y)
+	// result: (Div64u (ZeroExt16to64 x) (ZeroExt16to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpDiv64u)
+		v0 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpDiv32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Div32 x y)
+	// cond: buildcfg.GOSW64 <=3
+	// result: (Div64 (SignExt32to64 x) (SignExt32to64 y))
+	for {
+		x := v_0
+		y := v_1
+		if !(buildcfg.GOSW64 <= 3) {
+			break
+		}
+		v.reset(OpDiv64)
+		v0 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+	// match: (Div32 x y)
+	// cond: buildcfg.GOSW64 >=4
+	// result: (DIVW x y)
+	for {
+		x := v_0
+		y := v_1
+		if !(buildcfg.GOSW64 >= 4) {
+			break
+		}
+		v.reset(OpSW64DIVW)
+		v.AddArg2(x, y)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpDiv32u(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Div32u x y)
+	// cond: buildcfg.GOSW64 <=3
+	// result: (Div64u (ZeroExt32to64 x) (ZeroExt32to64 y))
+	for {
+		x := v_0
+		y := v_1
+		if !(buildcfg.GOSW64 <= 3) {
+			break
+		}
+		v.reset(OpDiv64u)
+		v0 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+	// match: (Div32u x y)
+	// cond: buildcfg.GOSW64 >=4
+	// result: (UDIVW x y)
+	for {
+		x := v_0
+		y := v_1
+		if !(buildcfg.GOSW64 >= 4) {
+			break
+		}
+		v.reset(OpSW64UDIVW)
+		v.AddArg2(x, y)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpDiv64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Div64 x y)
+	// cond: buildcfg.GOSW64 <=3
+	// result: (SUBV (XOR <typ.UInt64> (Select0 <typ.UInt64> (CALLudiv (SUBV <typ.UInt64> (XOR x <typ.UInt64> (Signmask x)) (Signmask x)) (SUBV <typ.UInt64> (XOR y <typ.UInt64> (Signmask y)) (Signmask y)))) (Signmask (XOR <typ.UInt64> x y))) (Signmask (XOR <typ.UInt64> x y)))
+	for {
+		x := v_0
+		y := v_1
+		if !(buildcfg.GOSW64 <= 3) {
+			break
+		}
+		v.reset(OpSW64SUBV)
+		v0 := b.NewValue0(v.Pos, OpSW64XOR, typ.UInt64)
+		v1 := b.NewValue0(v.Pos, OpSelect0, typ.UInt64)
+		v2 := b.NewValue0(v.Pos, OpSW64CALLudiv, types.NewTuple(typ.UInt64, typ.UInt64))
+		v3 := b.NewValue0(v.Pos, OpSW64SUBV, typ.UInt64)
+		v4 := b.NewValue0(v.Pos, OpSW64XOR, typ.UInt64)
+		v5 := b.NewValue0(v.Pos, OpSignmask, typ.Int32)
+		v5.AddArg(x)
+		v4.AddArg2(x, v5)
+		v3.AddArg2(v4, v5)
+		v6 := b.NewValue0(v.Pos, OpSW64SUBV, typ.UInt64)
+		v7 := b.NewValue0(v.Pos, OpSW64XOR, typ.UInt64)
+		v8 := b.NewValue0(v.Pos, OpSignmask, typ.Int32)
+		v8.AddArg(y)
+		v7.AddArg2(y, v8)
+		v6.AddArg2(v7, v8)
+		v2.AddArg2(v3, v6)
+		v1.AddArg(v2)
+		v9 := b.NewValue0(v.Pos, OpSignmask, typ.Int32)
+		v10 := b.NewValue0(v.Pos, OpSW64XOR, typ.UInt64)
+		v10.AddArg2(x, y)
+		v9.AddArg(v10)
+		v0.AddArg2(v1, v9)
+		v.AddArg2(v0, v9)
+		return true
+	}
+	// match: (Div64 [false] x y)
+	// cond: buildcfg.GOSW64 >=4
+	// result: (DIVV x y)
+	for {
+		if auxIntToBool(v.AuxInt) != false {
+			break
+		}
+		x := v_0
+		y := v_1
+		if !(buildcfg.GOSW64 >= 4) {
+			break
+		}
+		v.reset(OpSW64DIVV)
+		v.AddArg2(x, y)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpDiv64u(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Div64u x y)
+	// cond: buildcfg.GOSW64 <=3
+	// result: (Select0 <typ.UInt64> (CALLudiv x y))
+	for {
+		x := v_0
+		y := v_1
+		if !(buildcfg.GOSW64 <= 3) {
+			break
+		}
+		v.reset(OpSelect0)
+		v.Type = typ.UInt64
+		v0 := b.NewValue0(v.Pos, OpSW64CALLudiv, types.NewTuple(typ.UInt64, typ.UInt64))
+		v0.AddArg2(x, y)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Div64u x y)
+	// cond: buildcfg.GOSW64 >=4
+	// result: (UDIVV x y)
+	for {
+		x := v_0
+		y := v_1
+		if !(buildcfg.GOSW64 >= 4) {
+			break
+		}
+		v.reset(OpSW64UDIVV)
+		v.AddArg2(x, y)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpDiv8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Div8 x y)
+	// result: (Div64 (SignExt8to64 x) (SignExt8to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpDiv64)
+		v0 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpDiv8u(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Div8u x y)
+	// result: (Div64u (ZeroExt8to64 x) (ZeroExt8to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpDiv64u)
+		v0 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpEq16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Eq16 x y)
+	// result: (CMPEQ (ZeroExt16to64 x) (ZeroExt16to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64CMPEQ)
+		v0 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpEq32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Eq32 x y)
+	// result: (CMPEQ (ZeroExt32to64 x) (ZeroExt32to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64CMPEQ)
+		v0 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpEq32F(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Eq32F x y)
+	// result: (FEqual (FCMPEQ x y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64FEqual)
+		v0 := b.NewValue0(v.Pos, OpSW64FCMPEQ, typ.Float64)
+		v0.AddArg2(x, y)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpEq64F(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Eq64F x y)
+	// result: (FEqual (FCMPEQ x y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64FEqual)
+		v0 := b.NewValue0(v.Pos, OpSW64FCMPEQ, typ.Float64)
+		v0.AddArg2(x, y)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpEq8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Eq8 x y)
+	// result: (CMPEQ (ZeroExt8to64 x) (ZeroExt8to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64CMPEQ)
+		v0 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpEqB(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (EqB x y)
+	// result: (XOR (MOVVconst [1]) (XOR <typ.Bool> x y) )
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64XOR)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(1)
+		v1 := b.NewValue0(v.Pos, OpSW64XOR, typ.Bool)
+		v1.AddArg2(x, y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpHmul32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Hmul32 x y)
+	// result: (SRAconst (MULL <typ.Int64> (SignExt32to64 x) (SignExt32to64 y)) [32])
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(32)
+		v0 := b.NewValue0(v.Pos, OpSW64MULL, typ.Int64)
+		v1 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v1.AddArg(x)
+		v2 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v2.AddArg(y)
+		v0.AddArg2(v1, v2)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpHmul32u(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Hmul32u x y)
+	// result: (SRLconst (MULL <typ.UInt64> (ZeroExt32to64 x) (ZeroExt32to64 y)) [32])
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRLconst)
+		v.AuxInt = int64ToAuxInt(32)
+		v0 := b.NewValue0(v.Pos, OpSW64MULL, typ.UInt64)
+		v1 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v1.AddArg(x)
+		v2 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v2.AddArg(y)
+		v0.AddArg2(v1, v2)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpHmul64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Hmul64 x y)
+	// result: ( SUBV <typ.Int64> (SUBV <typ.Int64> (UMULH <typ.Int64> x y) (MULL <typ.Int64> (SRLconst x [63]) y)) (MULL <typ.Int64> (SRLconst y [63]) x) )
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SUBV)
+		v.Type = typ.Int64
+		v0 := b.NewValue0(v.Pos, OpSW64SUBV, typ.Int64)
+		v1 := b.NewValue0(v.Pos, OpSW64UMULH, typ.Int64)
+		v1.AddArg2(x, y)
+		v2 := b.NewValue0(v.Pos, OpSW64MULL, typ.Int64)
+		v3 := b.NewValue0(v.Pos, OpSW64SRLconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(63)
+		v3.AddArg(x)
+		v2.AddArg2(v3, y)
+		v0.AddArg2(v1, v2)
+		v4 := b.NewValue0(v.Pos, OpSW64MULL, typ.Int64)
+		v5 := b.NewValue0(v.Pos, OpSW64SRLconst, typ.UInt64)
+		v5.AuxInt = int64ToAuxInt(63)
+		v5.AddArg(y)
+		v4.AddArg2(v5, x)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpIsNonNil(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (IsNonNil ptr)
+	// result: (CMPULT (MOVVconst [0]) ptr)
+	for {
+		ptr := v_0
+		v.reset(OpSW64CMPULT)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v.AddArg2(v0, ptr)
+		return true
+	}
+}
+func rewriteValueSW64_OpLeq16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Leq16 x y)
+	// result: (CMPLE (SignExt16to64 x) (SignExt16to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64CMPLE)
+		v0 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpLeq16U(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Leq16U x y)
+	// result: (CMPULE (ZeroExt16to64 x) (ZeroExt16to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64CMPULE)
+		v0 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpLeq32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Leq32 x y)
+	// result: (CMPLE (SignExt32to64 x) (SignExt32to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64CMPLE)
+		v0 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpLeq32F(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Leq32F x y)
+	// result: (FEqual (FCMPLE x y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64FEqual)
+		v0 := b.NewValue0(v.Pos, OpSW64FCMPLE, typ.Float64)
+		v0.AddArg2(x, y)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpLeq32U(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Leq32U x y)
+	// result: (CMPULE (ZeroExt32to64 x) (ZeroExt32to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64CMPULE)
+		v0 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpLeq64F(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Leq64F x y)
+	// result: (FEqual (FCMPLE x y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64FEqual)
+		v0 := b.NewValue0(v.Pos, OpSW64FCMPLE, typ.Float64)
+		v0.AddArg2(x, y)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpLeq8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Leq8 x y)
+	// result: (CMPLE (SignExt8to64 x) (SignExt8to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64CMPLE)
+		v0 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpLeq8U(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Leq8U x y)
+	// result: (CMPULE (ZeroExt8to64 x) (ZeroExt8to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64CMPULE)
+		v0 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpLess16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Less16 x y)
+	// result: (CMPLT (SignExt16to64 x) (SignExt16to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64CMPLT)
+		v0 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpLess16U(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Less16U x y)
+	// result: (CMPULT (ZeroExt16to64 x) (ZeroExt16to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64CMPULT)
+		v0 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpLess32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Less32 x y)
+	// result: (CMPLT (SignExt32to64 x) (SignExt32to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64CMPLT)
+		v0 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpLess32F(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Less32F x y)
+	// result: (FEqual (FCMPLT x y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64FEqual)
+		v0 := b.NewValue0(v.Pos, OpSW64FCMPLT, typ.Float64)
+		v0.AddArg2(x, y)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpLess32U(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Less32U x y)
+	// result: (CMPULT (ZeroExt32to64 x) (ZeroExt32to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64CMPULT)
+		v0 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpLess64F(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Less64F x y)
+	// result: (FEqual (FCMPLT x y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64FEqual)
+		v0 := b.NewValue0(v.Pos, OpSW64FCMPLT, typ.Float64)
+		v0.AddArg2(x, y)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpLess8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Less8 x y)
+	// result: (CMPLT (SignExt8to64 x) (SignExt8to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64CMPLT)
+		v0 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpLess8U(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Less8U x y)
+	// result: (CMPULT (ZeroExt8to64 x) (ZeroExt8to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64CMPULT)
+		v0 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpLoad(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (Load <t> ptr mem)
+	// cond: t.IsBoolean()
+	// result: (MOVBUload ptr mem)
+	for {
+		t := v.Type
+		ptr := v_0
+		mem := v_1
+		if !(t.IsBoolean()) {
+			break
+		}
+		v.reset(OpSW64MOVBUload)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (Load <t> ptr mem)
+	// cond: (is8BitInt(t) && t.IsSigned())
+	// result: (MOVBload ptr mem)
+	for {
+		t := v.Type
+		ptr := v_0
+		mem := v_1
+		if !(is8BitInt(t) && t.IsSigned()) {
+			break
+		}
+		v.reset(OpSW64MOVBload)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (Load <t> ptr mem)
+	// cond: (is8BitInt(t) && !t.IsSigned())
+	// result: (MOVBUload ptr mem)
+	for {
+		t := v.Type
+		ptr := v_0
+		mem := v_1
+		if !(is8BitInt(t) && !t.IsSigned()) {
+			break
+		}
+		v.reset(OpSW64MOVBUload)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (Load <t> ptr mem)
+	// cond: (is16BitInt(t) && t.IsSigned())
+	// result: (MOVHload ptr mem)
+	for {
+		t := v.Type
+		ptr := v_0
+		mem := v_1
+		if !(is16BitInt(t) && t.IsSigned()) {
+			break
+		}
+		v.reset(OpSW64MOVHload)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (Load <t> ptr mem)
+	// cond: (is16BitInt(t) && !t.IsSigned())
+	// result: (MOVHUload ptr mem)
+	for {
+		t := v.Type
+		ptr := v_0
+		mem := v_1
+		if !(is16BitInt(t) && !t.IsSigned()) {
+			break
+		}
+		v.reset(OpSW64MOVHUload)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (Load <t> ptr mem)
+	// cond: (is32BitInt(t) && t.IsSigned())
+	// result: (MOVWload ptr mem)
+	for {
+		t := v.Type
+		ptr := v_0
+		mem := v_1
+		if !(is32BitInt(t) && t.IsSigned()) {
+			break
+		}
+		v.reset(OpSW64MOVWload)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (Load <t> ptr mem)
+	// cond: (is32BitInt(t) && !t.IsSigned())
+	// result: (MOVWUload ptr mem)
+	for {
+		t := v.Type
+		ptr := v_0
+		mem := v_1
+		if !(is32BitInt(t) && !t.IsSigned()) {
+			break
+		}
+		v.reset(OpSW64MOVWUload)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (Load <t> ptr mem)
+	// cond: (is64BitInt(t) || isPtr(t))
+	// result: (MOVVload ptr mem)
+	for {
+		t := v.Type
+		ptr := v_0
+		mem := v_1
+		if !(is64BitInt(t) || isPtr(t)) {
+			break
+		}
+		v.reset(OpSW64MOVVload)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (Load <t> ptr mem)
+	// cond: is32BitFloat(t)
+	// result: (MOVFload ptr mem)
+	for {
+		t := v.Type
+		ptr := v_0
+		mem := v_1
+		if !(is32BitFloat(t)) {
+			break
+		}
+		v.reset(OpSW64MOVFload)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (Load <t> ptr mem)
+	// cond: is64BitFloat(t)
+	// result: (MOVDload ptr mem)
+	for {
+		t := v.Type
+		ptr := v_0
+		mem := v_1
+		if !(is64BitFloat(t)) {
+			break
+		}
+		v.reset(OpSW64MOVDload)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpLocalAddr(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (LocalAddr <t> {sym} base mem)
+	// cond: t.Elem().HasPointers()
+	// result: (SYMADDR {sym} (SPanchored base mem))
+	for {
+		t := v.Type
+		sym := auxToSym(v.Aux)
+		base := v_0
+		mem := v_1
+		if !(t.Elem().HasPointers()) {
+			break
+		}
+		v.reset(OpSW64SYMADDR)
+		v.Aux = symToAux(sym)
+		v0 := b.NewValue0(v.Pos, OpSPanchored, typ.Uintptr)
+		v0.AddArg2(base, mem)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (LocalAddr <t> {sym} base _)
+	// cond: !t.Elem().HasPointers()
+	// result: (SYMADDR {sym} base)
+	for {
+		t := v.Type
+		sym := auxToSym(v.Aux)
+		base := v_0
+		if !(!t.Elem().HasPointers()) {
+			break
+		}
+		v.reset(OpSW64SYMADDR)
+		v.Aux = symToAux(sym)
+		v.AddArg(base)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpLsh16x16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh16x16 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt16to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v4.AddArg2(x, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpLsh16x32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh16x32 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt32to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v4.AddArg2(x, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpLsh16x64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh16x64 x (Const64 [c]))
+	// cond: uint64(c) < 16
+	// result: (SLLconst (ZeroExt16to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 16) {
+			break
+		}
+		v.reset(OpSW64SLLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Lsh16x64 x (MOVVconst [c]))
+	// cond: uint64(c) < 16
+	// result: (SLLconst (ZeroExt16to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 16) {
+			break
+		}
+		v.reset(OpSW64SLLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Lsh16x64 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SLL <t> x y))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v2.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(y, v2)
+		v0.AddArg(v1)
+		v3 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v3.AddArg2(x, y)
+		v.AddArg2(v0, v3)
+		return true
+	}
+}
+func rewriteValueSW64_OpLsh16x8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh16x8 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt8to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt8to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v4.AddArg2(x, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpLsh32x16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh32x16 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt16to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v4.AddArg2(x, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpLsh32x32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh32x32 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt32to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v4.AddArg2(x, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpLsh32x64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh32x64 x (Const64 [c]))
+	// cond: uint64(c) < 32
+	// result: (SLLconst (ZeroExt32to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 32) {
+			break
+		}
+		v.reset(OpSW64SLLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Lsh32x64 x (MOVVconst [c]))
+	// cond: uint64(c) < 32
+	// result: (SLLconst (ZeroExt32to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 32) {
+			break
+		}
+		v.reset(OpSW64SLLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Lsh32x64 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SLL <t> x y))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v2.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(y, v2)
+		v0.AddArg(v1)
+		v3 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v3.AddArg2(x, y)
+		v.AddArg2(v0, v3)
+		return true
+	}
+}
+func rewriteValueSW64_OpLsh32x8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh32x8 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt8to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt8to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v4.AddArg2(x, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpLsh64x16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh64x16 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt16to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v4.AddArg2(x, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpLsh64x32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh64x32 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt32to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v4.AddArg2(x, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpLsh64x64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh64x64 x (Const64 [c]))
+	// cond: uint64(c) < 64
+	// result: (SLLconst x [c])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 64) {
+			break
+		}
+		v.reset(OpSW64SLLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v.AddArg(x)
+		return true
+	}
+	// match: (Lsh64x64 x (MOVVconst [c]))
+	// cond: uint64(c) < 64
+	// result: (SLLconst x [c])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 64) {
+			break
+		}
+		v.reset(OpSW64SLLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v.AddArg(x)
+		return true
+	}
+	// match: (Lsh64x64 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SLL <t> x y))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v2.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(y, v2)
+		v0.AddArg(v1)
+		v3 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v3.AddArg2(x, y)
+		v.AddArg2(v0, v3)
+		return true
+	}
+}
+func rewriteValueSW64_OpLsh64x8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh64x8 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt8to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt8to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v4.AddArg2(x, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpLsh8x16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh8x16 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt16to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v4.AddArg2(x, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpLsh8x32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh8x32 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt32to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v4.AddArg2(x, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpLsh8x64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh8x64 x (Const64 [c]))
+	// cond: uint64(c) < 8
+	// result: (SLLconst (ZeroExt8to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 8) {
+			break
+		}
+		v.reset(OpSW64SLLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Lsh8x64 x (MOVVconst [c]))
+	// cond: uint64(c) < 8
+	// result: (SLLconst (ZeroExt8to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 8) {
+			break
+		}
+		v.reset(OpSW64SLLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Lsh8x64 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SLL <t> x y))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v2.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(y, v2)
+		v0.AddArg(v1)
+		v3 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v3.AddArg2(x, y)
+		v.AddArg2(v0, v3)
+		return true
+	}
+}
+func rewriteValueSW64_OpLsh8x8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Lsh8x8 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt8to64 y) (MOVVconst <typ.UInt64> [64]))) (SLL <t> x (ZeroExt8to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SLL, t)
+		v4.AddArg2(x, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpMod16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Mod16 x y)
+	// result: (Mod64 (SignExt16to64 x) (SignExt16to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpMod64)
+		v0 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpMod16u(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Mod16u x y)
+	// result: (Mod64u (ZeroExt16to64 x) (ZeroExt16to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpMod64u)
+		v0 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpMod32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Mod32 x y)
+	// result: (Mod64 (SignExt32to64 x) (SignExt32to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpMod64)
+		v0 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpMod32u(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Mod32u x y)
+	// result: (Mod64u (ZeroExt32to64 x) (ZeroExt32to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpMod64u)
+		v0 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpMod64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Mod64 x y)
+	// result: (SUBV (XOR <typ.UInt64> (Select1 <typ.UInt64> (CALLudiv (SUBV <typ.UInt64> (XOR <typ.UInt64> x (Signmask x)) (Signmask x)) (SUBV <typ.UInt64> (XOR <typ.UInt64> y (Signmask y)) (Signmask y)))) (Signmask x)) (Signmask x))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SUBV)
+		v0 := b.NewValue0(v.Pos, OpSW64XOR, typ.UInt64)
+		v1 := b.NewValue0(v.Pos, OpSelect1, typ.UInt64)
+		v2 := b.NewValue0(v.Pos, OpSW64CALLudiv, types.NewTuple(typ.UInt64, typ.UInt64))
+		v3 := b.NewValue0(v.Pos, OpSW64SUBV, typ.UInt64)
+		v4 := b.NewValue0(v.Pos, OpSW64XOR, typ.UInt64)
+		v5 := b.NewValue0(v.Pos, OpSignmask, typ.Int32)
+		v5.AddArg(x)
+		v4.AddArg2(x, v5)
+		v3.AddArg2(v4, v5)
+		v6 := b.NewValue0(v.Pos, OpSW64SUBV, typ.UInt64)
+		v7 := b.NewValue0(v.Pos, OpSW64XOR, typ.UInt64)
+		v8 := b.NewValue0(v.Pos, OpSignmask, typ.Int32)
+		v8.AddArg(y)
+		v7.AddArg2(y, v8)
+		v6.AddArg2(v7, v8)
+		v2.AddArg2(v3, v6)
+		v1.AddArg(v2)
+		v0.AddArg2(v1, v5)
+		v.AddArg2(v0, v5)
+		return true
+	}
+}
+func rewriteValueSW64_OpMod64u(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Mod64u x y)
+	// result: (Select1 <typ.UInt64> (CALLudiv x y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSelect1)
+		v.Type = typ.UInt64
+		v0 := b.NewValue0(v.Pos, OpSW64CALLudiv, types.NewTuple(typ.UInt64, typ.UInt64))
+		v0.AddArg2(x, y)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpMod8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Mod8 x y)
+	// result: (Mod64 (SignExt8to64 x) (SignExt8to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpMod64)
+		v0 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpMod8u(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Mod8u x y)
+	// result: (Mod64u (ZeroExt8to64 x) (ZeroExt8to64 y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpMod64u)
+		v0 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v1.AddArg(y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpMove(v *Value) bool {
+	v_2 := v.Args[2]
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	typ := &b.Func.Config.Types
+	// match: (Move [0] _ _ mem)
+	// result: mem
+	for {
+		if auxIntToInt64(v.AuxInt) != 0 {
+			break
+		}
+		mem := v_2
+		v.copyOf(mem)
+		return true
+	}
+	// match: (Move [1] dst src mem)
+	// result: (MOVBstore dst (MOVBload src mem) mem)
+	for {
+		if auxIntToInt64(v.AuxInt) != 1 {
+			break
+		}
+		dst := v_0
+		src := v_1
+		mem := v_2
+		v.reset(OpSW64MOVBstore)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVBload, typ.Int8)
+		v0.AddArg2(src, mem)
+		v.AddArg3(dst, v0, mem)
+		return true
+	}
+	// match: (Move [2] {t} dst src mem)
+	// cond: t.Alignment()%2 == 0
+	// result: (MOVHstore dst (MOVHload src mem) mem)
+	for {
+		if auxIntToInt64(v.AuxInt) != 2 {
+			break
+		}
+		t := auxToType(v.Aux)
+		dst := v_0
+		src := v_1
+		mem := v_2
+		if !(t.Alignment()%2 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVHstore)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVHload, typ.Int16)
+		v0.AddArg2(src, mem)
+		v.AddArg3(dst, v0, mem)
+		return true
+	}
+	// match: (Move [2] dst src mem)
+	// result: (MOVBstore [1] dst (MOVBload [1] src mem) (MOVBstore dst (MOVBload src mem) mem))
+	for {
+		if auxIntToInt64(v.AuxInt) != 2 {
+			break
+		}
+		dst := v_0
+		src := v_1
+		mem := v_2
+		v.reset(OpSW64MOVBstore)
+		v.AuxInt = int32ToAuxInt(1)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVBload, typ.Int8)
+		v0.AuxInt = int32ToAuxInt(1)
+		v0.AddArg2(src, mem)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVBstore, types.TypeMem)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVBload, typ.Int8)
+		v2.AddArg2(src, mem)
+		v1.AddArg3(dst, v2, mem)
+		v.AddArg3(dst, v0, v1)
+		return true
+	}
+	// match: (Move [4] {t} dst src mem)
+	// cond: t.Alignment()%4 == 0
+	// result: (MOVWstore dst (MOVWload src mem) mem)
+	for {
+		if auxIntToInt64(v.AuxInt) != 4 {
+			break
+		}
+		t := auxToType(v.Aux)
+		dst := v_0
+		src := v_1
+		mem := v_2
+		if !(t.Alignment()%4 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVWstore)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVWload, typ.Int32)
+		v0.AddArg2(src, mem)
+		v.AddArg3(dst, v0, mem)
+		return true
+	}
+	// match: (Move [4] {t} dst src mem)
+	// cond: t.Alignment()%2 == 0
+	// result: (MOVHstore [2] dst (MOVHload [2] src mem) (MOVHstore dst (MOVHload src mem) mem))
+	for {
+		if auxIntToInt64(v.AuxInt) != 4 {
+			break
+		}
+		t := auxToType(v.Aux)
+		dst := v_0
+		src := v_1
+		mem := v_2
+		if !(t.Alignment()%2 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVHstore)
+		v.AuxInt = int32ToAuxInt(2)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVHload, typ.Int16)
+		v0.AuxInt = int32ToAuxInt(2)
+		v0.AddArg2(src, mem)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVHstore, types.TypeMem)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVHload, typ.Int16)
+		v2.AddArg2(src, mem)
+		v1.AddArg3(dst, v2, mem)
+		v.AddArg3(dst, v0, v1)
+		return true
+	}
+	// match: (Move [4] dst src mem)
+	// result: (MOVBstore [3] dst (MOVBload [3] src mem) (MOVBstore [2] dst (MOVBload [2] src mem) (MOVBstore [1] dst (MOVBload [1] src mem) (MOVBstore dst (MOVBload src mem) mem))))
+	for {
+		if auxIntToInt64(v.AuxInt) != 4 {
+			break
+		}
+		dst := v_0
+		src := v_1
+		mem := v_2
+		v.reset(OpSW64MOVBstore)
+		v.AuxInt = int32ToAuxInt(3)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVBload, typ.Int8)
+		v0.AuxInt = int32ToAuxInt(3)
+		v0.AddArg2(src, mem)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVBstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(2)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVBload, typ.Int8)
+		v2.AuxInt = int32ToAuxInt(2)
+		v2.AddArg2(src, mem)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVBstore, types.TypeMem)
+		v3.AuxInt = int32ToAuxInt(1)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVBload, typ.Int8)
+		v4.AuxInt = int32ToAuxInt(1)
+		v4.AddArg2(src, mem)
+		v5 := b.NewValue0(v.Pos, OpSW64MOVBstore, types.TypeMem)
+		v6 := b.NewValue0(v.Pos, OpSW64MOVBload, typ.Int8)
+		v6.AddArg2(src, mem)
+		v5.AddArg3(dst, v6, mem)
+		v3.AddArg3(dst, v4, v5)
+		v1.AddArg3(dst, v2, v3)
+		v.AddArg3(dst, v0, v1)
+		return true
+	}
+	// match: (Move [8] {t} dst src mem)
+	// cond: t.Alignment()%8 == 0
+	// result: (MOVVstore dst (MOVVload src mem) mem)
+	for {
+		if auxIntToInt64(v.AuxInt) != 8 {
+			break
+		}
+		t := auxToType(v.Aux)
+		dst := v_0
+		src := v_1
+		mem := v_2
+		if !(t.Alignment()%8 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVVstore)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVload, typ.UInt64)
+		v0.AddArg2(src, mem)
+		v.AddArg3(dst, v0, mem)
+		return true
+	}
+	// match: (Move [8] {t} dst src mem)
+	// cond: t.Alignment()%4 == 0
+	// result: (MOVWstore [4] dst (MOVWload [4] src mem) (MOVWstore dst (MOVWload src mem) mem))
+	for {
+		if auxIntToInt64(v.AuxInt) != 8 {
+			break
+		}
+		t := auxToType(v.Aux)
+		dst := v_0
+		src := v_1
+		mem := v_2
+		if !(t.Alignment()%4 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVWstore)
+		v.AuxInt = int32ToAuxInt(4)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVWload, typ.Int32)
+		v0.AuxInt = int32ToAuxInt(4)
+		v0.AddArg2(src, mem)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVWstore, types.TypeMem)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVWload, typ.Int32)
+		v2.AddArg2(src, mem)
+		v1.AddArg3(dst, v2, mem)
+		v.AddArg3(dst, v0, v1)
+		return true
+	}
+	// match: (Move [8] {t} dst src mem)
+	// cond: t.Alignment()%2 == 0
+	// result: (MOVHstore [6] dst (MOVHload [6] src mem) (MOVHstore [4] dst (MOVHload [4] src mem) (MOVHstore [2] dst (MOVHload [2] src mem) (MOVHstore dst (MOVHload src mem) mem))))
+	for {
+		if auxIntToInt64(v.AuxInt) != 8 {
+			break
+		}
+		t := auxToType(v.Aux)
+		dst := v_0
+		src := v_1
+		mem := v_2
+		if !(t.Alignment()%2 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVHstore)
+		v.AuxInt = int32ToAuxInt(6)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVHload, typ.Int16)
+		v0.AuxInt = int32ToAuxInt(6)
+		v0.AddArg2(src, mem)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVHstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(4)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVHload, typ.Int16)
+		v2.AuxInt = int32ToAuxInt(4)
+		v2.AddArg2(src, mem)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVHstore, types.TypeMem)
+		v3.AuxInt = int32ToAuxInt(2)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVHload, typ.Int16)
+		v4.AuxInt = int32ToAuxInt(2)
+		v4.AddArg2(src, mem)
+		v5 := b.NewValue0(v.Pos, OpSW64MOVHstore, types.TypeMem)
+		v6 := b.NewValue0(v.Pos, OpSW64MOVHload, typ.Int16)
+		v6.AddArg2(src, mem)
+		v5.AddArg3(dst, v6, mem)
+		v3.AddArg3(dst, v4, v5)
+		v1.AddArg3(dst, v2, v3)
+		v.AddArg3(dst, v0, v1)
+		return true
+	}
+	// match: (Move [3] dst src mem)
+	// result: (MOVBstore [2] dst (MOVBload [2] src mem) (MOVBstore [1] dst (MOVBload [1] src mem) (MOVBstore dst (MOVBload src mem) mem)))
+	for {
+		if auxIntToInt64(v.AuxInt) != 3 {
+			break
+		}
+		dst := v_0
+		src := v_1
+		mem := v_2
+		v.reset(OpSW64MOVBstore)
+		v.AuxInt = int32ToAuxInt(2)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVBload, typ.Int8)
+		v0.AuxInt = int32ToAuxInt(2)
+		v0.AddArg2(src, mem)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVBstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(1)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVBload, typ.Int8)
+		v2.AuxInt = int32ToAuxInt(1)
+		v2.AddArg2(src, mem)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVBstore, types.TypeMem)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVBload, typ.Int8)
+		v4.AddArg2(src, mem)
+		v3.AddArg3(dst, v4, mem)
+		v1.AddArg3(dst, v2, v3)
+		v.AddArg3(dst, v0, v1)
+		return true
+	}
+	// match: (Move [6] {t} dst src mem)
+	// cond: t.Alignment()%2 == 0
+	// result: (MOVHstore [4] dst (MOVHload [4] src mem) (MOVHstore [2] dst (MOVHload [2] src mem) (MOVHstore dst (MOVHload src mem) mem)))
+	for {
+		if auxIntToInt64(v.AuxInt) != 6 {
+			break
+		}
+		t := auxToType(v.Aux)
+		dst := v_0
+		src := v_1
+		mem := v_2
+		if !(t.Alignment()%2 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVHstore)
+		v.AuxInt = int32ToAuxInt(4)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVHload, typ.Int16)
+		v0.AuxInt = int32ToAuxInt(4)
+		v0.AddArg2(src, mem)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVHstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(2)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVHload, typ.Int16)
+		v2.AuxInt = int32ToAuxInt(2)
+		v2.AddArg2(src, mem)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVHstore, types.TypeMem)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVHload, typ.Int16)
+		v4.AddArg2(src, mem)
+		v3.AddArg3(dst, v4, mem)
+		v1.AddArg3(dst, v2, v3)
+		v.AddArg3(dst, v0, v1)
+		return true
+	}
+	// match: (Move [12] {t} dst src mem)
+	// cond: t.Alignment()%4 == 0
+	// result: (MOVWstore [8] dst (MOVWload [8] src mem) (MOVWstore [4] dst (MOVWload [4] src mem) (MOVWstore dst (MOVWload src mem) mem)))
+	for {
+		if auxIntToInt64(v.AuxInt) != 12 {
+			break
+		}
+		t := auxToType(v.Aux)
+		dst := v_0
+		src := v_1
+		mem := v_2
+		if !(t.Alignment()%4 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVWstore)
+		v.AuxInt = int32ToAuxInt(8)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVWload, typ.Int32)
+		v0.AuxInt = int32ToAuxInt(8)
+		v0.AddArg2(src, mem)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVWstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(4)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVWload, typ.Int32)
+		v2.AuxInt = int32ToAuxInt(4)
+		v2.AddArg2(src, mem)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVWstore, types.TypeMem)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVWload, typ.Int32)
+		v4.AddArg2(src, mem)
+		v3.AddArg3(dst, v4, mem)
+		v1.AddArg3(dst, v2, v3)
+		v.AddArg3(dst, v0, v1)
+		return true
+	}
+	// match: (Move [16] {t} dst src mem)
+	// cond: t.Alignment()%8 == 0
+	// result: (MOVVstore [8] dst (MOVVload [8] src mem) (MOVVstore dst (MOVVload src mem) mem))
+	for {
+		if auxIntToInt64(v.AuxInt) != 16 {
+			break
+		}
+		t := auxToType(v.Aux)
+		dst := v_0
+		src := v_1
+		mem := v_2
+		if !(t.Alignment()%8 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVVstore)
+		v.AuxInt = int32ToAuxInt(8)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVload, typ.UInt64)
+		v0.AuxInt = int32ToAuxInt(8)
+		v0.AddArg2(src, mem)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVVstore, types.TypeMem)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVVload, typ.UInt64)
+		v2.AddArg2(src, mem)
+		v1.AddArg3(dst, v2, mem)
+		v.AddArg3(dst, v0, v1)
+		return true
+	}
+	// match: (Move [24] {t} dst src mem)
+	// cond: t.Alignment()%8 == 0
+	// result: (MOVVstore [16] dst (MOVVload [16] src mem) (MOVVstore [8] dst (MOVVload [8] src mem) (MOVVstore dst (MOVVload src mem) mem)))
+	for {
+		if auxIntToInt64(v.AuxInt) != 24 {
+			break
+		}
+		t := auxToType(v.Aux)
+		dst := v_0
+		src := v_1
+		mem := v_2
+		if !(t.Alignment()%8 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVVstore)
+		v.AuxInt = int32ToAuxInt(16)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVload, typ.UInt64)
+		v0.AuxInt = int32ToAuxInt(16)
+		v0.AddArg2(src, mem)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVVstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(8)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVVload, typ.UInt64)
+		v2.AuxInt = int32ToAuxInt(8)
+		v2.AddArg2(src, mem)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVstore, types.TypeMem)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVVload, typ.UInt64)
+		v4.AddArg2(src, mem)
+		v3.AddArg3(dst, v4, mem)
+		v1.AddArg3(dst, v2, v3)
+		v.AddArg3(dst, v0, v1)
+		return true
+	}
+	// match: (Move [s] {t} dst src mem)
+	// cond: s > 24 && logLargeCopy(v, s) || t.Alignment()%8 != 0
+	// result: (LoweredMove [t.Alignment()] dst src (ADDVconst <src.Type> src [s-moveSize(t.Alignment(), config)]) mem)
+	for {
+		s := auxIntToInt64(v.AuxInt)
+		t := auxToType(v.Aux)
+		dst := v_0
+		src := v_1
+		mem := v_2
+		if !(s > 24 && logLargeCopy(v, s) || t.Alignment()%8 != 0) {
+			break
+		}
+		v.reset(OpSW64LoweredMove)
+		v.AuxInt = int64ToAuxInt(t.Alignment())
+		v0 := b.NewValue0(v.Pos, OpSW64ADDVconst, src.Type)
+		v0.AuxInt = int64ToAuxInt(s - moveSize(t.Alignment(), config))
+		v0.AddArg(src)
+		v.AddArg4(dst, src, v0, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpNeq16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Neq16 x y)
+	// result: (Not (CMPEQ (ZeroExt16to64 x) (ZeroExt16to64 y)))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpNot)
+		v0 := b.NewValue0(v.Pos, OpSW64CMPEQ, typ.Bool)
+		v1 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v1.AddArg(x)
+		v2 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v2.AddArg(y)
+		v0.AddArg2(v1, v2)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpNeq32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Neq32 x y)
+	// result: (Not (CMPEQ (ZeroExt32to64 x) (ZeroExt32to64 y)))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpNot)
+		v0 := b.NewValue0(v.Pos, OpSW64CMPEQ, typ.Bool)
+		v1 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v1.AddArg(x)
+		v2 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v2.AddArg(y)
+		v0.AddArg2(v1, v2)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpNeq32F(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Neq32F x y)
+	// result: (FNotEqual (FCMPEQ x y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64FNotEqual)
+		v0 := b.NewValue0(v.Pos, OpSW64FCMPEQ, typ.Float64)
+		v0.AddArg2(x, y)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpNeq64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Neq64 x y)
+	// result: (Not (CMPEQ x y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpNot)
+		v0 := b.NewValue0(v.Pos, OpSW64CMPEQ, typ.Bool)
+		v0.AddArg2(x, y)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpNeq64F(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Neq64F x y)
+	// result: (FNotEqual (FCMPEQ x y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpSW64FNotEqual)
+		v0 := b.NewValue0(v.Pos, OpSW64FCMPEQ, typ.Float64)
+		v0.AddArg2(x, y)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpNeq8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Neq8 x y)
+	// result: (Not (CMPEQ (ZeroExt8to64 x) (ZeroExt8to64 y)))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpNot)
+		v0 := b.NewValue0(v.Pos, OpSW64CMPEQ, typ.Bool)
+		v1 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v1.AddArg(x)
+		v2 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v2.AddArg(y)
+		v0.AddArg2(v1, v2)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpNeqPtr(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (NeqPtr x y)
+	// result: (Not (CMPEQ x y))
+	for {
+		x := v_0
+		y := v_1
+		v.reset(OpNot)
+		v0 := b.NewValue0(v.Pos, OpSW64CMPEQ, typ.Bool)
+		v0.AddArg2(x, y)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpNot(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (Not x)
+	// result: (XORconst x [1])
+	for {
+		x := v_0
+		v.reset(OpSW64XORconst)
+		v.AuxInt = int64ToAuxInt(1)
+		v.AddArg(x)
+		return true
+	}
+}
+func rewriteValueSW64_OpOffPtr(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (OffPtr [off] ptr:(SP))
+	// cond: is32Bit(off)
+	// result: (SYMADDR [int32(off)] ptr)
+	for {
+		off := auxIntToInt64(v.AuxInt)
+		ptr := v_0
+		if ptr.Op != OpSP || !(is32Bit(off)) {
+			break
+		}
+		v.reset(OpSW64SYMADDR)
+		v.AuxInt = int32ToAuxInt(int32(off))
+		v.AddArg(ptr)
+		return true
+	}
+	// match: (OffPtr [off] ptr)
+	// result: (ADDVconst [off] ptr)
+	for {
+		off := auxIntToInt64(v.AuxInt)
+		ptr := v_0
+		v.reset(OpSW64ADDVconst)
+		v.AuxInt = int64ToAuxInt(off)
+		v.AddArg(ptr)
+		return true
+	}
+}
+func rewriteValueSW64_OpPanicBounds(v *Value) bool {
+	v_2 := v.Args[2]
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (PanicBounds [kind] x y mem)
+	// cond: boundsABI(kind) == 0
+	// result: (LoweredPanicBoundsA [kind] x y mem)
+	for {
+		kind := auxIntToInt64(v.AuxInt)
+		x := v_0
+		y := v_1
+		mem := v_2
+		if !(boundsABI(kind) == 0) {
+			break
+		}
+		v.reset(OpSW64LoweredPanicBoundsA)
+		v.AuxInt = int64ToAuxInt(kind)
+		v.AddArg3(x, y, mem)
+		return true
+	}
+	// match: (PanicBounds [kind] x y mem)
+	// cond: boundsABI(kind) == 1
+	// result: (LoweredPanicBoundsB [kind] x y mem)
+	for {
+		kind := auxIntToInt64(v.AuxInt)
+		x := v_0
+		y := v_1
+		mem := v_2
+		if !(boundsABI(kind) == 1) {
+			break
+		}
+		v.reset(OpSW64LoweredPanicBoundsB)
+		v.AuxInt = int64ToAuxInt(kind)
+		v.AddArg3(x, y, mem)
+		return true
+	}
+	// match: (PanicBounds [kind] x y mem)
+	// cond: boundsABI(kind) == 2
+	// result: (LoweredPanicBoundsC [kind] x y mem)
+	for {
+		kind := auxIntToInt64(v.AuxInt)
+		x := v_0
+		y := v_1
+		mem := v_2
+		if !(boundsABI(kind) == 2) {
+			break
+		}
+		v.reset(OpSW64LoweredPanicBoundsC)
+		v.AuxInt = int64ToAuxInt(kind)
+		v.AddArg3(x, y, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpPopCount16(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (PopCount16 x)
+	// result: (CTPOP (ZeroExt16to64 x))
+	for {
+		x := v_0
+		v.reset(OpSW64CTPOP)
+		v0 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpPopCount32(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (PopCount32 x)
+	// result: (CTPOP (ZeroExt32to64 x))
+	for {
+		x := v_0
+		v.reset(OpSW64CTPOP)
+		v0 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpPopCount8(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (PopCount8 x)
+	// result: (CTPOP (ZeroExt8to64 x))
+	for {
+		x := v_0
+		v.reset(OpSW64CTPOP)
+		v0 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpRotateLeft16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (RotateLeft16 <t> x (MOVVconst [c]))
+	// result: (Or16 (Lsh16x64 <t> x (MOVVconst [c&15])) (Rsh16Ux64 <t> x (MOVVconst [-c&15])))
+	for {
+		t := v.Type
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		v.reset(OpOr16)
+		v0 := b.NewValue0(v.Pos, OpLsh16x64, t)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v1.AuxInt = int64ToAuxInt(c & 15)
+		v0.AddArg2(x, v1)
+		v2 := b.NewValue0(v.Pos, OpRsh16Ux64, t)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(-c & 15)
+		v2.AddArg2(x, v3)
+		v.AddArg2(v0, v2)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpRotateLeft32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (RotateLeft32 <t> x (MOVVconst [c]))
+	// result: (Or32 (Lsh32x64 <t> x (MOVVconst [c&31])) (Rsh32Ux64 <t> x (MOVVconst [-c&31])))
+	for {
+		t := v.Type
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		v.reset(OpOr32)
+		v0 := b.NewValue0(v.Pos, OpLsh32x64, t)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v1.AuxInt = int64ToAuxInt(c & 31)
+		v0.AddArg2(x, v1)
+		v2 := b.NewValue0(v.Pos, OpRsh32Ux64, t)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(-c & 31)
+		v2.AddArg2(x, v3)
+		v.AddArg2(v0, v2)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpRotateLeft64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (RotateLeft64 <t> x (MOVVconst [c]))
+	// result: (Or64 (Lsh64x64 <t> x (MOVVconst [c&63])) (Rsh64Ux64 <t> x (MOVVconst [-c&63])))
+	for {
+		t := v.Type
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		v.reset(OpOr64)
+		v0 := b.NewValue0(v.Pos, OpLsh64x64, t)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v1.AuxInt = int64ToAuxInt(c & 63)
+		v0.AddArg2(x, v1)
+		v2 := b.NewValue0(v.Pos, OpRsh64Ux64, t)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(-c & 63)
+		v2.AddArg2(x, v3)
+		v.AddArg2(v0, v2)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpRotateLeft8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (RotateLeft8 <t> x (MOVVconst [c]))
+	// result: (Or8 (Lsh8x64 <t> x (MOVVconst [c&7])) (Rsh8Ux64 <t> x (MOVVconst [-c&7])))
+	for {
+		t := v.Type
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		v.reset(OpOr8)
+		v0 := b.NewValue0(v.Pos, OpLsh8x64, t)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v1.AuxInt = int64ToAuxInt(c & 7)
+		v0.AddArg2(x, v1)
+		v2 := b.NewValue0(v.Pos, OpRsh8Ux64, t)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(-c & 7)
+		v2.AddArg2(x, v3)
+		v.AddArg2(v0, v2)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpRsh16Ux16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh16Ux16 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt16to64 x) (ZeroExt16to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v5 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v5.AddArg(x)
+		v4.AddArg2(v5, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh16Ux32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh16Ux32 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt16to64 x) (ZeroExt32to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v5 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v5.AddArg(x)
+		v4.AddArg2(v5, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh16Ux64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh16Ux64 x (Const64 [c]))
+	// cond: uint64(c) < 16
+	// result: (SRLconst (ZeroExt16to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 16) {
+			break
+		}
+		v.reset(OpSW64SRLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh16Ux64 x (MOVVconst [c]))
+	// cond: uint64(c) < 16
+	// result: (SRLconst (ZeroExt16to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 16) {
+			break
+		}
+		v.reset(OpSW64SRLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh16Ux64 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt16to64 x) y))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v2.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(y, v2)
+		v0.AddArg(v1)
+		v3 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v4 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v4.AddArg(x)
+		v3.AddArg2(v4, y)
+		v.AddArg2(v0, v3)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh16Ux8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh16Ux8 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt8to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt16to64 x) (ZeroExt8to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v5 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v5.AddArg(x)
+		v4.AddArg2(v5, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh16x16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh16x16 <t> x y)
+	// result: (SRA (SignExt16to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt16to64 y))) (ZeroExt16to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v2 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v3 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v4.AuxInt = int64ToAuxInt(63)
+		v5 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v5.AddArg(y)
+		v3.AddArg2(v4, v5)
+		v2.AddArg(v3)
+		v1.AddArg2(v2, v5)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh16x32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh16x32 <t> x y)
+	// result: (SRA (SignExt16to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt32to64 y))) (ZeroExt32to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v2 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v3 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v4.AuxInt = int64ToAuxInt(63)
+		v5 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v5.AddArg(y)
+		v3.AddArg2(v4, v5)
+		v2.AddArg(v3)
+		v1.AddArg2(v2, v5)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh16x64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh16x64 x (Const64 [c]))
+	// cond: uint64(c) < 16
+	// result: (SRAconst (SignExt16to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 16) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh16x64 x (Const64 [c]))
+	// cond: uint64(c) >= 16
+	// result: (SRAconst (SignExt16to64 x) [63])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) >= 16) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(63)
+		v0 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh16x64 x (MOVVconst [c]))
+	// cond: uint64(c) >= 16
+	// result: (SRAconst (SignExt16to64 x) [63])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) >= 16) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(63)
+		v0 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh16x64 x (MOVVconst [c]))
+	// cond: uint64(c) < 16
+	// result: (SRAconst (SignExt16to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 16) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh16x64 <t> x y)
+	// result: (SRA (SignExt16to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) y)) y))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v2 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v3 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v4.AuxInt = int64ToAuxInt(63)
+		v3.AddArg2(v4, y)
+		v2.AddArg(v3)
+		v1.AddArg2(v2, y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh16x8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh16x8 <t> x y)
+	// result: (SRA (SignExt16to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt8to64 y))) (ZeroExt8to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSignExt16to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v2 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v3 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v4.AuxInt = int64ToAuxInt(63)
+		v5 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v5.AddArg(y)
+		v3.AddArg2(v4, v5)
+		v2.AddArg(v3)
+		v1.AddArg2(v2, v5)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh32Ux16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh32Ux16 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt32to64 x) (ZeroExt16to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v5 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v5.AddArg(x)
+		v4.AddArg2(v5, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh32Ux32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh32Ux32 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt32to64 x) (ZeroExt32to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v5 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v5.AddArg(x)
+		v4.AddArg2(v5, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh32Ux64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh32Ux64 x (Const64 [c]))
+	// cond: uint64(c) < 32
+	// result: (SRLconst (ZeroExt32to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 32) {
+			break
+		}
+		v.reset(OpSW64SRLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh32Ux64 x (MOVVconst [c]))
+	// cond: uint64(c) < 32
+	// result: (SRLconst (ZeroExt32to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 32) {
+			break
+		}
+		v.reset(OpSW64SRLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh32Ux64 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt32to64 x) y))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v2.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(y, v2)
+		v0.AddArg(v1)
+		v3 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v4 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v4.AddArg(x)
+		v3.AddArg2(v4, y)
+		v.AddArg2(v0, v3)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh32Ux8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh32Ux8 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt8to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt32to64 x) (ZeroExt8to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v5 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v5.AddArg(x)
+		v4.AddArg2(v5, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh32x16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh32x16 <t> x y)
+	// result: (SRA (SignExt32to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt16to64 y))) (ZeroExt16to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v2 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v3 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v4.AuxInt = int64ToAuxInt(63)
+		v5 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v5.AddArg(y)
+		v3.AddArg2(v4, v5)
+		v2.AddArg(v3)
+		v1.AddArg2(v2, v5)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh32x32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh32x32 <t> x y)
+	// result: (SRA (SignExt32to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt32to64 y))) (ZeroExt32to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v2 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v3 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v4.AuxInt = int64ToAuxInt(63)
+		v5 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v5.AddArg(y)
+		v3.AddArg2(v4, v5)
+		v2.AddArg(v3)
+		v1.AddArg2(v2, v5)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh32x64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh32x64 x (Const64 [c]))
+	// cond: uint64(c) < 32
+	// result: (SRAconst (SignExt32to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 32) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh32x64 x (Const64 [c]))
+	// cond: uint64(c) >= 32
+	// result: (SRAconst (SignExt32to64 x) [63])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) >= 32) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(63)
+		v0 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh32x64 x (MOVVconst [c]))
+	// cond: uint64(c) >= 32
+	// result: (SRAconst (SignExt32to64 x) [63])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) >= 32) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(63)
+		v0 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh32x64 x (MOVVconst [c]))
+	// cond: uint64(c) < 32
+	// result: (SRAconst (SignExt32to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 32) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh32x64 <t> x y)
+	// result: (SRA (SignExt32to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) y)) y))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v2 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v3 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v4.AuxInt = int64ToAuxInt(63)
+		v3.AddArg2(v4, y)
+		v2.AddArg(v3)
+		v1.AddArg2(v2, y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh32x8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh32x8 <t> x y)
+	// result: (SRA (SignExt32to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt8to64 y))) (ZeroExt8to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSignExt32to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v2 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v3 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v4.AuxInt = int64ToAuxInt(63)
+		v5 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v5.AddArg(y)
+		v3.AddArg2(v4, v5)
+		v2.AddArg(v3)
+		v1.AddArg2(v2, v5)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh64Ux16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh64Ux16 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> x (ZeroExt16to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v4.AddArg2(x, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh64Ux32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh64Ux32 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> x (ZeroExt32to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v4.AddArg2(x, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh64Ux64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh64Ux64 x (Const64 [c]))
+	// cond: uint64(c) < 64
+	// result: (SRLconst x [c])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 64) {
+			break
+		}
+		v.reset(OpSW64SRLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v.AddArg(x)
+		return true
+	}
+	// match: (Rsh64Ux64 x (MOVVconst [c]))
+	// cond: uint64(c) < 64
+	// result: (SRLconst x [c])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 64) {
+			break
+		}
+		v.reset(OpSW64SRLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v.AddArg(x)
+		return true
+	}
+	// match: (Rsh64Ux64 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SRL <t> x y))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v2.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(y, v2)
+		v0.AddArg(v1)
+		v3 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v3.AddArg2(x, y)
+		v.AddArg2(v0, v3)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh64Ux8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh64Ux8 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt8to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> x (ZeroExt8to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v4.AddArg2(x, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh64x16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh64x16 <t> x y)
+	// result: (SRA x (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt16to64 y))) (ZeroExt16to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v1 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v2 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(63)
+		v4 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v4.AddArg(y)
+		v2.AddArg2(v3, v4)
+		v1.AddArg(v2)
+		v0.AddArg2(v1, v4)
+		v.AddArg2(x, v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh64x32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh64x32 <t> x y)
+	// result: (SRA x (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt32to64 y))) (ZeroExt32to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v1 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v2 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(63)
+		v4 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v4.AddArg(y)
+		v2.AddArg2(v3, v4)
+		v1.AddArg(v2)
+		v0.AddArg2(v1, v4)
+		v.AddArg2(x, v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh64x64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh64x64 x (Const64 [c]))
+	// cond: uint64(c) < 64
+	// result: (SRAconst x [c])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 64) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v.AddArg(x)
+		return true
+	}
+	// match: (Rsh64x64 x (Const64 [c]))
+	// cond: uint64(c) >= 64
+	// result: (SRAconst x [63])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) >= 64) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(63)
+		v.AddArg(x)
+		return true
+	}
+	// match: (Rsh64x64 x (MOVVconst [c]))
+	// cond: uint64(c) >= 64
+	// result: (SRAconst x [63])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) >= 64) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(63)
+		v.AddArg(x)
+		return true
+	}
+	// match: (Rsh64x64 x (MOVVconst [c]))
+	// cond: uint64(c) < 64
+	// result: (SRAconst x [c])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 64) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v.AddArg(x)
+		return true
+	}
+	// match: (Rsh64x64 <t> x y)
+	// result: (SRA x (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) y)) y))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v1 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v2 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(63)
+		v2.AddArg2(v3, y)
+		v1.AddArg(v2)
+		v0.AddArg2(v1, y)
+		v.AddArg2(x, v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh64x8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh64x8 <t> x y)
+	// result: (SRA x (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt8to64 y))) (ZeroExt8to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v1 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v2 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(63)
+		v4 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v4.AddArg(y)
+		v2.AddArg2(v3, v4)
+		v1.AddArg(v2)
+		v0.AddArg2(v1, v4)
+		v.AddArg2(x, v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh8Ux16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh8Ux16 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt16to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt8to64 x) (ZeroExt16to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v5 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v5.AddArg(x)
+		v4.AddArg2(v5, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh8Ux32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh8Ux32 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt32to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt8to64 x) (ZeroExt32to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v5 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v5.AddArg(x)
+		v4.AddArg2(v5, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh8Ux64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh8Ux64 x (Const64 [c]))
+	// cond: uint64(c) < 8
+	// result: (SRLconst (ZeroExt8to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 8) {
+			break
+		}
+		v.reset(OpSW64SRLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh8Ux64 x (MOVVconst [c]))
+	// cond: uint64(c) < 8
+	// result: (SRLconst (ZeroExt8to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 8) {
+			break
+		}
+		v.reset(OpSW64SRLconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh8Ux64 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT y (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt8to64 x) y))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v2.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(y, v2)
+		v0.AddArg(v1)
+		v3 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v4 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v4.AddArg(x)
+		v3.AddArg2(v4, y)
+		v.AddArg2(v0, v3)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh8Ux8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh8Ux8 <t> x y)
+	// result: (AND (NEGV <t> (CMPULT (ZeroExt8to64 y) (MOVVconst <typ.UInt64> [64]))) (SRL <t> (ZeroExt8to64 x) (ZeroExt8to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64AND)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v1 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v2 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v2.AddArg(y)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v3.AuxInt = int64ToAuxInt(64)
+		v1.AddArg2(v2, v3)
+		v0.AddArg(v1)
+		v4 := b.NewValue0(v.Pos, OpSW64SRL, t)
+		v5 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v5.AddArg(x)
+		v4.AddArg2(v5, v2)
+		v.AddArg2(v0, v4)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh8x16(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh8x16 <t> x y)
+	// result: (SRA (SignExt8to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt16to64 y))) (ZeroExt16to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v2 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v3 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v4.AuxInt = int64ToAuxInt(63)
+		v5 := b.NewValue0(v.Pos, OpZeroExt16to64, typ.UInt64)
+		v5.AddArg(y)
+		v3.AddArg2(v4, v5)
+		v2.AddArg(v3)
+		v1.AddArg2(v2, v5)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh8x32(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh8x32 <t> x y)
+	// result: (SRA (SignExt8to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt32to64 y))) (ZeroExt32to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v2 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v3 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v4.AuxInt = int64ToAuxInt(63)
+		v5 := b.NewValue0(v.Pos, OpZeroExt32to64, typ.UInt64)
+		v5.AddArg(y)
+		v3.AddArg2(v4, v5)
+		v2.AddArg(v3)
+		v1.AddArg2(v2, v5)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh8x64(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh8x64 x (Const64 [c]))
+	// cond: uint64(c) < 8
+	// result: (SRAconst (SignExt8to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 8) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh8x64 x (Const64 [c]))
+	// cond: uint64(c) >= 8
+	// result: (SRAconst (SignExt8to64 x) [63])
+	for {
+		x := v_0
+		if v_1.Op != OpConst64 {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) >= 8) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(63)
+		v0 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh8x64 x (MOVVconst [c]))
+	// cond: uint64(c) >= 8
+	// result: (SRAconst (SignExt8to64 x) [63])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) >= 8) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(63)
+		v0 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh8x64 x (MOVVconst [c]))
+	// cond: uint64(c) < 8
+	// result: (SRAconst (SignExt8to64 x) [c])
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(uint64(c) < 8) {
+			break
+		}
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v0 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (Rsh8x64 <t> x y)
+	// result: (SRA (SignExt8to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) y)) y))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v2 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v3 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v4.AuxInt = int64ToAuxInt(63)
+		v3.AddArg2(v4, y)
+		v2.AddArg(v3)
+		v1.AddArg2(v2, y)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpRsh8x8(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	typ := &b.Func.Config.Types
+	// match: (Rsh8x8 <t> x y)
+	// result: (SRA (SignExt8to64 x) (BIS <t> (NEGV <t> (CMPULT (MOVVconst <typ.UInt64> [63]) (ZeroExt8to64 y))) (ZeroExt8to64 y)))
+	for {
+		t := v.Type
+		x := v_0
+		y := v_1
+		v.reset(OpSW64SRA)
+		v0 := b.NewValue0(v.Pos, OpSignExt8to64, typ.Int64)
+		v0.AddArg(x)
+		v1 := b.NewValue0(v.Pos, OpSW64BIS, t)
+		v2 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v3 := b.NewValue0(v.Pos, OpSW64CMPULT, typ.Bool)
+		v4 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v4.AuxInt = int64ToAuxInt(63)
+		v5 := b.NewValue0(v.Pos, OpZeroExt8to64, typ.UInt64)
+		v5.AddArg(y)
+		v3.AddArg2(v4, v5)
+		v2.AddArg(v3)
+		v1.AddArg2(v2, v5)
+		v.AddArg2(v0, v1)
+		return true
+	}
+}
+func rewriteValueSW64_OpSW64ADDV(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (ADDV x (MOVVconst <t> [c]))
+	// cond: is32Bit(c) && !t.IsPtr()
+	// result: (ADDVconst [c] x)
+	for {
+		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
+			x := v_0
+			if v_1.Op != OpSW64MOVVconst {
+				continue
+			}
+			t := v_1.Type
+			c := auxIntToInt64(v_1.AuxInt)
+			if !(is32Bit(c) && !t.IsPtr()) {
+				continue
+			}
+			v.reset(OpSW64ADDVconst)
+			v.AuxInt = int64ToAuxInt(c)
+			v.AddArg(x)
+			return true
+		}
+		break
+	}
+	// match: (ADDV x (NEGV y))
+	// result: (SUBV x y)
+	for {
+		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
+			x := v_0
+			if v_1.Op != OpSW64NEGV {
+				continue
+			}
+			y := v_1.Args[0]
+			v.reset(OpSW64SUBV)
+			v.AddArg2(x, y)
+			return true
+		}
+		break
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64ADDVconst(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (ADDVconst [0] x)
+	// result: x
+	for {
+		if auxIntToInt64(v.AuxInt) != 0 {
+			break
+		}
+		x := v_0
+		v.copyOf(x)
+		return true
+	}
+	// match: (ADDVconst [c] (MOVVconst [d]))
+	// result: (MOVVconst [c+d])
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		d := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(c + d)
+		return true
+	}
+	// match: (ADDVconst [c] (ADDVconst [d] x))
+	// cond: is32Bit(c+d)
+	// result: (ADDVconst [c+d] x)
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		d := auxIntToInt64(v_0.AuxInt)
+		x := v_0.Args[0]
+		if !(is32Bit(c + d)) {
+			break
+		}
+		v.reset(OpSW64ADDVconst)
+		v.AuxInt = int64ToAuxInt(c + d)
+		v.AddArg(x)
+		return true
+	}
+	// match: (ADDVconst [c] (SUBVconst [d] x))
+	// cond: is32Bit(c-d)
+	// result: (ADDVconst [c-d] x)
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64SUBVconst {
+			break
+		}
+		d := auxIntToInt64(v_0.AuxInt)
+		x := v_0.Args[0]
+		if !(is32Bit(c - d)) {
+			break
+		}
+		v.reset(OpSW64ADDVconst)
+		v.AuxInt = int64ToAuxInt(c - d)
+		v.AddArg(x)
+		return true
+	}
+	// match: (ADDVconst [off1] (SYMADDR [off2] {sym} ptr))
+	// cond: is32Bit(off1+int64(off2))
+	// result: (SYMADDR [int32(off1)+off2] {sym} ptr)
+	for {
+		off1 := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		if !(is32Bit(off1 + int64(off2))) {
+			break
+		}
+		v.reset(OpSW64SYMADDR)
+		v.AuxInt = int32ToAuxInt(int32(off1) + off2)
+		v.Aux = symToAux(sym)
+		v.AddArg(ptr)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64ADDWconst(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (ADDWconst (MOVVconst [c]) [0])
+	// result: (MOVVconst [int64(int32(c))])
+	for {
+		if auxIntToInt32(v.AuxInt) != 0 || v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(int32(c)))
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64AND(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (AND x (MOVVconst [c]))
+	// cond: is32Bit(c)
+	// result: (ANDconst [c] x)
+	for {
+		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
+			x := v_0
+			if v_1.Op != OpSW64MOVVconst {
+				continue
+			}
+			c := auxIntToInt64(v_1.AuxInt)
+			if !(is32Bit(c)) {
+				continue
+			}
+			v.reset(OpSW64ANDconst)
+			v.AuxInt = int64ToAuxInt(c)
+			v.AddArg(x)
+			return true
+		}
+		break
+	}
+	// match: (AND x x)
+	// result: x
+	for {
+		x := v_0
+		if x != v_1 {
+			break
+		}
+		v.copyOf(x)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64ANDconst(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (ANDconst (MOVVconst [c]) [255])
+	// result: (MOVVconst [int64(uint8(c))])
+	for {
+		if auxIntToInt64(v.AuxInt) != 255 || v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(uint8(c)))
+		return true
+	}
+	// match: (ANDconst (MOVVconst [c]) [65535])
+	// result: (MOVVconst [int64(uint16(c))])
+	for {
+		if auxIntToInt64(v.AuxInt) != 65535 || v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(uint16(c)))
+		return true
+	}
+	// match: (ANDconst (MOVVconst [c]) [0xffffffff])
+	// result: (MOVVconst [int64(uint32(c))])
+	for {
+		if auxIntToInt64(v.AuxInt) != 0xffffffff || v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(uint32(c)))
+		return true
+	}
+	// match: (ANDconst [0] _)
+	// result: (MOVVconst [0])
+	for {
+		if auxIntToInt64(v.AuxInt) != 0 {
+			break
+		}
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(0)
+		return true
+	}
+	// match: (ANDconst [-1] x)
+	// result: x
+	for {
+		if auxIntToInt64(v.AuxInt) != -1 {
+			break
+		}
+		x := v_0
+		v.copyOf(x)
+		return true
+	}
+	// match: (ANDconst [c] (MOVVconst [d]))
+	// result: (MOVVconst [c&d])
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		d := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(c & d)
+		return true
+	}
+	// match: (ANDconst [c] (ANDconst [d] x))
+	// result: (ANDconst [c&d] x)
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64ANDconst {
+			break
+		}
+		d := auxIntToInt64(v_0.AuxInt)
+		x := v_0.Args[0]
+		v.reset(OpSW64ANDconst)
+		v.AuxInt = int64ToAuxInt(c & d)
+		v.AddArg(x)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64BIS(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (BIS x (MOVVconst [c]))
+	// cond: is32Bit(c)
+	// result: (BISconst [c] x)
+	for {
+		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
+			x := v_0
+			if v_1.Op != OpSW64MOVVconst {
+				continue
+			}
+			c := auxIntToInt64(v_1.AuxInt)
+			if !(is32Bit(c)) {
+				continue
+			}
+			v.reset(OpSW64BISconst)
+			v.AuxInt = int64ToAuxInt(c)
+			v.AddArg(x)
+			return true
+		}
+		break
+	}
+	// match: (BIS x x)
+	// result: x
+	for {
+		x := v_0
+		if x != v_1 {
+			break
+		}
+		v.copyOf(x)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64BISconst(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (BISconst [0] x)
+	// result: x
+	for {
+		if auxIntToInt64(v.AuxInt) != 0 {
+			break
+		}
+		x := v_0
+		v.copyOf(x)
+		return true
+	}
+	// match: (BISconst [-1] _)
+	// result: (MOVVconst [-1])
+	for {
+		if auxIntToInt64(v.AuxInt) != -1 {
+			break
+		}
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(-1)
+		return true
+	}
+	// match: (BISconst [c] (MOVVconst [d]))
+	// result: (MOVVconst [c|d])
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		d := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(c | d)
+		return true
+	}
+	// match: (BISconst [c] (BISconst [d] x))
+	// cond: is32Bit(c|d)
+	// result: (BISconst [c|d] x)
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64BISconst {
+			break
+		}
+		d := auxIntToInt64(v_0.AuxInt)
+		x := v_0.Args[0]
+		if !(is32Bit(c | d)) {
+			break
+		}
+		v.reset(OpSW64BISconst)
+		v.AuxInt = int64ToAuxInt(c | d)
+		v.AddArg(x)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64CMPEQ(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (CMPEQ x (MOVVconst [c]))
+	// cond: is32Bit(c)
+	// result: (CMPEQconst [c] x)
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(is32Bit(c)) {
+			break
+		}
+		v.reset(OpSW64CMPEQconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v.AddArg(x)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64CMPLE(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (CMPLE x (MOVVconst [c]))
+	// cond: is32Bit(c)
+	// result: (CMPLEconst [c] x)
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(is32Bit(c)) {
+			break
+		}
+		v.reset(OpSW64CMPLEconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v.AddArg(x)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64CMPLT(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (CMPLT x (MOVVconst [c]))
+	// cond: is32Bit(c)
+	// result: (CMPLTconst [c] x)
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(is32Bit(c)) {
+			break
+		}
+		v.reset(OpSW64CMPLTconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v.AddArg(x)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64CMPULE(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (CMPULE x (MOVVconst [c]))
+	// cond: is32Bit(c)
+	// result: (CMPULEconst [c] x)
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(is32Bit(c)) {
+			break
+		}
+		v.reset(OpSW64CMPULEconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v.AddArg(x)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64CMPULT(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (CMPULT x (MOVVconst [c]))
+	// cond: is32Bit(c)
+	// result: (CMPULTconst [c] x)
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(is32Bit(c)) {
+			break
+		}
+		v.reset(OpSW64CMPULTconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v.AddArg(x)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVBUload(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVBUload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVBUload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVBUload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVBUload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVBUload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVBUload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVBUload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVBUload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVBUload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVBUreg(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (MOVBUreg x:(MOVBUload _ _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVBUload {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVBUreg x:(MOVBUreg _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVBUreg {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVBUreg (MOVVconst [c]))
+	// result: (MOVVconst [int64(uint8(c))])
+	for {
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(uint8(c)))
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVBload(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVBload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVBload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVBload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVBload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVBload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVBload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVBload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVBload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVBload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVBreg(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (MOVBreg x:(MOVBreg _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVBreg {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVBreg (MOVVconst [c]))
+	// result: (MOVVconst [int64(int8(c))])
+	for {
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(int8(c)))
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVBstore(v *Value) bool {
+	v_2 := v.Args[2]
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVBstore [off1] {sym} (ADDVconst [off2] ptr) val mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVBstore [off1+int32(off2)] {sym} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVBstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVBstore [off1] {sym} (ADDVconst [off2] ptr) val mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVBstore [off1+int32(off2)] {sym} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVBstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVBstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVBstore [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVBstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVBstore [off] {sym} ptr (MOVVconst [0]) mem)
+	// result: (MOVBstorezero [off] {sym} ptr mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVVconst || auxIntToInt64(v_1.AuxInt) != 0 {
+			break
+		}
+		mem := v_2
+		v.reset(OpSW64MOVBstorezero)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVBstore [off] {sym} ptr (MOVBreg x) mem)
+	// result: (MOVBstore [off] {sym} ptr x mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVBreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v_2
+		v.reset(OpSW64MOVBstore)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, x, mem)
+		return true
+	}
+	// match: (MOVBstore [off] {sym} ptr (MOVBUreg x) mem)
+	// result: (MOVBstore [off] {sym} ptr x mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVBUreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v_2
+		v.reset(OpSW64MOVBstore)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, x, mem)
+		return true
+	}
+	// match: (MOVBstore [off] {sym} ptr (MOVHreg x) mem)
+	// result: (MOVBstore [off] {sym} ptr x mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVHreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v_2
+		v.reset(OpSW64MOVBstore)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, x, mem)
+		return true
+	}
+	// match: (MOVBstore [off] {sym} ptr (MOVHUreg x) mem)
+	// result: (MOVBstore [off] {sym} ptr x mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVHUreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v_2
+		v.reset(OpSW64MOVBstore)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, x, mem)
+		return true
+	}
+	// match: (MOVBstore [off] {sym} ptr (MOVWreg x) mem)
+	// result: (MOVBstore [off] {sym} ptr x mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVWreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v_2
+		v.reset(OpSW64MOVBstore)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, x, mem)
+		return true
+	}
+	// match: (MOVBstore [off] {sym} ptr (MOVWUreg x) mem)
+	// result: (MOVBstore [off] {sym} ptr x mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVWUreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v_2
+		v.reset(OpSW64MOVBstore)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, x, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVBstorezero(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVBstorezero [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVBstorezero [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVBstorezero)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVBstorezero [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVBstorezero [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVBstorezero)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVBstorezero [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVBstorezero [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVBstorezero)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVDload(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVDload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVDload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVDload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVDload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVDload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVDload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVDload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVDload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVDload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVDstore(v *Value) bool {
+	v_2 := v.Args[2]
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVDstore [off1] {sym} (ADDVconst [off2] ptr) val mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVDstore [off1+int32(off2)] {sym} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVDstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVDstore [off1] {sym} (ADDVconst [off2] ptr) val mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVDstore [off1+int32(off2)] {sym} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVDstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVDstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVDstore [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVDstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVFload(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVFload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVFload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVFload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVFload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVFload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVFload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVFload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVFload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVFload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVFstore(v *Value) bool {
+	v_2 := v.Args[2]
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVFstore [off1] {sym} (ADDVconst [off2] ptr) val mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVFstore [off1+int32(off2)] {sym} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVFstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVFstore [off1] {sym} (ADDVconst [off2] ptr) val mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVFstore [off1+int32(off2)] {sym} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVFstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVFstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVFstore [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVFstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVHUload(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVHUload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVHUload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVHUload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVHUload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVHUload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVHUload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVHUload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVHUload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVHUload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVHUreg(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (MOVHUreg x:(MOVBUload _ _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVBUload {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVHUreg x:(MOVHUload _ _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVHUload {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVHUreg x:(MOVBUreg _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVBUreg {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVHUreg x:(MOVHUreg _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVHUreg {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVHUreg (MOVVconst [c]))
+	// result: (MOVVconst [int64(uint16(c))])
+	for {
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(uint16(c)))
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVHload(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVHload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVHload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVHload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVHload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVHload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVHload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVHload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVHload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVHload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVHreg(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (MOVHreg x:(MOVBreg _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVBreg {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVHreg x:(MOVHreg _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVHreg {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVHreg (MOVVconst [c]))
+	// result: (MOVVconst [int64(int16(c))])
+	for {
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(int16(c)))
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVHstore(v *Value) bool {
+	v_2 := v.Args[2]
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVHstore [off1] {sym} (ADDVconst [off2] ptr) val mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVHstore [off1+int32(off2)] {sym} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVHstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVHstore [off1] {sym} (ADDVconst [off2] ptr) val mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVHstore [off1+int32(off2)] {sym} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVHstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVHstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVHstore [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVHstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVHstore [off] {sym} ptr (MOVVconst [0]) mem)
+	// result: (MOVHstorezero [off] {sym} ptr mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVVconst || auxIntToInt64(v_1.AuxInt) != 0 {
+			break
+		}
+		mem := v_2
+		v.reset(OpSW64MOVHstorezero)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVHstore [off] {sym} ptr (MOVHreg x) mem)
+	// result: (MOVHstore [off] {sym} ptr x mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVHreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v_2
+		v.reset(OpSW64MOVHstore)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, x, mem)
+		return true
+	}
+	// match: (MOVHstore [off] {sym} ptr (MOVHUreg x) mem)
+	// result: (MOVHstore [off] {sym} ptr x mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVHUreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v_2
+		v.reset(OpSW64MOVHstore)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, x, mem)
+		return true
+	}
+	// match: (MOVHstore [off] {sym} ptr (MOVWreg x) mem)
+	// result: (MOVHstore [off] {sym} ptr x mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVWreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v_2
+		v.reset(OpSW64MOVHstore)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, x, mem)
+		return true
+	}
+	// match: (MOVHstore [off] {sym} ptr (MOVWUreg x) mem)
+	// result: (MOVHstore [off] {sym} ptr x mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVWUreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v_2
+		v.reset(OpSW64MOVHstore)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, x, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVHstorezero(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVHstorezero [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVHstorezero [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVHstorezero)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVHstorezero [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVHstorezero [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVHstorezero)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVHstorezero [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVHstorezero [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVHstorezero)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVVload(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVVload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVVload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVVload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVVload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVVload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVVload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVVload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVVload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVVload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVVnop(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (MOVVnop (MOVVconst [c]))
+	// result: (MOVVconst [c])
+	for {
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(c)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVVreg(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (MOVVreg x)
+	// cond: x.Uses == 1
+	// result: (MOVVnop x)
+	for {
+		x := v_0
+		if !(x.Uses == 1) {
+			break
+		}
+		v.reset(OpSW64MOVVnop)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVVreg (MOVVconst [c]))
+	// result: (MOVVconst [c])
+	for {
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(c)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVVstore(v *Value) bool {
+	v_2 := v.Args[2]
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVVstore [off1] {sym} (ADDVconst [off2] ptr) val mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVVstore [off1+int32(off2)] {sym} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVVstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVVstore [off1] {sym} (ADDVconst [off2] ptr) val mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVVstore [off1+int32(off2)] {sym} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVVstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVVstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVVstore [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVVstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVVstore [off] {sym} ptr (MOVVconst [0]) mem)
+	// result: (MOVVstorezero [off] {sym} ptr mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVVconst || auxIntToInt64(v_1.AuxInt) != 0 {
+			break
+		}
+		mem := v_2
+		v.reset(OpSW64MOVVstorezero)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVVstorezero(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVVstorezero [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVVstorezero [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVVstorezero)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVVstorezero [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVVstorezero [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVVstorezero)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVVstorezero [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVVstorezero [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVVstorezero)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVWUload(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVWUload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVWUload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVWUload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVWUload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVWUload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVWUload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVWUload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVWUload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVWUload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVWUreg(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (MOVWUreg x:(MOVBUload _ _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVBUload {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVWUreg x:(MOVHUload _ _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVHUload {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVWUreg x:(MOVBUreg _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVBUreg {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVWUreg x:(MOVHUreg _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVHUreg {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVWUreg x:(MOVWUreg _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVWUreg {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVWUreg (MOVVconst [c]))
+	// result: (MOVVconst [int64(uint32(c))])
+	for {
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(uint32(c)))
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVWload(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVWload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVWload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVWload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVWload [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVWload [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVWload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVWload [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVWload [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVWload)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVWreg(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (MOVWreg x:(MOVWload _ _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVWload {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVWreg x:(MOVBreg _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVBreg {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVWreg x:(MOVHreg _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVHreg {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVWreg x:(MOVWreg _))
+	// result: (MOVVreg x)
+	for {
+		x := v_0
+		if x.Op != OpSW64MOVWreg {
+			break
+		}
+		v.reset(OpSW64MOVVreg)
+		v.AddArg(x)
+		return true
+	}
+	// match: (MOVWreg (MOVVconst [c]))
+	// result: (MOVVconst [int64(int32(c))])
+	for {
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(int32(c)))
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVWstore(v *Value) bool {
+	v_2 := v.Args[2]
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVWstore [off1] {sym} (ADDVconst [off2] ptr) val mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVWstore [off1+int32(off2)] {sym} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVWstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVWstore [off1] {sym} (ADDVconst [off2] ptr) val mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVWstore [off1+int32(off2)] {sym} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVWstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVWstore [off1] {sym1} (SYMADDR [off2] {sym2} ptr) val mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVWstore [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr val mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		val := v_1
+		mem := v_2
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVWstore)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (MOVWstore [off] {sym} ptr (MOVVconst [0]) mem)
+	// result: (MOVWstorezero [off] {sym} ptr mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVVconst || auxIntToInt64(v_1.AuxInt) != 0 {
+			break
+		}
+		mem := v_2
+		v.reset(OpSW64MOVWstorezero)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVWstore [off] {sym} ptr (MOVWreg x) mem)
+	// result: (MOVWstore [off] {sym} ptr x mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVWreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v_2
+		v.reset(OpSW64MOVWstore)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, x, mem)
+		return true
+	}
+	// match: (MOVWstore [off] {sym} ptr (MOVWUreg x) mem)
+	// result: (MOVWstore [off] {sym} ptr x mem)
+	for {
+		off := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		ptr := v_0
+		if v_1.Op != OpSW64MOVWUreg {
+			break
+		}
+		x := v_1.Args[0]
+		mem := v_2
+		v.reset(OpSW64MOVWstore)
+		v.AuxInt = int32ToAuxInt(off)
+		v.Aux = symToAux(sym)
+		v.AddArg3(ptr, x, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MOVWstorezero(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	// match: (MOVWstorezero [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is16Bit(int64(off1)+off2)
+	// result: (MOVWstorezero [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is16Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVWstorezero)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVWstorezero [off1] {sym} (ADDVconst [off2] ptr) mem)
+	// cond: is32Bit(int64(off1)+off2)
+	// result: (MOVWstorezero [off1+int32(off2)] {sym} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym := auxToSym(v.Aux)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		off2 := auxIntToInt64(v_0.AuxInt)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(is32Bit(int64(off1) + off2)) {
+			break
+		}
+		v.reset(OpSW64MOVWstorezero)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(sym)
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (MOVWstorezero [off1] {sym1} (SYMADDR [off2] {sym2} ptr) mem)
+	// cond: canMergeSym(sym1,sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)
+	// result: (MOVWstorezero [off1+int32(off2)] {mergeSym(sym1,sym2)} ptr mem)
+	for {
+		off1 := auxIntToInt32(v.AuxInt)
+		sym1 := auxToSym(v.Aux)
+		if v_0.Op != OpSW64SYMADDR {
+			break
+		}
+		off2 := auxIntToInt32(v_0.AuxInt)
+		sym2 := auxToSym(v_0.Aux)
+		ptr := v_0.Args[0]
+		mem := v_1
+		if !(canMergeSym(sym1, sym2) && is32Bit(int64(off1)+int64(off2)) && (ptr.Op != OpSB || !config.ctxt.Flag_shared)) {
+			break
+		}
+		v.reset(OpSW64MOVWstorezero)
+		v.AuxInt = int32ToAuxInt(off1 + int32(off2))
+		v.Aux = symToAux(mergeSym(sym1, sym2))
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MULL(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (MULL x (MOVVconst [c]))
+	// result: (MULLconst [c] x)
+	for {
+		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
+			x := v_0
+			if v_1.Op != OpSW64MOVVconst {
+				continue
+			}
+			c := auxIntToInt64(v_1.AuxInt)
+			v.reset(OpSW64MULLconst)
+			v.AuxInt = int64ToAuxInt(c)
+			v.AddArg(x)
+			return true
+		}
+		break
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MULLconst(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	// match: (MULLconst [c] x)
+	// cond: isPowerOfTwo64(c-1) && c>=3
+	// result: (ADDV (SLLconst <x.Type> x [log64(c-1)]) x)
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		x := v_0
+		if !(isPowerOfTwo64(c-1) && c >= 3) {
+			break
+		}
+		v.reset(OpSW64ADDV)
+		v0 := b.NewValue0(v.Pos, OpSW64SLLconst, x.Type)
+		v0.AuxInt = int64ToAuxInt(log64(c - 1))
+		v0.AddArg(x)
+		v.AddArg2(v0, x)
+		return true
+	}
+	// match: (MULLconst [c] x)
+	// cond: isPowerOfTwo64(c+1) && c>=7
+	// result: (SUBV (SLLconst <x.Type> x [log64(c+1)]) x)
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		x := v_0
+		if !(isPowerOfTwo64(c+1) && c >= 7) {
+			break
+		}
+		v.reset(OpSW64SUBV)
+		v0 := b.NewValue0(v.Pos, OpSW64SLLconst, x.Type)
+		v0.AuxInt = int64ToAuxInt(log64(c + 1))
+		v0.AddArg(x)
+		v.AddArg2(v0, x)
+		return true
+	}
+	// match: (MULLconst [c] x)
+	// cond: c%3 == 0 && isPowerOfTwo64(c/3)
+	// result: (SLLconst <x.Type> (ADDV <x.Type> (SLLconst <x.Type> x [1]) x) [log64(c/3)])
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		x := v_0
+		if !(c%3 == 0 && isPowerOfTwo64(c/3)) {
+			break
+		}
+		v.reset(OpSW64SLLconst)
+		v.Type = x.Type
+		v.AuxInt = int64ToAuxInt(log64(c / 3))
+		v0 := b.NewValue0(v.Pos, OpSW64ADDV, x.Type)
+		v1 := b.NewValue0(v.Pos, OpSW64SLLconst, x.Type)
+		v1.AuxInt = int64ToAuxInt(1)
+		v1.AddArg(x)
+		v0.AddArg2(v1, x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (MULLconst [c] x)
+	// cond: c%5 == 0 && isPowerOfTwo64(c/5)
+	// result: (SLLconst <x.Type> (S4ADDV <x.Type> x x) [log64(c/5)])
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		x := v_0
+		if !(c%5 == 0 && isPowerOfTwo64(c/5)) {
+			break
+		}
+		v.reset(OpSW64SLLconst)
+		v.Type = x.Type
+		v.AuxInt = int64ToAuxInt(log64(c / 5))
+		v0 := b.NewValue0(v.Pos, OpSW64S4ADDV, x.Type)
+		v0.AddArg2(x, x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (MULLconst [c] x)
+	// cond: c%7 == 0 && isPowerOfTwo64(c/7)
+	// result: (SLLconst <x.Type> (S8SUBV <x.Type> x x) [log64(c/7)])
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		x := v_0
+		if !(c%7 == 0 && isPowerOfTwo64(c/7)) {
+			break
+		}
+		v.reset(OpSW64SLLconst)
+		v.Type = x.Type
+		v.AuxInt = int64ToAuxInt(log64(c / 7))
+		v0 := b.NewValue0(v.Pos, OpSW64S8SUBV, x.Type)
+		v0.AddArg2(x, x)
+		v.AddArg(v0)
+		return true
+	}
+	// match: (MULLconst [c] x)
+	// cond: c%9 == 0 && isPowerOfTwo64(c/9)
+	// result: (SLLconst <x.Type> (S8ADDV <x.Type> x x) [log64(c/9)])
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		x := v_0
+		if !(c%9 == 0 && isPowerOfTwo64(c/9)) {
+			break
+		}
+		v.reset(OpSW64SLLconst)
+		v.Type = x.Type
+		v.AuxInt = int64ToAuxInt(log64(c / 9))
+		v0 := b.NewValue0(v.Pos, OpSW64S8ADDV, x.Type)
+		v0.AddArg2(x, x)
+		v.AddArg(v0)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64MULW(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (MULW x (MOVVconst [c]))
+	// cond: is32Bit(c)
+	// result: (MULWconst [c] x)
+	for {
+		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
+			x := v_0
+			if v_1.Op != OpSW64MOVVconst {
+				continue
+			}
+			c := auxIntToInt64(v_1.AuxInt)
+			if !(is32Bit(c)) {
+				continue
+			}
+			v.reset(OpSW64MULWconst)
+			v.AuxInt = int64ToAuxInt(c)
+			v.AddArg(x)
+			return true
+		}
+		break
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64NEGV(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (NEGV (MOVVconst [c]))
+	// result: (MOVVconst [-c])
+	for {
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(-c)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64ORNOT(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (ORNOT x (MOVVconst [c]))
+	// cond: is32Bit(c)
+	// result: (ORNOTconst [c] x)
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(is32Bit(c)) {
+			break
+		}
+		v.reset(OpSW64ORNOTconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v.AddArg(x)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64SEXTB(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (SEXTB (MOVVconst [c]))
+	// result: (MOVVconst [int64(int8(c))])
+	for {
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(int8(c)))
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64SEXTH(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (SEXTH (MOVVconst [c]))
+	// result: (MOVVconst [int64(int16(c))])
+	for {
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(int16(c)))
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64SLLconst(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (SLLconst [c] (MOVVconst [d]))
+	// result: (MOVVconst [int64(d)<<uint64(c)])
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		d := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(d) << uint64(c))
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64SRAconst(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (SRAconst [c] (MOVVconst [d]))
+	// result: (MOVVconst [int64(d)>>uint64(c)])
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		d := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(d) >> uint64(c))
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64SRLconst(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (SRLconst [c] (MOVVconst [d]))
+	// result: (MOVVconst [int64(uint64(d)>>uint64(c))])
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		d := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(int64(uint64(d) >> uint64(c)))
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64SUBV(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (SUBV x (MOVVconst [c]))
+	// cond: is32Bit(c)
+	// result: (SUBVconst [c] x)
+	for {
+		x := v_0
+		if v_1.Op != OpSW64MOVVconst {
+			break
+		}
+		c := auxIntToInt64(v_1.AuxInt)
+		if !(is32Bit(c)) {
+			break
+		}
+		v.reset(OpSW64SUBVconst)
+		v.AuxInt = int64ToAuxInt(c)
+		v.AddArg(x)
+		return true
+	}
+	// match: (SUBV x x)
+	// result: (MOVVconst [0])
+	for {
+		x := v_0
+		if x != v_1 {
+			break
+		}
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(0)
+		return true
+	}
+	// match: (SUBV (MOVVconst [0]) x)
+	// result: (NEGV x)
+	for {
+		if v_0.Op != OpSW64MOVVconst || auxIntToInt64(v_0.AuxInt) != 0 {
+			break
+		}
+		x := v_1
+		v.reset(OpSW64NEGV)
+		v.AddArg(x)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64SUBVconst(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (SUBVconst [0] x)
+	// result: x
+	for {
+		if auxIntToInt64(v.AuxInt) != 0 {
+			break
+		}
+		x := v_0
+		v.copyOf(x)
+		return true
+	}
+	// match: (SUBVconst [c] (MOVVconst [d]))
+	// result: (MOVVconst [d-c])
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		d := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(d - c)
+		return true
+	}
+	// match: (SUBVconst [c] (SUBVconst [d] x))
+	// cond: is32Bit(-c-d)
+	// result: (ADDVconst [-c-d] x)
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64SUBVconst {
+			break
+		}
+		d := auxIntToInt64(v_0.AuxInt)
+		x := v_0.Args[0]
+		if !(is32Bit(-c - d)) {
+			break
+		}
+		v.reset(OpSW64ADDVconst)
+		v.AuxInt = int64ToAuxInt(-c - d)
+		v.AddArg(x)
+		return true
+	}
+	// match: (SUBVconst [c] (ADDVconst [d] x))
+	// cond: is32Bit(-c+d)
+	// result: (ADDVconst [-c+d] x)
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64ADDVconst {
+			break
+		}
+		d := auxIntToInt64(v_0.AuxInt)
+		x := v_0.Args[0]
+		if !(is32Bit(-c + d)) {
+			break
+		}
+		v.reset(OpSW64ADDVconst)
+		v.AuxInt = int64ToAuxInt(-c + d)
+		v.AddArg(x)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64XOR(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (XOR x (MOVVconst [c]))
+	// cond: is32Bit(c)
+	// result: (XORconst [c] x)
+	for {
+		for _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {
+			x := v_0
+			if v_1.Op != OpSW64MOVVconst {
+				continue
+			}
+			c := auxIntToInt64(v_1.AuxInt)
+			if !(is32Bit(c)) {
+				continue
+			}
+			v.reset(OpSW64XORconst)
+			v.AuxInt = int64ToAuxInt(c)
+			v.AddArg(x)
+			return true
+		}
+		break
+	}
+	// match: (XOR x x)
+	// result: (MOVVconst [0])
+	for {
+		x := v_0
+		if x != v_1 {
+			break
+		}
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(0)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSW64XORconst(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (XORconst [0] x)
+	// result: x
+	for {
+		if auxIntToInt64(v.AuxInt) != 0 {
+			break
+		}
+		x := v_0
+		v.copyOf(x)
+		return true
+	}
+	// match: (XORconst [c] (MOVVconst [d]))
+	// result: (MOVVconst [c^d])
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64MOVVconst {
+			break
+		}
+		d := auxIntToInt64(v_0.AuxInt)
+		v.reset(OpSW64MOVVconst)
+		v.AuxInt = int64ToAuxInt(c ^ d)
+		return true
+	}
+	// match: (XORconst [c] (XORconst [d] x))
+	// cond: is32Bit(c^d)
+	// result: (XORconst [c^d] x)
+	for {
+		c := auxIntToInt64(v.AuxInt)
+		if v_0.Op != OpSW64XORconst {
+			break
+		}
+		d := auxIntToInt64(v_0.AuxInt)
+		x := v_0.Args[0]
+		if !(is32Bit(c ^ d)) {
+			break
+		}
+		v.reset(OpSW64XORconst)
+		v.AuxInt = int64ToAuxInt(c ^ d)
+		v.AddArg(x)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpSignmask(v *Value) bool {
+	v_0 := v.Args[0]
+	// match: (Signmask x)
+	// result: (SRAconst x [63])
+	for {
+		x := v_0
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(63)
+		v.AddArg(x)
+		return true
+	}
+}
+func rewriteValueSW64_OpSlicemask(v *Value) bool {
+	v_0 := v.Args[0]
+	b := v.Block
+	// match: (Slicemask <t> x)
+	// result: (SRAconst (NEGV <t> x) [63])
+	for {
+		t := v.Type
+		x := v_0
+		v.reset(OpSW64SRAconst)
+		v.AuxInt = int64ToAuxInt(63)
+		v0 := b.NewValue0(v.Pos, OpSW64NEGV, t)
+		v0.AddArg(x)
+		v.AddArg(v0)
+		return true
+	}
+}
+func rewriteValueSW64_OpStore(v *Value) bool {
+	v_2 := v.Args[2]
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	// match: (Store {t} ptr val mem)
+	// cond: t.Size() == 1
+	// result: (MOVBstore ptr val mem)
+	for {
+		t := auxToType(v.Aux)
+		ptr := v_0
+		val := v_1
+		mem := v_2
+		if !(t.Size() == 1) {
+			break
+		}
+		v.reset(OpSW64MOVBstore)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (Store {t} ptr val mem)
+	// cond: t.Size() == 2
+	// result: (MOVHstore ptr val mem)
+	for {
+		t := auxToType(v.Aux)
+		ptr := v_0
+		val := v_1
+		mem := v_2
+		if !(t.Size() == 2) {
+			break
+		}
+		v.reset(OpSW64MOVHstore)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (Store {t} ptr val mem)
+	// cond: t.Size() == 4 && !is32BitFloat(val.Type)
+	// result: (MOVWstore ptr val mem)
+	for {
+		t := auxToType(v.Aux)
+		ptr := v_0
+		val := v_1
+		mem := v_2
+		if !(t.Size() == 4 && !is32BitFloat(val.Type)) {
+			break
+		}
+		v.reset(OpSW64MOVWstore)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (Store {t} ptr val mem)
+	// cond: t.Size() == 8 && !is64BitFloat(val.Type)
+	// result: (MOVVstore ptr val mem)
+	for {
+		t := auxToType(v.Aux)
+		ptr := v_0
+		val := v_1
+		mem := v_2
+		if !(t.Size() == 8 && !is64BitFloat(val.Type)) {
+			break
+		}
+		v.reset(OpSW64MOVVstore)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (Store {t} ptr val mem)
+	// cond: t.Size() == 4 && is32BitFloat(val.Type)
+	// result: (MOVFstore ptr val mem)
+	for {
+		t := auxToType(v.Aux)
+		ptr := v_0
+		val := v_1
+		mem := v_2
+		if !(t.Size() == 4 && is32BitFloat(val.Type)) {
+			break
+		}
+		v.reset(OpSW64MOVFstore)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	// match: (Store {t} ptr val mem)
+	// cond: t.Size() == 8 && is64BitFloat(val.Type)
+	// result: (MOVDstore ptr val mem)
+	for {
+		t := auxToType(v.Aux)
+		ptr := v_0
+		val := v_1
+		mem := v_2
+		if !(t.Size() == 8 && is64BitFloat(val.Type)) {
+			break
+		}
+		v.reset(OpSW64MOVDstore)
+		v.AddArg3(ptr, val, mem)
+		return true
+	}
+	return false
+}
+func rewriteValueSW64_OpZero(v *Value) bool {
+	v_1 := v.Args[1]
+	v_0 := v.Args[0]
+	b := v.Block
+	config := b.Func.Config
+	typ := &b.Func.Config.Types
+	// match: (Zero [0] _ mem)
+	// result: mem
+	for {
+		if auxIntToInt64(v.AuxInt) != 0 {
+			break
+		}
+		mem := v_1
+		v.copyOf(mem)
+		return true
+	}
+	// match: (Zero [1] ptr mem)
+	// result: (MOVBstore ptr (MOVVconst [0]) mem)
+	for {
+		if auxIntToInt64(v.AuxInt) != 1 {
+			break
+		}
+		ptr := v_0
+		mem := v_1
+		v.reset(OpSW64MOVBstore)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v.AddArg3(ptr, v0, mem)
+		return true
+	}
+	// match: (Zero [2] {t} ptr mem)
+	// cond: t.Alignment()%2 == 0
+	// result: (MOVHstore ptr (MOVVconst [0]) mem)
+	for {
+		if auxIntToInt64(v.AuxInt) != 2 {
+			break
+		}
+		t := auxToType(v.Aux)
+		ptr := v_0
+		mem := v_1
+		if !(t.Alignment()%2 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVHstore)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v.AddArg3(ptr, v0, mem)
+		return true
+	}
+	// match: (Zero [2] ptr mem)
+	// result: (MOVBstore [1] ptr (MOVVconst [0]) (MOVBstore [0] ptr (MOVVconst [0]) mem))
+	for {
+		if auxIntToInt64(v.AuxInt) != 2 {
+			break
+		}
+		ptr := v_0
+		mem := v_1
+		v.reset(OpSW64MOVBstore)
+		v.AuxInt = int32ToAuxInt(1)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVBstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(0)
+		v1.AddArg3(ptr, v0, mem)
+		v.AddArg3(ptr, v0, v1)
+		return true
+	}
+	// match: (Zero [4] {t} ptr mem)
+	// cond: t.Alignment()%4 == 0
+	// result: (MOVWstore ptr (MOVVconst [0]) mem)
+	for {
+		if auxIntToInt64(v.AuxInt) != 4 {
+			break
+		}
+		t := auxToType(v.Aux)
+		ptr := v_0
+		mem := v_1
+		if !(t.Alignment()%4 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVWstore)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v.AddArg3(ptr, v0, mem)
+		return true
+	}
+	// match: (Zero [4] {t} ptr mem)
+	// cond: t.Alignment()%2 == 0
+	// result: (MOVHstore [2] ptr (MOVVconst [0]) (MOVHstore [0] ptr (MOVVconst [0]) mem))
+	for {
+		if auxIntToInt64(v.AuxInt) != 4 {
+			break
+		}
+		t := auxToType(v.Aux)
+		ptr := v_0
+		mem := v_1
+		if !(t.Alignment()%2 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVHstore)
+		v.AuxInt = int32ToAuxInt(2)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVHstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(0)
+		v1.AddArg3(ptr, v0, mem)
+		v.AddArg3(ptr, v0, v1)
+		return true
+	}
+	// match: (Zero [4] ptr mem)
+	// result: (MOVBstore [3] ptr (MOVVconst [0]) (MOVBstore [2] ptr (MOVVconst [0]) (MOVBstore [1] ptr (MOVVconst [0]) (MOVBstore [0] ptr (MOVVconst [0]) mem))))
+	for {
+		if auxIntToInt64(v.AuxInt) != 4 {
+			break
+		}
+		ptr := v_0
+		mem := v_1
+		v.reset(OpSW64MOVBstore)
+		v.AuxInt = int32ToAuxInt(3)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVBstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(2)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVBstore, types.TypeMem)
+		v2.AuxInt = int32ToAuxInt(1)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVBstore, types.TypeMem)
+		v3.AuxInt = int32ToAuxInt(0)
+		v3.AddArg3(ptr, v0, mem)
+		v2.AddArg3(ptr, v0, v3)
+		v1.AddArg3(ptr, v0, v2)
+		v.AddArg3(ptr, v0, v1)
+		return true
+	}
+	// match: (Zero [8] {t} ptr mem)
+	// cond: t.Alignment()%8 == 0
+	// result: (MOVVstore ptr (MOVVconst [0]) mem)
+	for {
+		if auxIntToInt64(v.AuxInt) != 8 {
+			break
+		}
+		t := auxToType(v.Aux)
+		ptr := v_0
+		mem := v_1
+		if !(t.Alignment()%8 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVVstore)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v.AddArg3(ptr, v0, mem)
+		return true
+	}
+	// match: (Zero [8] {t} ptr mem)
+	// cond: t.Alignment()%4 == 0
+	// result: (MOVWstore [4] ptr (MOVVconst [0]) (MOVWstore [0] ptr (MOVVconst [0]) mem))
+	for {
+		if auxIntToInt64(v.AuxInt) != 8 {
+			break
+		}
+		t := auxToType(v.Aux)
+		ptr := v_0
+		mem := v_1
+		if !(t.Alignment()%4 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVWstore)
+		v.AuxInt = int32ToAuxInt(4)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVWstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(0)
+		v1.AddArg3(ptr, v0, mem)
+		v.AddArg3(ptr, v0, v1)
+		return true
+	}
+	// match: (Zero [8] {t} ptr mem)
+	// cond: t.Alignment()%2 == 0
+	// result: (MOVHstore [6] ptr (MOVVconst [0]) (MOVHstore [4] ptr (MOVVconst [0]) (MOVHstore [2] ptr (MOVVconst [0]) (MOVHstore [0] ptr (MOVVconst [0]) mem))))
+	for {
+		if auxIntToInt64(v.AuxInt) != 8 {
+			break
+		}
+		t := auxToType(v.Aux)
+		ptr := v_0
+		mem := v_1
+		if !(t.Alignment()%2 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVHstore)
+		v.AuxInt = int32ToAuxInt(6)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVHstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(4)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVHstore, types.TypeMem)
+		v2.AuxInt = int32ToAuxInt(2)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVHstore, types.TypeMem)
+		v3.AuxInt = int32ToAuxInt(0)
+		v3.AddArg3(ptr, v0, mem)
+		v2.AddArg3(ptr, v0, v3)
+		v1.AddArg3(ptr, v0, v2)
+		v.AddArg3(ptr, v0, v1)
+		return true
+	}
+	// match: (Zero [3] ptr mem)
+	// result: (MOVBstore [2] ptr (MOVVconst [0]) (MOVBstore [1] ptr (MOVVconst [0]) (MOVBstore [0] ptr (MOVVconst [0]) mem)))
+	for {
+		if auxIntToInt64(v.AuxInt) != 3 {
+			break
+		}
+		ptr := v_0
+		mem := v_1
+		v.reset(OpSW64MOVBstore)
+		v.AuxInt = int32ToAuxInt(2)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVBstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(1)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVBstore, types.TypeMem)
+		v2.AuxInt = int32ToAuxInt(0)
+		v2.AddArg3(ptr, v0, mem)
+		v1.AddArg3(ptr, v0, v2)
+		v.AddArg3(ptr, v0, v1)
+		return true
+	}
+	// match: (Zero [6] {t} ptr mem)
+	// cond: t.Alignment()%2 == 0
+	// result: (MOVHstore [4] ptr (MOVVconst [0]) (MOVHstore [2] ptr (MOVVconst [0]) (MOVHstore [0] ptr (MOVVconst [0]) mem)))
+	for {
+		if auxIntToInt64(v.AuxInt) != 6 {
+			break
+		}
+		t := auxToType(v.Aux)
+		ptr := v_0
+		mem := v_1
+		if !(t.Alignment()%2 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVHstore)
+		v.AuxInt = int32ToAuxInt(4)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVHstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(2)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVHstore, types.TypeMem)
+		v2.AuxInt = int32ToAuxInt(0)
+		v2.AddArg3(ptr, v0, mem)
+		v1.AddArg3(ptr, v0, v2)
+		v.AddArg3(ptr, v0, v1)
+		return true
+	}
+	// match: (Zero [12] {t} ptr mem)
+	// cond: t.Alignment()%4 == 0
+	// result: (MOVWstore [8] ptr (MOVVconst [0]) (MOVWstore [4] ptr (MOVVconst [0]) (MOVWstore [0] ptr (MOVVconst [0]) mem)))
+	for {
+		if auxIntToInt64(v.AuxInt) != 12 {
+			break
+		}
+		t := auxToType(v.Aux)
+		ptr := v_0
+		mem := v_1
+		if !(t.Alignment()%4 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVWstore)
+		v.AuxInt = int32ToAuxInt(8)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVWstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(4)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVWstore, types.TypeMem)
+		v2.AuxInt = int32ToAuxInt(0)
+		v2.AddArg3(ptr, v0, mem)
+		v1.AddArg3(ptr, v0, v2)
+		v.AddArg3(ptr, v0, v1)
+		return true
+	}
+	// match: (Zero [16] {t} ptr mem)
+	// cond: t.Alignment()%8 == 0
+	// result: (MOVVstore [8] ptr (MOVVconst [0]) (MOVVstore [0] ptr (MOVVconst [0]) mem))
+	for {
+		if auxIntToInt64(v.AuxInt) != 16 {
+			break
+		}
+		t := auxToType(v.Aux)
+		ptr := v_0
+		mem := v_1
+		if !(t.Alignment()%8 == 0) {
+			break
+		}
+		v.reset(OpSW64MOVVstore)
+		v.AuxInt = int32ToAuxInt(8)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVVstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(0)
+		v1.AddArg3(ptr, v0, mem)
+		v.AddArg3(ptr, v0, v1)
+		return true
+	}
+	// match: (Zero [24] {t} ptr mem)
+	// cond: (t.Alignment()%8 == 0 || buildcfg.GOSW64 >=4)
+	// result: (MOVVstore [16] ptr (MOVVconst [0]) (MOVVstore [8] ptr (MOVVconst [0]) (MOVVstore [0] ptr (MOVVconst [0]) mem)))
+	for {
+		if auxIntToInt64(v.AuxInt) != 24 {
+			break
+		}
+		t := auxToType(v.Aux)
+		ptr := v_0
+		mem := v_1
+		if !(t.Alignment()%8 == 0 || buildcfg.GOSW64 >= 4) {
+			break
+		}
+		v.reset(OpSW64MOVVstore)
+		v.AuxInt = int32ToAuxInt(16)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVVstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(8)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVVstore, types.TypeMem)
+		v2.AuxInt = int32ToAuxInt(0)
+		v2.AddArg3(ptr, v0, mem)
+		v1.AddArg3(ptr, v0, v2)
+		v.AddArg3(ptr, v0, v1)
+		return true
+	}
+	// match: (Zero [32] {t} ptr mem)
+	// cond: (t.Alignment()%8 == 0 || buildcfg.GOSW64 >=4)
+	// result: (MOVVstore [24] ptr (MOVVconst [0]) (MOVVstore [16] ptr (MOVVconst [0]) (MOVVstore [8] ptr (MOVVconst [0]) (MOVVstore [0] ptr (MOVVconst [0]) mem))))
+	for {
+		if auxIntToInt64(v.AuxInt) != 32 {
+			break
+		}
+		t := auxToType(v.Aux)
+		ptr := v_0
+		mem := v_1
+		if !(t.Alignment()%8 == 0 || buildcfg.GOSW64 >= 4) {
+			break
+		}
+		v.reset(OpSW64MOVVstore)
+		v.AuxInt = int32ToAuxInt(24)
+		v0 := b.NewValue0(v.Pos, OpSW64MOVVconst, typ.UInt64)
+		v0.AuxInt = int64ToAuxInt(0)
+		v1 := b.NewValue0(v.Pos, OpSW64MOVVstore, types.TypeMem)
+		v1.AuxInt = int32ToAuxInt(16)
+		v2 := b.NewValue0(v.Pos, OpSW64MOVVstore, types.TypeMem)
+		v2.AuxInt = int32ToAuxInt(8)
+		v3 := b.NewValue0(v.Pos, OpSW64MOVVstore, types.TypeMem)
+		v3.AuxInt = int32ToAuxInt(0)
+		v3.AddArg3(ptr, v0, mem)
+		v2.AddArg3(ptr, v0, v3)
+		v1.AddArg3(ptr, v0, v2)
+		v.AddArg3(ptr, v0, v1)
+		return true
+	}
+	// match: (Zero [s] {t} ptr mem)
+	// cond: s%8 == 0 && s > 24 && s <= 8*128 && t.Alignment()%8 == 0 && !config.noDuffDevice
+	// result: (DUFFZERO [8 * (128 - int64(s/8))] ptr mem)
+	for {
+		s := auxIntToInt64(v.AuxInt)
+		t := auxToType(v.Aux)
+		ptr := v_0
+		mem := v_1
+		if !(s%8 == 0 && s > 24 && s <= 8*128 && t.Alignment()%8 == 0 && !config.noDuffDevice) {
+			break
+		}
+		v.reset(OpSW64DUFFZERO)
+		v.AuxInt = int64ToAuxInt(8 * (128 - int64(s/8)))
+		v.AddArg2(ptr, mem)
+		return true
+	}
+	// match: (Zero [s] {t} ptr mem)
+	// cond: (s > 8*128 || config.noDuffDevice) || t.Alignment()%8 != 0
+	// result: (LoweredZero [t.Alignment()] ptr (ADDVconst <ptr.Type> ptr [s-moveSize(t.Alignment(), config)]) mem)
+	for {
+		s := auxIntToInt64(v.AuxInt)
+		t := auxToType(v.Aux)
+		ptr := v_0
+		mem := v_1
+		if !((s > 8*128 || config.noDuffDevice) || t.Alignment()%8 != 0) {
+			break
+		}
+		v.reset(OpSW64LoweredZero)
+		v.AuxInt = int64ToAuxInt(t.Alignment())
+		v0 := b.NewValue0(v.Pos, OpSW64ADDVconst, ptr.Type)
+		v0.AuxInt = int64ToAuxInt(s - moveSize(t.Alignment(), config))
+		v0.AddArg(ptr)
+		v.AddArg3(ptr, v0, mem)
+		return true
+	}
+	return false
+}
+func rewriteBlockSW64(b *Block) bool {
+	typ := &b.Func.Config.Types
+	switch b.Kind {
+	case BlockSW64EQ:
+		// match: (EQ (XORconst cmp:(CMPEQ _ _) [1]) yes no)
+		// result: (NE cmp yes no)
+		for b.Controls[0].Op == OpSW64XORconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 1 {
+				break
+			}
+			cmp := v_0.Args[0]
+			if cmp.Op != OpSW64CMPEQ {
+				break
+			}
+			b.resetWithControl(BlockSW64NE, cmp)
+			return true
+		}
+		// match: (EQ (XORconst cmp:(CMPEQconst _) [1]) yes no)
+		// result: (NE cmp yes no)
+		for b.Controls[0].Op == OpSW64XORconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 1 {
+				break
+			}
+			cmp := v_0.Args[0]
+			if cmp.Op != OpSW64CMPEQconst {
+				break
+			}
+			b.resetWithControl(BlockSW64NE, cmp)
+			return true
+		}
+		// match: (EQ (CMPEQconst x [0]) yes no)
+		// result: (NE x yes no)
+		for b.Controls[0].Op == OpSW64CMPEQconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 0 {
+				break
+			}
+			x := v_0.Args[0]
+			b.resetWithControl(BlockSW64NE, x)
+			return true
+		}
+		// match: (EQ (CMPLTconst x [0]) yes no)
+		// result: (GE x yes no)
+		for b.Controls[0].Op == OpSW64CMPLTconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 0 {
+				break
+			}
+			x := v_0.Args[0]
+			b.resetWithControl(BlockSW64GE, x)
+			return true
+		}
+		// match: (EQ (CMPLEconst x [0]) yes no)
+		// result: (GT x yes no)
+		for b.Controls[0].Op == OpSW64CMPLEconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 0 {
+				break
+			}
+			x := v_0.Args[0]
+			b.resetWithControl(BlockSW64GT, x)
+			return true
+		}
+		// match: (EQ (CMPLTconst x [1]) yes no)
+		// result: (GT x yes no)
+		for b.Controls[0].Op == OpSW64CMPLTconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 1 {
+				break
+			}
+			x := v_0.Args[0]
+			b.resetWithControl(BlockSW64GT, x)
+			return true
+		}
+		// match: (EQ (CMPULTconst x [1]) yes no)
+		// result: (NE x yes no)
+		for b.Controls[0].Op == OpSW64CMPULTconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 1 {
+				break
+			}
+			x := v_0.Args[0]
+			b.resetWithControl(BlockSW64NE, x)
+			return true
+		}
+		// match: (EQ (CMPULEconst x [0]) yes no)
+		// result: (NE x yes no)
+		for b.Controls[0].Op == OpSW64CMPULEconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 0 {
+				break
+			}
+			x := v_0.Args[0]
+			b.resetWithControl(BlockSW64NE, x)
+			return true
+		}
+		// match: (EQ (CMPEQ x (MOVVconst [0])) yes no)
+		// result: (NE x yes no)
+		for b.Controls[0].Op == OpSW64CMPEQ {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpSW64MOVVconst || auxIntToInt64(v_0_1.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64NE, x)
+			return true
+		}
+		// match: (EQ (CMPLT x (MOVVconst [0])) yes no)
+		// result: (GE x yes no)
+		for b.Controls[0].Op == OpSW64CMPLT {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpSW64MOVVconst || auxIntToInt64(v_0_1.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64GE, x)
+			return true
+		}
+		// match: (EQ (CMPLT x (MOVVconst [1])) yes no)
+		// result: (GT x yes no)
+		for b.Controls[0].Op == OpSW64CMPLT {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpSW64MOVVconst || auxIntToInt64(v_0_1.AuxInt) != 1 {
+				break
+			}
+			b.resetWithControl(BlockSW64GT, x)
+			return true
+		}
+		// match: (EQ (CMPLE x (MOVVconst [0])) yes no)
+		// result: (GT x yes no)
+		for b.Controls[0].Op == OpSW64CMPLE {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpSW64MOVVconst || auxIntToInt64(v_0_1.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64GT, x)
+			return true
+		}
+		// match: (EQ (CMPULT x (MOVVconst [1])) yes no)
+		// result: (NE x yes no)
+		for b.Controls[0].Op == OpSW64CMPULT {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpSW64MOVVconst || auxIntToInt64(v_0_1.AuxInt) != 1 {
+				break
+			}
+			b.resetWithControl(BlockSW64NE, x)
+			return true
+		}
+		// match: (EQ (CMPULE x (MOVVconst [0])) yes no)
+		// result: (NE x yes no)
+		for b.Controls[0].Op == OpSW64CMPULE {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpSW64MOVVconst || auxIntToInt64(v_0_1.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64NE, x)
+			return true
+		}
+		// match: (EQ (CMPEQ (MOVVconst [0]) x) yes no)
+		// result: (NE x yes no)
+		for b.Controls[0].Op == OpSW64CMPEQ {
+			v_0 := b.Controls[0]
+			x := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpSW64MOVVconst || auxIntToInt64(v_0_0.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64NE, x)
+			return true
+		}
+		// match: (EQ (CMPLT (MOVVconst [0]) x) yes no)
+		// result: (LE x yes no)
+		for b.Controls[0].Op == OpSW64CMPLT {
+			v_0 := b.Controls[0]
+			x := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpSW64MOVVconst || auxIntToInt64(v_0_0.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64LE, x)
+			return true
+		}
+		// match: (EQ (CMPLE (MOVVconst [0]) x) yes no)
+		// result: (LT x yes no)
+		for b.Controls[0].Op == OpSW64CMPLE {
+			v_0 := b.Controls[0]
+			x := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpSW64MOVVconst || auxIntToInt64(v_0_0.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64LT, x)
+			return true
+		}
+		// match: (EQ (CMPLE (MOVVconst [1]) x) yes no)
+		// result: (LE x yes no)
+		for b.Controls[0].Op == OpSW64CMPLE {
+			v_0 := b.Controls[0]
+			x := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpSW64MOVVconst || auxIntToInt64(v_0_0.AuxInt) != 1 {
+				break
+			}
+			b.resetWithControl(BlockSW64LE, x)
+			return true
+		}
+		// match: (EQ (CMPULT (MOVVconst [0]) x) yes no)
+		// result: (EQ x yes no)
+		for b.Controls[0].Op == OpSW64CMPULT {
+			v_0 := b.Controls[0]
+			x := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpSW64MOVVconst || auxIntToInt64(v_0_0.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64EQ, x)
+			return true
+		}
+		// match: (EQ (CMPULE (MOVVconst [1]) x) yes no)
+		// result: (EQ x yes no)
+		for b.Controls[0].Op == OpSW64CMPULE {
+			v_0 := b.Controls[0]
+			x := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpSW64MOVVconst || auxIntToInt64(v_0_0.AuxInt) != 1 {
+				break
+			}
+			b.resetWithControl(BlockSW64EQ, x)
+			return true
+		}
+		// match: (EQ (FNotEqual cmp) yes no)
+		// result: (FNE cmp yes no)
+		for b.Controls[0].Op == OpSW64FNotEqual {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
+			b.resetWithControl(BlockSW64FNE, cmp)
+			return true
+		}
+		// match: (EQ (FEqual cmp) yes no)
+		// result: (FEQ cmp yes no)
+		for b.Controls[0].Op == OpSW64FEqual {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
+			b.resetWithControl(BlockSW64FEQ, cmp)
+			return true
+		}
+	case BlockIf:
+		// match: (If cond yes no)
+		// result: (LBS cond yes no)
+		for {
+			cond := b.Controls[0]
+			b.resetWithControl(BlockSW64LBS, cond)
+			return true
+		}
+	case BlockJumpTable:
+		// match: (JumpTable idx)
+		// result: (JUMPTABLE {makeJumpTableSym(b)} idx (SYMADDR <typ.Uintptr> {makeJumpTableSym(b)} (SB)))
+		for {
+			idx := b.Controls[0]
+			v0 := b.NewValue0(b.Pos, OpSW64SYMADDR, typ.Uintptr)
+			v0.Aux = symToAux(makeJumpTableSym(b))
+			v1 := b.NewValue0(b.Pos, OpSB, typ.Uintptr)
+			v0.AddArg(v1)
+			b.resetWithControl2(BlockSW64JUMPTABLE, idx, v0)
+			b.Aux = symToAux(makeJumpTableSym(b))
+			return true
+		}
+	case BlockSW64LBS:
+		// match: (LBS (CMPEQ x y) yes no)
+		// result: (NE (CMPEQ x y) yes no)
+		for b.Controls[0].Op == OpSW64CMPEQ {
+			v_0 := b.Controls[0]
+			y := v_0.Args[1]
+			x := v_0.Args[0]
+			v0 := b.NewValue0(v_0.Pos, OpSW64CMPEQ, typ.Bool)
+			v0.AddArg2(x, y)
+			b.resetWithControl(BlockSW64NE, v0)
+			return true
+		}
+		// match: (LBS (XORconst (CMPEQ x y) [1]) yes no)
+		// result: (EQ (CMPEQ x y) yes no)
+		for b.Controls[0].Op == OpSW64XORconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 1 {
+				break
+			}
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpSW64CMPEQ {
+				break
+			}
+			y := v_0_0.Args[1]
+			x := v_0_0.Args[0]
+			v0 := b.NewValue0(v_0.Pos, OpSW64CMPEQ, typ.Bool)
+			v0.AddArg2(x, y)
+			b.resetWithControl(BlockSW64EQ, v0)
+			return true
+		}
+		// match: (LBS (CMPLT x y) yes no)
+		// result: (NE (CMPLT x y) yes no)
+		for b.Controls[0].Op == OpSW64CMPLT {
+			v_0 := b.Controls[0]
+			y := v_0.Args[1]
+			x := v_0.Args[0]
+			v0 := b.NewValue0(v_0.Pos, OpSW64CMPLT, typ.Bool)
+			v0.AddArg2(x, y)
+			b.resetWithControl(BlockSW64NE, v0)
+			return true
+		}
+		// match: (LBS (CMPULT x y) yes no)
+		// result: (NE (CMPULT x y) yes no)
+		for b.Controls[0].Op == OpSW64CMPULT {
+			v_0 := b.Controls[0]
+			y := v_0.Args[1]
+			x := v_0.Args[0]
+			v0 := b.NewValue0(v_0.Pos, OpSW64CMPULT, typ.Bool)
+			v0.AddArg2(x, y)
+			b.resetWithControl(BlockSW64NE, v0)
+			return true
+		}
+		// match: (LBS (CMPLE x y) yes no)
+		// result: (NE (CMPLE x y) yes no)
+		for b.Controls[0].Op == OpSW64CMPLE {
+			v_0 := b.Controls[0]
+			y := v_0.Args[1]
+			x := v_0.Args[0]
+			v0 := b.NewValue0(v_0.Pos, OpSW64CMPLE, typ.Bool)
+			v0.AddArg2(x, y)
+			b.resetWithControl(BlockSW64NE, v0)
+			return true
+		}
+		// match: (LBS (CMPULE x y) yes no)
+		// result: (NE (CMPULE x y) yes no)
+		for b.Controls[0].Op == OpSW64CMPULE {
+			v_0 := b.Controls[0]
+			y := v_0.Args[1]
+			x := v_0.Args[0]
+			v0 := b.NewValue0(v_0.Pos, OpSW64CMPULE, typ.Bool)
+			v0.AddArg2(x, y)
+			b.resetWithControl(BlockSW64NE, v0)
+			return true
+		}
+		// match: (LBS (FEqual cc) yes no)
+		// result: (FNE cc yes no)
+		for b.Controls[0].Op == OpSW64FEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
+			b.resetWithControl(BlockSW64FNE, cc)
+			return true
+		}
+		// match: (LBS (FNotEqual cc) yes no)
+		// result: (FEQ cc yes no)
+		for b.Controls[0].Op == OpSW64FNotEqual {
+			v_0 := b.Controls[0]
+			cc := v_0.Args[0]
+			b.resetWithControl(BlockSW64FEQ, cc)
+			return true
+		}
+	case BlockSW64NE:
+		// match: (NE (XORconst cmp:(CMPEQ _ _) [1]) yes no)
+		// result: (EQ cmp yes no)
+		for b.Controls[0].Op == OpSW64XORconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 1 {
+				break
+			}
+			cmp := v_0.Args[0]
+			if cmp.Op != OpSW64CMPEQ {
+				break
+			}
+			b.resetWithControl(BlockSW64EQ, cmp)
+			return true
+		}
+		// match: (NE (XORconst cmp:(CMPEQconst _) [1]) yes no)
+		// result: (EQ cmp yes no)
+		for b.Controls[0].Op == OpSW64XORconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 1 {
+				break
+			}
+			cmp := v_0.Args[0]
+			if cmp.Op != OpSW64CMPEQconst {
+				break
+			}
+			b.resetWithControl(BlockSW64EQ, cmp)
+			return true
+		}
+		// match: (NE (CMPEQconst x [0]) yes no)
+		// result: (EQ x yes no)
+		for b.Controls[0].Op == OpSW64CMPEQconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 0 {
+				break
+			}
+			x := v_0.Args[0]
+			b.resetWithControl(BlockSW64EQ, x)
+			return true
+		}
+		// match: (NE (CMPLTconst x [0]) yes no)
+		// result: (LT x yes no)
+		for b.Controls[0].Op == OpSW64CMPLTconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 0 {
+				break
+			}
+			x := v_0.Args[0]
+			b.resetWithControl(BlockSW64LT, x)
+			return true
+		}
+		// match: (NE (CMPLEconst x [0]) yes no)
+		// result: (LE x yes no)
+		for b.Controls[0].Op == OpSW64CMPLEconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 0 {
+				break
+			}
+			x := v_0.Args[0]
+			b.resetWithControl(BlockSW64LE, x)
+			return true
+		}
+		// match: (NE (CMPLTconst x [1]) yes no)
+		// result: (LE x yes no)
+		for b.Controls[0].Op == OpSW64CMPLTconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 1 {
+				break
+			}
+			x := v_0.Args[0]
+			b.resetWithControl(BlockSW64LE, x)
+			return true
+		}
+		// match: (NE (CMPULTconst x [1]) yes no)
+		// result: (EQ x yes no)
+		for b.Controls[0].Op == OpSW64CMPULTconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 1 {
+				break
+			}
+			x := v_0.Args[0]
+			b.resetWithControl(BlockSW64EQ, x)
+			return true
+		}
+		// match: (NE (CMPULEconst x [0]) yes no)
+		// result: (EQ x yes no)
+		for b.Controls[0].Op == OpSW64CMPULEconst {
+			v_0 := b.Controls[0]
+			if auxIntToInt64(v_0.AuxInt) != 0 {
+				break
+			}
+			x := v_0.Args[0]
+			b.resetWithControl(BlockSW64EQ, x)
+			return true
+		}
+		// match: (NE (CMPEQ x (MOVVconst [0])) yes no)
+		// result: (EQ x yes no)
+		for b.Controls[0].Op == OpSW64CMPEQ {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpSW64MOVVconst || auxIntToInt64(v_0_1.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64EQ, x)
+			return true
+		}
+		// match: (NE (CMPLT x (MOVVconst [0])) yes no)
+		// result: (LT x yes no)
+		for b.Controls[0].Op == OpSW64CMPLT {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpSW64MOVVconst || auxIntToInt64(v_0_1.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64LT, x)
+			return true
+		}
+		// match: (NE (CMPLT x (MOVVconst [1])) yes no)
+		// result: (LE x yes no)
+		for b.Controls[0].Op == OpSW64CMPLT {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpSW64MOVVconst || auxIntToInt64(v_0_1.AuxInt) != 1 {
+				break
+			}
+			b.resetWithControl(BlockSW64LE, x)
+			return true
+		}
+		// match: (NE (CMPLE x (MOVVconst [0])) yes no)
+		// result: (LE x yes no)
+		for b.Controls[0].Op == OpSW64CMPLE {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpSW64MOVVconst || auxIntToInt64(v_0_1.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64LE, x)
+			return true
+		}
+		// match: (NE (CMPULT x (MOVVconst [1])) yes no)
+		// result: (EQ x yes no)
+		for b.Controls[0].Op == OpSW64CMPULT {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpSW64MOVVconst || auxIntToInt64(v_0_1.AuxInt) != 1 {
+				break
+			}
+			b.resetWithControl(BlockSW64EQ, x)
+			return true
+		}
+		// match: (NE (CMPULE x (MOVVconst [0])) yes no)
+		// result: (EQ x yes no)
+		for b.Controls[0].Op == OpSW64CMPULE {
+			v_0 := b.Controls[0]
+			_ = v_0.Args[1]
+			x := v_0.Args[0]
+			v_0_1 := v_0.Args[1]
+			if v_0_1.Op != OpSW64MOVVconst || auxIntToInt64(v_0_1.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64EQ, x)
+			return true
+		}
+		// match: (NE (CMPEQ (MOVVconst [0]) x) yes no)
+		// result: (EQ x yes no)
+		for b.Controls[0].Op == OpSW64CMPEQ {
+			v_0 := b.Controls[0]
+			x := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpSW64MOVVconst || auxIntToInt64(v_0_0.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64EQ, x)
+			return true
+		}
+		// match: (NE (CMPLT (MOVVconst [0]) x) yes no)
+		// result: (GT x yes no)
+		for b.Controls[0].Op == OpSW64CMPLT {
+			v_0 := b.Controls[0]
+			x := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpSW64MOVVconst || auxIntToInt64(v_0_0.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64GT, x)
+			return true
+		}
+		// match: (NE (CMPLE (MOVVconst [0]) x) yes no)
+		// result: (GE x yes no)
+		for b.Controls[0].Op == OpSW64CMPLE {
+			v_0 := b.Controls[0]
+			x := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpSW64MOVVconst || auxIntToInt64(v_0_0.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64GE, x)
+			return true
+		}
+		// match: (NE (CMPLE (MOVVconst [1]) x) yes no)
+		// result: (GT x yes no)
+		for b.Controls[0].Op == OpSW64CMPLE {
+			v_0 := b.Controls[0]
+			x := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpSW64MOVVconst || auxIntToInt64(v_0_0.AuxInt) != 1 {
+				break
+			}
+			b.resetWithControl(BlockSW64GT, x)
+			return true
+		}
+		// match: (NE (CMPULT (MOVVconst [0]) x) yes no)
+		// result: (NE x yes no)
+		for b.Controls[0].Op == OpSW64CMPULT {
+			v_0 := b.Controls[0]
+			x := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpSW64MOVVconst || auxIntToInt64(v_0_0.AuxInt) != 0 {
+				break
+			}
+			b.resetWithControl(BlockSW64NE, x)
+			return true
+		}
+		// match: (NE (CMPULE (MOVVconst [1]) x) yes no)
+		// result: (NE x yes no)
+		for b.Controls[0].Op == OpSW64CMPULE {
+			v_0 := b.Controls[0]
+			x := v_0.Args[1]
+			v_0_0 := v_0.Args[0]
+			if v_0_0.Op != OpSW64MOVVconst || auxIntToInt64(v_0_0.AuxInt) != 1 {
+				break
+			}
+			b.resetWithControl(BlockSW64NE, x)
+			return true
+		}
+		// match: (NE (FNotEqual cmp) yes no)
+		// result: (FEQ cmp yes no)
+		for b.Controls[0].Op == OpSW64FNotEqual {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
+			b.resetWithControl(BlockSW64FEQ, cmp)
+			return true
+		}
+		// match: (NE (FEqual cmp) yes no)
+		// result: (FNE cmp yes no)
+		for b.Controls[0].Op == OpSW64FEqual {
+			v_0 := b.Controls[0]
+			cmp := v_0.Args[0]
+			b.resetWithControl(BlockSW64FNE, cmp)
+			return true
+		}
+	}
+	return false
+}
diff --git a/src/cmd/compile/internal/ssa/schedule.go b/src/cmd/compile/internal/ssa/schedule.go
index fb38f40d..cea43e11 100644
--- a/src/cmd/compile/internal/ssa/schedule.go
+++ b/src/cmd/compile/internal/ssa/schedule.go
@@ -90,7 +90,7 @@ func (op Op) isLoweredGetClosurePtr() bool {
 	switch op {
 	case OpAMD64LoweredGetClosurePtr, OpPPC64LoweredGetClosurePtr, OpARMLoweredGetClosurePtr, OpARM64LoweredGetClosurePtr,
 		Op386LoweredGetClosurePtr, OpMIPS64LoweredGetClosurePtr, OpLOONG64LoweredGetClosurePtr, OpS390XLoweredGetClosurePtr, OpMIPSLoweredGetClosurePtr,
-		OpRISCV64LoweredGetClosurePtr, OpWasmLoweredGetClosurePtr:
+		OpRISCV64LoweredGetClosurePtr, OpWasmLoweredGetClosurePtr, OpSW64LoweredGetClosurePtr:
 		return true
 	}
 	return false
diff --git a/src/cmd/compile/internal/ssagen/ssa.go b/src/cmd/compile/internal/ssagen/ssa.go
index c794d6ff..f78b8c8a 100644
--- a/src/cmd/compile/internal/ssagen/ssa.go
+++ b/src/cmd/compile/internal/ssagen/ssa.go
@@ -4294,21 +4294,21 @@ func InitTables() {
 			s.vars[memVar] = s.newValue1(ssa.OpSelect1, types.TypeMem, v)
 			return s.newValue1(ssa.OpSelect0, types.Types[types.TUINT32], v)
 		},
-		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X)
+		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.SW64)
 	addF("runtime/internal/atomic", "Load8",
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			v := s.newValue2(ssa.OpAtomicLoad8, types.NewTuple(types.Types[types.TUINT8], types.TypeMem), args[0], s.mem())
 			s.vars[memVar] = s.newValue1(ssa.OpSelect1, types.TypeMem, v)
 			return s.newValue1(ssa.OpSelect0, types.Types[types.TUINT8], v)
 		},
-		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X)
+		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.SW64)
 	addF("runtime/internal/atomic", "Load64",
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			v := s.newValue2(ssa.OpAtomicLoad64, types.NewTuple(types.Types[types.TUINT64], types.TypeMem), args[0], s.mem())
 			s.vars[memVar] = s.newValue1(ssa.OpSelect1, types.TypeMem, v)
 			return s.newValue1(ssa.OpSelect0, types.Types[types.TUINT64], v)
 		},
-		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X)
+		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.SW64)
 	addF("runtime/internal/atomic", "LoadAcq",
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			v := s.newValue2(ssa.OpAtomicLoadAcq32, types.NewTuple(types.Types[types.TUINT32], types.TypeMem), args[0], s.mem())
@@ -4329,32 +4329,32 @@ func InitTables() {
 			s.vars[memVar] = s.newValue1(ssa.OpSelect1, types.TypeMem, v)
 			return s.newValue1(ssa.OpSelect0, s.f.Config.Types.BytePtr, v)
 		},
-		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X)
+		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.SW64)
 
 	addF("runtime/internal/atomic", "Store",
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			s.vars[memVar] = s.newValue3(ssa.OpAtomicStore32, types.TypeMem, args[0], args[1], s.mem())
 			return nil
 		},
-		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X)
+		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.SW64)
 	addF("runtime/internal/atomic", "Store8",
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			s.vars[memVar] = s.newValue3(ssa.OpAtomicStore8, types.TypeMem, args[0], args[1], s.mem())
 			return nil
 		},
-		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X)
+		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.SW64)
 	addF("runtime/internal/atomic", "Store64",
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			s.vars[memVar] = s.newValue3(ssa.OpAtomicStore64, types.TypeMem, args[0], args[1], s.mem())
 			return nil
 		},
-		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X)
+		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.SW64)
 	addF("runtime/internal/atomic", "StorepNoWB",
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			s.vars[memVar] = s.newValue3(ssa.OpAtomicStorePtrNoWB, types.TypeMem, args[0], args[1], s.mem())
 			return nil
 		},
-		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.RISCV64, sys.S390X)
+		sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.RISCV64, sys.S390X, sys.SW64)
 	addF("runtime/internal/atomic", "StoreRel",
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			s.vars[memVar] = s.newValue3(ssa.OpAtomicStoreRel32, types.TypeMem, args[0], args[1], s.mem())
@@ -4374,14 +4374,14 @@ func InitTables() {
 			s.vars[memVar] = s.newValue1(ssa.OpSelect1, types.TypeMem, v)
 			return s.newValue1(ssa.OpSelect0, types.Types[types.TUINT32], v)
 		},
-		sys.AMD64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X)
+		sys.AMD64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.SW64)
 	addF("runtime/internal/atomic", "Xchg64",
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			v := s.newValue3(ssa.OpAtomicExchange64, types.NewTuple(types.Types[types.TUINT64], types.TypeMem), args[0], args[1], s.mem())
 			s.vars[memVar] = s.newValue1(ssa.OpSelect1, types.TypeMem, v)
 			return s.newValue1(ssa.OpSelect0, types.Types[types.TUINT64], v)
 		},
-		sys.AMD64, sys.Loong64, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X)
+		sys.AMD64, sys.Loong64, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.SW64)
 
 	type atomicOpEmitter func(s *state, n *ir.CallExpr, args []*ssa.Value, op ssa.Op, typ types.Kind)
 
@@ -4439,14 +4439,14 @@ func InitTables() {
 			s.vars[memVar] = s.newValue1(ssa.OpSelect1, types.TypeMem, v)
 			return s.newValue1(ssa.OpSelect0, types.Types[types.TUINT32], v)
 		},
-		sys.AMD64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X)
+		sys.AMD64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.SW64)
 	addF("runtime/internal/atomic", "Xadd64",
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			v := s.newValue3(ssa.OpAtomicAdd64, types.NewTuple(types.Types[types.TUINT64], types.TypeMem), args[0], args[1], s.mem())
 			s.vars[memVar] = s.newValue1(ssa.OpSelect1, types.TypeMem, v)
 			return s.newValue1(ssa.OpSelect0, types.Types[types.TUINT64], v)
 		},
-		sys.AMD64, sys.Loong64, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X)
+		sys.AMD64, sys.Loong64, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.SW64)
 
 	addF("runtime/internal/atomic", "Xadd",
 		makeAtomicGuardedIntrinsicARM64(ssa.OpAtomicAdd32, ssa.OpAtomicAdd32Variant, types.TUINT32, types.TUINT32, atomicXchgXaddEmitterARM64),
@@ -4461,14 +4461,14 @@ func InitTables() {
 			s.vars[memVar] = s.newValue1(ssa.OpSelect1, types.TypeMem, v)
 			return s.newValue1(ssa.OpSelect0, types.Types[types.TBOOL], v)
 		},
-		sys.AMD64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X)
+		sys.AMD64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.SW64)
 	addF("runtime/internal/atomic", "Cas64",
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			v := s.newValue4(ssa.OpAtomicCompareAndSwap64, types.NewTuple(types.Types[types.TBOOL], types.TypeMem), args[0], args[1], args[2], s.mem())
 			s.vars[memVar] = s.newValue1(ssa.OpSelect1, types.TypeMem, v)
 			return s.newValue1(ssa.OpSelect0, types.Types[types.TBOOL], v)
 		},
-		sys.AMD64, sys.Loong64, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X)
+		sys.AMD64, sys.Loong64, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.SW64)
 	addF("runtime/internal/atomic", "CasRel",
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			v := s.newValue4(ssa.OpAtomicCompareAndSwap32, types.NewTuple(types.Types[types.TBOOL], types.TypeMem), args[0], args[1], args[2], s.mem())
@@ -4584,7 +4584,7 @@ func InitTables() {
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			return s.newValue1(ssa.OpSqrt, types.Types[types.TFLOAT64], args[0])
 		},
-		sys.I386, sys.AMD64, sys.ARM, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.Wasm)
+		sys.I386, sys.AMD64, sys.ARM, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.Wasm, sys.SW64)
 	addF("math", "Trunc",
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			return s.newValue1(ssa.OpTrunc, types.Types[types.TFLOAT64], args[0])
@@ -4614,12 +4614,12 @@ func InitTables() {
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			return s.newValue1(ssa.OpAbs, types.Types[types.TFLOAT64], args[0])
 		},
-		sys.ARM64, sys.ARM, sys.PPC64, sys.RISCV64, sys.Wasm, sys.MIPS, sys.MIPS64)
+		sys.ARM64, sys.ARM, sys.PPC64, sys.RISCV64, sys.Wasm, sys.MIPS, sys.MIPS64, sys.SW64)
 	addF("math", "Copysign",
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			return s.newValue2(ssa.OpCopysign, types.Types[types.TFLOAT64], args[0], args[1])
 		},
-		sys.PPC64, sys.RISCV64, sys.Wasm)
+		sys.PPC64, sys.RISCV64, sys.Wasm, sys.SW64)
 	addF("math", "FMA",
 		func(s *state, n *ir.CallExpr, args []*ssa.Value) *ssa.Value {
 			return s.newValue3(ssa.OpFMA, types.Types[types.TFLOAT64], args[0], args[1], args[2])
@@ -8085,7 +8085,7 @@ func (s *State) Call(v *ssa.Value) *obj.Prog {
 		switch Arch.LinkArch.Family {
 		case sys.AMD64, sys.I386, sys.PPC64, sys.RISCV64, sys.S390X, sys.Wasm:
 			p.To.Type = obj.TYPE_REG
-		case sys.ARM, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64:
+		case sys.ARM, sys.ARM64, sys.Loong64, sys.MIPS, sys.MIPS64, sys.SW64:
 			p.To.Type = obj.TYPE_MEM
 		default:
 			base.Fatalf("unknown indirect call family")
diff --git a/src/cmd/compile/internal/sw64/galign.go b/src/cmd/compile/internal/sw64/galign.go
new file mode 100644
index 00000000..853a5c45
--- /dev/null
+++ b/src/cmd/compile/internal/sw64/galign.go
@@ -0,0 +1,28 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package sw64
+
+import (
+	"cmd/compile/internal/ssa"
+	"cmd/compile/internal/ssagen"
+	"cmd/internal/obj/sw64"
+)
+
+func Init(arch *ssagen.ArchInfo) {
+	arch.LinkArch = &sw64.LinkSW64
+	arch.REGSP = sw64.REGSP
+	arch.MAXWIDTH = 1 << 50
+
+	arch.ZeroRange = zerorange
+	//arch.ZeroAuto = zeroAuto //zxw new change
+	arch.Ginsnop = ginsnop
+	//arch.Ginsnopdefer = ginsnop //zxw new add
+
+	arch.SSAMarkMoves = func(s *ssagen.State, b *ssa.Block) {}
+	arch.SSAGenValue = ssaGenValue
+	arch.SSAGenBlock = ssaGenBlock
+	arch.LoadRegResult = loadRegResult
+	arch.SpillArgReg = spillArgReg
+}
diff --git a/src/cmd/compile/internal/sw64/ggen.go b/src/cmd/compile/internal/sw64/ggen.go
new file mode 100644
index 00000000..d6596017
--- /dev/null
+++ b/src/cmd/compile/internal/sw64/ggen.go
@@ -0,0 +1,33 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package sw64
+
+import (
+	"cmd/compile/internal/objw"
+	"cmd/compile/internal/types"
+	"cmd/internal/obj"
+	"cmd/internal/obj/sw64"
+)
+
+func zerorange(pp *objw.Progs, p *obj.Prog, off, cnt int64, _ *uint32) *obj.Prog {
+	base := p.Ctxt.Arch.FixedFrameSize + off
+	for i := int64(0); i < cnt; i += int64(types.PtrSize) {
+		// STL ZERO, FixedFrameSize+off+i(SP)
+		p = pp.Append(p, sw64.ASTL, obj.TYPE_REG, sw64.REGZERO, 0, obj.TYPE_MEM, sw64.REGSP, base+i)
+	}
+
+	return p
+}
+
+//zxw new change
+func ginsnop(pp *objw.Progs) *obj.Prog {
+	p := pp.Prog(sw64.ALDI)
+	p.From.Type = obj.TYPE_REG
+	p.From.Reg = sw64.REG_R31
+
+	p.To.Type = obj.TYPE_CONST
+	p.To.Offset = 0
+	return p
+}
diff --git a/src/cmd/compile/internal/sw64/ssa.go b/src/cmd/compile/internal/sw64/ssa.go
new file mode 100644
index 00000000..33a59f4e
--- /dev/null
+++ b/src/cmd/compile/internal/sw64/ssa.go
@@ -0,0 +1,1140 @@
+// Copyright 2016 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package sw64
+
+import (
+	"cmd/compile/internal/base"
+	"cmd/compile/internal/ir"
+	"cmd/compile/internal/logopt"
+	"cmd/compile/internal/objw"
+	"cmd/compile/internal/ssa"
+	"cmd/compile/internal/ssagen"
+	"cmd/compile/internal/types"
+	"cmd/internal/obj"
+	"cmd/internal/obj/sw64"
+	"math"
+)
+
+// isFPreg returns whether r is an FP register
+func isFPreg(r int16) bool {
+	return sw64.REG_F0 <= r && r <= sw64.REG_F31
+}
+
+func loadByType(t *types.Type, r int16) obj.As {
+	if sw64.IsFReg(int(r)) {
+		if t.Size() == 4 {
+			return sw64.AFLDS
+		}
+		if t.Size() == 8 {
+			return sw64.AFLDD
+		}
+		panic("bad load type")
+	}
+	switch t.Size() {
+	case 1:
+		return sw64.ALDBU
+	case 2:
+		return sw64.ALDHU
+	case 4:
+		return sw64.ALDW
+	case 8:
+		return sw64.ALDL
+	}
+	panic("bad load type")
+}
+
+func storeByType(t *types.Type, r int16) obj.As {
+	if sw64.IsFReg(int(r)) {
+		if t.Size() == 4 {
+			return sw64.AFSTS
+		}
+		if t.Size() == 8 {
+			return sw64.AFSTD
+		}
+		panic("bad store type")
+	}
+
+	switch t.Size() {
+	case 1:
+		return sw64.ASTB
+	case 2:
+		return sw64.ASTH
+	case 4:
+		return sw64.ASTW
+	case 8:
+		return sw64.ASTL
+	}
+	panic("bad store type")
+}
+
+func ssaGenValue(s *ssagen.State, v *ssa.Value) {
+	switch v.Op {
+	case ssa.OpLoadReg:
+		r := v.Reg()
+		p := s.Prog(loadByType(v.Type, r))
+
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = r
+
+		ssagen.AddrAuto(&p.To, v.Args[0])
+	case ssa.OpStoreReg:
+		r := v.Args[0].Reg()
+		p := s.Prog(storeByType(v.Type, r))
+
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = r
+
+		ssagen.AddrAuto(&p.To, v)
+	case ssa.OpArgIntReg, ssa.OpArgFloatReg:
+		// The assembler needs to wrap the entry safepoint/stack growth code with spill/unspill
+		// The loop only runs once.
+		for _, a := range v.Block.Func.RegArgs {
+			// Pass the spill/unspill information along to the assembler, offset by size of
+			// the saved LR slot.
+			addr := ssagen.SpillSlotAddr(a, sw64.REGSP, base.Ctxt.Arch.FixedFrameSize)
+			s.FuncInfo().AddSpill(
+				obj.RegSpill{Reg: a.Reg, Addr: addr, Unspill: loadByType(a.Type, a.Reg), Spill: storeByType(a.Type, a.Reg)})
+		}
+		v.Block.Func.RegArgs = nil
+		ssagen.CheckArgReg(v)
+	case ssa.OpSW64CALLstatic:
+		s.Call(v)
+	case ssa.OpSW64CALLclosure, ssa.OpSW64CALLinter:
+		_, ok := v.Aux.(*obj.LSym)
+		if !ok && v.Args[0].Reg() != sw64.REG_R27 {
+			// TODO(snyh): remove this if we can restrict ACALL use R27 in ssa
+			p := s.Prog(sw64.ALDI)
+			p.From = obj.Addr{Type: obj.TYPE_REG, Reg: sw64.REG_R27}
+			p.To = obj.Addr{Type: obj.TYPE_ADDR, Reg: v.Args[0].Reg()}
+		}
+		s.Call(v)
+	case ssa.OpSW64CALLtail:
+		s.TailCall(v)
+	case ssa.OpSW64LoweredWB:
+		p := s.Prog(obj.ACALL)
+		p.To.Type = obj.TYPE_MEM
+		p.To.Name = obj.NAME_EXTERN
+		// AuxInt encodes how many buffer entries we need.
+		p.To.Sym = ir.Syms.GCWriteBarrier[v.AuxInt-1]
+	case ssa.OpSW64MOVVnop:
+		// nothing to do
+	case ssa.OpSW64FCVTSD,
+		ssa.OpSW64FCVTDS,
+		ssa.OpSW64IFMOVD,
+		ssa.OpSW64IFMOVS,
+		ssa.OpSW64FIMOVD,
+		ssa.OpSW64FIMOVS,
+		ssa.OpSW64FCVTDL,
+		ssa.OpSW64FCVTLS,
+		ssa.OpSW64FCVTLD,
+		ssa.OpSW64FCVTLW,
+		ssa.OpSW64FCVTWL,
+		ssa.OpSW64FSQRTS,
+		ssa.OpSW64FSQRTD,
+		ssa.OpSW64CTLZ,
+		ssa.OpSW64CTTZ,
+		ssa.OpSW64CTPOP,
+		ssa.OpSW64SEXTB,
+		ssa.OpSW64SEXTH,
+		ssa.OpSW64FCVTDL_Z,
+		ssa.OpSW64FCVTDL_P,
+		ssa.OpSW64FCVTDL_G,
+		ssa.OpSW64FCVTDL_N,
+		ssa.OpSW64MOVBreg,
+		ssa.OpSW64MOVBUreg,
+		ssa.OpSW64MOVHreg,
+		ssa.OpSW64MOVHUreg,
+		ssa.OpSW64MOVWreg,
+		ssa.OpSW64MOVWUreg,
+		ssa.OpSW64MOVVreg:
+		p := s.Prog(v.Op.Asm())
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Args[0].Reg()
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = v.Reg()
+	case ssa.OpSW64SEXTBconst,
+		ssa.OpSW64SEXTHconst:
+		p := s.Prog(v.Op.Asm())
+		p.From.Type = obj.TYPE_CONST
+		p.From.Offset = v.AuxInt
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = v.Reg()
+	case ssa.OpSW64FADDS,
+		ssa.OpSW64FADDD,
+		ssa.OpSW64FSUBD,
+		ssa.OpSW64FSUBS,
+		ssa.OpSW64FMULS,
+		ssa.OpSW64FMULD,
+		ssa.OpSW64FDIVS,
+		ssa.OpSW64FDIVD,
+		ssa.OpSW64FCPYS,
+		ssa.OpSW64ADDV,
+		ssa.OpSW64ADDW,
+		ssa.OpSW64S4ADDV,
+		ssa.OpSW64S8ADDV,
+		ssa.OpSW64SUBV,
+		ssa.OpSW64S4SUBV,
+		ssa.OpSW64S8SUBV,
+		ssa.OpSW64MULW,
+		ssa.OpSW64MULL,
+		ssa.OpSW64UMULH,
+		ssa.OpSW64AND,
+		ssa.OpSW64BIS,
+		ssa.OpSW64XOR,
+		ssa.OpSW64ORNOT,
+		ssa.OpSW64SLL,
+		ssa.OpSW64SRL,
+		ssa.OpSW64SRA:
+		p := s.Prog(v.Op.Asm())
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Args[0].Reg()
+		p.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  v.Args[1].Reg(),
+		})
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = v.Reg()
+
+	case ssa.OpSW64DIVV,
+		ssa.OpSW64UDIVV,
+		ssa.OpSW64DIVW,
+		ssa.OpSW64UDIVW:
+		// z := sdiv intXX, x , y
+		// will fault on division with -1, fix it
+		//x := v.Args[1].Reg()
+
+		var j *obj.Prog
+		if v.Op == ssa.OpSW64DIVV || v.Op == ssa.OpSW64DIVW {
+			if ssa.DivisionNeedsFixUp(v) {
+				var c *obj.Prog
+				l := s.Prog(sw64.ALDI)
+				l.From.Type = obj.TYPE_REG
+				l.From.Reg = sw64.REGTMP
+				l.To.Type = obj.TYPE_CONST
+				l.To.Offset = -1
+
+				c = s.Prog(sw64.ACMPEQ)
+				j = s.Prog(sw64.ABNE)
+
+				c.From.Type = obj.TYPE_REG
+				c.From.Reg = sw64.REGTMP
+				c.To.Type = obj.TYPE_REG
+				c.To.Reg = sw64.REGTMP
+				c.AddRestSource(obj.Addr{
+					Type: obj.TYPE_REG,
+					Reg:  v.Args[1].Reg(),
+				})
+
+				j.From.Type = obj.TYPE_REG
+				j.From.Reg = sw64.REGTMP
+				j.To.Type = obj.TYPE_BRANCH
+			}
+		}
+
+		var j2 *obj.Prog
+		var n *obj.Prog
+
+		p := s.Prog(v.Op.Asm())
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Args[0].Reg()
+		p.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  v.Args[1].Reg(),
+		})
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = v.Reg()
+
+		if j != nil {
+			j2 = s.Prog(sw64.ABR)
+			j2.From.Type = obj.TYPE_REG
+			j2.From.Reg = sw64.REG_R31
+			j2.To.Type = obj.TYPE_BRANCH
+
+			if v.Op == ssa.OpSW64DIVV || v.Op == ssa.OpSW64DIVW {
+				// n / -1 = -n
+				n = s.Prog(sw64.ASUBL)
+				n.From.Type = obj.TYPE_REG
+				n.From.Reg = sw64.REG_R31
+				n.AddRestSource(obj.Addr{
+					Type: obj.TYPE_REG,
+					Reg:  v.Args[0].Reg(),
+				})
+
+				n.To.Type = obj.TYPE_REG
+				n.To.Reg = v.Reg()
+			}
+			//			j3 = s.Prog(sw64.ABR)
+			//			j3.From.Type = obj.TYPE_REG
+			//			j3.From.Reg = sw64.REG_R31
+			//			j3.To.Type = obj.TYPE_BRANCH
+
+			//			if n != nil {
+			j.To.SetTarget(n)
+			j2.To.SetTarget(s.Pc())
+			//			}
+		}
+
+		//		if j2 != nil {
+		//j3.To.SetTarget(s.Pc())
+		//		}
+
+	case ssa.OpSW64FABS:
+		p := s.Prog(v.Op.Asm())
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = sw64.REG_F31
+		p.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  v.Args[0].Reg(),
+		})
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = v.Reg()
+
+	case ssa.OpSW64CALLudiv:
+		p := s.Prog(obj.ACALL)
+		p.To.Type = obj.TYPE_MEM
+		p.To.Name = obj.NAME_EXTERN
+		p.To.Sym = ir.Syms.Udiv
+	case ssa.OpSW64ADDVconst,
+		ssa.OpSW64ADDWconst,
+		ssa.OpSW64SUBVconst,
+		ssa.OpSW64MULWconst,
+		ssa.OpSW64MULLconst,
+		ssa.OpSW64UMULHconst,
+		ssa.OpSW64DIVVconst,
+		ssa.OpSW64ANDconst,
+		ssa.OpSW64BISconst,
+		ssa.OpSW64XORconst,
+		ssa.OpSW64ORNOTconst,
+		ssa.OpSW64SLLconst,
+		ssa.OpSW64SRLconst,
+		ssa.OpSW64SRAconst,
+		ssa.OpSW64CMPLEconst,
+		ssa.OpSW64CMPLTconst,
+		ssa.OpSW64CMPEQconst,
+		ssa.OpSW64CMPULEconst,
+		ssa.OpSW64CMPULTconst,
+		ssa.OpSW64ZAPNOTconst:
+		p := s.Prog(v.Op.Asm())
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Args[0].Reg()
+		ib := obj.Addr{
+			Type:   obj.TYPE_CONST,
+			Offset: v.AuxInt,
+		}
+		p.AddRestSource(ib)
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = v.Reg()
+	case ssa.OpSW64NEGV:
+		// SUB from REGZERO
+		p := s.Prog(v.Op.Asm())
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = sw64.REGZERO
+		p.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  v.Args[0].Reg(),
+		})
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = v.Reg()
+	case ssa.OpSW64NEGF,
+		ssa.OpSW64NEGD:
+		//FCPYSN Fx,Fx,Fy
+		p := s.Prog(v.Op.Asm())
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Args[0].Reg()
+		p.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  v.Args[0].Reg(),
+		})
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = v.Reg()
+	case ssa.OpSW64MOVBstorezero,
+		ssa.OpSW64MOVHstorezero,
+		ssa.OpSW64MOVWstorezero,
+		ssa.OpSW64MOVVstorezero:
+		p := s.Prog(v.Op.Asm())
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = sw64.REGZERO
+		p.To.Type = obj.TYPE_MEM
+		p.To.Reg = v.Args[0].Reg()
+		ssagen.AddAux(&p.To, v)
+	case ssa.OpSW64MOVBstore,
+		ssa.OpSW64MOVHstore,
+		ssa.OpSW64MOVWstore,
+		ssa.OpSW64MOVVstore,
+		ssa.OpSW64MOVFstore,
+		ssa.OpSW64MOVDstore:
+		p := s.Prog(v.Op.Asm())
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Args[1].Reg()
+		p.To.Type = obj.TYPE_MEM
+		p.To.Reg = v.Args[0].Reg()
+		ssagen.AddAux(&p.To, v)
+	case ssa.OpSW64MOVBload,
+		ssa.OpSW64MOVBUload,
+		ssa.OpSW64MOVHload,
+		ssa.OpSW64MOVHUload,
+		ssa.OpSW64MOVWload,
+		ssa.OpSW64MOVWUload,
+		ssa.OpSW64MOVVload,
+		ssa.OpSW64MOVFload,
+		ssa.OpSW64MOVDload:
+		p := s.Prog(v.Op.Asm())
+		p.To.Type = obj.TYPE_MEM
+		p.To.Reg = v.Args[0].Reg()
+		ssagen.AddAux(&p.To, v)
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Reg()
+
+	case ssa.OpSW64SYMADDR:
+		// arg0 + auxInt + aux.(*gc.Sym), arg0=SP/SB
+		p := s.Prog(sw64.ASYMADDR)
+		p.To.Type = obj.TYPE_ADDR
+		p.To.Reg = v.Args[0].Reg()
+		var wantreg string
+		// LDL R, $sym+off(base)
+		// the assembler expands it as the following:
+		// - base is SP: add constant offset to SP
+		//               when constant is large, tmp registe may be used
+		// - base is SB: load external address with relocation
+		switch v.Aux.(type) {
+		default:
+			v.Fatalf("aux is of unknown type %T", v.Aux)
+		case *obj.LSym:
+			wantreg = "SB"
+			ssagen.AddAux(&p.To, v)
+		case *ir.Name:
+			// TODO: can ir change Node interface ?
+			p.As = sw64.ALDI
+			wantreg = "SP"
+			ssagen.AddAux(&p.To, v)
+		case nil:
+			p.As = sw64.ALDI
+			// No sym, just LDL R, $off(SP)
+			wantreg = "SP"
+			p.To.Offset = v.AuxInt
+		}
+		if reg := v.Args[0].RegName(); reg != wantreg {
+			v.Fatalf("bad reg %s for symbol type %T, want %s", reg, v.Aux, wantreg)
+		}
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Reg()
+
+	case ssa.OpCopy, ssa.OpSW64MOVVconvert:
+		if v.Type.IsMemory() {
+			return
+		}
+		x := int(v.Args[0].Reg())
+		y := int(v.Reg())
+		if x == y {
+			return
+		}
+		var as obj.As
+		switch {
+		case sw64.IsFReg(x) && sw64.IsRReg(y) && v.Type.Size() == 4:
+			as = sw64.AFIMOVS
+		case sw64.IsFReg(x) && sw64.IsRReg(y) && v.Type.Size() == 8:
+			as = sw64.AFIMOVD
+		case sw64.IsRReg(x) && sw64.IsFReg(y) && v.Type.Size() == 4:
+			as = sw64.AIFMOVS
+		case sw64.IsRReg(x) && sw64.IsFReg(y) && v.Type.Size() == 8:
+			as = sw64.AIFMOVD
+		case sw64.IsRReg(x) && sw64.IsRReg(y):
+			as = sw64.ALDI
+			x, y = y, x
+		case sw64.IsFReg(x) && sw64.IsFReg(y):
+			as = sw64.AFCPYS
+		default:
+			v.Fatalf("not implement OpCopy with %v and %v. %s\n",
+				x&63, y&63,
+				v.LongString())
+		}
+		p := s.Prog(as)
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = int16(x)
+		if as == sw64.AFCPYS {
+			p.AddRestSource(obj.Addr{
+				Type: obj.TYPE_REG,
+				Reg:  int16(x),
+			})
+		}
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = int16(y)
+	case ssa.OpSW64MOVFconst,
+		ssa.OpSW64MOVDconst:
+		p := s.Prog(v.Op.Asm())
+		p.To.Type = obj.TYPE_FCONST
+		p.To.Val = math.Float64frombits(uint64(v.AuxInt))
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Reg()
+	case ssa.OpSW64CMPEQ, ssa.OpSW64CMPLE, ssa.OpSW64CMPLT,
+		ssa.OpSW64CMPULE, ssa.OpSW64CMPULT, ssa.OpSW64FCMPUN,
+		ssa.OpSW64FCMPEQ, ssa.OpSW64FCMPLE, ssa.OpSW64FCMPLT:
+		p := s.Prog(v.Op.Asm())
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Args[0].Reg()
+		p.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  v.Args[1].Reg(),
+		})
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = v.Reg()
+	case ssa.OpSW64MOVVconst:
+		r := v.Reg()
+		p := s.Prog(v.Op.Asm())
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = r
+		p.To.Type = obj.TYPE_CONST
+		p.To.Offset = v.AuxInt
+		if isFPreg(r) {
+			// cannot move into FP registers, use TMP as intermediate
+			p.From.Reg = sw64.REGTMP
+			p = s.Prog(sw64.AIFMOVD)
+			p.From.Type = obj.TYPE_REG
+			p.From.Reg = sw64.REGTMP
+			p.To.Type = obj.TYPE_REG
+			p.To.Reg = r
+		}
+
+	case ssa.OpSW64LoweredNilCheck:
+		// Issue a load which will fault if arg is nil.
+		p := s.Prog(sw64.ALDBU)
+		p.To.Type = obj.TYPE_MEM
+		p.To.Reg = v.Args[0].Reg()
+		ssagen.AddAux(&p.To, v)
+
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = sw64.REGTMP
+		if logopt.Enabled() {
+			logopt.LogOpt(v.Pos, "nilcheck", "genssa", v.Block.Func.Name)
+		}
+
+		if base.Debug.Nil != 0 && v.Pos.Line() > 1 { // v.Pos.Line()==1 in generated wrappers
+			base.WarnfAt(v.Pos, "generated nil check")
+		}
+	case ssa.OpSW64DUFFZERO:
+		// runtime.duffzero expects start address - 8 in R1
+
+		//SUBL arg0.REG, $8, R1
+		p := s.Prog(sw64.ASUBL)
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Args[0].Reg()
+		p.AddRestSource(obj.Addr{
+			Type:   obj.TYPE_CONST,
+			Offset: 8,
+		})
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = sw64.REG_R1
+		// DUFFZERO runtime.duffzero+v.AuxInt(SB)
+		p = s.Prog(obj.ADUFFZERO)
+		p.To.Type = obj.TYPE_MEM
+		p.To.Name = obj.NAME_EXTERN
+		p.To.Sym = ir.Syms.Duffzero
+		p.To.Offset = v.AuxInt
+	case ssa.OpSW64LoweredZero:
+		//SUBL   R1, $sz ,R1
+		//STx    R31,sz(R1)
+		//ADDL   R1, $sz, R1
+		//CMPULT R1, Rarg1, REGTMP
+		//BNE    REGTMP, -3(PC)
+		var sz int64
+		var mov obj.As
+		switch {
+		case v.AuxInt%8 == 0:
+			sz = 8
+			mov = sw64.ASTL
+		case v.AuxInt%4 == 0:
+			sz = 4
+			mov = sw64.ASTW
+		case v.AuxInt%2 == 0:
+			sz = 2
+			mov = sw64.ASTH
+		default:
+			sz = 1
+			mov = sw64.ASTB
+		}
+		//SUBL R1, $sz ,R1
+		p := s.Prog(sw64.ASUBL)
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = sw64.REG_R1
+		p.AddRestSource(obj.Addr{
+			Type:   obj.TYPE_CONST,
+			Offset: sz,
+		})
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = sw64.REG_R1
+		//STx R31, sz(R1)
+		p2 := s.Prog(mov)
+		p2.From.Type = obj.TYPE_REG
+		p2.From.Reg = sw64.REGZERO
+		p2.To.Type = obj.TYPE_MEM
+		p2.To.Reg = sw64.REG_R1
+		p2.To.Offset = sz
+		//ADDL R1, $sz, R1
+		p3 := s.Prog(sw64.AADDL)
+		p3.From.Type = obj.TYPE_REG
+		p3.From.Reg = sw64.REG_R1
+		p3.AddRestSource(obj.Addr{
+			Type:   obj.TYPE_CONST,
+			Offset: sz,
+		})
+		p3.To.Type = obj.TYPE_REG
+		p3.To.Reg = sw64.REG_R1
+		//CMPULT R1, Rarg1, REGTMP
+		p4 := s.Prog(sw64.ACMPULT)
+		p4.From.Type = obj.TYPE_REG
+		p4.From.Reg = sw64.REG_R1
+		p4.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  v.Args[1].Reg(),
+		})
+		p4.To.Type = obj.TYPE_REG
+		p4.To.Reg = sw64.REGTMP
+		//BNE RGETMP, -3(PC)
+		p5 := s.Prog(sw64.ABNE)
+		p5.From.Type = obj.TYPE_REG
+		p5.From.Reg = sw64.REGTMP
+		p5.To.Type = obj.TYPE_BRANCH
+		p5.To.SetTarget(p2)
+	case ssa.OpSW64LoweredMove:
+		//SUBL R1, $8, R1
+		//LDx  Rtmp, 8(R1)
+		//STx  Rtmp, (R2)
+		//ADDL R1, $8, R1
+		//ADDL R2, $8, R2
+		//CMPULT R1, Rarg2, Rtmp
+		//BNE Rtmp, -5(PC)
+		var sz int64
+		var ldx obj.As
+		var stx obj.As
+		switch {
+		case v.AuxInt%8 == 0:
+			sz = 8
+			ldx = sw64.ALDL
+			stx = sw64.ASTL
+		case v.AuxInt%4 == 0:
+			sz = 4
+			ldx = sw64.ALDW
+			stx = sw64.ASTW
+		case v.AuxInt%2 == 0:
+			sz = 2
+			ldx = sw64.ALDHU
+			stx = sw64.ASTH
+		default:
+			sz = 1
+			ldx = sw64.ALDBU
+			stx = sw64.ASTB
+		}
+		//SUBL R1, $sz, R1
+		p := s.Prog(sw64.ASUBL)
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = sw64.REG_R1
+		p.AddRestSource(obj.Addr{
+			Type:   obj.TYPE_CONST,
+			Offset: sz,
+		})
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = sw64.REG_R1
+		//LDL Rtmp, sz(R1)
+		p2 := s.Prog(ldx)
+		p2.From.Type = obj.TYPE_REG
+		p2.From.Reg = sw64.REGTMP
+		p2.To.Offset = sz
+		p2.To.Type = obj.TYPE_MEM
+		p2.To.Reg = sw64.REG_R1
+		//STL Rtmp, (R2)
+		p3 := s.Prog(stx)
+		p3.From.Type = obj.TYPE_REG
+		p3.From.Reg = sw64.REGTMP
+		p3.To.Type = obj.TYPE_MEM
+		p3.To.Reg = sw64.REG_R2
+		//ADDL R1, $sz, R1
+		p4 := s.Prog(sw64.AADDL)
+		p4.From.Type = obj.TYPE_REG
+		p4.From.Reg = sw64.REG_R1
+		p4.AddRestSource(obj.Addr{
+			Type:   obj.TYPE_CONST,
+			Offset: sz,
+		})
+		p4.To.Type = obj.TYPE_REG
+		p4.To.Reg = sw64.REG_R1
+		//ADDL R2, $sz, R2
+		p5 := s.Prog(sw64.AADDL)
+		p5.From.Type = obj.TYPE_REG
+		p5.From.Reg = sw64.REG_R2
+		p5.AddRestSource(obj.Addr{
+			Type:   obj.TYPE_CONST,
+			Offset: sz,
+		})
+		p5.To.Type = obj.TYPE_REG
+		p5.To.Reg = sw64.REG_R2
+		//CMPULT R1, Rarg2, Rtmp
+		p6 := s.Prog(sw64.ACMPULT)
+		p6.From.Type = obj.TYPE_REG
+		p6.From.Reg = sw64.REG_R1
+		p6.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  v.Args[2].Reg(),
+		})
+		p6.To.Type = obj.TYPE_REG
+		p6.To.Reg = sw64.REGTMP
+		//BNE Rtmp, -5(PC)
+		p7 := s.Prog(sw64.ABNE)
+		p7.From.Type = obj.TYPE_REG
+		p7.From.Reg = sw64.REGTMP
+		p7.To.Type = obj.TYPE_BRANCH
+		p7.To.SetTarget(p2)
+	case ssa.OpSW64LoweredGetClosurePtr:
+		// Closure pointer is R27 (sw64.REGCTXT).
+		ssagen.CheckLoweredGetClosurePtr(v)
+	case ssa.OpSW64LoweredGetCallerSP:
+		// caller's SP is FixedFrameSize below the address of the first arg
+		p := s.Prog(sw64.ALDI)
+		p.To.Type = obj.TYPE_ADDR
+		p.To.Offset = -base.Ctxt.Arch.FixedFrameSize
+		p.To.Name = obj.NAME_PARAM
+
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Reg()
+	case ssa.OpSW64LoweredGetCallerPC:
+		p := s.Prog(obj.AGETCALLERPC)
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Reg()
+	case ssa.OpSW64FEqual,
+		ssa.OpSW64FNotEqual:
+		as := sw64.ACMPULT
+		if v.Op == ssa.OpSW64FNotEqual {
+			as = sw64.ACMPEQ
+		}
+		p := s.Prog(sw64.AFIMOVD)
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Args[0].Reg()
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = v.Reg()
+		p1 := s.Prog(as)
+		p1.From.Type = obj.TYPE_REG
+		p1.From.Reg = sw64.REGZERO
+		p1.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  v.Reg(),
+		})
+		p1.To.Type = obj.TYPE_REG
+		p1.To.Reg = v.Reg()
+
+	case ssa.OpSW64LoweredPanicBoundsA, ssa.OpSW64LoweredPanicBoundsB, ssa.OpSW64LoweredPanicBoundsC:
+		p := s.Prog(obj.ACALL)
+		p.To.Type = obj.TYPE_MEM
+		p.To.Name = obj.NAME_EXTERN
+		p.To.Sym = ssagen.BoundsCheckFunc[v.AuxInt]
+		s.UseArgs(16) // space used in callee args area by assembly stubs
+
+		//zxw new add
+	case ssa.OpSW64LoweredAtomicLoad8, ssa.OpSW64LoweredAtomicLoad32, ssa.OpSW64LoweredAtomicLoad64:
+		as := sw64.ALDL
+		switch v.Op {
+		case ssa.OpSW64LoweredAtomicLoad8:
+			as = sw64.ALDBU
+		case ssa.OpSW64LoweredAtomicLoad32:
+			as = sw64.ALDW
+		}
+		s.Prog(sw64.AMEMB)
+		p := s.Prog(as)
+		p.To.Type = obj.TYPE_MEM
+		p.To.Reg = v.Args[0].Reg()
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Reg0()
+		s.Prog(sw64.AMEMB)
+	case ssa.OpSW64LoweredAtomicStore8, ssa.OpSW64LoweredAtomicStore32, ssa.OpSW64LoweredAtomicStore64:
+		as := sw64.ASTL
+		switch v.Op {
+		case ssa.OpSW64LoweredAtomicStore8:
+			as = sw64.ASTB
+		case ssa.OpSW64LoweredAtomicStore32:
+			as = sw64.ASTW
+		}
+		s.Prog(sw64.AMEMB)
+		p := s.Prog(as)
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Args[1].Reg()
+		p.To.Type = obj.TYPE_MEM
+		p.To.Reg = v.Args[0].Reg()
+		s.Prog(sw64.AMEMB)
+	case ssa.OpSW64LoweredAtomicAdd32, ssa.OpSW64LoweredAtomicAdd64:
+		// MEMB
+		// LLDx Rout, (Rarg0)
+		// LDI  Rtmp, 1
+		// WR_F Rtmp
+		// ADDL Rarg1, Rout, Rtmp
+		// LSTx Rtmp, (Rarg0)
+		// RD_F Rtmp
+		// BEQ  Rtmp, -6(PC)
+		// ADDL Rarg1, Rout, Rout
+		// MEMB
+		var sz int64
+		sz = 1
+		lldx := sw64.ALLDL
+		lstx := sw64.ALSTL
+		if v.Op == ssa.OpSW64LoweredAtomicAdd32 {
+			lldx = sw64.ALLDW
+			lstx = sw64.ALSTW
+		}
+		s.Prog(sw64.AMEMB)
+		// LLDx Rout, (Rarg0)
+		p := s.Prog(lldx)
+		p.To.Type = obj.TYPE_MEM
+		p.To.Reg = v.Args[0].Reg()
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Reg0()
+		// LDI  Rtmp, 1
+		p1 := s.Prog(sw64.ALDI)
+		p1.From.Type = obj.TYPE_REG
+		p1.From.Reg = sw64.REGTMP
+		p1.To.Type = obj.TYPE_CONST
+		p1.To.Offset = sz
+		// WR_F Rtmp
+		p2 := s.Prog(sw64.AWR_F)
+		p2.From.Type = obj.TYPE_REG
+		p2.From.Reg = sw64.REGTMP
+		// ADDL Rarg1, Rout, Rtmp
+		p3 := s.Prog(sw64.AADDL)
+		p3.From.Type = obj.TYPE_REG
+		p3.From.Reg = v.Args[1].Reg()
+		p3.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  v.Reg0(),
+		})
+		p3.To.Type = obj.TYPE_REG
+		p3.To.Reg = sw64.REGTMP
+		// LSTx Rtmp, (Rarg0)
+		p4 := s.Prog(lstx)
+		p4.From.Type = obj.TYPE_REG
+		p4.From.Reg = sw64.REGTMP
+		p4.To.Type = obj.TYPE_MEM
+		p4.To.Reg = v.Args[0].Reg()
+		// RD_F Rtmp
+		p5 := s.Prog(sw64.ARD_F)
+		p5.From.Type = obj.TYPE_REG
+		p5.From.Reg = sw64.REGTMP
+		// BEQ  Rtmp, -6(PC)
+		p6 := s.Prog(sw64.ABEQ)
+		p6.From.Type = obj.TYPE_REG
+		p6.From.Reg = sw64.REGTMP
+		p6.To.Type = obj.TYPE_BRANCH
+		p6.To.SetTarget(p)
+		// ADDL Rarg1, Rout, Rout
+		p7 := s.Prog(sw64.AADDL)
+		p7.From.Type = obj.TYPE_REG
+		p7.From.Reg = v.Args[1].Reg()
+		p7.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  v.Reg0(),
+		})
+		p7.To.Type = obj.TYPE_REG
+		p7.To.Reg = v.Reg0()
+		s.Prog(sw64.AMEMB)
+	case ssa.OpSW64LoweredAtomicExchange32, ssa.OpSW64LoweredAtomicExchange64:
+		// MEMB
+		// LLDx Rout, (Rarg0)
+		// LDI  Rtmp, 1
+		// WR_F Rtmp
+		// BIS  Rarg1, R31, Rtmp
+		// LSTx Rtmp, (Rarg0)
+		// RD_F Rtmp
+		// BEQ  Rtmp, -6(PC)
+		// MEMB
+		var sz int64
+		sz = 1
+		lldx := sw64.ALLDL
+		lstx := sw64.ALSTL
+		if v.Op == ssa.OpSW64LoweredAtomicExchange32 {
+			lldx = sw64.ALLDW
+			lstx = sw64.ALSTW
+		}
+		s.Prog(sw64.AMEMB)
+		// LLDx Rout, (Rarg0)
+		p := s.Prog(lldx)
+		p.To.Type = obj.TYPE_MEM
+		p.To.Reg = v.Args[0].Reg()
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Reg0()
+		// LDI  Rtmp, 1
+		p1 := s.Prog(sw64.ALDI)
+		p1.From.Type = obj.TYPE_REG
+		p1.From.Reg = sw64.REGTMP
+		p1.To.Type = obj.TYPE_CONST
+		p1.To.Offset = sz
+		// WR_F Rtmp
+		p2 := s.Prog(sw64.AWR_F)
+		p2.From.Type = obj.TYPE_REG
+		p2.From.Reg = sw64.REGTMP
+		// BIS  Rarg1, R31, Rtmp
+		p3 := s.Prog(sw64.ABIS)
+		p3.From.Type = obj.TYPE_REG
+		p3.From.Reg = v.Args[1].Reg()
+		p3.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  sw64.REGZERO,
+		})
+		p3.To.Type = obj.TYPE_REG
+		p3.To.Reg = sw64.REGTMP
+		// LSTx Rtmp, (Rarg0)
+		p4 := s.Prog(lstx)
+		p4.From.Type = obj.TYPE_REG
+		p4.From.Reg = sw64.REGTMP
+		p4.To.Type = obj.TYPE_MEM
+		p4.To.Reg = v.Args[0].Reg()
+		// RD_F Rtmp
+		p5 := s.Prog(sw64.ARD_F)
+		p5.From.Type = obj.TYPE_REG
+		p5.From.Reg = sw64.REGTMP
+		// BEQ  Rtmp, -6(PC)
+		p6 := s.Prog(sw64.ABEQ)
+		p6.From.Type = obj.TYPE_REG
+		p6.From.Reg = sw64.REGTMP
+		p6.To.Type = obj.TYPE_BRANCH
+		p6.To.SetTarget(p)
+		s.Prog(sw64.AMEMB)
+	case ssa.OpSW64LoweredAtomicCas32, ssa.OpSW64LoweredAtomicCas64:
+		// MEMB
+		// LLDx  Rout, (Rarg0)
+		// CMPEQ Rout, Rarg1, Rout
+		// WR_F	 Rout
+		// BIS   Rarg2, R31, Rtmp
+		// LSTx  Rtmp, (Rarg0)
+		// RD_F  Rtmp
+		// BEQ   Rout, 2(PC)
+		// BEQ   Rtmp, -7(PC)
+		// MEMB
+		lldx := sw64.ALLDL
+		lstx := sw64.ALSTL
+		if v.Op == ssa.OpSW64LoweredAtomicCas32 {
+			lldx = sw64.ALLDW
+			lstx = sw64.ALSTW
+		}
+		s.Prog(sw64.AMEMB)
+		// LLDx Rout, (Rarg0)
+		p := s.Prog(lldx)
+		p.To.Type = obj.TYPE_MEM
+		p.To.Reg = v.Args[0].Reg()
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = v.Reg0()
+		// CMPEQ Rout, Rarg1, Rout
+		p1 := s.Prog(sw64.ACMPEQ)
+		p1.From.Type = obj.TYPE_REG
+		p1.From.Reg = v.Reg0()
+		p1.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  v.Args[1].Reg(),
+		})
+		p1.To.Type = obj.TYPE_REG
+		p1.To.Reg = v.Reg0()
+		// WR_F Rout
+		p2 := s.Prog(sw64.AWR_F)
+		p2.From.Type = obj.TYPE_REG
+		p2.From.Reg = v.Reg0()
+		// BIS  Rarg2, R31, Rtmp
+		p3 := s.Prog(sw64.ABIS)
+		p3.From.Type = obj.TYPE_REG
+		p3.From.Reg = v.Args[2].Reg()
+		p3.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  sw64.REGZERO,
+		})
+		p3.To.Type = obj.TYPE_REG
+		p3.To.Reg = sw64.REGTMP
+		// LSTx Rtmp, (Rarg0)
+		p4 := s.Prog(lstx)
+		p4.From.Type = obj.TYPE_REG
+		p4.From.Reg = sw64.REGTMP
+		p4.To.Type = obj.TYPE_MEM
+		p4.To.Reg = v.Args[0].Reg()
+		// RD_F Rtmp
+		p5 := s.Prog(sw64.ARD_F)
+		p5.From.Type = obj.TYPE_REG
+		p5.From.Reg = sw64.REGTMP
+		// BEQ  Rout, 2(PC)
+		p6 := s.Prog(sw64.ABEQ)
+		p6.From.Type = obj.TYPE_REG
+		p6.From.Reg = v.Reg0()
+		p6.To.Type = obj.TYPE_BRANCH
+		// BEQ  Rtmp, -7(PC)
+		p7 := s.Prog(sw64.ABEQ)
+		p7.From.Type = obj.TYPE_REG
+		p7.From.Reg = sw64.REGTMP
+		p7.To.Type = obj.TYPE_BRANCH
+		p7.To.SetTarget(p)
+		p8 := s.Prog(sw64.AMEMB)
+		p6.To.SetTarget(p8)
+
+	default:
+		v.Fatalf("genValue not implemented: %s", v.LongString())
+	}
+}
+
+var blockJump = map[ssa.BlockKind]struct {
+	asm, invasm obj.As
+}{
+	ssa.BlockSW64NE:  {sw64.ABNE, sw64.ABEQ},
+	ssa.BlockSW64EQ:  {sw64.ABEQ, sw64.ABNE},
+	ssa.BlockSW64LT:  {sw64.ABLT, sw64.ABGE},
+	ssa.BlockSW64LE:  {sw64.ABLE, sw64.ABGT},
+	ssa.BlockSW64GT:  {sw64.ABGT, sw64.ABLE},
+	ssa.BlockSW64GE:  {sw64.ABGE, sw64.ABLT},
+	ssa.BlockSW64FNE: {sw64.AFBNE, sw64.AFBEQ},
+	ssa.BlockSW64FEQ: {sw64.AFBEQ, sw64.AFBNE},
+	ssa.BlockSW64FLT: {sw64.AFBLT, sw64.AFBGE},
+	ssa.BlockSW64FLE: {sw64.AFBLE, sw64.AFBGT},
+	ssa.BlockSW64FGT: {sw64.AFBGT, sw64.AFBLE},
+	ssa.BlockSW64FGE: {sw64.AFBGE, sw64.AFBLT},
+	ssa.BlockSW64LBC: {sw64.ABLBC, sw64.ABLBS},
+	ssa.BlockSW64LBS: {sw64.ABLBS, sw64.ABLBC},
+}
+
+func ssaGenBlock(s *ssagen.State, b, next *ssa.Block) {
+	switch b.Kind {
+	case ssa.BlockPlain:
+		if b.Succs[0].Block() != next {
+			p := s.Prog(obj.AJMP)
+			p.To.Type = obj.TYPE_BRANCH
+			s.Branches = append(s.Branches, ssagen.Branch{P: p, B: b.Succs[0].Block()})
+		}
+
+	case ssa.BlockDefer:
+		// defer returns in R0:
+		// 0 if we should continue executing
+		// 1 if we should jump to deferreturn call
+		//
+		// see also runtime/asm_sw64.s:return0
+		p := s.Prog(sw64.ABNE)
+		p.From = obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  sw64.REG_R0,
+		}
+		p.To.Type = obj.TYPE_BRANCH
+		s.Branches = append(s.Branches, ssagen.Branch{P: p, B: b.Succs[1].Block()})
+
+		if b.Succs[0].Block() != next {
+			p := s.Prog(obj.AJMP)
+			p.To.Type = obj.TYPE_BRANCH
+			s.Branches = append(s.Branches, ssagen.Branch{P: p, B: b.Succs[0].Block()})
+		}
+
+	case ssa.BlockExit, ssa.BlockRetJmp:
+		//s.Prog(obj.AUNDEF) // tell plive.go that we never reach here
+
+	case ssa.BlockRet:
+		s.Prog(obj.ARET)
+
+	case ssa.BlockSW64NE,
+		ssa.BlockSW64EQ,
+		ssa.BlockSW64LT,
+		ssa.BlockSW64LE,
+		ssa.BlockSW64GT,
+		ssa.BlockSW64GE,
+		ssa.BlockSW64FNE,
+		ssa.BlockSW64FEQ,
+		ssa.BlockSW64FLT,
+		ssa.BlockSW64FLE,
+		ssa.BlockSW64FGT,
+		ssa.BlockSW64FGE,
+		ssa.BlockSW64LBC,
+		ssa.BlockSW64LBS:
+		jmp := blockJump[b.Kind]
+		var p *obj.Prog
+		switch next {
+		case b.Succs[0].Block():
+			p = s.Prog(jmp.invasm)
+			p.To.Type = obj.TYPE_BRANCH
+			p.From.Type = obj.TYPE_REG
+			p.From.Reg = b.Controls[0].Reg() //zxw new change
+			s.Branches = append(s.Branches, ssagen.Branch{P: p, B: b.Succs[1].Block()})
+		case b.Succs[1].Block():
+			p = s.Prog(jmp.asm)
+			p.To.Type = obj.TYPE_BRANCH
+			p.From.Type = obj.TYPE_REG
+			p.From.Reg = b.Controls[0].Reg()
+			s.Branches = append(s.Branches, ssagen.Branch{P: p, B: b.Succs[0].Block()})
+		default:
+			//zxw change
+			if b.Likely != ssa.BranchUnlikely {
+				p = s.Prog(jmp.asm)
+				p.To.Type = obj.TYPE_BRANCH
+				p.From.Type = obj.TYPE_REG
+				p.From.Reg = b.Controls[0].Reg()
+				s.Branches = append(s.Branches, ssagen.Branch{P: p, B: b.Succs[0].Block()})
+				q := s.Prog(obj.AJMP)
+				q.To.Type = obj.TYPE_BRANCH
+				s.Branches = append(s.Branches, ssagen.Branch{P: q, B: b.Succs[1].Block()})
+			} else {
+				p = s.Prog(jmp.invasm)
+				p.To.Type = obj.TYPE_BRANCH
+				p.From.Type = obj.TYPE_REG
+				p.From.Reg = b.Controls[0].Reg()
+				s.Branches = append(s.Branches, ssagen.Branch{P: p, B: b.Succs[1].Block()})
+				q := s.Prog(obj.AJMP)
+				q.To.Type = obj.TYPE_BRANCH
+				s.Branches = append(s.Branches, ssagen.Branch{P: q, B: b.Succs[0].Block()})
+			}
+		}
+
+	case ssa.BlockSW64JUMPTABLE:
+		// S8ADDL IDX, TABLE, Rtmp
+		// LDL    Rtmp, (Rtmp)
+		// JMP    ZERO, (Rtmp)
+		p := s.Prog(sw64.AS8ADDL)
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = b.Controls[0].Reg()
+		p.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  b.Controls[1].Reg(),
+		})
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = sw64.REGTMP
+
+		p2 := s.Prog(sw64.ALDL)
+		p2.From.Type = obj.TYPE_REG
+		p2.From.Reg = sw64.REGTMP
+		p2.To.Type = obj.TYPE_MEM
+		p2.To.Reg = sw64.REGTMP
+		p2.To.Offset = 0
+
+		p3 := s.Prog(sw64.AJMP)
+		p3.From.Reg = sw64.REGZERO
+		p3.From.Type = obj.TYPE_REG
+		p3.To.Type = obj.TYPE_MEM
+		p3.To.Reg = sw64.REGTMP
+		p3.To.Offset = 0
+
+		// Save jump tables for later resolution of the target blocks.
+		s.JumpTables = append(s.JumpTables, b)
+
+	default:
+		b.Fatalf("branch not implemented: %s", b.LongString())
+	}
+}
+
+func loadRegResult(s *ssagen.State, f *ssa.Func, t *types.Type, reg int16, n *ir.Name, off int64) *obj.Prog {
+	p := s.Prog(loadByType(t, reg))
+//	p.From.Type = obj.TYPE_MEM
+//	p.From.Name = obj.NAME_AUTO
+//	p.From.Sym = n.Linksym()
+//	p.From.Offset = n.FrameOffset() + off
+//	p.To.Type = obj.TYPE_REG
+//	p.To.Reg = reg
+	p.From.Type = obj.TYPE_REG
+	p.From.Reg = reg
+	p.To.Type = obj.TYPE_MEM
+	p.To.Name = obj.NAME_AUTO
+	p.To.Sym = n.Linksym()
+	p.To.Offset = n.FrameOffset() + off
+	return p
+}
+
+func spillArgReg(pp *objw.Progs, p *obj.Prog, f *ssa.Func, t *types.Type, reg int16, n *ir.Name, off int64) *obj.Prog {
+	p = pp.Append(p, storeByType(t, reg), obj.TYPE_REG, reg, 0, obj.TYPE_MEM, 0, n.FrameOffset()+off)
+	p.To.Name = obj.NAME_PARAM
+	p.To.Sym = n.Linksym()
+	p.Pos = p.Pos.WithNotStmt()
+	return p
+}
diff --git a/src/cmd/compile/internal/test/inl_test.go b/src/cmd/compile/internal/test/inl_test.go
index 0ccc7b37..4c30549d 100644
--- a/src/cmd/compile/internal/test/inl_test.go
+++ b/src/cmd/compile/internal/test/inl_test.go
@@ -237,7 +237,7 @@ func TestIntendedInlining(t *testing.T) {
 		},
 	}
 
-	if runtime.GOARCH != "386" && runtime.GOARCH != "loong64" && runtime.GOARCH != "mips64" && runtime.GOARCH != "mips64le" && runtime.GOARCH != "riscv64" {
+	if runtime.GOARCH != "386" && runtime.GOARCH != "loong64" && runtime.GOARCH != "mips64" && runtime.GOARCH != "mips64le" && runtime.GOARCH != "riscv64" && runtime.GOARCH != "sw64" {
 		// nextFreeFast calls sys.TrailingZeros64, which on 386 is implemented in asm and is not inlinable.
 		// We currently don't have midstack inlining so nextFreeFast is also not inlinable on 386.
 		// On loong64, mips64x and riscv64, TrailingZeros64 is not intrinsified and causes nextFreeFast
diff --git a/src/cmd/compile/internal/types2/gccgosizes.go b/src/cmd/compile/internal/types2/gccgosizes.go
index 46020012..3ce62077 100644
--- a/src/cmd/compile/internal/types2/gccgosizes.go
+++ b/src/cmd/compile/internal/types2/gccgosizes.go
@@ -38,4 +38,5 @@ var gccgoArchSizes = map[string]*StdSizes{
 	"sparc":       {4, 8},
 	"sparc64":     {8, 8},
 	"wasm":        {8, 8},
+	"sw64":        {8, 8},
 }
diff --git a/src/cmd/compile/internal/types2/sizes.go b/src/cmd/compile/internal/types2/sizes.go
index 486c05c6..bafc6bd0 100644
--- a/src/cmd/compile/internal/types2/sizes.go
+++ b/src/cmd/compile/internal/types2/sizes.go
@@ -244,6 +244,7 @@ var gcArchSizes = map[string]*gcSizes{
 	"s390x":    {8, 8},
 	"sparc64":  {8, 8},
 	"wasm":     {8, 8},
+	"sw64":     {8, 8},
 	// When adding more architectures here,
 	// update the doc string of SizesFor below.
 }
@@ -253,7 +254,7 @@ var gcArchSizes = map[string]*gcSizes{
 //
 // Supported architectures for compiler "gc":
 // "386", "amd64", "amd64p32", "arm", "arm64", "loong64", "mips", "mipsle",
-// "mips64", "mips64le", "ppc64", "ppc64le", "riscv64", "s390x", "sparc64", "wasm".
+// "mips64", "mips64le", "ppc64", "ppc64le", "riscv64", "s390x", "sparc64", "wasm", "sw64".
 func SizesFor(compiler, arch string) Sizes {
 	switch compiler {
 	case "gc":
diff --git a/src/cmd/compile/main.go b/src/cmd/compile/main.go
index 7d38bea7..1c59d4c6 100644
--- a/src/cmd/compile/main.go
+++ b/src/cmd/compile/main.go
@@ -17,6 +17,7 @@ import (
 	"cmd/compile/internal/riscv64"
 	"cmd/compile/internal/s390x"
 	"cmd/compile/internal/ssagen"
+	"cmd/compile/internal/sw64"
 	"cmd/compile/internal/wasm"
 	"cmd/compile/internal/x86"
 	"fmt"
@@ -40,6 +41,7 @@ var archInits = map[string]func(*ssagen.ArchInfo){
 	"riscv64":  riscv64.Init,
 	"s390x":    s390x.Init,
 	"wasm":     wasm.Init,
+	"sw64":     sw64.Init,
 }
 
 func main() {
diff --git a/src/cmd/dist/build.go b/src/cmd/dist/build.go
index 32e59b44..773d4510 100644
--- a/src/cmd/dist/build.go
+++ b/src/cmd/dist/build.go
@@ -38,6 +38,7 @@ var (
 	gomips           string
 	gomips64         string
 	goppc64          string
+	gosw64           string
 	goroot           string
 	goroot_final     string
 	goextlinkenabled string
@@ -79,6 +80,7 @@ var okgoarch = []string{
 	"s390x",
 	"sparc64",
 	"wasm",
+	"sw64",
 }
 
 // The known operating systems.
@@ -177,6 +179,12 @@ func xinit() {
 	}
 	goppc64 = b
 
+	b = os.Getenv("GOSW64")
+	if b == "" {
+		b = xgetgosw64()
+	}
+	gosw64 = b
+
 	if p := pathf("%s/src/all.bash", goroot); !isfile(p) {
 		fatalf("$GOROOT is not set correctly or not exported\n"+
 			"\tGOROOT=%s\n"+
@@ -236,6 +244,7 @@ func xinit() {
 	os.Setenv("GOMIPS", gomips)
 	os.Setenv("GOMIPS64", gomips64)
 	os.Setenv("GOPPC64", goppc64)
+	os.Setenv("GOSW64", gosw64)
 	os.Setenv("GOROOT", goroot)
 	os.Setenv("GOROOT_FINAL", goroot_final)
 
@@ -576,7 +585,7 @@ func setup() {
 func mustLinkExternal(goos, goarch string, cgoEnabled bool) bool {
 	if cgoEnabled {
 		switch goarch {
-		case "loong64", "mips", "mipsle", "mips64", "mips64le":
+		case "loong64", "mips", "mipsle", "mips64", "mips64le", "sw64":
 			// Internally linking cgo is incomplete on some architectures.
 			// https://golang.org/issue/14449
 			return true
@@ -1236,6 +1245,9 @@ func cmdenv() {
 	if goarch == "ppc64" || goarch == "ppc64le" {
 		xprintf(format, "GOPPC64", goppc64)
 	}
+	if goarch == "sw64" {
+		xprintf(format, "GOSW64", gosw64)
+	}
 	xprintf(format, "GOWORK", "off")
 
 	if *path {
@@ -1711,6 +1723,7 @@ var cgoEnabled = map[string]bool{
 	"linux/riscv64":   true,
 	"linux/s390x":     true,
 	"linux/sparc64":   true,
+	"linux/sw64":      true,
 	"android/386":     true,
 	"android/amd64":   true,
 	"android/arm":     true,
diff --git a/src/cmd/dist/buildruntime.go b/src/cmd/dist/buildruntime.go
index 1de78f0f..53997ea2 100644
--- a/src/cmd/dist/buildruntime.go
+++ b/src/cmd/dist/buildruntime.go
@@ -57,6 +57,7 @@ func mkbuildcfg(file string) {
 	fmt.Fprintf(&buf, "const defaultGOMIPS = `%s`\n", gomips)
 	fmt.Fprintf(&buf, "const defaultGOMIPS64 = `%s`\n", gomips64)
 	fmt.Fprintf(&buf, "const defaultGOPPC64 = `%s`\n", goppc64)
+	fmt.Fprintf(&buf, "const defaultGOSW64 = `%s`\n", gosw64)
 	fmt.Fprintf(&buf, "const defaultGOEXPERIMENT = `%s`\n", goexperiment)
 	fmt.Fprintf(&buf, "const defaultGO_EXTLINK_ENABLED = `%s`\n", goextlinkenabled)
 	fmt.Fprintf(&buf, "const defaultGO_LDSO = `%s`\n", defaultldso)
diff --git a/src/cmd/dist/main.go b/src/cmd/dist/main.go
index f3425a9d..3b687ad8 100644
--- a/src/cmd/dist/main.go
+++ b/src/cmd/dist/main.go
@@ -130,6 +130,8 @@ func main() {
 			gohostarch = "riscv64"
 		case strings.Contains(out, "s390x"):
 			gohostarch = "s390x"
+		case strings.Contains(out, "sw_64"), strings.Contains(out, "sw64"):
+                        gohostarch = "sw64"
 		case gohostos == "darwin", gohostos == "ios":
 			if strings.Contains(run("", CheckExit, "uname", "-v"), "RELEASE_ARM64_") {
 				gohostarch = "arm64"
@@ -168,6 +170,12 @@ func main() {
 		os.Exit(0)
 	}
 
+	if len(os.Args) > 1 && os.Args[1] == "-check-gosw64" {
+		useUIDVv1() // might fail with SIGILL
+		println("UDIVv1 OK.")
+		os.Exit(0)
+	}
+
 	xinit()
 	xmain()
 	xexit(0)
diff --git a/src/cmd/dist/test.go b/src/cmd/dist/test.go
index 5e62bbf4..bf55dee0 100644
--- a/src/cmd/dist/test.go
+++ b/src/cmd/dist/test.go
@@ -1080,7 +1080,7 @@ func (t *tester) internalLink() bool {
 	// Internally linking cgo is incomplete on some architectures.
 	// https://golang.org/issue/10373
 	// https://golang.org/issue/14449
-	if goarch == "loong64" || goarch == "mips64" || goarch == "mips64le" || goarch == "mips" || goarch == "mipsle" || goarch == "riscv64" {
+	if goarch == "loong64" || goarch == "mips64" || goarch == "mips64le" || goarch == "mips" || goarch == "mipsle" || goarch == "riscv64" || goarch == "sw64" {
 		return false
 	}
 	if goos == "aix" {
@@ -1581,7 +1581,7 @@ func buildModeSupported(compiler, buildmode, goos, goarch string) bool {
 			return true
 		case "linux":
 			switch goarch {
-			case "386", "amd64", "arm", "armbe", "arm64", "arm64be", "loong64", "ppc64le", "riscv64", "s390x":
+			case "386", "amd64", "arm", "armbe", "arm64", "arm64be", "loong64", "ppc64le", "riscv64", "s390x", "sw64":
 				// linux/ppc64 not supported because it does
 				// not support external linking mode yet.
 				return true
@@ -1601,7 +1601,7 @@ func buildModeSupported(compiler, buildmode, goos, goarch string) bool {
 
 	case "c-shared":
 		switch platform {
-		case "linux/amd64", "linux/arm", "linux/arm64", "linux/loong64", "linux/386", "linux/ppc64le", "linux/riscv64", "linux/s390x",
+		case "linux/amd64", "linux/arm", "linux/arm64", "linux/loong64", "linux/386", "linux/ppc64le", "linux/riscv64", "linux/s390x", "linux/sw64",
 			"android/amd64", "android/arm", "android/arm64", "android/386",
 			"freebsd/amd64",
 			"darwin/amd64", "darwin/arm64",
@@ -1638,7 +1638,7 @@ func buildModeSupported(compiler, buildmode, goos, goarch string) bool {
 
 	case "plugin":
 		switch platform {
-		case "linux/amd64", "linux/arm", "linux/arm64", "linux/386", "linux/loong64", "linux/s390x", "linux/ppc64le",
+		case "linux/amd64", "linux/arm", "linux/arm64", "linux/386", "linux/loong64", "linux/s390x", "linux/ppc64le", "linux/sw64",
 			"android/amd64", "android/386",
 			"darwin/amd64", "darwin/arm64",
 			"freebsd/amd64":
diff --git a/src/cmd/dist/udiv_default.s b/src/cmd/dist/udiv_default.s
new file mode 100644
index 00000000..371dcd96
--- /dev/null
+++ b/src/cmd/dist/udiv_default.s
@@ -0,0 +1,10 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build !sw64,gc
+
+#include "textflag.h"
+
+TEXT ·useUIDVv1(SB),NOSPLIT,$0
+	RET
diff --git a/src/cmd/dist/udiv_sw64.s b/src/cmd/dist/udiv_sw64.s
new file mode 100644
index 00000000..8d7155fd
--- /dev/null
+++ b/src/cmd/dist/udiv_sw64.s
@@ -0,0 +1,12 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build sw64,gc
+
+#include "textflag.h"
+
+// try to run "vmov.f64 d0, d0" instruction
+TEXT ·useUIDVv1(SB),NOSPLIT,$0
+	WORD $0x400003E0	// vmov.f64 d0, d0
+	RET
diff --git a/src/cmd/dist/util.go b/src/cmd/dist/util.go
index 2eeab18a..54f467fc 100644
--- a/src/cmd/dist/util.go
+++ b/src/cmd/dist/util.go
@@ -405,6 +405,23 @@ func xgetgoarm() string {
 	return "7"
 }
 
+func xgetgosw64() string {
+	if gohostarch != "sw64" || goos != gohostos {
+		// Conservative default for cross-compilation.
+		return "swv3"
+	}
+	// Try to exec ourselves in a mode to detect DIV,REM support.
+	// Seeing how far it gets determines which instructions failed.
+	// The test is OS-agnostic.
+	out := run("", 0, os.Args[0], "-check-gosw64")
+	v1ok := strings.Contains(out, "UDIVv1 OK.")
+
+	if v1ok {
+		return "swv4"
+	}
+	return "swv3"
+}
+
 func min(a, b int) int {
 	if a < b {
 		return a
diff --git a/src/cmd/dist/util_gc.go b/src/cmd/dist/util_gc.go
index 6efdf23e..f6e917ab 100644
--- a/src/cmd/dist/util_gc.go
+++ b/src/cmd/dist/util_gc.go
@@ -18,3 +18,8 @@ func useVFPv3()
 // It will crash the current process if it doesn't implement
 // ARMv6K or above.
 func useARMv6K()
+
+// useUIDVv1 tries to run core4 instructions on SW64.
+// It will crash the current process if it doesn't implement
+// Core4 or above.
+func useUIDVv1()
diff --git a/src/cmd/go/internal/cfg/cfg.go b/src/cmd/go/internal/cfg/cfg.go
index a8daa2df..31913f67 100644
--- a/src/cmd/go/internal/cfg/cfg.go
+++ b/src/cmd/go/internal/cfg/cfg.go
@@ -414,6 +414,7 @@ var (
 	GOMIPS   = envOr("GOMIPS", buildcfg.GOMIPS)
 	GOMIPS64 = envOr("GOMIPS64", buildcfg.GOMIPS64)
 	GOPPC64  = envOr("GOPPC64", fmt.Sprintf("%s%d", "power", buildcfg.GOPPC64))
+	GOSW64   = envOr("GOSW64", fmt.Sprintf("%s%d", "core", buildcfg.GOSW64))
 	GOWASM   = envOr("GOWASM", fmt.Sprint(buildcfg.GOWASM))
 
 	GOPROXY    = envOr("GOPROXY", "")
diff --git a/src/cmd/go/internal/imports/build.go b/src/cmd/go/internal/imports/build.go
index 3a4a66b8..4cc231c7 100644
--- a/src/cmd/go/internal/imports/build.go
+++ b/src/cmd/go/internal/imports/build.go
@@ -371,4 +371,5 @@ var KnownArch = map[string]bool{
 	"sparc":       true,
 	"sparc64":     true,
 	"wasm":        true,
+	"sw64":        true,
 }
diff --git a/src/cmd/go/internal/modindex/syslist.go b/src/cmd/go/internal/modindex/syslist.go
index 41adcc53..1707acf3 100644
--- a/src/cmd/go/internal/modindex/syslist.go
+++ b/src/cmd/go/internal/modindex/syslist.go
@@ -75,4 +75,5 @@ var knownArch = map[string]bool{
 	"sparc":       true,
 	"sparc64":     true,
 	"wasm":        true,
+	"sw64":        true,
 }
diff --git a/src/cmd/go/testdata/mod/golang.org_toolchain_v0.0.1-go1.999testmod.linux-sw64.txt b/src/cmd/go/testdata/mod/golang.org_toolchain_v0.0.1-go1.999testmod.linux-sw64.txt
new file mode 100644
index 00000000..0deea828
--- /dev/null
+++ b/src/cmd/go/testdata/mod/golang.org_toolchain_v0.0.1-go1.999testmod.linux-sw64.txt
@@ -0,0 +1,14 @@
+golang.org/toolchain@v0.0.1-go1.999testmod.linux-sw64
+
+-- .mod --
+module golang.org/toolchain
+-- .info --
+{"Version":"v0.0.1-go1.999testmod.linux-sw64"}
+-- go.mod --
+module golang.org/toolchain
+-- bin/go --
+#!/bin/sh
+echo go1.999testmod here!
+-- bin/gofmt --
+echo i am unused
+-- pkg/tool/fake --
diff --git a/src/cmd/internal/obj/link.go b/src/cmd/internal/obj/link.go
index 0b787865..f487e453 100644
--- a/src/cmd/internal/obj/link.go
+++ b/src/cmd/internal/obj/link.go
@@ -442,6 +442,7 @@ const (
 	ABaseRISCV
 	ABaseS390X
 	ABaseWasm
+	ABaseSW64
 
 	AllowedOpCodes = 1 << 11            // The number of opcodes available for any given architecture.
 	AMask          = AllowedOpCodes - 1 // AND with this to use the opcode as an array index.
@@ -1106,6 +1107,19 @@ func (fi *FuncInfo) UnspillRegisterArgs(last *Prog, pa ProgAlloc) *Prog {
 	return last
 }
 
+// TODO: delete this function after converting the format of sw64 LDx
+func (fi *FuncInfo) UnspillRegisterArgsSW64(last *Prog, pa ProgAlloc) *Prog {
+	for _, ra := range fi.spills {
+		unspill := Appendp(last, pa)
+		unspill.As = ra.Unspill
+		unspill.From.Type = TYPE_REG
+		unspill.From.Reg = ra.Reg
+		unspill.To = ra.Addr
+		last = unspill
+	}
+	return last
+}
+
 // LinkArch is the definition of a single architecture.
 type LinkArch struct {
 	*sys.Arch
diff --git a/src/cmd/internal/obj/stringer_sw64.go b/src/cmd/internal/obj/stringer_sw64.go
new file mode 100644
index 00000000..faa4e3db
--- /dev/null
+++ b/src/cmd/internal/obj/stringer_sw64.go
@@ -0,0 +1,104 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build ignore
+// +build ignore
+
+// This is a mini version of the stringer tool customized for the Anames table
+// in the architecture support for obj.
+// This version just generates the slice of strings, not the String method.
+
+package main
+
+import (
+	"bufio"
+	"flag"
+	"fmt"
+	"log"
+	"os"
+	"regexp"
+	"strings"
+)
+
+var (
+	input  = flag.String("i", "", "input file name")
+	output = flag.String("o", "", "output file name")
+	pkg    = flag.String("p", "", "package name")
+)
+
+var Are = regexp.MustCompile(`^\tA([A-Z0-9_]+)`)
+
+func main() {
+	flag.Parse()
+	if *input == "" || *output == "" || *pkg == "" {
+		flag.Usage()
+		os.Exit(2)
+	}
+	in, err := os.Open(*input)
+	if err != nil {
+		log.Fatal(err)
+	}
+	fd, err := os.Create(*output)
+	if err != nil {
+		log.Fatal(err)
+	}
+	out := bufio.NewWriter(fd)
+	defer out.Flush()
+	var on = false
+	s := bufio.NewScanner(in)
+	first := true
+	for s.Scan() {
+		line := s.Text()
+		if !on {
+			// First relevant line contains "= obj.ABase".
+			// If we find it, delete the = so we don't stop immediately.
+			const prefix = "= obj.ABase"
+			index := strings.Index(line, prefix)
+			if index < 0 {
+				continue
+			}
+			// It's on. Start with the header.
+			fmt.Fprintf(out, header, *input, *output, *pkg, *pkg)
+			on = true
+			line = line[:index]
+		}
+		// Strip comments so their text won't defeat our heuristic.
+		index := strings.Index(line, "//")
+		if index > 0 {
+			line = line[:index]
+		}
+		index = strings.Index(line, "/*")
+		if index > 0 {
+			line = line[:index]
+		}
+		// Termination condition: Any line with an = changes the sequence,
+		// so stop there, and stop at a closing brace.
+		if strings.HasPrefix(line, "}") || strings.ContainsRune(line, '=') {
+			break
+		}
+		sub := Are.FindStringSubmatch(line)
+		if len(sub) < 2 {
+			continue
+		}
+		if first {
+			fmt.Fprintf(out, "\tobj.A_ARCHSPECIFIC: %q,\n", sub[1])
+			first = false
+		} else {
+			fmt.Fprintf(out, "\t%q,\n", sub[1])
+		}
+	}
+	fmt.Fprintln(out, "}")
+	if s.Err() != nil {
+		log.Fatal(err)
+	}
+}
+
+const header = `// Code generated by stringer -i %s -o %s -p %s; DO NOT EDIT.
+
+package %s
+
+import "cmd/internal/obj"
+
+var Anames = []string{
+`
diff --git a/src/cmd/internal/obj/sw64/a.out.go b/src/cmd/internal/obj/sw64/a.out.go
new file mode 100644
index 00000000..718b6b59
--- /dev/null
+++ b/src/cmd/internal/obj/sw64/a.out.go
@@ -0,0 +1,502 @@
+// cmd/9c/9.out.h from Vita Nuova.
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2008 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2008 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors. All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+package sw64
+
+import (
+	"cmd/internal/obj"
+)
+
+//go:generate go run ../stringer_sw64.go -i $GOFILE -o anames.go -p sw64
+
+/*
+ * sw64
+ */
+const (
+	NREG  = 32        /* number of general registers */
+	NFREG = 32        /* number of floating point registers */
+	NVREG = 32        /* number of SIMD registers */
+	NINST = 253 + 114 /* number of instructions */
+)
+
+const (
+	REG_R0 = obj.RBaseSW64 + iota
+	REG_R1
+	REG_R2
+	REG_R3
+	REG_R4
+	REG_R5
+	REG_R6
+	REG_R7
+	REG_R8
+	REG_R9
+	REG_R10
+	REG_R11
+	REG_R12
+	REG_R13
+	REG_R14
+	REG_R15
+	REG_R16
+	REG_R17
+	REG_R18
+	REG_R19
+	REG_R20
+	REG_R21
+	REG_R22
+	REG_R23
+	REG_R24
+	REG_R25
+	REG_R26
+	REG_R27
+	REG_R28
+	REG_R29
+	REG_R30
+	REG_R31
+
+	REG_F0
+	REG_F1
+	REG_F2
+	REG_F3
+	REG_F4
+	REG_F5
+	REG_F6
+	REG_F7
+	REG_F8
+	REG_F9
+	REG_F10
+	REG_F11
+	REG_F12
+	REG_F13
+	REG_F14
+	REG_F15
+	REG_F16
+	REG_F17
+	REG_F18
+	REG_F19
+	REG_F20
+	REG_F21
+	REG_F22
+	REG_F23
+	REG_F24
+	REG_F25
+	REG_F26
+	REG_F27
+	REG_F28
+	REG_F29
+	REG_F30
+	REG_F31
+
+	// SIMD
+	REG_V0
+	REG_V1
+	REG_V2
+	REG_V3
+	REG_V4
+	REG_V5
+	REG_V6
+	REG_V7
+	REG_V8
+	REG_V9
+	REG_V10
+	REG_V11
+	REG_V12
+	REG_V13
+	REG_V14
+	REG_V15
+	REG_V16
+	REG_V17
+	REG_V18
+	REG_V19
+	REG_V20
+	REG_V21
+	REG_V22
+	REG_V23
+	REG_V24
+	REG_V25
+	REG_V26
+	REG_V27
+	REG_V28
+	REG_V29
+	REG_V30
+	REG_V31
+
+	REGG    = REG_R15 // fp
+	REGLINK = REG_R26 // ra
+	REGCTXT = REG_R25 // t12/pv
+	REGTMP  = REG_R28 // at
+	REGSB   = REG_R29 // gp
+	REGSP   = REG_R30 // sp
+	REGZERO = REG_R31 // zero
+
+)
+
+var SW64DWARFRegisters = map[int16]int16{}
+
+func init() {
+	// f assigns dwarfregisters[from:to] = (base):(to-from+base)
+	f := func(from, to, base int16) {
+		for r := int16(from); r <= to; r++ {
+			SW64DWARFRegisters[r] = (r - from) + base
+		}
+	}
+	f(REG_R0, REG_R31, 0)
+	f(REG_F0, REG_F31, 32) // For 32-bit SW64, compiler only uses even numbered registers --  see cmd/compile/internal/ssa/gen/SW64Ops.go
+}
+
+const (
+	BIG = 32766
+)
+
+const (
+	C_NONE    = iota
+	C_RREG    // integer register
+	C_FREG    // float-point register
+	C_VREG    // SIMD externtion register
+	C_REG     // any register
+	C_SUCON   // integer constant not greater than 0xff
+	C_MCON    // integer constant [-0x8000,0x7fff]
+	C_LCON    // integer constant without restriction
+	C_FCON    // float-point constant without restriction
+	C_LEXT    // external symbol
+	C_ADDR    // all symbol
+	C_SAUTO   // (a.NAME == NAME_PARAM || a.NAME == NAME_AUTO) && offset is [-0x7fff, 0x7fff]
+	C_LAUTO   // a.NAME == NAME_PARAM || a.NAME == NAME_AUTO
+	C_ZOREG   // a.NAME == NAME_NONE && offset is 0
+	C_SOREG   // (a.NAME == NAME_NONE) && offset is [-0x7fff, 0x7fff]
+	C_LOREG   // a.NAME == NAME_NONE
+	C_SBRA    // a.NAME == NAME_NONE && offset is 0
+	C_GOTADDR // The GOT slot for a symbol in -dynlink mode
+	C_GOK
+	C_TLS_LE
+	C_TLS_IE
+	C_NCLASS /* must be the last */
+)
+
+const (
+	ASYS_CALL = obj.ABaseSW64 + obj.A_ARCHSPECIFIC + iota
+	ASYS_CALL_B
+	AEXCB
+	//控制指令, JMP,RET,CALL定义为obj.AJMP,obj.ARET,obj.CALL
+	ABR
+	ALBR
+	ABSR
+	ABEQ
+	ABNE
+	ABLT
+	ABLE
+	ABGT
+	ABGE
+	ABLBC
+	ABLBS
+	AFBEQ
+	AFBNE
+	AFBLT
+	AFBLE
+	AFBGT
+	AFBGE
+
+	//Load/Store
+	AMOVB
+	AMOVBU
+	AMOVH
+	AMOVHU
+	AMOVW
+	AMOVWU
+	AMOVV
+	AMOVF
+	AMOVD
+	ALDBU //存储装载指令
+	ALDHU
+	ALDW
+	ALDL
+	ALDL_U
+	ASTB
+	ASTH
+	ASTW
+	ASTL
+	ASTL_U
+	AFLDS
+	AFLDD
+	AFSTS
+	AFSTD
+
+	// Load/Store with addend
+	ALDBUA
+	ALDHUA
+	ALDWA
+	ALDLA
+	AFLDSA
+	AFLDDA
+	ASTBA
+	ASTHA
+	ASTWA
+	ASTLA
+	AFSTSA
+	AFSTDA
+
+	//装入立即数
+	ALDI
+	ALDF //装入浮点立即数
+	ALDIH
+	// 整数算数运算
+	AADDW
+	ASUBW
+	AS4ADDW
+	AS4SUBW
+	AS8ADDW
+	AS8SUBW
+	AADDL
+	ASUBL
+	AS4ADDL
+	AS4SUBL
+	AS8ADDL
+	AS8SUBL
+	AMULW
+	AMULL
+	AUMULH
+	ACTPOP
+	ACTLZ
+	ACTTZ
+	AZAP
+	AZAPNOT
+	ASEXTB
+	ASEXTH
+	ADIVW
+	AUDIVW
+	AREMW
+	AUREMW
+	ADIVL
+	AUDIVL
+	AREML
+	AUREML
+	AADDPI
+	AADDPIS
+	ASBT
+	ACBT
+
+	//浮点数运算
+	AFADDS
+	AFADDD
+	AFSUBS
+	AFSUBD
+	AFMULS
+	AFMULD
+	AFMAS
+	AFMAD
+	AFMSS
+	AFMSD
+	AFNMAS
+	AFNMAD
+	AFNMSS
+	AFNMSD
+	AFSELEQ
+	AFSELNE
+	AFSELLT
+	AFSELLE
+	AFSELGT
+	AFSELGE
+	AFDIVS
+	AFDIVD
+	AFCPYS
+	AFCVTSD
+	AFCVTDS
+	AFCVTDL
+	AFCVTLS
+	AFCVTLD
+	AFCVTLW
+	AFCVTWL
+	AFSQRTS
+	AFSQRTD
+	AFCVTDL_Z
+	AFCVTDL_P
+	AFCVTDL_G
+	AFCVTDL_N
+	AFCMPLE
+	AFCMPLT
+	AFCMPEQ
+	AFCMPUN
+	AFCPYSN
+	AFCPYSE
+	AIFMOVS
+	AIFMOVD
+	AFIMOVS
+	AFIMOVD
+	ARFPCR
+	AWFPCR
+	ASETFPEC0
+	ASETFPEC1
+	ASETFPEC2
+	ASETFPEC3
+	//杂项指令
+	AMEMB
+	AIMEMB
+	ARTC
+	ARCID
+	AHALT
+	ARD_F
+	AWR_F
+	ARTID
+	ALLDW
+	ALLDL
+	ALDW_INC
+	ALDL_INC
+	ALDW_DEC
+	ALDL_DEC
+	ALDW_SET
+	ALDL_SET
+	ALSTW
+	ALSTL
+	ALDW_NC
+	ALDL_NC
+	ALDD_NC
+	ASTW_NC
+	ASTL_NC
+	ASTD_NC
+	ACMPEQ
+	ACMPLT
+	ACMPLE
+	ACMPULT
+	ACMPULE
+	AAND
+	ABIC
+	ABIS
+	AORNOT
+	AXOR
+	AEQV
+	AINSLB
+	AINSLH
+	AINSLW
+	AINSLL
+	AINSHB
+	AINSHH
+	AINSHW
+	AINSHL
+	ASLL
+	ASRL
+	ASRA
+	AEXTLB
+	AEXTLH
+	AEXTLW
+	AEXTLL
+	AEXTHB
+	AEXTHH
+	AEXTHW
+	AEXTHL
+	AMASKLB
+	AMASKLH
+	AMASKLW
+	AMASKLL
+	AMASKHB
+	AMASKHH
+	AMASKHW
+	AMASKHL
+	ACMPGEB
+	ASELEQ
+	ASELGE
+	ASELGT
+	ASELLE
+	ASELLT
+	ASELNE
+	ASELLBC
+	ASELLBS
+	APRI_ST
+	APRI_LD
+	ASYMADDR
+	AWORD
+	ANOOP
+	ALDGP
+
+	// CRC32
+	ACRC32L
+	ACRC32W
+	ACRC32H
+	ACRC32B
+	ACRC32CL
+	ACRC32CW
+	ACRC32CH
+	ACRC32CB
+
+	// SIMD
+	AVLDD
+	AVLDS
+	AVSTD
+	AVSTS
+	AVAND
+	AVXOR
+	AVOR
+	AVORNOT
+	AVBIC
+	AVADDW
+	AVADDL
+	AVSUBW
+	AVSUBL
+	AVCMPUEQB
+	AVCMPUGTB
+	AVCPYB
+	AVCPYH
+	AVCTPOP
+	AVCTLZ
+	AVMAXB
+	AVMAXH
+	AVMAXW
+	AVMAXL
+	AVUMAXB
+	AVUMAXH
+	AVUMAXW
+	AVUMAXL
+	AVMINB
+	AVMINH
+	AVMINW
+	AVMINL
+	AVUMINB
+	AVUMINH
+	AVUMINW
+	AVUMINL
+	ALAST
+
+	// aliases
+	AJMP  = obj.AJMP
+	ACALL = obj.ACALL
+	ARET  = obj.ARET
+)
+
+const (
+	/* mark flags */
+	FOLL    = 1 << 0
+	LABEL   = 1 << 1
+	LEAF    = 1 << 2
+	SYNC    = 1 << 3
+	BRANCH  = 1 << 4
+	LOAD    = 1 << 5
+	FCMP    = 1 << 6
+	NOSCHED = 1 << 7
+	CHANGED = 1 << 9
+
+	NSCHED = 20
+)
diff --git a/src/cmd/internal/obj/sw64/anames.go b/src/cmd/internal/obj/sw64/anames.go
new file mode 100644
index 00000000..6d87a05e
--- /dev/null
+++ b/src/cmd/internal/obj/sw64/anames.go
@@ -0,0 +1,273 @@
+// Code generated by stringer -i a.out.go -o anames.go -p sw64; DO NOT EDIT.
+
+package sw64
+
+import "cmd/internal/obj"
+
+var Anames = []string{
+	obj.A_ARCHSPECIFIC: "SYS_CALL",
+	"SYS_CALL_B",
+	"EXCB",
+	"BR",
+	"LBR",
+	"BSR",
+	"BEQ",
+	"BNE",
+	"BLT",
+	"BLE",
+	"BGT",
+	"BGE",
+	"BLBC",
+	"BLBS",
+	"FBEQ",
+	"FBNE",
+	"FBLT",
+	"FBLE",
+	"FBGT",
+	"FBGE",
+	"MOVB",
+	"MOVBU",
+	"MOVH",
+	"MOVHU",
+	"MOVW",
+	"MOVWU",
+	"MOVV",
+	"MOVF",
+	"MOVD",
+	"LDBU",
+	"LDHU",
+	"LDW",
+	"LDL",
+	"LDL_U",
+	"STB",
+	"STH",
+	"STW",
+	"STL",
+	"STL_U",
+	"FLDS",
+	"FLDD",
+	"FSTS",
+	"FSTD",
+	"LDBUA",
+	"LDHUA",
+	"LDWA",
+	"LDLA",
+	"FLDSA",
+	"FLDDA",
+	"STBA",
+	"STHA",
+	"STWA",
+	"STLA",
+	"FSTSA",
+	"FSTDA",
+	"LDI",
+	"LDF",
+	"LDIH",
+	"ADDW",
+	"SUBW",
+	"S4ADDW",
+	"S4SUBW",
+	"S8ADDW",
+	"S8SUBW",
+	"ADDL",
+	"SUBL",
+	"S4ADDL",
+	"S4SUBL",
+	"S8ADDL",
+	"S8SUBL",
+	"MULW",
+	"MULL",
+	"UMULH",
+	"CTPOP",
+	"CTLZ",
+	"CTTZ",
+	"ZAP",
+	"ZAPNOT",
+	"SEXTB",
+	"SEXTH",
+	"DIVW",
+	"UDIVW",
+	"REMW",
+	"UREMW",
+	"DIVL",
+	"UDIVL",
+	"REML",
+	"UREML",
+	"ADDPI",
+	"ADDPIS",
+	"SBT",
+	"CBT",
+	"FADDS",
+	"FADDD",
+	"FSUBS",
+	"FSUBD",
+	"FMULS",
+	"FMULD",
+	"FMAS",
+	"FMAD",
+	"FMSS",
+	"FMSD",
+	"FNMAS",
+	"FNMAD",
+	"FNMSS",
+	"FNMSD",
+	"FSELEQ",
+	"FSELNE",
+	"FSELLT",
+	"FSELLE",
+	"FSELGT",
+	"FSELGE",
+	"FDIVS",
+	"FDIVD",
+	"FCPYS",
+	"FCVTSD",
+	"FCVTDS",
+	"FCVTDL",
+	"FCVTLS",
+	"FCVTLD",
+	"FCVTLW",
+	"FCVTWL",
+	"FSQRTS",
+	"FSQRTD",
+	"FCVTDL_Z",
+	"FCVTDL_P",
+	"FCVTDL_G",
+	"FCVTDL_N",
+	"FCMPLE",
+	"FCMPLT",
+	"FCMPEQ",
+	"FCMPUN",
+	"FCPYSN",
+	"FCPYSE",
+	"IFMOVS",
+	"IFMOVD",
+	"FIMOVS",
+	"FIMOVD",
+	"RFPCR",
+	"WFPCR",
+	"SETFPEC0",
+	"SETFPEC1",
+	"SETFPEC2",
+	"SETFPEC3",
+	"MEMB",
+	"IMEMB",
+	"RTC",
+	"RCID",
+	"HALT",
+	"RD_F",
+	"WR_F",
+	"RTID",
+	"LLDW",
+	"LLDL",
+	"LDW_INC",
+	"LDL_INC",
+	"LDW_DEC",
+	"LDL_DEC",
+	"LDW_SET",
+	"LDL_SET",
+	"LSTW",
+	"LSTL",
+	"LDW_NC",
+	"LDL_NC",
+	"LDD_NC",
+	"STW_NC",
+	"STL_NC",
+	"STD_NC",
+	"CMPEQ",
+	"CMPLT",
+	"CMPLE",
+	"CMPULT",
+	"CMPULE",
+	"AND",
+	"BIC",
+	"BIS",
+	"ORNOT",
+	"XOR",
+	"EQV",
+	"INSLB",
+	"INSLH",
+	"INSLW",
+	"INSLL",
+	"INSHB",
+	"INSHH",
+	"INSHW",
+	"INSHL",
+	"SLL",
+	"SRL",
+	"SRA",
+	"EXTLB",
+	"EXTLH",
+	"EXTLW",
+	"EXTLL",
+	"EXTHB",
+	"EXTHH",
+	"EXTHW",
+	"EXTHL",
+	"MASKLB",
+	"MASKLH",
+	"MASKLW",
+	"MASKLL",
+	"MASKHB",
+	"MASKHH",
+	"MASKHW",
+	"MASKHL",
+	"CMPGEB",
+	"SELEQ",
+	"SELGE",
+	"SELGT",
+	"SELLE",
+	"SELLT",
+	"SELNE",
+	"SELLBC",
+	"SELLBS",
+	"PRI_ST",
+	"PRI_LD",
+	"SYMADDR",
+	"WORD",
+	"NOOP",
+	"LDGP",
+	"CRC32L",
+	"CRC32W",
+	"CRC32H",
+	"CRC32B",
+	"CRC32CL",
+	"CRC32CW",
+	"CRC32CH",
+	"CRC32CB",
+	"VLDD",
+	"VLDS",
+	"VSTD",
+	"VSTS",
+	"VAND",
+	"VXOR",
+	"VOR",
+	"VORNOT",
+	"VBIC",
+	"VADDW",
+	"VADDL",
+	"VSUBW",
+	"VSUBL",
+	"VCMPUEQB",
+	"VCMPUGTB",
+	"VCPYB",
+	"VCPYH",
+	"VCTPOP",
+	"VCTLZ",
+	"VMAXB",
+	"VMAXH",
+	"VMAXW",
+	"VMAXL",
+	"VUMAXB",
+	"VUMAXH",
+	"VUMAXW",
+	"VUMAXL",
+	"VMINB",
+	"VMINH",
+	"VMINW",
+	"VMINL",
+	"VUMINB",
+	"VUMINH",
+	"VUMINW",
+	"VUMINL",
+	"LAST",
+}
diff --git a/src/cmd/internal/obj/sw64/anames77.go b/src/cmd/internal/obj/sw64/anames77.go
new file mode 100644
index 00000000..9486c07a
--- /dev/null
+++ b/src/cmd/internal/obj/sw64/anames77.go
@@ -0,0 +1,30 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package sw64
+
+var cnames77 = []string{
+	"NONE",
+	"RREG",
+	"FREG",
+	"VREG",
+	"REG",
+	"SUCON",
+	"MCON",
+	"LCON",
+	"FCON",
+	"LEXT",
+	"ADDR",
+	"SAUTO",
+	"LAUTO",
+	"ZOREG",
+	"SOREG",
+	"LOREG",
+	"SBRA",
+	"GOTADDR",
+	"GOK",
+	"C_TLS_LE",
+	"C_TLS_IE",
+	"NCLASS",
+}
diff --git a/src/cmd/internal/obj/sw64/asm77.go b/src/cmd/internal/obj/sw64/asm77.go
new file mode 100644
index 00000000..9206f5f5
--- /dev/null
+++ b/src/cmd/internal/obj/sw64/asm77.go
@@ -0,0 +1,2179 @@
+// cmd/9l/optab.c, cmd/9l/asmout.c from Vita Nuova.
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2008 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2008 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors. All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+package sw64
+
+import (
+	"cmd/internal/obj"
+	"cmd/internal/objabi"
+	"fmt"
+	"internal/buildcfg"
+	"log"
+	"math"
+	"sort"
+)
+
+// ctxt77 holds state while assembling a single function.
+// Each function gets a fresh ctxt77.
+// This allows for multiple functions to be safely concurrently assembled.
+type ctxt77 struct {
+	ctxt       *obj.Link
+	newprog    obj.ProgAlloc
+	cursym     *obj.LSym
+	autosize   int32
+	instoffset int64
+	pc         int64
+}
+
+const (
+	funcAlign = 16
+)
+
+type Optab struct {
+	as    obj.As
+	a1    uint8
+	a2    uint8
+	a3    uint8
+	a4    uint8
+	type_ int8
+	size  int8
+	param int16
+	flag  uint8
+}
+
+const (
+	// Optab.flag
+	NOTUSETMP = 1 << iota // p expands to multiple instructions, but does NOT use REGTMP
+)
+
+var optab = []Optab{
+	{obj.ANOP, C_NONE, C_NONE, C_NONE, C_NONE, 0, 0, 0, 0},
+	{obj.AFUNCDATA, C_SUCON, C_NONE, C_NONE, C_LEXT, 0, 0, 0, 0},
+	{obj.APCDATA, C_SUCON, C_NONE, C_NONE, C_LCON, 0, 0, 0, 0},
+	{obj.ARET, C_RREG, C_NONE, C_NONE, C_SOREG, 2, 4, 0, 0},
+	//zxw add
+	{obj.ARET, C_NONE, C_NONE, C_NONE, C_LEXT, 24, 12, REG_R29, NOTUSETMP},
+	{AMEMB, C_NONE, C_NONE, C_NONE, C_NONE, 4, 4, 0, 0},
+	//	{ARTC, C_RREG, C_NONE, C_NONE, C_NONE, 4, 4, 0, 0},
+	{ARD_F, C_RREG, C_NONE, C_NONE, C_NONE, 4, 4, 0, 0},
+	{ASYS_CALL, C_SUCON, C_NONE, C_NONE, C_NONE, 1, 4, 0, 0},
+	{AEXCB, C_RREG, C_NONE, C_NONE, C_SAUTO, 2, 4, 0, 0},
+
+	{ARFPCR, C_FREG, C_NONE, C_NONE, C_NONE, 6, 4, 0, 0},
+	{ASETFPEC0, C_NONE, C_NONE, C_NONE, C_NONE, 6, 4, 0, 0},
+
+	{AADDW, C_RREG, C_RREG, C_NONE, C_RREG, 6, 4, 0, 0},
+	{AADDW, C_RREG, C_SUCON, C_NONE, C_RREG, 7, 4, 0, 0},
+	{AADDW, C_RREG, C_MCON, C_NONE, C_RREG, 14, 8, 0, 0},
+	{AADDW, C_RREG, C_LCON, C_NONE, C_RREG, 16, 16, 0, 0},
+	{AADDW, C_RREG, C_NONE, C_NONE, C_RREG, 6, 4, 0, 0},
+
+	{ACTPOP, C_RREG, C_RREG, C_NONE, C_RREG, 6, 4, 0, 0},
+	{AIFMOVS, C_RREG, C_NONE, C_NONE, C_FREG, 6, 4, 0, 0},
+	{AFIMOVS, C_FREG, C_NONE, C_NONE, C_RREG, 6, 4, 0, 0},
+	{AFADDS, C_FREG, C_FREG, C_NONE, C_FREG, 6, 4, 0, 0},
+	{AFSQRTS, C_RREG, C_FREG, C_NONE, C_FREG, 6, 4, 0, 0},
+
+	{ALDBU, C_RREG, C_NONE, C_NONE, C_SAUTO, 2, 4, REG_R30, 0},
+	{ALDBU, C_RREG, C_NONE, C_NONE, C_LAUTO, 17, 20, REG_R30, 0},
+	{ALDBU, C_RREG, C_NONE, C_NONE, C_SOREG, 2, 4, 0, 0},
+	{ALDBU, C_RREG, C_NONE, C_NONE, C_LOREG, 17, 20, 0, 0},
+	{ALDBU, C_RREG, C_NONE, C_NONE, C_LEXT, 12, 8, REG_R29, NOTUSETMP},
+	{ALDBU, C_RREG, C_NONE, C_NONE, C_TLS_LE, 22, 12, 0, NOTUSETMP},
+	{ALDBU, C_RREG, C_NONE, C_NONE, C_TLS_IE, 23, 16, 0, 0},
+	{ASTB, C_RREG, C_NONE, C_NONE, C_SAUTO, 2, 4, REG_R30, 0},
+	{ASTB, C_RREG, C_NONE, C_NONE, C_LAUTO, 17, 20, REG_R30, 0},
+	{ASTB, C_RREG, C_NONE, C_NONE, C_SOREG, 2, 4, 0, 0},
+	{ASTB, C_RREG, C_NONE, C_NONE, C_LOREG, 17, 20, 0, 0},
+	{ASTB, C_RREG, C_NONE, C_NONE, C_LEXT, 13, 8, REG_R29, 0},
+	{ASTB, C_RREG, C_NONE, C_NONE, C_TLS_LE, 22, 12, 0, NOTUSETMP},
+	{ASTB, C_RREG, C_NONE, C_NONE, C_TLS_IE, 23, 16, 0, 0},
+
+	{AFLDD, C_FREG, C_NONE, C_NONE, C_SAUTO, 2, 4, REG_R30, 0},
+	{AFLDD, C_FREG, C_NONE, C_NONE, C_LAUTO, 17, 20, REG_R30, 0},
+	{AFLDD, C_FREG, C_NONE, C_NONE, C_SOREG, 2, 4, 0, 0},
+	{AFLDD, C_FREG, C_NONE, C_NONE, C_LOREG, 17, 20, 0, 0},
+	{AFLDD, C_FREG, C_NONE, C_NONE, C_LEXT, 15, 12, REG_R29, 0},
+
+	{AFSTD, C_FREG, C_NONE, C_NONE, C_SAUTO, 2, 4, REG_R30, 0},
+	{AFSTD, C_FREG, C_NONE, C_NONE, C_LAUTO, 17, 20, REG_R30, 0},
+	{AFSTD, C_FREG, C_NONE, C_NONE, C_SOREG, 2, 4, 0, 0},
+	{AFSTD, C_FREG, C_NONE, C_NONE, C_LOREG, 17, 20, 0, 0},
+	{AFSTD, C_FREG, C_NONE, C_NONE, C_LEXT, 13, 8, REG_R29, 0},
+
+	{ALDI, C_RREG, C_NONE, C_NONE, C_MCON, 2, 4, 0, 0},
+	{ALDI, C_RREG, C_NONE, C_NONE, C_SAUTO, 2, 4, REG_R30, 0},
+	{ALDI, C_RREG, C_NONE, C_NONE, C_LAUTO, 17, 20, REG_R30, 0},
+	{ALDI, C_RREG, C_NONE, C_NONE, C_RREG, 2, 4, 0, 0},
+	{ALDI, C_RREG, C_NONE, C_NONE, C_SOREG, 2, 4, 0, 0},
+	{ALDI, C_RREG, C_NONE, C_NONE, C_LOREG, 17, 20, 0, 0},
+	{AADDPI, C_LEXT, C_NONE, C_NONE, C_RREG, 27, 4, 0, 0},
+
+	{ASYMADDR, C_RREG, C_NONE, C_NONE, C_LEXT, 12, 8, REG_R29, NOTUSETMP},
+	{ALLDW, C_RREG, C_NONE, C_NONE, C_SOREG, 5, 4, 0, 0},
+	{ABR, C_RREG, C_NONE, C_NONE, C_SBRA, 3, 4, 0, 0},
+	{ABR, C_RREG, C_NONE, C_NONE, C_LEXT, 10, 4, REG_R29, 0},
+	{AFBGE, C_FREG, C_NONE, C_NONE, C_SBRA, 3, 4, 0, 0},
+	{AFBGE, C_FREG, C_NONE, C_NONE, C_LEXT, 10, 4, REG_R29, 0},
+	{obj.AJMP, C_RREG, C_NONE, C_NONE, C_LEXT, 9, 12, REG_R29, NOTUSETMP},
+	{obj.AJMP, C_RREG, C_NONE, C_NONE, C_SOREG, 21, 4, 0, 0},
+
+	{AFMAS, C_FREG, C_FREG, C_FREG, C_FREG, 8, 4, 0, 0},
+	{ASELEQ, C_RREG, C_RREG, C_RREG, C_RREG, 8, 4, 0, 0},
+
+	{AMOVD, C_GOTADDR, C_NONE, C_NONE, C_RREG, 25, 8, 0, 0},
+	{ASYMADDR, C_RREG, C_NONE, C_NONE, C_GOTADDR, 26, 8, 0, 0},
+
+	{AVADDW, C_VREG, C_VREG, C_NONE, C_VREG, 30, 4, 0, 0},
+	{AVADDW, C_VREG, C_NONE, C_NONE, C_VREG, 30, 4, 0, 0},
+	{AVAND, C_VREG, C_VREG, C_NONE, C_VREG, 31, 4, 0, 0},
+	{AVAND, C_VREG, C_NONE, C_NONE, C_VREG, 31, 4, 0, 0},
+	{AVLDD, C_VREG, C_NONE, C_NONE, C_SOREG, 32, 4, 0, 0},
+	//{AVLDD, C_SOREG, C_NONE, C_NONE, C_VREG, 32, 4, 0, 0},
+	{AVSTD, C_VREG, C_NONE, C_NONE, C_SOREG, 32, 4, 0, 0},
+	{AVCPYB, C_FREG, C_NONE, C_NONE, C_VREG, 33, 4, 0, 0},
+	{AVCTPOP, C_VREG, C_NONE, C_NONE, C_VREG, 34, 4, 0, 0},
+
+	{AMOVB, C_RREG, C_NONE, C_NONE, C_RREG, 35, 4, 0, 0},
+	{AMOVBU, C_RREG, C_NONE, C_NONE, C_RREG, 36, 4, 0, 0},
+
+	{ALDGP, C_RREG, C_NONE, C_NONE, C_RREG, 20, 16, 0, 0},
+	{ANOOP, C_NONE, C_NONE, C_NONE, C_NONE, 11, 4, 0, 0},
+	{obj.AUNDEF, C_NONE, C_NONE, C_NONE, C_NONE, 18, 4, 0, 0},
+	{AWORD, C_LCON, C_NONE, C_NONE, C_NONE, 19, 4, 0, 0},
+	{obj.AXXX, C_NONE, C_NONE, C_NONE, C_NONE, 0, 4, 0, 0},
+}
+
+var oprange [ALAST & obj.AMask][]Optab
+
+var xcmp [C_NCLASS][C_NCLASS]bool
+
+func span77(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
+	if ctxt.Retpoline {
+		ctxt.Diag("-spectre=ret not supported on sw64")
+		ctxt.Retpoline = false // don't keep printing
+	}
+	p := cursym.Func().Text
+	if p == nil || p.Link == nil { // handle external functions and ELF section symbols
+		return
+	}
+
+	c := ctxt77{ctxt: ctxt, newprog: newprog, cursym: cursym, autosize: int32(p.To.Offset + ctxt.Arch.FixedFrameSize)}
+
+	if oprange[AADDL&obj.AMask] == nil {
+		c.ctxt.Diag("sw64 ops not initialized, call sw64.buildop first")
+
+	}
+
+	pc := int64(0)
+	p.Pc = pc
+
+	var m int
+	var o *Optab
+	for p = p.Link; p != nil; p = p.Link {
+		p.Pc = pc
+		o = c.oplook(p)
+		m = int(o.size)
+		if m == 0 {
+			if p.As != obj.ANOP && p.As != obj.AFUNCDATA && p.As != obj.APCDATA {
+				c.ctxt.Diag("zero-width instruction\n%v", p)
+			}
+			continue
+		}
+
+		if (p.As == ALSTW || p.As == ALSTL) && p.Pc&0x7 != 0 {
+			m += 4
+		}
+		pc += int64(m)
+	}
+
+	c.cursym.Size = pc
+
+	/*
+	 * if any procedure is large enough to
+	 * generate a large SBRA branch, then
+	 * generate extra passes putting branches
+	 * around jmps to fix. this is rare.
+	 */
+	/*	bflag := 1
+
+		var otxt int64
+		var q *obj.Prog
+		for bflag != 0 {
+			bflag = 0
+			pc = 0
+			for p = c.cursym.Func().Text.Link; p != nil; p = p.Link {
+				p.Pc = pc
+				o = c.oplook(p)
+				// very large conditional branches
+				if (o.type_ == 3 || o.type_ == 10) && p.To.Target() != nil {
+					otxt = p.To.Target().Pc - pc
+					if otxt < -(1<<17)+10 || otxt >= (1<<17)-10 {
+						q = c.newprog()
+						q.Link = p.Link
+						p.Link = q
+						q.As = ABR
+						q.To.Type = obj.TYPE_BRANCH
+						q.To.SetTarget(p.To.Target())
+					 	p.To.SetTarget(q)
+						q = c.newprog()
+						q.Link = p.Link
+						p.Link = q
+						q.As = ABR
+						q.To.Type = obj.TYPE_BRANCH
+						q.To.SetTarget(q.Link.Link)
+						c.addnop(p.Link)
+						c.addnop(p)
+						bflag = 1
+					}
+				}
+				m = int(o.size)
+				if m == 0 {
+					if p.As != obj.ANOP && p.As != obj.AFUNCDATA && p.As != obj.APCDATA {
+						c.ctxt.Diag("zero-width instruction\n%v", p)
+					}
+					continue
+				}
+
+				pc += int64(m)
+			}
+
+			c.cursym.Size = pc
+		}
+
+		pc += -pc & (funcAlign - 1)
+		c.cursym.Size = pc
+	*/
+	/*
+	 * lay out the code, emitting code and data relocations.
+	 */
+	c.cursym.Grow(c.cursym.Size)
+	bp := c.cursym.P
+	var i int32
+	var out [5]uint32
+	for p := c.cursym.Func().Text.Link; p != nil; p = p.Link {
+		c.pc = p.Pc
+		o = c.oplook(p)
+		if int(o.size) > 4*len(out) {
+			log.Fatalf("out array in span77 is too small, need at least %d for %v", o.size/4, p)
+		}
+		c.asmout(p, o, out[:])
+		n := o.size
+		if (p.As == ALSTW || p.As == ALSTL) && p.Pc&0x7 != 0 {
+			n += 4
+		}
+		for i = 0; i < int32(n/4); i++ {
+			c.ctxt.Arch.ByteOrder.PutUint32(bp, out[i])
+			bp = bp[4:]
+		}
+	}
+
+	// Mark nonpreemptible instruction sequences.
+	// We use REGTMP as a scratch register during call injection,
+	// so instruction sequences that use REGTMP are unsafe to
+	// preempt asynchronously.
+	obj.MarkUnsafePoints(c.ctxt, c.cursym.Func().Text, c.newprog, c.isUnsafePoint, c.isRestartable)
+
+	// Now that we know byte offsets, we can generate jump table entries.
+	for _, jt := range cursym.Func().JumpTables {
+		for i, p := range jt.Targets {
+			// The ith jumptable entry points to the p.Pc'th
+			// byte in the function symbol s.
+			jt.Sym.WriteAddr(ctxt, int64(i)*8, 8, cursym, p.Pc)
+		}
+	}
+
+	verifyLock(c)
+}
+
+// isUnsafePoint returns whether p is an unsafe point.
+func (c *ctxt77) isUnsafePoint(p *obj.Prog) bool {
+	// If p explicitly uses REGTMP, it's unsafe to preempt, because the
+	// preemption sequence clobbers REGTMP.
+	return p.From.Reg == REGTMP || p.To.Reg == REGTMP || p.Reg == REGTMP
+}
+
+// isRestartable returns whether p is a multi-instruction sequence that,
+// if preempted, can be restarted.
+func (c *ctxt77) isRestartable(p *obj.Prog) bool {
+	if c.isUnsafePoint(p) {
+		return false
+	}
+	// If p is a multi-instruction sequence with uses REGTMP inserted by
+	// the assembler in order to materialize a large constant/offset, we
+	// can restart p (at the start of the instruction sequence), recompute
+	// the content of REGTMP, upon async preemption. Currently, all cases
+	// of assembler-inserted REGTMP fall into this category.
+	// If p doesn't use REGTMP, it can be simply preempted, so we don't
+	// mark it.
+	o := c.oplook(p)
+	return o.size > 4 && o.flag&NOTUSETMP == 0
+}
+
+func verifyLock(c ctxt77) {
+	for p := c.cursym.Func().Text.Link; p != nil; p = p.Link {
+		// 判断锁装入指令与写锁标志指令是否成对出现
+		if p.As == ALLDW || p.As == ALLDL {
+			for q := p; q != nil; q = q.Link {
+				if q.As != AWR_F {
+					if q.As == ALSTW || q.As == ALSTL {
+						c.ctxt.Diag("missing WR_F after %s\n", p.As)
+						return
+					} else {
+						if (q.Pc + 4) == c.cursym.Size {
+							c.ctxt.Diag("Atomic operation is not logical!\n")
+							return
+						}
+						continue
+					}
+				} else {
+					break
+				}
+			}
+		}
+		if p.As == ALSTW || p.As == ALSTL {
+			// 判断锁存储指令与读锁标志指令是否成对出现
+			if p.Link.As != ARD_F {
+				c.ctxt.Diag("missing RD_F after %s\n", p.As)
+				return
+			}
+			if p.From.Reg != p.Link.From.Reg {
+				c.ctxt.Diag("the source regs of %s and RD_F should be same!\n", p.As)
+				return
+			}
+		}
+	}
+
+}
+
+func IsReg(r int) bool {
+	return REG_R0 <= r && r <= REG_V31
+}
+func IsFReg(r int) bool {
+	return REG_F0 <= r && r <= REG_F31
+}
+func IsRReg(r int) bool {
+	return REG_R0 <= r && r <= REG_R31
+}
+func IsVReg(r int) bool {
+	return REG_V0 <= r && r <= REG_V31
+}
+func isint16(v int64) bool {
+	return int64(int16(v)) == v
+}
+func isuint8(v uint64) bool {
+	return uint64(uint8(v)) == v
+}
+
+func isint32(v int64) bool {
+	return int64(int32(v)) == v
+}
+
+func isuint32(v uint64) bool {
+	return uint64(uint32(v)) == v
+}
+
+func (c *ctxt77) aclass(a *obj.Addr) int {
+	if a.Sym != nil { // use relocation
+		if a.Sym.Type == objabi.STLSBSS {
+			if c.ctxt.Flag_shared {
+				return C_TLS_IE
+			} else {
+				return C_TLS_LE
+			}
+		}
+	}
+	switch a.Type {
+	case obj.TYPE_NONE:
+		return C_NONE
+
+	case obj.TYPE_REG:
+		if IsRReg(int(a.Reg)) {
+			return C_RREG
+		}
+
+		if IsFReg(int(a.Reg)) {
+			return C_FREG
+		}
+
+		if IsVReg(int(a.Reg)) {
+			return C_VREG
+		}
+
+	case obj.TYPE_CONST:
+		if isuint8(uint64(a.Offset)) {
+			return C_SUCON
+		}
+		if isint16(a.Offset) {
+			return C_MCON
+		}
+		return C_LCON
+
+	case obj.TYPE_FCONST:
+		return C_FCON
+
+	case obj.TYPE_MEM,
+		obj.TYPE_ADDR:
+		switch a.Name {
+		case obj.NAME_GOTREF:
+			return C_GOTADDR
+		case obj.NAME_EXTERN, obj.NAME_STATIC:
+			if a.Sym.Type == objabi.STLSBSS {
+				c.ctxt.Diag("taking address of TLS variable is not supported")
+			}
+			return C_LEXT
+		case obj.NAME_PARAM, obj.NAME_AUTO:
+			if isint16(a.Offset) {
+				return C_SAUTO
+			}
+			if a.Offset > math.MaxInt16 || -a.Offset > math.MaxInt16 {
+				return C_LAUTO
+			}
+		case obj.NAME_NONE:
+			if isint16(a.Offset) {
+				return C_SOREG
+			}
+			if a.Offset > math.MaxInt16 || -a.Offset > math.MaxInt16 {
+				return C_LOREG
+			}
+		}
+		return C_ADDR
+
+	case obj.TYPE_BRANCH:
+		switch a.Name {
+		case obj.NAME_EXTERN, obj.NAME_STATIC:
+			return C_LEXT
+		}
+		return C_SBRA
+	case obj.TYPE_INDIR:
+		switch a.Name {
+		case obj.NAME_EXTERN, obj.NAME_STATIC:
+			return C_LEXT
+		}
+	}
+	return C_GOK
+}
+
+func prasm(p *obj.Prog) {
+	fmt.Printf("%v\n", p)
+}
+
+func (c *ctxt77) oplook(p *obj.Prog) *Optab {
+	if oprange[AADDL&obj.AMask] == nil {
+		c.ctxt.Diag("sw64 ops not initialized, call sw64.buildop first")
+	}
+	a1 := int(p.Optab)
+	if a1 != 0 {
+		return &optab[a1-1]
+	}
+	a1 = int(p.From.Class)
+	if a1 == 0 {
+		a1 = c.aclass(&p.From) + 1
+		p.From.Class = int8(a1)
+	}
+
+	a1--
+
+	a3 := C_NONE
+	if len(p.RestArgs) == 2 {
+		a3 = int(p.RestArgs[1].Addr.Class)
+		if a3 == 0 {
+			a3 = c.aclass(&p.RestArgs[1].Addr) + 1
+			p.GetFrom3().Class = int8(a3)
+		}
+		a3--
+
+	}
+
+	a2 := C_NONE
+	if p.Reg != 0 {
+		a2 = C_RREG
+		if IsFReg(int(p.Reg)) {
+			a2 = C_FREG
+		}
+		if IsVReg(int(p.Reg)) {
+			a2 = C_VREG
+		}
+	}
+	if (p.Reg == 0) && (len(p.RestArgs) != 0) {
+		a2 = int(p.RestArgs[0].Addr.Class)
+		if a2 == 0 {
+			a2 = c.aclass(&p.RestArgs[0].Addr) + 1
+			p.RestArgs[0].Addr.Class = int8(a2)
+		}
+		a2--
+	}
+	a4 := int(p.To.Class)
+	if a4 == 0 {
+		a4 = c.aclass(&p.To) + 1
+		p.To.Class = int8(a4)
+	}
+
+	a4--
+
+	ops := oprange[p.As&obj.AMask]
+	c1 := &xcmp[a1]
+	c2 := &xcmp[a2]
+	c3 := &xcmp[a3]
+	c4 := &xcmp[a4]
+	for i := range ops {
+		op := &ops[i]
+		if c1[op.a1] && c2[op.a2] && c3[op.a3] && c4[op.a4] {
+			p.Optab = uint16(cap(optab) - cap(ops) + i + 1)
+			return op
+		}
+	}
+
+	c.ctxt.Diag("illegal combination %v %v %v %v %v", p.As, DRconv(a1), DRconv(a2), DRconv(a3), DRconv(a4))
+	prasm(p)
+	if ops == nil {
+		ops = optab
+	}
+	return &ops[0]
+}
+
+func cmp(a int, b int) bool {
+	if a == b {
+		return true
+	}
+	switch a {
+	case C_LCON:
+		if b == C_SUCON || b == C_MCON {
+			return true
+		}
+
+	case C_MCON:
+		if b == C_SUCON {
+			return true
+		}
+
+	case C_LAUTO:
+		if b == C_SAUTO {
+			return true
+		}
+
+	case C_LOREG:
+		if b == C_ZOREG || b == C_SOREG {
+			return true
+		}
+
+	case C_SOREG:
+		if b == C_ZOREG {
+			return true
+		}
+
+	}
+
+	return false
+}
+
+type ocmp []Optab
+
+func (x ocmp) Len() int {
+	return len(x)
+}
+
+func (x ocmp) Swap(i, j int) {
+	x[i], x[j] = x[j], x[i]
+}
+
+func (x ocmp) Less(i, j int) bool {
+	p1 := &x[i]
+	p2 := &x[j]
+	n := int(p1.as) - int(p2.as)
+	if n != 0 {
+		return n < 0
+	}
+	n = int(p1.a1) - int(p2.a1)
+	if n != 0 {
+		return n < 0
+	}
+	n = int(p1.a2) - int(p2.a2)
+	if n != 0 {
+		return n < 0
+	}
+	n = int(p1.a3) - int(p2.a3)
+	if n != 0 {
+		return n < 0
+	}
+	n = int(p1.a4) - int(p2.a4)
+	if n != 0 {
+		return n < 0
+	}
+	return false
+}
+
+func opset(a, b0 obj.As) {
+	oprange[a&obj.AMask] = oprange[b0]
+}
+
+func buildop(ctxt *obj.Link) {
+	if oprange[AADDL&obj.AMask] != nil {
+		// Already initialized; stop now.
+		// This happens in the cmd/asm tests,
+		// each of which re-initializes the arch.
+		return
+	}
+
+	var n int
+
+	for i := 0; i < C_NCLASS; i++ {
+		for n = 0; n < C_NCLASS; n++ {
+			if cmp(n, i) {
+				xcmp[i][n] = true
+			}
+		}
+	}
+	for n = 0; optab[n].as != obj.AXXX; n++ {
+	}
+	sort.Sort(ocmp(optab[:n]))
+	for i := 0; i < n; i++ {
+		r := optab[i].as
+		r0 := r & obj.AMask
+		start := i
+		for optab[i].as == r {
+			i++
+		}
+		oprange[r0] = optab[start:i]
+		i--
+
+		switch r {
+		default:
+			ctxt.Diag("unknown op in build: %v", r)
+			ctxt.DiagFlush()
+			log.Fatalf("bad code")
+		case ASYS_CALL:
+			opset(ASYS_CALL_B, r0)
+		case AEXCB:
+			opset(APRI_LD, r0)
+			opset(APRI_ST, r0)
+		case AADDW:
+			opset(AADDL, r0)
+			opset(ASUBL, r0)
+			opset(ASUBW, r0)
+			opset(AMULW, r0)
+			opset(AMULL, r0)
+			opset(AUMULH, r0)
+			opset(ACMPEQ, r0)
+			opset(ACMPLT, r0)
+			opset(ACMPLE, r0)
+			opset(ACMPULT, r0)
+			opset(ACMPULE, r0)
+			opset(AAND, r0)
+			opset(ABIS, r0)
+			opset(AXOR, r0)
+			opset(AORNOT, r0)
+			opset(ASLL, r0)
+			opset(ASRL, r0)
+			opset(ASRA, r0)
+			opset(ASEXTB, r0)
+			opset(ASEXTH, r0)
+			opset(AS4ADDW, r0)
+			opset(AS4SUBW, r0)
+			opset(AS8ADDW, r0)
+			opset(AS8SUBW, r0)
+			opset(AS4ADDL, r0)
+			opset(AS4SUBL, r0)
+			opset(AS8ADDL, r0)
+			opset(AS8SUBL, r0)
+			opset(ABIC, r0)
+			opset(AEQV, r0)
+			opset(AINSLB, r0)
+			opset(AINSLH, r0)
+			opset(AINSLW, r0)
+			opset(AINSLL, r0)
+			opset(AINSHB, r0)
+			opset(AINSHH, r0)
+			opset(AINSHW, r0)
+			opset(AINSHL, r0)
+			opset(AEXTLB, r0)
+			opset(AEXTLH, r0)
+			opset(AEXTLW, r0)
+			opset(AEXTLL, r0)
+			opset(AEXTHB, r0)
+			opset(AEXTHH, r0)
+			opset(AEXTHW, r0)
+			opset(AEXTHL, r0)
+			opset(AMASKLB, r0)
+			opset(AMASKLH, r0)
+			opset(AMASKLW, r0)
+			opset(AMASKLL, r0)
+			opset(AMASKHB, r0)
+			opset(AMASKHH, r0)
+			opset(AMASKHW, r0)
+			opset(AMASKHL, r0)
+			opset(ACMPGEB, r0)
+			opset(AZAP, r0)
+			opset(AZAPNOT, r0)
+			opset(ASBT, r0)
+			opset(ACBT, r0)
+			opset(ACRC32CL, r0)
+			opset(ACRC32CW, r0)
+			opset(ACRC32CH, r0)
+			opset(ACRC32CB, r0)
+			opset(ACRC32L, r0)
+			opset(ACRC32W, r0)
+			opset(ACRC32H, r0)
+			opset(ACRC32B, r0)
+		case ABR:
+			opset(ABSR, r0)
+			opset(ABEQ, r0)
+			opset(ABGE, r0)
+			opset(ABGT, r0)
+			opset(ABLE, r0)
+			opset(ABLT, r0)
+			opset(ABNE, r0)
+			opset(ABLBC, r0)
+			opset(ABLBS, r0)
+		case AFBGE:
+			opset(AFBGT, r0)
+			opset(AFBEQ, r0)
+			opset(AFBLE, r0)
+			opset(AFBLT, r0)
+			opset(AFBNE, r0)
+		case AMEMB:
+			opset(AIMEMB, r0)
+		case ARD_F:
+			opset(AWR_F, r0)
+			//			opset(ARTC, r0)
+		case ALLDW:
+			opset(ALLDL, r0)
+			opset(ALSTW, r0)
+			opset(ALSTL, r0)
+		case AFMAS:
+			opset(AFMAD, r0)
+			opset(AFMSS, r0)
+			opset(AFMSD, r0)
+			opset(AFNMAS, r0)
+			opset(AFNMAD, r0)
+			opset(AFNMSS, r0)
+			opset(AFNMSD, r0)
+			opset(AFSELEQ, r0)
+			opset(AFSELNE, r0)
+			opset(AFSELLT, r0)
+			opset(AFSELLE, r0)
+			opset(AFSELGT, r0)
+			opset(AFSELGE, r0)
+		case ASELEQ:
+			opset(ASELNE, r0)
+			opset(ASELGE, r0)
+			opset(ASELGT, r0)
+			opset(ASELLE, r0)
+			opset(ASELLT, r0)
+			opset(ASELLBC, r0)
+			opset(ASELLBS, r0)
+		case ALDBU:
+			opset(ALDHU, r0)
+			opset(ALDW, r0)
+			opset(ALDL, r0)
+			opset(ALDBUA, r0)
+			opset(ALDHUA, r0)
+			opset(ALDWA, r0)
+			opset(ALDLA, r0)
+			opset(AFLDSA, r0)
+			opset(AFLDDA, r0)
+		case AVLDD:
+			opset(AVLDS, r0)
+			opset(ALDL_U, r0)
+		case ASTB:
+			opset(ASTH, r0)
+			opset(ASTW, r0)
+			opset(ASTL, r0)
+			opset(ASTBA, r0)
+			opset(ASTHA, r0)
+			opset(ASTWA, r0)
+			opset(ASTLA, r0)
+			opset(AFSTSA, r0)
+			opset(AFSTDA, r0)
+		case AVSTD:
+			opset(AVSTS, r0)
+			opset(ASTL_U, r0)
+		case ACTPOP:
+			opset(ACTLZ, r0)
+			opset(ACTTZ, r0)
+			opset(ADIVW, r0)
+			opset(AUDIVW, r0)
+			opset(AREMW, r0)
+			opset(AUREMW, r0)
+			opset(ADIVL, r0)
+			opset(AUDIVL, r0)
+			opset(AREML, r0)
+			opset(AUREML, r0)
+		case AFIMOVS:
+			opset(AFIMOVD, r0)
+		case AIFMOVS:
+			opset(AIFMOVD, r0)
+		case AFADDS:
+			opset(AFADDD, r0)
+			opset(AFSUBS, r0)
+			opset(AFSUBD, r0)
+			opset(AFMULS, r0)
+			opset(AFMULD, r0)
+			opset(AFDIVS, r0)
+			opset(AFDIVD, r0)
+			opset(AFCMPEQ, r0)
+			opset(AFCMPLE, r0)
+			opset(AFCMPLT, r0)
+			opset(AFCMPUN, r0)
+			opset(AFCPYS, r0)
+			opset(AFCPYSE, r0)
+			opset(AFCPYSN, r0)
+		case AFSQRTS:
+			opset(AFSQRTD, r0)
+			opset(AFCVTSD, r0)
+			opset(AFCVTDS, r0)
+			opset(AFCVTDL_G, r0)
+			opset(AFCVTDL_P, r0)
+			opset(AFCVTDL_Z, r0)
+			opset(AFCVTDL_N, r0)
+			opset(AFCVTDL, r0)
+			opset(AFCVTWL, r0)
+			opset(AFCVTLW, r0)
+			opset(AFCVTLS, r0)
+			opset(AFCVTLD, r0)
+		case ARFPCR:
+			opset(AWFPCR, r0)
+		case ASETFPEC0:
+			opset(ASETFPEC1, r0)
+			opset(ASETFPEC2, r0)
+			opset(ASETFPEC3, r0)
+		case AFLDD:
+			opset(AFLDS, r0)
+		case AFSTD:
+			opset(AFSTS, r0)
+		case ALDI:
+			opset(ALDIH, r0)
+		case obj.AJMP:
+			opset(obj.ACALL, r0)
+		case AADDPI:
+			opset(AADDPIS, r0)
+			// SIMD v2
+		case AVAND:
+			opset(AVOR, r0)
+			opset(AVXOR, r0)
+			opset(AVORNOT, r0)
+			opset(AVBIC, r0)
+		case AVCPYB:
+			opset(AVCPYH, r0)
+		case AVADDW:
+			opset(AVADDL, r0)
+			opset(AVSUBW, r0)
+			opset(AVSUBL, r0)
+			opset(AVCMPUEQB, r0)
+			opset(AVCMPUGTB, r0)
+			opset(AVMAXB, r0)
+			opset(AVMAXH, r0)
+			opset(AVMAXW, r0)
+			opset(AVMAXL, r0)
+			opset(AVUMAXB, r0)
+			opset(AVUMAXH, r0)
+			opset(AVUMAXW, r0)
+			opset(AVUMAXL, r0)
+			opset(AVMINB, r0)
+			opset(AVMINH, r0)
+			opset(AVMINW, r0)
+			opset(AVMINL, r0)
+			opset(AVUMINB, r0)
+			opset(AVUMINH, r0)
+			opset(AVUMINW, r0)
+			opset(AVUMINL, r0)
+		case AVCTPOP:
+			opset(AVCTLZ, r0)
+		case AMOVB:
+			opset(AMOVH, r0)
+			opset(AMOVW, r0)
+			opset(AMOVV, r0)
+		case AMOVBU:
+			opset(AMOVHU, r0)
+			opset(AMOVWU, r0)
+		case ASYMADDR,
+			ALDGP,
+			obj.ANOP,
+			obj.AFUNCDATA,
+			obj.APCDATA,
+			obj.AUNDEF,
+			obj.ARET,
+			ANOOP,
+			AMOVD,
+			AWORD:
+			break
+		}
+
+	}
+
+}
+
+// 操作码
+func SP(x uint32, y uint32) uint32 {
+	return x<<30 | y<<26
+}
+
+// 带功能码的指令
+func FLD(x uint32) uint32 {
+	return SP(0, 0x1E) | x<<12
+}
+func FMM(x uint32, y uint32) uint32 {
+	return SP(0, 6) | x<<8 | y<<0
+}
+
+func FA(x uint32, y uint32) uint32 {
+	return SP(1, 0) | x<<9 | y<<5
+}
+
+func VFA(x uint32, y uint32) uint32 {
+	return SP(1, 0xa) | x<<9 | y<<5
+}
+
+func FAF(x uint32, y uint32) uint32 {
+	return SP(1, 8) | x<<9 | y<<5
+}
+
+func FAI(x uint32, y uint32) uint32 {
+	return SP(1, 2) | x<<9 | y<<5
+}
+
+func FCA(x uint32, y uint32) uint32 {
+	return SP(1, 9) | x<<14 | y<<10
+}
+
+func VFCA(x uint32, y uint32) uint32 {
+	return SP(1, 0xb) | x<<14 | y<<10
+}
+
+func VLOG(x uint32, y uint32) uint32 {
+	return SP(1, 4) | x<<26 | y<<10
+}
+
+// 系统调用指令
+func OP_SYSCALL(op uint32, fn uint32) uint32 {
+	return op | fn
+}
+
+// 转移控制指令
+func OP_CONTROL(op uint32, ra int16, disp int32) uint32 {
+	return op | uint32(ra)<<21 | uint32(disp)&(1<<21-1)
+}
+
+// 存储器指令
+func OP_MEMORY(op uint32, ra int16, rb int16, disp int16) uint32 {
+	return op | uint32(ra)<<21 | uint32(rb)<<16 | uint32(uint16(disp))
+}
+
+// 杂项指令
+func OP_MISI_MEMORY(op uint32, ra int16, rb int16) uint32 {
+	return op | uint32(ra)<<21 | uint32(rb)<<16
+}
+
+// 带功能域的存储器指令
+func OP_FUNC_MEMORY(op uint32, ra int16, rb int16, disp int16) uint32 {
+	return op | uint32(ra)<<21 | uint32(rb)<<16 | uint32(uint16(disp))
+}
+
+// 简单运算指令寄存器格式
+func OP_ARITHMETIC(op uint32, ra int16, rb int16, rc int16) uint32 {
+	return op | uint32(ra)<<21 | uint32(rb)<<16 | uint32(rc)
+}
+
+// 简单运算指令立即数格式
+func OP_ARITHMETIC_I(op uint32, ra int16, ib int16, rc int16) uint32 {
+	return op | uint32(ra)<<21 | uint32(ib)<<13 | uint32(rc)
+}
+
+// 简单运算指令立即数格式
+func OP_ADDPI(op uint32, rc int16, ib int16) uint32 {
+	return op | uint32(ib)<<13 | uint32(rc)
+}
+
+// 浮点复合运算指令
+func OP_COMPLEX_ARITHMETIC(op uint32, ra int16, rb int16, rc int16, rd int16) uint32 {
+	return op | uint32(ra)<<21 | uint32(rb)<<16 | uint32(rc)<<5 | uint32(rd)
+}
+
+func (c *ctxt77) asmout(p *obj.Prog, o *Optab, out []uint32) {
+	o1 := uint32(0)
+	o2 := uint32(0)
+	o3 := uint32(0)
+	o4 := uint32(0)
+	o5 := uint32(0)
+
+	switch o.type_ {
+	default:
+		c.ctxt.Diag("unknown type %d %v", o.type_)
+		prasm(p)
+
+	case 0: /* buildNull */
+		break
+	case 1: /*OPC_SYSCALL*/
+		o1 = OP_SYSCALL(c.oprrr(p.As), uint32(p.From.Offset))
+	case 2: /*OPC_MEMORY*/
+		disp := p.To.Offset
+
+		if (disp > 0 && disp&0xffff != disp) ||
+			(disp < 0 && -disp&0xffff != -disp) {
+			c.ctxt.Diag("Memory instruction with immediate(0x%x) bigger than 0xffff at\n%v\n", disp, p)
+		}
+
+		o1 = OP_MEMORY(c.oprrr(p.As), getRegister(p.From.Reg), getRegister(p.To.Reg), int16(disp))
+	case 3: /*OPC_CONTROL*/
+		if p.To.Type == obj.TYPE_BRANCH {
+			target := p.To.Val.(*obj.Prog)
+			offset := (target.Pc - p.Pc - 4)
+			//offset := (p.To.Target().Pc - p.Pc - 4)
+			o1 = OP_CONTROL(c.oprrr(p.As), getRegister(p.From.Reg), int32(offset)/4)
+		} else {
+			o1 = OP_CONTROL(c.oprrr(p.As), getRegister(p.From.Reg), int32(p.To.Offset)/4)
+		}
+	case 4: /*OPC_MISI_MEMORY*/
+		o1 = OP_MISI_MEMORY(c.oprrr(p.As), getRegister(p.From.Reg), getRegister(p.To.Reg))
+	case 5: /*OPC_FUNC_MEMORY*/
+		disp := p.To.Offset
+
+		if (disp >= 0x1000) || (disp <= -0x1000) {
+			c.ctxt.Diag("Memory instruction with immediate(0x%x) bigger than 0x1000 at\n%v\n", disp, p)
+		}
+		if (p.As == ALSTW || p.As == ALSTL) && p.Pc&0x7 != 0 {
+			o1 = OP_MEMORY(c.oprrr(ALDIH), REGZERO, REGSP, 0)
+			o2 = OP_FUNC_MEMORY(c.oprrr(p.As), getRegister(p.From.Reg), getRegister(p.To.Reg), int16(disp))
+		} else {
+			o1 = OP_FUNC_MEMORY(c.oprrr(p.As), getRegister(p.From.Reg), getRegister(p.To.Reg), int16(disp))
+		}
+	case 6: /*OPC_ARITHMETIC*/
+		o1 = OP_ARITHMETIC(c.oprrr(p.As), getRegister(p.From.Reg), getReg2(p), getRegister(p.To.Reg))
+	case 7: /*OPC_ARITHMETIC_I*/
+		ib := p.RestArgs[0].Offset
+
+		if ib > 255 {
+			c.ctxt.Diag("Arithmetic instruction with immediate(0x%x) bigger than 0xff at\n%v\n", ib, p)
+		}
+
+		o1 = OP_ARITHMETIC_I(c.opirr(p.As), getRegister(p.From.Reg), int16(ib), getRegister(p.To.Reg))
+	case 8: /*OPC_COMPLEX_ARITHMETIC*/
+		o1 = OP_COMPLEX_ARITHMETIC(c.oprrr(p.As), getRegister(p.From.Reg), getReg2(p), getFrom3Reg(p), getRegister(p.To.Reg))
+
+	case 9: /*buildCall,obj.AJMP, obj.ACALL*/
+		sym := p.To.Sym
+		r := getRegister(p.From.Reg)
+		pv := REG_R27 & int16(31)
+		if buildcfg.GOSW64 == 6 {
+			o1 = OP_ARITHMETIC(c.oprrr(ABIS), 31, 31, 31) // only for alignment
+			o2 = OP_ADDPI(c.oprrr(AADDPI), REG_R26&31, 4) // addpi r, sym
+			o3 = OP_SYSCALL(c.oprrr(ALBR), 0)
+			addrel(c.cursym, int32(p.Pc+8), p.To.Offset, sym, objabi.R_CALLSW64)
+		} else {
+			o1 = OP_MEMORY(c.oprrr(ALDIH), pv, REGSB&31, 0) // ldih R27, sym(GP)
+			addrel(c.cursym, int32(p.Pc), p.To.Offset, sym, objabi.R_SW64_GPRELHIGH)
+			o2 = OP_MEMORY(c.oprrr(ALDI), pv, pv, 0) // ldi  R27, sym_lo(R27)
+			addrel(c.cursym, int32(p.Pc+4), p.To.Offset, sym, objabi.R_SW64_GPRELLOW)
+			o3 = OP_MEMORY(c.oprrr(p.As), r, pv, 0) //CALL/JMP R, (R27)
+			addrel(c.cursym, int32(p.Pc+8), p.To.Offset, sym, objabi.R_SW64_HINT)
+		}
+	case 10: /*buildCall,ABSR, ABR,ABEQ, ABGE, ABGT, ABLE, ABLT,ABNE, ABLBC, ABLBS, AFBEQ, AFBGE, AFBGT, AFBLE, AFBLT, AFBNE*/
+		sym := p.To.Sym
+		addrel(c.cursym, int32(p.Pc), p.To.Offset, sym, objabi.R_SW64_BRADDR)
+
+		if p.To.Type == obj.TYPE_BRANCH {
+			target := p.To.Val.(*obj.Prog)
+			offset := (target.Pc - p.Pc - 4)
+			//offset := (p.To.Target().Pc - p.Pc - 4)
+			o1 = OP_CONTROL(c.oprrr(p.As), getRegister(p.From.Reg), int32(offset)/4)
+		} else {
+			o1 = OP_CONTROL(c.oprrr(p.As), getRegister(p.From.Reg), int32(p.To.Offset)/4)
+		}
+	case 11: /*buildNoop*/
+		p.As = ALDIH
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = REGZERO
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = REGSP
+		disp := p.To.Offset
+
+		if (disp > 0 && disp&0xffff != disp) ||
+			(disp < 0 && -disp&0xffff != -disp) {
+			c.ctxt.Diag("Memory instruction with immediate(0x%x) bigger than 0xffff at\n%v\n", disp, p)
+		}
+
+		o1 = OP_MEMORY(c.oprrr(p.As), getRegister(p.From.Reg), getRegister(p.To.Reg), int16(disp))
+	case 12: /*buildLoad,ALDL, ALDW, ALDHU, ALDBU, ASYMADDR*/
+		sym := p.To.Sym
+		r := getRegister(p.From.Reg)
+		as := p.As
+		if as == ASYMADDR {
+			as = ALDI
+		}
+		o1 = OP_MEMORY(c.oprrr(ALDIH), r, REGSB&31, 0) // ldih r, sym(gp)
+		addrel(c.cursym, int32(p.Pc), p.To.Offset, sym, objabi.R_SW64_GPRELHIGH)
+		o2 = OP_MEMORY(c.oprrr(as), r, r, 0) // ldx  r, sym_lo(r)
+		addrel(c.cursym, int32(p.Pc+4), p.To.Offset, sym, objabi.R_SW64_GPRELLOW)
+	case 13: /*buildStore*/
+		sym := p.To.Sym
+
+		if sym == nil {
+			c.ctxt.Diag("buildStore not support %v", p)
+		}
+
+		// STx Rn, sym(SB)
+		r := getRegister(p.From.Reg)
+		if buildcfg.GOSW64 == 5 {
+			o1 = OP_ADDPI(c.oprrr(AADDPIS), REGTMP&31, 0) // addpis r, sym
+			addrel8(c.cursym, int32(p.Pc), p.To.Offset, sym, objabi.R_SW64_ADDR)
+			o2 = OP_MEMORY(c.oprrr(p.As), r, REGTMP&31, 0) // STx  Rn, sym_lo(TMP)
+		} else {
+			o1 = OP_MEMORY(c.oprrr(ALDIH), REGTMP&31, REGSB&31, 0) // ldih TMP, sym(gp)
+			addrel(c.cursym, int32(p.Pc), p.To.Offset, sym, objabi.R_SW64_GPRELHIGH)
+			o2 = OP_MEMORY(c.oprrr(p.As), r, REGTMP&31, 0) // STx  Rn, sym_lo(TMP)
+			addrel(c.cursym, int32(p.Pc+4), p.To.Offset, sym, objabi.R_SW64_GPRELLOW)
+		}
+	case 14:
+		//LDI AT, $const
+		ib := p.RestArgs[0].Offset
+		q := c.newprog()
+		q.Pc = p.Pc
+		q.As = ALDI
+		q.From.Type = obj.TYPE_REG
+		q.From.Reg = REGTMP
+		q.To.Type = obj.TYPE_CONST
+		q.To.Offset = ib
+		disp := q.To.Offset
+
+		if (disp > 0 && disp&0xffff != disp) ||
+			(disp < 0 && -disp&0xffff != -disp) {
+			c.ctxt.Diag("Memory instruction with immediate(0x%x) bigger than 0xffff at\n%v\n", disp, q)
+		}
+
+		o1 = OP_MEMORY(c.oprrr(q.As), getRegister(q.From.Reg), getRegister(q.To.Reg), int16(disp))
+		// XXX Rn1, AT, Rn2
+		o2 = OP_ARITHMETIC(c.oprrr(p.As), getRegister(p.From.Reg), REGTMP&31, getRegister(p.To.Reg))
+	case 15: /*buildLoad,AFLDD, AFLDS*/
+		sym := p.To.Sym
+		if buildcfg.GOSW64 >= 5 {
+			o1 = OP_ADDPI(c.oprrr(AADDPIS), REGTMP&31, 0) // addpis r, sym
+			addrel8(c.cursym, int32(p.Pc), p.To.Offset, sym, objabi.R_SW64_ADDR)
+			o2 = OP_MEMORY(c.oprrr(ALDI), REGTMP&31, REGTMP&31, 0) // STx  Rn, sym_lo(TMP)
+		} else {
+			o1 = OP_MEMORY(c.oprrr(ALDIH), REGTMP&31, REGSB&31, 0) // LDIH AT, sym(gp)
+			addrel(c.cursym, int32(p.Pc), p.To.Offset, sym, objabi.R_SW64_GPRELHIGH)
+			o2 = OP_MEMORY(c.oprrr(ALDI), REGTMP&31, REGTMP&31, 0) // LDI  AT, sym_lo(AT)
+			addrel(c.cursym, int32(p.Pc+4), p.To.Offset, sym, objabi.R_SW64_GPRELLOW)
+		}
+		o3 = OP_MEMORY(c.oprrr(p.As), getRegister(p.From.Reg), REGTMP&31, 0) // FLDX, Fn, (AT)
+	case 16:
+		//SYMADDR AT, $int64.ib
+		ib := p.RestArgs[0].Offset
+		q := c.newprog()
+		q.Pc = p.Pc
+		q.As = ASYMADDR
+		q.From.Type = obj.TYPE_REG
+		q.From.Reg = REGTMP
+		q.To.Type = obj.TYPE_MEM
+		q.To.Sym = c.ctxt.Int64Sym(ib)
+		q.To.Name = obj.NAME_EXTERN
+		sym := q.To.Sym
+		r := getRegister(q.From.Reg)
+		as := q.As
+		if as == ASYMADDR {
+			as = ALDI
+		}
+		if buildcfg.GOSW64 == 5 {
+			o1 = OP_ADDPI(c.oprrr(AADDPIS), r, 0) // addpis r, sym
+			addrel8(c.cursym, int32(p.Pc), p.To.Offset, sym, objabi.R_SW64_ADDR)
+			o2 = OP_MEMORY(c.oprrr(as), r, r, 0) // STx  Rn, sym_lo(TMP)
+		} else {
+			o1 = OP_MEMORY(c.oprrr(ALDIH), r, REGSB&31, 0) // ldih r, sym(gp)
+			addrel(c.cursym, int32(q.Pc), q.To.Offset, sym, objabi.R_SW64_GPRELHIGH)
+			o2 = OP_MEMORY(c.oprrr(as), r, r, 0) // ldx  r, sym_lo(r)
+			addrel(c.cursym, int32(q.Pc+4), q.To.Offset, sym, objabi.R_SW64_GPRELLOW)
+		}
+		// LDL AT, (AT)
+		q2 := c.newprog()
+		q2.As = ALDL
+		q2.Pc = p.Pc + 8
+		q2.From.Type = obj.TYPE_REG
+		q2.From.Reg = REGTMP
+		q2.To.Type = obj.TYPE_MEM
+		q2.To.Reg = REGTMP
+		disp := q2.To.Offset
+
+		if (disp > 0 && disp&0xffff != disp) || (disp < 0 && -disp&0xffff != -disp) {
+			c.ctxt.Diag("Memory instruction with immediate(0x%x) bigger than 0xffff at\n%v\n", disp, q2)
+		}
+
+		o3 = OP_MEMORY(c.oprrr(q2.As), getRegister(q2.From.Reg), getRegister(q2.To.Reg), int16(disp))
+		// XXX Rn1, AT, Rn2
+		o4 = OP_ARITHMETIC(c.oprrr(p.As), getRegister(p.From.Reg), REGTMP&31, getRegister(p.To.Reg))
+
+	case 17:
+		// LDx/STx   Ra, off(Rb)
+		//  convert to --->
+		// ADDL      Rb, $off, REGTMP  #len 16
+		// LDx/STx   Ra, (REGTMP)       #len 4
+		rb := p.To.Reg
+		off := p.To.Offset
+
+		// ADDL Rb, $off, REGTMP
+		addl := c.newprog()
+		addl.Pc = p.Pc
+		addl.As = AADDL
+		addl.From = obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  rb,
+		}
+		addl.AddRestSource(obj.Addr{
+			Type:   obj.TYPE_CONST,
+			Offset: off,
+		})
+		addl.To = obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  REGTMP,
+		}
+
+		//SYMADDR AT, $int64.ib
+		ib := addl.RestArgs[0].Offset
+		q := c.newprog()
+		q.Pc = addl.Pc
+		q.As = ASYMADDR
+		q.From.Type = obj.TYPE_REG
+		q.From.Reg = REGTMP
+		q.To.Type = obj.TYPE_MEM
+		q.To.Sym = c.ctxt.Int64Sym(ib)
+		q.To.Name = obj.NAME_EXTERN
+		sym := q.To.Sym
+		r := getRegister(q.From.Reg)
+		as := q.As
+		if as == ASYMADDR {
+			as = ALDI
+		}
+		//		if buildcfg.GOSW64 == 4 {
+		//			o1 = OP_ADDPI(c.oprrr(AADDPIS), REGTMP&31, 0) // addpis r, sym
+		//			addrel8(c.cursym, int32(p.Pc), p.To.Offset, sym, objabi.R_SW64_ADDR)
+		//			o2 = OP_MEMORY(c.oprrr(p.As), r, REGTMP&31, 0) // STx  Rn, sym_lo(TMP)
+		//		} else {
+		o1 = OP_MEMORY(c.oprrr(ALDIH), r, REGSB&31, 0) // ldih r, sym(gp)
+		addrel(c.cursym, int32(q.Pc), q.To.Offset, sym, objabi.R_SW64_GPRELHIGH)
+		o2 = OP_MEMORY(c.oprrr(as), r, r, 0) // ldx  r, sym_lo(r)
+		addrel(c.cursym, int32(q.Pc+4), q.To.Offset, sym, objabi.R_SW64_GPRELLOW)
+		//		}
+		// LDL AT, (AT)
+		q2 := c.newprog()
+		q2.As = ALDL
+		q2.Pc = addl.Pc + 8
+		q2.From.Type = obj.TYPE_REG
+		q2.From.Reg = REGTMP
+		q2.To.Type = obj.TYPE_MEM
+		q2.To.Reg = REGTMP
+		disp := q2.To.Offset
+
+		if (disp > 0 && disp&0xffff != disp) || (disp < 0 && -disp&0xffff != -disp) {
+			c.ctxt.Diag("Memory instruction with immediate(0x%x) bigger than 0xffff at\n%v\n", disp, q2)
+		}
+
+		o3 = OP_MEMORY(c.oprrr(q2.As), getRegister(q2.From.Reg), getRegister(q2.To.Reg), int16(disp))
+		// XXX Rn1, AT, Rn2
+		o4 = OP_ARITHMETIC(c.oprrr(addl.As), getRegister(addl.From.Reg), REGTMP&31, getRegister(addl.To.Reg))
+		// LDx Ra, (REGTMP)
+		p.To = obj.Addr{
+			Type: obj.TYPE_MEM,
+			Reg:  REGTMP,
+		}
+
+		//disp := p.To.Offset
+		if (disp > 0 && disp&0xffff != disp) ||
+			(disp < 0 && -disp&0xffff != -disp) {
+			c.ctxt.Diag("Memory instruction with immediate(0x%x) bigger than 0xffff at\n%v\n", disp, p)
+		}
+
+		o5 = OP_MEMORY(c.oprrr(p.As), getRegister(p.From.Reg), getRegister(p.To.Reg), int16(p.To.Offset))
+
+	case 18: /* buildTrap */
+		o1 = 80
+	case 19: /* buildWORD */
+		o1 = uint32(p.From.Offset)
+	case 20: /*buildLDGP*/
+		dummysym := c.cursym
+
+		gp := getRegister(p.From.Reg)
+		r := getRegister(p.To.Reg)
+
+		if p.To.Reg == REGZERO {
+			// If the ATEXT+0 isn't the noop, then
+			// runtime.goexit will be invoked at o3 which is ldgp
+			// without setup $at. see the logical in
+			// runtime/proc.go' func newproc1 about
+			// newg.sched.pc = funcPC(goexit) + sys.PCQuantum
+			o1 = OP_MEMORY(c.oprrr(ALDIH), gp, gp, 0) // only for alignment
+
+			//insert a "BR AT, 0" to find the correct PC value
+			o2 = OP_CONTROL(c.oprrr(ABR), REGTMP, 0)
+			o3 = OP_MEMORY(c.oprrr(ALDIH), gp, REGTMP&31, 0)
+			addrel(c.cursym, int32(p.Pc+8), 4, dummysym, objabi.R_SW64_GPDISP)
+			o4 = OP_MEMORY(c.oprrr(ALDI), gp, gp, 0) //ldi  $gp, m($gp)
+		} else {
+			if p.To.Reg == REG_R27 && p.Pc != 0 {
+				p.To.Offset = p.Pc
+			}
+			o1 = OP_MEMORY(c.oprrr(ALDIH), gp, r, 0) //ldih $gp, n($r)
+			addrel(c.cursym, int32(p.Pc), 4, dummysym, objabi.R_SW64_GPDISP)
+			o2 = OP_MEMORY(c.oprrr(ALDI), gp, gp, 0) //ldi  $gp, m($gp)
+
+			o3 = OP_MEMORY(c.oprrr(ALDI), gp, gp, int16(p.To.Offset))
+			o4 = OP_MEMORY(c.oprrr(ALDIH), gp, gp, 0) // only for alignment
+		}
+	case 21: /*buildCallByReg*/
+		offset := p.To.Offset
+		if (p.As != obj.AJMP && p.As != obj.ACALL) || p.To.Sym != nil || !isint16(offset) {
+			c.ctxt.Diag("buildCallByReg doesn't support %v", p)
+			return
+		}
+		ra := getRegister(p.From.Reg)
+		pv := getRegister(p.To.Reg)
+		o1 = OP_MEMORY(c.oprrr(p.As), ra, pv, int16(offset)) //CALL/JMP RA, (Rn
+	case 22: /*LDx Reg,(TLS_LE)(SB)*/
+		if p.To.Sym == nil || p.From.Type != obj.TYPE_REG || !isint16(p.To.Offset) {
+			c.ctxt.Diag("%v is not support TLS_LE", p)
+		}
+
+		offset := int16(p.To.Offset)
+		rn := int16(p.From.Reg & 31)
+		r0 := int16(REG_R0 & 31)
+		sym := p.To.Sym
+		// sys_call 0x9e
+		o1 = OP_SYSCALL(c.oprrr(ASYS_CALL), 0x9e)
+		// LDIH R0, sym(R0) !tprelhi
+		o2 = OP_MEMORY(c.oprrr(ALDIH), r0, r0, 0)
+		addrel(c.cursym, int32(p.Pc+4), 0, sym, objabi.R_SW64_TPRELHI)
+		// STx/LDx Rn, sym(R0) !tprello
+		o3 = OP_MEMORY(c.oprrr(p.As), rn, r0, offset)
+		addrel(c.cursym, int32(p.Pc+8), 0, sym, objabi.R_SW64_TPRELLO)
+
+	case 23: /*LDx Reg,(TLS_IE)(SB)*/
+		if p.To.Sym == nil || p.From.Type != obj.TYPE_REG || !isint16(p.To.Offset) {
+			c.ctxt.Diag("%v is not support TLS_IE", p)
+		}
+		offset := int16(p.To.Offset)
+		rn := int16(p.From.Reg & 31)
+		r0 := int16(REG_R0 & 31)
+		rtmp := int16(REGTMP & 31)
+		sym := p.To.Sym
+		// sys_call 0x9e
+		o1 = OP_SYSCALL(c.oprrr(ASYS_CALL), 0x9e)
+
+		//LDL RTMP, offset($sym) !gottprel
+		o2 = OP_MEMORY(c.oprrr(ALDL), rtmp, REGSB&31, offset)
+		addrel(c.cursym, int32(p.Pc+4), 0, sym, objabi.R_SW64_GOTTPREL)
+
+		//ADDL R0, RTMP, RTMP
+		o3 = OP_MEMORY(c.oprrr(AADDL), r0, rtmp, rtmp)
+		//STx/LDx Rn, 0(RTMP)
+		o4 = OP_MEMORY(c.oprrr(p.As), rn, rtmp, 0)
+
+	case 24: /*retjmp*/
+		sym := p.To.Sym
+		//r := getRegister(p.From.Reg)
+		pv := REG_R27 & int16(31)
+		o1 = OP_MEMORY(c.oprrr(ALDIH), pv, REGSB&31, 0) // ldih R27, sym(GP)
+		addrel(c.cursym, int32(p.Pc), p.To.Offset, sym, objabi.R_SW64_GPRELHIGH)
+		o2 = OP_MEMORY(c.oprrr(ALDI), pv, pv, 0) // ldi  R27, sym_lo(R27)
+		addrel(c.cursym, int32(p.Pc+4), p.To.Offset, sym, objabi.R_SW64_GPRELLOW)
+		o3 = OP_MEMORY(c.oprrr(obj.AJMP), REGLINK&31, pv, 0) //CALL/JMP R, (R27)
+		addrel(c.cursym, int32(p.Pc+8), p.To.Offset, sym, objabi.R_SW64_HINT)
+	case 25: /*MOVD sym@GOT */
+		o1 = OP_MEMORY(c.oprrr(ALDIH), REGTMP, REGSB&31, 0) // ldih r, sym(gp)
+		addrel(c.cursym, int32(p.Pc), p.From.Offset, p.From.Sym, objabi.R_SW64_LITERAL_GOT)
+		o2 = OP_MEMORY(c.oprrr(ALDL), REGTMP&31, REGTMP&31, 0) // ldx  r, sym_lo(r)
+		addrel(c.cursym, int32(p.Pc+4), p.From.Offset, p.From.Sym, objabi.R_SW64_LITERAL)
+	case 26: /*SYMADDR Rx, sym@GOT */
+		o1 = OP_MEMORY(c.oprrr(ALDIH), p.From.Reg, REGSB&31, 0) // ldih r, sym(gp)
+		addrel(c.cursym, int32(p.Pc), p.To.Offset, p.To.Sym, objabi.R_SW64_LITERAL_GOT)
+		o2 = OP_MEMORY(c.oprrr(ALDL), p.From.Reg&31, p.From.Reg&31, 0) // ldx  r, sym_lo(r)
+		addrel(c.cursym, int32(p.Pc+4), p.To.Offset, p.To.Sym, objabi.R_SW64_LITERAL)
+	case 27: /*ADDPI Rx, sym@GOT */
+		//			o1 = OP_MEMORY(c.oprrr(ALDIH), r, REGSB&31, 0) // ldih r, sym(gp)
+		//			addrel(c.cursym, int32(p.Pc), p.To.Offset, 0, objabi.R_SW64_LITERAL_GOT)
+		o1 = OP_ADDPI(c.oprrr(p.As), getRegister(p.To.Reg), 0)
+		//addrel(c.cursym, int32(p.Pc), p.To.Offset, p.To.Sym, objabi.R_SW64_LITERAL)
+	case 30: /*Vop  V1, V2, V3*/
+		rf := int16(p.From.Reg)
+		rt := int16(p.To.Reg)
+		r := int16(p.Reg)
+		if r == 0 {
+			r = rt
+		}
+		o1 = OP_ARITHMETIC(c.oprrr(p.As), getRegister(rf), getRegister(r), getRegister(rt))
+	case 31: /* VLOG Vx, Vy, Vz */
+		rf := int16(p.From.Reg)
+		rt := int16(p.To.Reg)
+		r := int16(p.Reg)
+		if r == 0 {
+			r = rt
+		}
+		o1 = OP_COMPLEX_ARITHMETIC(c.oprrr(p.As), getRegister(rf), getRegister(r), 31, getRegister(rt))
+	case 32: /* VLDD Vx , disp(Rx) */
+		disp := p.To.Offset
+
+		if (disp > 0 && disp&0xffff != disp) ||
+			(disp < 0 && -disp&0xffff != -disp) {
+			c.ctxt.Diag("Memory instruction with immediate(0x%x) bigger than 0xffff at\n%v\n", disp, p)
+		}
+		o1 = OP_MEMORY(c.oprrr(p.As), getRegister(p.From.Reg), getRegister(p.To.Reg), int16(disp))
+	case 33: /* VCPYX Vx , Vy, Vz */
+		o1 = OP_COMPLEX_ARITHMETIC(c.oprrr(p.As), getRegister(p.From.Reg), 31, 31, getRegister(p.To.Reg))
+	case 34: /* VCPYX Vx , Vy, Vz */
+		rf := int16(p.From.Reg)
+		rt := int16(p.To.Reg)
+		if rt == 0 {
+			rt = rf
+		}
+		o1 = OP_ARITHMETIC(c.oprrr(p.As), getRegister(rf), 31, getRegister(rt))
+	case 35: /* MOVX Rx, Rx*/
+		as := p.As
+		rt, rf := p.To.Reg, p.From.Reg
+		switch as {
+		case AMOVB: // MOVB -> SEXTB
+			o1 = OP_ARITHMETIC(c.oprrr(ASEXTB), REGZERO, getRegister(rf), getRegister(rt))
+
+		case AMOVH: // MOVH -> SEXTH
+			o1 = OP_ARITHMETIC(c.oprrr(ASEXTH), REGZERO, getRegister(rf), getRegister(rt))
+
+		case AMOVW: // MOVW x -> ADDWconst x [0]
+			o1 = OP_ARITHMETIC_I(c.opirr(AADDW), getRegister(rf), 0, getRegister(rt))
+
+		case AMOVV: // MOVV -> BIS
+			o1 = OP_ARITHMETIC_I(c.opirr(ABIS), getRegister(rf), 0, getRegister(rt))
+
+		default:
+			c.ctxt.Diag("bad sign extract %v", as)
+		}
+	case 36: /* MOVUX Rx, Rx*/
+		as := p.As
+		rt, rf := p.To.Reg, p.From.Reg
+		v := 1
+		switch as {
+		case AMOVBU:
+			v = 1
+		case AMOVHU:
+			v = 3
+		case AMOVWU:
+			v = 15
+		default:
+			c.ctxt.Diag("bad unsign extract %v", as)
+		}
+		o1 = OP_ARITHMETIC_I(c.opirr(AZAPNOT), getRegister(rf), int16(v), getRegister(rt))
+	}
+	out[0] = o1
+	out[1] = o2
+	out[2] = o3
+	out[3] = o4
+	out[4] = o5
+	return
+}
+
+func (c *ctxt77) oprrr(a obj.As) uint32 {
+	switch a {
+	case ASYS_CALL_B:
+		return SP(0, 0) | (0 << 25)
+	case ASYS_CALL:
+		return SP(0, 0) | (1 << 25)
+	case obj.AUNDEF:
+		return 0
+	case AEXCB:
+		return SP(1, 0)
+	case ACALL:
+		return SP(0, 1)
+	case ALBR:
+		return SP(0, 0x1d)
+	case AJMP:
+		return SP(0, 3)
+	case ARET:
+		return SP(0, 2)
+	case ABR:
+		return SP(0, 4)
+	case ABSR:
+		return SP(0, 5)
+	case AMEMB:
+		return FMM(0, 0)
+	case AIMEMB:
+		return FMM(0, 1)
+	case ARTC:
+		return FMM(0, 32)
+	case ARD_F:
+		return FMM(16, 0)
+	case AWR_F:
+		return FMM(16, 32)
+	case ALLDW:
+		return SP(0, 8) | (0 << 12)
+	case ALLDL:
+		return SP(0, 8) | (1 << 12)
+	case ALSTW:
+		return SP(0, 8) | (8 << 12)
+	case ALSTL:
+		return SP(0, 8) | (9 << 12)
+	case AADDW:
+		return FA(0, 0)
+	case ASUBW:
+		return FA(0, 1)
+	case AS4ADDW:
+		return FA(0, 2)
+	case AS4SUBW:
+		return FA(0, 3)
+	case AS8ADDW:
+		return FA(0, 4)
+	case AS8SUBW:
+		return FA(0, 5)
+	case AADDL:
+		return FA(0, 8)
+	case ASUBL:
+		return FA(0, 9)
+	case AS4ADDL:
+		return FA(0, 10)
+	case AS4SUBL:
+		return FA(0, 11)
+	case AS8ADDL:
+		return FA(0, 12)
+	case AS8SUBL:
+		return FA(0, 13)
+	case AMULW:
+		return FA(1, 0)
+	case AMULL:
+		return FA(1, 8)
+	case AUMULH:
+		return FA(1, 9)
+	case ADIVW:
+		return FA(1, 1)
+	case AUDIVW:
+		return FA(1, 2)
+	case AREMW:
+		return FA(1, 3)
+	case AUREMW:
+		return FA(1, 4)
+	case ADIVL:
+		return FA(1, 0xa)
+	case AUDIVL:
+		return FA(1, 0xb)
+	case AREML:
+		return FA(1, 0xc)
+	case AUREML:
+		return FA(1, 0xd)
+	case ASBT:
+		return FA(2, 0xd)
+	case ACBT:
+		return FA(2, 0xe)
+	case ACRC32CL:
+		return FA(2, 7)
+	case ACRC32CW:
+		return FA(2, 6)
+	case ACRC32CH:
+		return FA(2, 5)
+	case ACRC32CB:
+		return FA(2, 4)
+	case ACRC32L:
+		return FA(2, 3)
+	case ACRC32W:
+		return FA(2, 2)
+	case ACRC32H:
+		return FA(2, 1)
+	case ACRC32B:
+		return FA(2, 0)
+	case AADDPI:
+		return FA(1, 0xe)
+	case AADDPIS:
+		return FA(1, 0xf)
+	case ACMPEQ:
+		return FA(2, 8)
+	case ACMPLT:
+		return FA(2, 9)
+	case ACMPLE:
+		return FA(2, 10)
+	case ACMPULT:
+		return FA(2, 11)
+	case ACMPULE:
+		return FA(2, 12)
+	case AAND:
+		return FA(3, 8)
+	case ABIC:
+		return FA(3, 9)
+	case ABIS:
+		return FA(3, 10)
+	case AORNOT:
+		return FA(3, 11)
+	case AXOR:
+		return FA(3, 12)
+	case AEQV:
+		return FA(3, 13)
+	case AINSLB:
+		return FA(4, 0)
+	case AINSLH:
+		return FA(4, 1)
+	case AINSLW:
+		return FA(4, 2)
+	case AINSLL:
+		return FA(4, 3)
+	case AINSHB:
+		return FA(4, 4)
+	case AINSHH:
+		return FA(4, 5)
+	case AINSHW:
+		return FA(4, 6)
+	case AINSHL:
+		return FA(4, 7)
+	case ASLL:
+		return FA(4, 8)
+	case ASRL:
+		return FA(4, 9)
+	case ASRA:
+		return FA(4, 10)
+	case AEXTLB:
+		return FA(5, 0)
+	case AEXTLH:
+		return FA(5, 1)
+	case AEXTLW:
+		return FA(5, 2)
+	case AEXTLL:
+		return FA(5, 3)
+	case AEXTHB:
+		return FA(5, 4)
+	case AEXTHH:
+		return FA(5, 5)
+	case AEXTHW:
+		return FA(5, 6)
+	case AEXTHL:
+		return FA(5, 7)
+	case ACTPOP:
+		return FA(5, 8)
+	case ACTLZ:
+		return FA(5, 9)
+	case ACTTZ:
+		return FA(5, 10)
+	case AMASKLB:
+		return FA(6, 0)
+	case AMASKLH:
+		return FA(6, 1)
+	case AMASKLW:
+		return FA(6, 2)
+	case AMASKLL:
+		return FA(6, 3)
+	case AMASKHB:
+		return FA(6, 4)
+	case AMASKHH:
+		return FA(6, 5)
+	case AMASKHW:
+		return FA(6, 6)
+	case AMASKHL:
+		return FA(6, 7)
+	case AZAP:
+		return FA(6, 8)
+	case AZAPNOT:
+		return FA(6, 9)
+	case ASEXTB:
+		return FA(6, 10)
+	case ASEXTH:
+		return FA(6, 11)
+	case ACMPGEB:
+		return FA(6, 12)
+	case AFIMOVS:
+		return FA(7, 0)
+	case AFIMOVD:
+		return FA(7, 8)
+	case ASELEQ:
+		return SP(1, 1) | (0 << 5)
+	case ASELGE:
+		return SP(1, 1) | (1 << 5)
+	case ASELGT:
+		return SP(1, 1) | (2 << 5)
+	case ASELLE:
+		return SP(1, 1) | (3 << 5)
+	case ASELLT:
+		return SP(1, 1) | (4 << 5)
+	case ASELNE:
+		return SP(1, 1) | (5 << 5)
+	case ASELLBC:
+		return SP(1, 1) | (6 << 5)
+	case ASELLBS:
+		return SP(1, 1) | (7 << 5)
+	case APRI_LD:
+		return SP(2, 5)
+	case ABEQ:
+		return SP(3, 0)
+	case ABNE:
+		return SP(3, 1)
+	case ABLT:
+		return SP(3, 2)
+	case ABLE:
+		return SP(3, 3)
+	case ABGT:
+		return SP(3, 4)
+	case ABGE:
+		return SP(3, 5)
+	case ABLBC:
+		return SP(3, 6)
+	case ABLBS:
+		return SP(3, 7)
+	case AFBEQ:
+		return SP(3, 8)
+	case AFBNE:
+		return SP(3, 9)
+	case AFBLT:
+		return SP(3, 10)
+	case AFBLE:
+		return SP(3, 11)
+	case AFBGT:
+		return SP(3, 12)
+	case AFBGE:
+		return SP(3, 13)
+	case AFADDS:
+		return FAF(0, 0)
+	case AFADDD:
+		return FAF(0, 1)
+	case AFSUBS:
+		return FAF(0, 2)
+	case AFSUBD:
+		return FAF(0, 3)
+	case AFMULS:
+		return FAF(0, 4)
+	case AFMULD:
+		return FAF(0, 5)
+	case AFDIVS:
+		return FAF(0, 6)
+	case AFDIVD:
+		return FAF(0, 7)
+	case AFSQRTS:
+		return FAF(0, 8)
+	case AFSQRTD:
+		return FAF(0, 9)
+	case AFCMPEQ:
+		return FAF(1, 0)
+	case AFCMPLE:
+		return FAF(1, 1)
+	case AFCMPLT:
+		return FAF(1, 2)
+	case AFCMPUN:
+		return FAF(1, 3)
+	case AFCVTSD:
+		return FAF(2, 0)
+	case AFCVTDS:
+		return FAF(2, 1)
+	case AFCVTDL_G:
+		return FAF(2, 2)
+	case AFCVTDL_P:
+		return FAF(2, 3)
+	case AFCVTDL_Z:
+		return FAF(2, 4)
+	case AFCVTDL_N:
+		return FAF(2, 5)
+	case AFCVTDL:
+		return FAF(2, 7)
+	case AFCVTWL:
+		return FAF(2, 8)
+	case AFCVTLW:
+		return FAF(2, 9)
+	case AFCVTLS:
+		return FAF(2, 13)
+	case AFCVTLD:
+		return FAF(2, 15)
+	case AFCPYS:
+		return FAF(3, 0)
+	case AFCPYSE:
+		return FAF(3, 1)
+	case AFCPYSN:
+		return FAF(3, 2)
+	case AIFMOVS:
+		return FAF(4, 0)
+	case AIFMOVD:
+		return FAF(4, 1)
+	case ARFPCR:
+		return FAF(5, 0)
+	case AWFPCR:
+		return FAF(5, 1)
+	case ASETFPEC0:
+		return FAF(5, 4)
+	case ASETFPEC1:
+		return FAF(5, 5)
+	case ASETFPEC2:
+		return FAF(5, 6)
+	case ASETFPEC3:
+		return FAF(5, 7)
+	case AFMAS:
+		return FCA(0, 0)
+	case AFMAD:
+		return FCA(0, 1)
+	case AFMSS:
+		return FCA(0, 2)
+	case AFMSD:
+		return FCA(0, 3)
+	case AFNMAS:
+		return FCA(0, 4)
+	case AFNMAD:
+		return FCA(0, 5)
+	case AFNMSS:
+		return FCA(0, 6)
+	case AFNMSD:
+		return FCA(0, 7)
+	case AFSELEQ:
+		return FCA(1, 0)
+	case AFSELNE:
+		return FCA(1, 1)
+	case AFSELLT:
+		return FCA(1, 2)
+	case AFSELLE:
+		return FCA(1, 3)
+	case AFSELGT:
+		return FCA(1, 4)
+	case AFSELGE:
+		return FCA(1, 5)
+	case ALDBU:
+		return SP(2, 0)
+	case ALDHU:
+		return SP(2, 1)
+	case ALDW:
+		return SP(2, 2)
+	case ALDL:
+		return SP(2, 3)
+	case ALDL_U:
+		return SP(2, 4)
+	case ALDBUA:
+		return FLD(0)
+	case ALDHUA:
+		return FLD(1)
+	case ALDWA:
+		return FLD(2)
+	case ALDLA:
+		return FLD(3)
+	case AFLDSA:
+		return FLD(4)
+	case AFLDDA:
+		return FLD(5)
+	case ASTBA:
+		return FLD(6)
+	case ASTHA:
+		return FLD(7)
+	case ASTWA:
+		return FLD(8)
+	case ASTLA:
+		return FLD(9)
+	case AFSTSA:
+		return FLD(10)
+	case AFSTDA:
+		return FLD(11)
+	case AFLDS:
+		return SP(2, 6)
+	case AFLDD:
+		return SP(2, 7)
+	case ASTB:
+		return SP(2, 8)
+	case ASTH:
+		return SP(2, 9)
+	case ASTW:
+		return SP(2, 10)
+	case ASTL:
+		return SP(2, 11)
+	case ASTL_U:
+		return SP(2, 12)
+	case APRI_ST:
+		return SP(2, 13)
+	case AFSTS:
+		return SP(2, 14)
+	case AFSTD:
+		return SP(2, 15)
+	case ALDI:
+		return SP(3, 14)
+	case ALDIH:
+		return SP(3, 15)
+	// SIMD v2
+	case AVOR:
+		return VLOG(1, 0x3c)
+	case AVAND:
+		return VLOG(1, 0)
+	case AVXOR:
+		return VLOG(0, 0x1c)
+	case AVORNOT:
+		return VLOG(0, 1)
+	case AVBIC:
+		return VLOG(0, 0x1f)
+	case AVLDS:
+		return SP(0, 0xc)
+	case AVLDD:
+		return SP(0, 0xd)
+	case AVSTS:
+		return SP(0, 0xe)
+	case AVSTD:
+		return SP(0, 0xf)
+	case AVADDW:
+		return VFA(0, 0)
+	case AVADDL:
+		return VFA(0, 0xe)
+	case AVSUBW:
+		return VFA(0, 1)
+	case AVSUBL:
+		return VFA(0, 0xf)
+	case AVCMPUEQB:
+		return VFA(4, 0xb)
+	case AVCMPUGTB:
+		return VFA(4, 0xc)
+	case AVMAXB:
+		return VFA(1, 0xe)
+	case AVMINB:
+		return VFA(1, 0xf)
+	case AVMAXH:
+		return VFA(5, 0x0)
+	case AVMINH:
+		return VFA(5, 0x1)
+	case AVMAXW:
+		return VFA(5, 0x2)
+	case AVMINW:
+		return VFA(5, 0x3)
+	case AVMAXL:
+		return VFA(5, 0x4)
+	case AVMINL:
+		return VFA(5, 0x5)
+	case AVUMAXB:
+		return VFA(5, 0x6)
+	case AVUMINB:
+		return VFA(5, 0x7)
+	case AVUMAXH:
+		return VFA(5, 0x8)
+	case AVUMINH:
+		return VFA(5, 0x9)
+	case AVUMAXW:
+		return VFA(5, 0xa)
+	case AVUMINW:
+		return VFA(5, 0xb)
+	case AVUMAXL:
+		return VFA(5, 0xc)
+	case AVUMINL:
+		return VFA(5, 0xd)
+	case AVCPYB:
+		return VFCA(3, 2)
+	case AVCPYH:
+		return VFCA(3, 2)
+	case AVCTPOP:
+		return VFA(1, 8)
+	case AVCTLZ:
+		return VFA(1, 9)
+	}
+
+	if a < 0 {
+		c.ctxt.Diag("bad orr opcode -%v", -a)
+	} else {
+		c.ctxt.Diag("bad orr opcode %v", a)
+	}
+	return 0
+}
+
+func (c *ctxt77) opirr(a obj.As) uint32 {
+	switch a {
+	case AADDW:
+		return FAI(0, 0)
+	case ASUBW:
+		return FAI(0, 1)
+	case AS4ADDW:
+		return FAI(0, 2)
+	case AS4SUBW:
+		return FAI(0, 3)
+	case AS8ADDW:
+		return FAI(0, 4)
+	case AS8SUBW:
+		return FAI(0, 5)
+	case AADDL:
+		return FAI(0, 8)
+	case ASUBL:
+		return FAI(0, 9)
+	case AS4ADDL:
+		return FAI(0, 10)
+	case AS4SUBL:
+		return FAI(0, 11)
+	case AS8ADDL:
+		return FAI(0, 12)
+	case AS8SUBL:
+		return FAI(0, 13)
+	case AMULW:
+		return FAI(1, 0)
+	case AMULL:
+		return FAI(1, 8)
+	case AUMULH:
+		return FAI(1, 9)
+	case ACMPEQ:
+		return FAI(2, 8)
+	case ACMPLT:
+		return FAI(2, 9)
+	case ACMPLE:
+		return FAI(2, 10)
+	case ACMPULT:
+		return FAI(2, 11)
+	case ACMPULE:
+		return FAI(2, 12)
+	case AAND:
+		return FAI(3, 8)
+	case ABIC:
+		return FAI(3, 9)
+	case ABIS:
+		return FAI(3, 10)
+	case AORNOT:
+		return FAI(3, 11)
+	case AXOR:
+		return FAI(3, 12)
+	case AEQV:
+		return FAI(3, 13)
+	case AINSLB:
+		return FAI(4, 0)
+	case AINSLH:
+		return FAI(4, 1)
+	case AINSLW:
+		return FAI(4, 2)
+	case AINSLL:
+		return FAI(4, 3)
+	case AINSHB:
+		return FAI(4, 4)
+	case AINSHH:
+		return FAI(4, 5)
+	case AINSHW:
+		return FAI(4, 6)
+	case AINSHL:
+		return FAI(4, 7)
+	case ASLL:
+		return FAI(4, 8)
+	case ASRL:
+		return FAI(4, 9)
+	case ASRA:
+		return FAI(4, 10)
+	case AEXTLB:
+		return FAI(5, 0)
+	case AEXTLH:
+		return FAI(5, 1)
+	case AEXTLW:
+		return FAI(5, 2)
+	case AEXTLL:
+		return FAI(5, 3)
+	case AEXTHB:
+		return FAI(5, 4)
+	case AEXTHH:
+		return FAI(5, 5)
+	case AEXTHW:
+		return FAI(5, 6)
+	case AEXTHL:
+		return FAI(5, 7)
+	case AMASKLB:
+		return FAI(6, 0)
+	case AMASKLH:
+		return FAI(6, 1)
+	case AMASKLW:
+		return FAI(6, 2)
+	case AMASKLL:
+		return FAI(6, 3)
+	case AMASKHB:
+		return FAI(6, 4)
+	case AMASKHH:
+		return FAI(6, 5)
+	case AMASKHW:
+		return FAI(6, 6)
+	case AMASKHL:
+		return FAI(6, 7)
+	case AZAP:
+		return FAI(6, 8)
+	case AZAPNOT:
+		return FAI(6, 9)
+	case ASEXTB:
+		return FAI(6, 10)
+	case ASEXTH:
+		return FAI(6, 11)
+	case ACMPGEB:
+		return FAI(6, 12)
+	case ASBT:
+		return FAI(2, 0xd)
+	case ACBT:
+		return FAI(2, 0xe)
+	case ASELEQ:
+		return SP(1, 3) | (0 << 5)
+	case ASELGE:
+		return SP(1, 3) | (1 << 5)
+	case ASELGT:
+		return SP(1, 3) | (2 << 5)
+	case ASELLE:
+		return SP(1, 3) | (3 << 5)
+	case ASELLT:
+		return SP(1, 3) | (4 << 5)
+	case ASELNE:
+		return SP(1, 3) | (5 << 5)
+	case ASELLBC:
+		return SP(1, 3) | (6 << 5)
+	case ASELLBS:
+		return SP(1, 3) | (7 << 5)
+	case AVADDW:
+		return VFA(2, 0)
+	case AVADDL:
+		return VFA(2, 0xe)
+	case AVSUBW:
+		return VFA(2, 1)
+	case AVSUBL:
+		return VFA(2, 0xf)
+	}
+	if a < 0 {
+		c.ctxt.Diag("bad irr opcode -%v", -a)
+	} else {
+		c.ctxt.Diag("bad irr opcode %v", a)
+	}
+	return 0
+}
+
+func getRegister(v int16) int16 {
+	if v == 0 {
+		return REGZERO & 31
+	}
+	return v & 31
+}
+func getReg2(p *obj.Prog) int16 {
+	reg := p.Reg
+	if reg == 0 && len(p.RestArgs) != 0 {
+		reg = p.RestArgs[0].Reg
+	}
+	return reg & 31
+}
+
+func getFrom3Reg(p *obj.Prog) int16 {
+	reg := p.RestArgs[1].Reg
+	if reg == 0 {
+		fmt.Errorf("illegal From3 reg: %v", reg)
+	}
+	return reg & 31
+}
+
+func addrel(cursym *obj.LSym, off int32, add int64, target *obj.LSym, rt objabi.RelocType) {
+	r := obj.Addrel(cursym)
+	r.Add = add
+	r.Siz = 4
+	r.Off = off
+	r.Sym = target
+	r.Type = rt
+}
+
+func addrel8(cursym *obj.LSym, off int32, add int64, target *obj.LSym, rt objabi.RelocType) {
+	r := obj.Addrel(cursym)
+	r.Add = add
+	r.Siz = 8
+	r.Off = off
+	r.Sym = target
+	r.Type = rt
+}
diff --git a/src/cmd/internal/obj/sw64/list77.go b/src/cmd/internal/obj/sw64/list77.go
new file mode 100644
index 00000000..bf9cf36e
--- /dev/null
+++ b/src/cmd/internal/obj/sw64/list77.go
@@ -0,0 +1,89 @@
+// cmd/9l/list.c from Vita Nuova.
+//
+//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
+//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
+//	Portions Copyright © 1997-1999 Vita Nuova Limited
+//	Portions Copyright © 2000-2008 Vita Nuova Holdings Limited (www.vitanuova.com)
+//	Portions Copyright © 2004,2006 Bruce Ellis
+//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
+//	Revisions Copyright © 2000-2008 Lucent Technologies Inc. and others
+//	Portions Copyright © 2009 The Go Authors. All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+package sw64
+
+import (
+	"cmd/internal/obj"
+	"fmt"
+)
+
+func init() {
+	obj.RegisterRegister(obj.RBaseSW64, REG_R0+1024, rconv)
+	//	obj.RegisterRegister(obj.RBaseSW64, REG_LAST+1, rconv)
+	obj.RegisterOpcode(obj.ABaseSW64, Anames)
+}
+
+func rconv(r int) string {
+	if r == 0 {
+		return "NONE"
+	}
+	//if r == REGG {
+	if r == REG_R15 {
+		// Special case.
+		return "g"
+	}
+	//if r == REGSB {
+	if r == REG_R29 {
+		// Special case.
+		return "RSB"
+	}
+	//if r == REGSP {
+	if r == REG_R30 {
+		// Special case.
+		return "SP"
+	}
+	if r == REGCTXT {
+		return "REGCTXT"
+	}
+	if r == REGZERO {
+		return "ZERO"
+	}
+	if IsRReg(r) {
+		return fmt.Sprintf("R%d", r-REG_R0)
+	}
+	if IsFReg(r) {
+		return fmt.Sprintf("F%d", r-REG_F0)
+	}
+	if REG_V0 <= r && r <= REG_V31 {
+		return fmt.Sprintf("V%d", r-REG_V0)
+	}
+	return fmt.Sprintf("badreg(%d)", r)
+
+}
+
+func DRconv(a int) string {
+	s := "C_??"
+	if a >= C_NONE && a <= C_NCLASS {
+		s = cnames77[a]
+	}
+	var fp string
+	fp += s
+	return fp
+}
diff --git a/src/cmd/internal/obj/sw64/obj77.go b/src/cmd/internal/obj/sw64/obj77.go
new file mode 100644
index 00000000..0a3251bd
--- /dev/null
+++ b/src/cmd/internal/obj/sw64/obj77.go
@@ -0,0 +1,1075 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package sw64
+
+import (
+	"cmd/internal/obj"
+	"cmd/internal/objabi"
+	"cmd/internal/sys"
+	"internal/abi"
+	"log"
+)
+
+func (c *ctxt77) stacksplit(p *obj.Prog, framesize int32) *obj.Prog {
+	p = insertLDGP(p, c.newprog, REGZERO)
+
+	if c.ctxt.Flag_maymorestack != "" {
+		p = c.ctxt.StartUnsafePoint(p, c.newprog)
+		// Spill Arguments. This has to happen before we open
+		// any more frame space.
+		p = c.cursym.Func().SpillRegisterArgs(p, c.newprog)
+
+		frameSize := 2 * c.ctxt.Arch.PtrSize
+
+		// Save LR and REGCTXT.
+		// STL RA, $-16(SP)
+		p = obj.Appendp(p, c.newprog)
+		p.As = ASTL
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = REGLINK
+		p.To.Type = obj.TYPE_MEM
+		p.To.Offset = int64(-frameSize)
+		p.To.Reg = REGSP
+
+		// STL REGCTXT, $-8(SP)
+		p = obj.Appendp(p, c.newprog)
+		p.As = ASTL
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = REGCTXT
+		p.To.Type = obj.TYPE_MEM
+		p.To.Offset = int64(-c.ctxt.Arch.PtrSize)
+		p.To.Reg = REGSP
+
+		// LDI SP, $-16(SP)
+		p = obj.Appendp(p, c.newprog)
+		p.As = ALDI
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = REGSP
+		p.To.Type = obj.TYPE_ADDR
+		p.To.Reg = REGSP
+		p.To.Offset = int64(-frameSize)
+		p.Spadj = int32(frameSize)
+
+		// CALL  maymorestack
+		p = obj.Appendp(p, c.newprog)
+		p.As = obj.ACALL
+		p.From.Type, p.From.Reg = obj.TYPE_REG, REGLINK
+		p.To.Type = obj.TYPE_BRANCH
+		p.To.Name = obj.NAME_EXTERN
+		// See ../x86/obj6.go
+		p.To.Sym = c.ctxt.LookupABI(c.ctxt.Flag_maymorestack, c.cursym.ABI())
+
+		// Restore LR and REGCTXT.
+		// LDL RA, $0(SP)
+		p = obj.Appendp(p, c.newprog)
+		p.As = ALDL
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = REGLINK
+		p.To.Type = obj.TYPE_MEM
+		p.To.Reg = REGSP
+		p.To.Offset = 0
+
+		// LDL REGCTXT, $8(SP)
+		p = obj.Appendp(p, c.newprog)
+		p.As = ALDL
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = REGCTXT
+		p.To.Type = obj.TYPE_MEM
+		p.To.Reg = REGSP
+		p.To.Offset = int64(c.ctxt.Arch.PtrSize)
+
+		// LDI SP, $16(SP),
+		p = obj.Appendp(p, c.newprog)
+		p.As = ALDI
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = REGSP
+		p.To.Type = obj.TYPE_ADDR
+		p.To.Reg = REGSP
+		p.To.Offset = int64(frameSize)
+		p.Spadj = int32(-frameSize)
+
+		// Unspill arguments
+		p = c.cursym.Func().UnspillRegisterArgsSW64(p, c.newprog)
+		p = c.ctxt.EndUnsafePoint(p, c.newprog, -1)
+	}
+
+	// Jump back to here after morestack returns.
+	p = obj.Appendp(p, c.newprog)
+	begin := p
+
+	// LDL R1, g_stackguard(g)
+	p.As = ALDL
+	p.From.Type = obj.TYPE_REG
+	p.From.Reg = REG_R1
+
+	p.To.Type = obj.TYPE_MEM
+	p.To.Reg = REGG
+	p.To.Offset = 2 * int64(c.ctxt.Arch.PtrSize) // G.stackguard0
+	if c.cursym.CFunc() {
+		p.To.Offset = 3 * int64(c.ctxt.Arch.PtrSize) // G.stackguard1
+	}
+
+	// Mark the stack bound check and morestack call async nonpreemptible.
+	// If we get preempted here, when resumed the preemption request is
+	// cleared, but we'll still call morestack, which will double the stack
+	// unnecessarily. See issue #35470.
+	// p = c.ctxt.StartUnsafePoint(p, c.newprog)
+
+	var to_done, to_more *obj.Prog
+
+	if framesize <= abi.StackSmall {
+		// if SP > stackguard { goto done }
+		// CMPULE stackguard, SP, R1
+		// BNE R1 , done
+		p = obj.Appendp(p, c.newprog)
+
+		p.As = ACMPULE
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = REG_R1
+		p.AddRestSource(obj.Addr{
+			Type: obj.TYPE_REG,
+			Reg:  REGSP,
+		})
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = REG_R1
+		p = obj.Appendp(p, c.newprog)
+		p.As = ABNE
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = REG_R1
+		p.To.Type = obj.TYPE_BRANCH
+		to_done = p
+	} else {
+		// large stack: SP-framesize < stackguard-StackSmall
+		offset := int64(framesize) - abi.StackSmall
+		if framesize > abi.StackBig {
+			// Such a large stack we need to protect against underflow.
+			// The runtime guarantees SP > abi.StackBig, but
+			// framesize is large enough that SP-framesize may
+			// underflow, causing a direct comparison with the
+			// stack guard to incorrectly succeed. We explicitly
+			// guard against underflow.
+			//
+			//  LDI R2, $(framesize-StackSmall)
+			//  CMPULE R2, SP, R0
+			//  BNE R0, label-of-call-to-morestack
+			if offset > 32767 {
+				hi := int16(offset >> 16)
+				lo := int16(offset & 0xffff)
+				if lo < 0 {
+					hi = hi + 1
+					lo = int16(offset - int64(hi)<<16)
+				}
+				p = obj.Appendp(p, c.newprog)
+				p.As = ALDIH
+				p.To.Type = obj.TYPE_CONST
+				p.To.Offset = int64(hi)
+				p.From.Type = obj.TYPE_REG
+				p.From.Reg = REG_R2
+				p = obj.Appendp(p, c.newprog)
+				p.As = ALDI
+				p.From.Type, p.From.Reg = obj.TYPE_REG, REG_R2
+				p.To.Type, p.To.Offset, p.To.Reg = obj.TYPE_ADDR, int64(lo), REG_R2
+			} else {
+				p = obj.Appendp(p, c.newprog)
+				p.As = ALDI
+				p.To.Type = obj.TYPE_CONST
+				p.To.Offset = offset
+				p.From.Type = obj.TYPE_REG
+				p.From.Reg = REG_R2
+			}
+
+			// CMPULE R2, SP, R0
+			// BNE R0, label-of-call-to-morestack
+			p = obj.Appendp(p, c.newprog)
+			p.As = ACMPULE
+			p.From.Type, p.From.Reg = obj.TYPE_REG, REGSP
+			p.AddRestSource(obj.Addr{Type: obj.TYPE_REG, Reg: REG_R2})
+			p.To.Type, p.To.Reg = obj.TYPE_REG, REG_R0
+			p = obj.Appendp(p, c.newprog)
+			p.As = ABNE
+			p.From.Type, p.From.Reg = obj.TYPE_REG, REG_R0
+			p.To.Type = obj.TYPE_BRANCH
+			to_more = p
+		}
+		// Check against the stack guard. We've ensured this won't underflow.
+		//  LDI R1, $-(framesize-StackSmall)
+		//  SUBL R1, SP, R2
+		//  // if R2 > stackguard { goto done }
+		//  CMPULE stackguard, R2, R1
+		//  BNE  R1, done
+
+		//	LDI R1, $(framesize+(StackGuard-StackSmall))
+		if offset > 32767 {
+			hi := int16(offset >> 16)
+			lo := int16(offset & 0xffff)
+			if lo < 0 {
+				hi = hi + 1
+				lo = int16(offset - int64(hi)<<16)
+			}
+			p = obj.Appendp(p, c.newprog)
+			p.As = ALDIH
+			p.To.Type = obj.TYPE_CONST
+			p.To.Offset = int64(hi)
+			p.From.Type = obj.TYPE_REG
+			p.From.Reg = REG_R2
+			p = obj.Appendp(p, c.newprog)
+			p.As = ALDI
+			p.From.Type, p.From.Reg = obj.TYPE_REG, REG_R2
+			p.To.Type, p.To.Offset, p.To.Reg = obj.TYPE_ADDR, int64(lo), REG_R2
+		} else {
+			p = obj.Appendp(p, c.newprog)
+			p.As = ALDI
+			p.To.Type = obj.TYPE_CONST
+			p.To.Offset = offset
+			p.From.Type = obj.TYPE_REG
+			p.From.Reg = REG_R2
+		}
+
+		//SUBL SP, R2, R2
+		p = obj.Appendp(p, c.newprog)
+		p.As = ASUBL
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = REGSP
+		p.Reg = REG_R2
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = REG_R2
+
+		// CMPULE  stackguard, R2 ,R0
+		p = obj.Appendp(p, c.newprog)
+		p.As = ACMPULE
+		p.From.Type, p.From.Reg = obj.TYPE_REG, REG_R1
+		p.AddRestSource(obj.Addr{Type: obj.TYPE_REG, Reg: REG_R2})
+		p.To.Type, p.To.Reg = obj.TYPE_REG, REG_R0
+		// q1: BNE R0, done
+		p = obj.Appendp(p, c.newprog)
+		p.As = ABNE
+		p.From.Type = obj.TYPE_REG
+		p.From.Reg = REG_R0
+		p.To.Type = obj.TYPE_BRANCH
+		to_done = p
+	}
+
+	// q1: BNE R1, done
+	//	p = obj.Appendp(p, c.newprog)
+	//	q1 := p
+	//
+	//	p.As = ABNE
+	//	p.From.Type = obj.TYPE_REG
+	//	p.From.Reg = REG_R1
+	//	p.To.Type = obj.TYPE_BRANCH
+
+	// LDI R3, LINK
+	p = obj.Appendp(p, c.newprog)
+	p.As = ALDI
+	p.From.Type = obj.TYPE_REG
+	p.From.Reg = REG_R3
+	p.To.Type = obj.TYPE_REG
+	p.To.Reg = REGLINK
+	if to_more != nil {
+		to_more.To.SetTarget(p)
+	}
+
+	p = c.ctxt.EmitEntryLiveness(c.cursym, p, c.newprog)
+	//p = c.ctxt.EmitEntryStackMap(c.cursym, p, c.newprog)
+
+	// Spill the register args that could be clobbered by the
+	// morestack code
+	p = c.cursym.Func().SpillRegisterArgs(p, c.newprog)
+
+	// JMP runtime.morestack(SB)
+	p = obj.Appendp(p, c.newprog)
+	p.As = AJMP
+	p.From.Type = obj.TYPE_REG
+	//Don't use RA, otherwise the GP value will wrong because when
+	//the morestack return the RA is not the next instruction address.
+	p.From.Reg = REG_R2
+	p.To.Type = obj.TYPE_BRANCH
+	p.To.Name = obj.NAME_EXTERN
+
+	if c.cursym.CFunc() {
+		p.To.Sym = c.ctxt.Lookup("runtime.morestackc")
+	} else if !c.cursym.Func().Text.From.Sym.NeedCtxt() {
+		p.To.Sym = c.ctxt.Lookup("runtime.morestack_noctxt")
+	} else {
+		p.To.Sym = c.ctxt.Lookup("runtime.morestack")
+	}
+	//	if to_more != nil {
+	//		to_more.To.SetTarget(p)
+	//	}
+
+	//zxw new add
+	//p = c.ctxt.EndUnsafePoint(p, c.newprog, -1)
+
+	p = c.cursym.Func().UnspillRegisterArgsSW64(p, c.newprog)
+
+	// JMP	start
+	p = obj.Appendp(p, c.newprog)
+	p.As = ABR
+	p.From.Type, p.From.Reg = obj.TYPE_REG, REGZERO
+	p.To.Type, p.To.Val = obj.TYPE_BRANCH, begin
+
+	// placeholder for q1's jump target
+	p = obj.Appendp(p, c.newprog)
+	p.As = obj.ANOP // zero-width place holder
+	to_done.To.SetTarget(p)
+
+	return p
+}
+
+func (c *ctxt77) addnop(p *obj.Prog) {
+	q := c.newprog()
+	q.As = ANOOP
+	q.Pos = p.Pos
+	q.Link = p.Link
+	p.Link = q
+}
+
+func insertLDGP(q *obj.Prog, newprog obj.ProgAlloc, rip int16) *obj.Prog {
+	q = obj.Appendp(q, newprog)
+	q.As = ALDGP
+	q.From = obj.Addr{Type: obj.TYPE_REG, Reg: REG_R29}
+	q.To = obj.Addr{Type: obj.TYPE_REG, Reg: rip}
+	return q
+}
+
+func preprocess(ctxt *obj.Link, cursym *obj.LSym, newprog obj.ProgAlloc) {
+	// 1. handle ARET and ATEXT to setup function prologue and epilogue
+	// 2. adjust Prog.Spadj if the prog change hardward SP
+
+	if cursym.Func().Text == nil || cursym.Func().Text.Link == nil {
+		return
+	}
+
+	c := ctxt77{ctxt: ctxt, newprog: newprog, cursym: cursym}
+	p := c.cursym.Func().Text
+	textstksiz := p.To.Offset
+
+	if textstksiz == -ctxt.Arch.FixedFrameSize {
+		// Historical way to mark NOFRAME.
+		p.From.Sym.Set(obj.AttrNoFrame, true)
+		textstksiz = 0
+	}
+	if textstksiz < 0 {
+		c.ctxt.Diag("negative frame size %d - did you mean NOFRAME?", textstksiz)
+	}
+	if p.From.Sym.NoFrame() {
+		if textstksiz != 0 {
+			c.ctxt.Diag("NOFRAME functions must have a frame size of 0, not %d", textstksiz)
+		}
+	}
+
+	c.cursym.Func().Args = p.To.Val.(int32)
+	c.cursym.Func().Locals = int32(textstksiz)
+
+	if textstksiz < 0 {
+		ctxt.Diag("Use NOFRAME attribute instead of a negative frame size.\n%v\n", p)
+		return
+	}
+
+	/*
+	 * find leaf subroutines
+	 * strip NOPs
+	 * expand RET
+	 */
+
+	for p := c.cursym.Func().Text; p != nil; p = p.Link {
+		switch p.As {
+		case obj.ATEXT:
+			p.Mark |= LEAF
+
+		case obj.ARET:
+			break
+
+		case ACALL,
+			obj.ADUFFZERO,
+			obj.ADUFFCOPY:
+			c.cursym.Func().Text.Mark &^= LEAF
+			fallthrough
+
+		case AJMP,
+			ABR,
+			ABSR,
+			ABNE,
+			ABEQ,
+			ABLT,
+			ABLE,
+			ABGT,
+			ABGE,
+			ABLBC,
+			ABLBS,
+			AFBNE,
+			AFBEQ,
+			AFBLT,
+			AFBLE,
+			AFBGT,
+			AFBGE:
+			q1 := p.To.Target()
+
+			if q1 != nil {
+				for q1.As == obj.ANOP {
+					q1 = q1.Link
+					//p.Pcond = q1
+					p.To.Val = q1
+				}
+			}
+
+			break
+		}
+
+	}
+
+	autosize := int32(0)
+	var retjmp *obj.LSym
+	for p := cursym.Func().Text; p != nil; p = p.Link {
+		o := p.As
+		switch o {
+		case obj.ATEXT:
+			autosize = int32(textstksiz)
+			q := p
+			if p.Mark&LEAF != 0 && autosize == 0 {
+				// A leaf function with no locals has no frame.
+				p.From.Sym.Set(obj.AttrNoFrame, true)
+			}
+
+			if !p.From.Sym.NoFrame() {
+				// If there is a stack frame at all, it includes
+				// space to save the LR.
+				autosize += int32(c.ctxt.Arch.FixedFrameSize)
+			}
+			if cursym.Attribute.NoFrame() {
+				if textstksiz != 0 {
+					ctxt.Diag("NoFrame symbol %v with non zero frame size(%d)", cursym, textstksiz)
+				}
+				autosize = 0
+			}
+
+			var manuallr *obj.Prog
+			var manualsp *obj.Prog
+			var preprog *obj.Prog
+			//convert virtual SP to hardware SP
+			//see also: https://bj.git.sndu.cn/xiabin/go-sw64/wikis/stack-frame-layout
+			for p := cursym.Func().Text; p != nil; p = p.Link {
+				switch p.To.Name {
+				case obj.NAME_PARAM:
+					p.To.Type = obj.TYPE_ADDR
+					p.To.Reg = REGSP
+					p.To.Offset += int64(autosize) + c.ctxt.Arch.FixedFrameSize
+					p.To.Sym = nil
+				case obj.NAME_AUTO:
+					p.To.Type = obj.TYPE_ADDR
+					p.To.Reg = REGSP
+					p.To.Offset += int64(autosize)
+					p.To.Sym = nil
+				}
+				if cursym.Attribute.NoFrame() && (manuallr == nil || manualsp == nil) {
+					switch p.As {
+					case ASTL:
+						if manuallr == nil && p.From.Reg == REGLINK && p.To.Reg == REGSP {
+							manuallr = p
+						} else {
+							preprog = p
+						}
+					case ALDI:
+						if manualsp == nil && p.From.Reg == REGSP && p.To.Reg == REGSP {
+							manualsp = p
+						} else {
+							preprog = p
+						}
+					default:
+						preprog = p
+					}
+				}
+			}
+
+			if autosize == 0 && c.cursym.Func().Text.Mark&LEAF == 0 {
+				if c.cursym.Func().Text.From.Sym.NoSplit() {
+					if ctxt.Debugvlog {
+						ctxt.Logf("save suppressed in: %s\n", c.cursym.Name)
+					}
+
+					c.cursym.Func().Text.Mark |= LEAF
+				}
+			}
+
+			//p.To.Offset = int64(autosize) - ctxt.Arch.FixedFrameSize
+
+			if c.cursym.Func().Text.Mark&LEAF != 0 {
+				c.cursym.Set(obj.AttrLeaf, true)
+				if p.From.Sym.NoFrame() {
+					//break
+				}
+			}
+
+			if !p.From.Sym.NoSplit() {
+				q = c.stacksplit(q, autosize) // emit split check
+			}
+			if autosize != 0 {
+				q = c.ctxt.StartUnsafePoint(q, c.newprog)
+
+				// STL RA, $-autosize(SP)
+				q = obj.Appendp(q, newprog)
+				q.As = ASTL
+				q.From.Type = obj.TYPE_REG
+				q.From.Reg = REGLINK
+				q.To.Type = obj.TYPE_MEM
+				q.To.Reg = REGSP
+				q.To.Offset = int64(-autosize)
+
+				// LDI SP, $-autosize(SP)
+				q = obj.Appendp(q, newprog)
+				q.Spadj = autosize
+				q.As = ALDI
+				q.From.Type = obj.TYPE_REG
+				q.From.Reg = REGSP
+				q.To.Type = obj.TYPE_ADDR
+				q.To.Reg = REGSP
+				q.To.Offset = int64(-autosize)
+				q = c.ctxt.EndUnsafePoint(q, c.newprog, -1)
+			} else if manuallr != nil && manualsp != nil {
+				if preprog.As == obj.AFUNCDATA && manuallr.Link == manualsp {
+					// This is a workaround for preempt_sw64.s
+					preprog.Link = manualsp.Link
+					q = c.ctxt.StartUnsafePoint(q, c.newprog)
+					q.Link = manuallr
+					q = q.Link
+					q.Link = manualsp
+					q = q.Link
+					q.Spadj = int32(-q.To.Offset)
+					q = c.ctxt.EndUnsafePoint(q, c.newprog, -1)
+				}
+			}
+			// snyh_TODO: #131
+			q = insertLDGP(q, newprog, REGZERO)
+
+			if c.cursym.Func().Text.From.Sym.Wrapper() {
+				// if(g->panic != nil && g->panic->argp == FP)
+				//    g->panic->argp = bottom-of-frame
+
+				// LDL R1, g_panic(g)
+				q = obj.Appendp(q, newprog)
+				q.As = ALDL
+				q.From = obj.Addr{Type: obj.TYPE_REG, Reg: REG_R1}
+				q.To = obj.Addr{
+					Type:   obj.TYPE_MEM,
+					Reg:    REGG,
+					Offset: 4 * int64(c.ctxt.Arch.PtrSize), // G.panic
+				}
+
+				// BEQ R1, end
+				q = obj.Appendp(q, newprog)
+				q.As = ABEQ
+				q.From.Type = obj.TYPE_REG
+				q.From.Reg = REG_R1
+				q.To.Type = obj.TYPE_BRANCH
+				p1 := q
+
+				// LDL R2, panic_argp(R1)
+				q = obj.Appendp(q, newprog)
+				q.As = ALDL
+				q.From = obj.Addr{Type: obj.TYPE_REG, Reg: REG_R2}
+				q.To = obj.Addr{
+					Type:   obj.TYPE_MEM,
+					Reg:    REG_R1,
+					Offset: 0, // Panic.argp
+				}
+
+				// ADDL SP, $autosize+FixedFrameSize, R3
+				q = obj.Appendp(q, newprog)
+				q.As = AADDL
+				q.From.Type = obj.TYPE_REG
+				q.From.Reg = REGSP
+				q.AddRestSource(obj.Addr{
+					Type:   obj.TYPE_CONST,
+					Offset: int64(autosize) + ctxt.Arch.FixedFrameSize,
+				})
+				q.To.Type = obj.TYPE_REG
+				q.To.Reg = REG_R3
+
+				// CMPEQ R2, R3, R0
+				q = obj.Appendp(q, newprog)
+				q.As = ACMPEQ
+				q.From.Type = obj.TYPE_REG
+				q.From.Reg = REG_R2
+				q.AddRestSource(obj.Addr{
+					Type: obj.TYPE_REG,
+					Reg:  REG_R3,
+				})
+				q.To.Type = obj.TYPE_REG
+				q.To.Reg = REG_R0
+				// BEQ R0, end
+				q = obj.Appendp(q, newprog)
+				q.As = ABEQ
+				q.From.Type = obj.TYPE_REG
+				q.From.Reg = REG_R0
+				q.To.Type = obj.TYPE_BRANCH
+				p2 := q
+
+				// ADD SP, $FIXED_FRAME, R2
+				q = obj.Appendp(q, newprog)
+				q.As = AADDL
+				q.From.Type = obj.TYPE_REG
+				q.From.Reg = REGSP
+				q.AddRestSource(obj.Addr{
+					Type:   obj.TYPE_CONST,
+					Offset: ctxt.Arch.FixedFrameSize,
+				})
+				q.To.Type = obj.TYPE_REG
+				q.To.Reg = REG_R2
+
+				// STL R2, panic_argp(R1)
+				q = obj.Appendp(q, newprog)
+				q.As = ASTL
+				q.From.Type = obj.TYPE_REG
+				q.From.Reg = REG_R2
+				q.To.Type = obj.TYPE_MEM
+				q.To.Reg = REG_R1
+				q.To.Offset = 0 // Panic.argp
+
+				// end:
+				q = obj.Appendp(q, newprog)
+				q.As = obj.ANOP
+				p1.To.Val = q
+				p2.To.Val = q
+			}
+			p = q
+
+		case obj.ARET:
+			retjmp = p.To.Sym
+
+			if cursym.Func().Text.Mark&LEAF != 0 {
+				if autosize == 0 {
+					p.As = AJMP
+					p.From.Reg = REGZERO
+					p.From.Type = obj.TYPE_REG
+
+					p.To.Name = obj.NAME_NONE
+					p.To.Sym = nil
+					if retjmp != nil { // retjmp
+						p.To.Type = obj.TYPE_BRANCH
+						p.To.Name = obj.NAME_EXTERN
+						p.To.Sym = retjmp
+					} else {
+						p.To.Type = obj.TYPE_MEM
+						p.To.Offset = 0
+						p.To.Reg = REGLINK
+					}
+					break
+				}
+			}
+
+			if autosize != 0 && retjmp == nil {
+				tmp := newprog()
+				*tmp = *p
+
+				// We can't use q = obj.Appendp(q, newprog),
+				// because the RET may be a jump target, and Appendp
+				// will change the pointer value of q
+				// LDL RA, $0(SP)
+				q := p
+				q.As = ALDL
+				q.From.Type = obj.TYPE_REG
+				q.From.Reg = REGLINK
+				q.To.Type = obj.TYPE_MEM
+				q.To.Reg = REGSP
+
+				//LDI SP, $autosize(SP)
+				q = obj.Appendp(q, newprog)
+				q.As = ALDI
+				q.From.Type = obj.TYPE_REG
+				q.From.Reg = REGSP
+				q.To.Type = obj.TYPE_ADDR
+				q.To.Reg = REGSP
+				q.To.Offset = int64(autosize)
+				q.Spadj = -autosize
+
+				q = obj.Appendp(q, newprog)
+				*q = *tmp
+
+				//insert a noop for restore spadj
+				q = obj.Appendp(q, newprog)
+				q.As = obj.ANOP
+				q.Spadj = autosize
+				p = q
+
+			}
+			if retjmp != nil {
+				if autosize == 0 {
+					tmp := newprog()
+					*tmp = *p
+
+					// We can't use q = obj.Appendp(q, newprog),
+					// because the RET may be a jump target, and Appendp
+					// will change the pointer value of q
+					// STL RA, $(int64(autosize) - c.ctxt.Arch.FixedFrameSize)(SP)
+					q := p
+					q.As = ASTL
+					q.From.Type = obj.TYPE_REG
+					q.From.Reg = REGLINK
+					q.To = obj.Addr{
+						Type:   obj.TYPE_MEM,
+						Reg:    REGSP,
+						Offset: -c.ctxt.Arch.FixedFrameSize,
+					}
+
+					// LDI SP, $(int64(autosize) - c.ctxt.Arch.FixedFrameSize)(SP)
+					q = obj.Appendp(q, newprog)
+					q.As = ALDI
+					q.Spadj = autosize
+					q.From.Type = obj.TYPE_REG
+					q.From.Reg = REGSP
+					q.To.Type = obj.TYPE_ADDR
+					q.To.Reg = REGSP
+					q.To.Offset = -c.ctxt.Arch.FixedFrameSize
+
+					q = obj.Appendp(q, newprog)
+					*q = *tmp
+					//insert a noop for restore spadj
+					q = obj.Appendp(q, newprog)
+					q.As = obj.ANOP
+					q.Spadj = autosize
+					p = q
+				}
+
+				tmp1 := newprog()
+				*tmp1 = *p
+
+				q1 := p
+				// snyh_TODO: #131
+				q1 = insertLDGP(q1, newprog, REGZERO)
+
+				//insert a noop for restore spadj
+				q1 = obj.Appendp(q1, newprog)
+				q1.As = obj.ANOP
+				q1.Spadj = autosize
+
+				// LDL RA, $0(SP)
+				q1 = obj.Appendp(q1, newprog)
+				q1.As = ALDL
+				q1.From.Type = obj.TYPE_REG
+				q1.From.Reg = REGLINK
+				q1.To.Type = obj.TYPE_MEM
+				q1.To.Reg = REGSP
+
+				if autosize != 0 {
+					//LDI SP, $autosize(SP)
+					q1 = obj.Appendp(q1, newprog)
+					q1.As = ALDI
+					q1.From.Type = obj.TYPE_REG
+					q1.From.Reg = REGSP
+					q1.To.Type = obj.TYPE_ADDR
+					q1.To.Reg = REGSP
+					q1.To.Offset = int64(autosize)
+					q1.Spadj = -autosize
+				} else {
+					//LDI SP, $8(SP)
+					q1 = obj.Appendp(q1, newprog)
+					q1.As = ALDI
+					q1.From.Type = obj.TYPE_REG
+					q1.From.Reg = REGSP
+					q1.To.Type = obj.TYPE_ADDR
+					q1.To.Reg = REGSP
+					q1.To.Offset = int64(autosize) + c.ctxt.Arch.FixedFrameSize
+					q1.Spadj = -autosize - int32(c.ctxt.Arch.FixedFrameSize)
+				}
+
+				//RET ZERO,RA
+				q1 = obj.Appendp(q1, newprog)
+				q1.As = ARET
+				q1.From.Type = obj.TYPE_REG
+				q1.From.Reg = REGZERO
+				q1.To.Type = obj.TYPE_MEM
+				q1.To.Reg = REGLINK
+
+				p = q1
+			}
+		case obj.AGETCALLERPC:
+			if cursym.Leaf() {
+				q := p
+				/* LDI Rd, LR */
+				q.As = ALDI
+				q.To.Type = obj.TYPE_REG
+				q.To.Reg = REGLINK
+				p = q
+			} else {
+				q := p
+				/* LDL Rd, (RSP) */
+				q.As = ALDL
+				q.To.Type = obj.TYPE_MEM
+				q.To.Reg = REGSP
+				p = q
+			}
+		}
+
+		if p.From.Type == obj.TYPE_REG && p.From.Reg == REGSP && p.Spadj == 0 && (p.As == ASTL || p.As == ALDL) {
+			f := c.cursym.Func()
+			if f.FuncFlag&abi.FuncFlagSPWrite == 0 {
+				c.cursym.Func().FuncFlag |= abi.FuncFlagSPWrite
+				if ctxt.Debugvlog || !ctxt.IsAsm {
+					ctxt.Logf("auto-SPWRITE: %s %v\n", c.cursym.Name, p)
+					if !ctxt.IsAsm {
+						ctxt.Diag("invalid auto-SPWRITE in non-assembly")
+						ctxt.DiagFlush()
+						log.Fatalf("bad SPWRITE")
+					}
+				}
+			}
+		}
+	}
+
+	for p := cursym.Func().Text; p != nil; p = p.Link {
+		switch p.As {
+		case obj.ACALL, obj.AJMP:
+			p = insertLDGP(p, newprog, REGZERO)
+		}
+	}
+}
+
+func progedit(ctxt *obj.Link, p *obj.Prog, newprog obj.ProgAlloc) {
+	c := ctxt77{ctxt: ctxt, newprog: newprog}
+
+	p.From.Class = 0
+	p.To.Class = 0
+	switch p.As {
+	case ACALL:
+		if p.From.Type == obj.TYPE_NONE {
+			p.From.Type = obj.TYPE_REG
+			p.From.Reg = REGLINK
+		}
+	case AJMP:
+		if p.To.Type == obj.TYPE_BRANCH {
+			p.As = ABR
+		}
+		if p.From.Type == obj.TYPE_NONE {
+			p.From.Type = obj.TYPE_REG
+			p.From.Reg = REGZERO
+		}
+	case ARET:
+		if p.To.Type == obj.TYPE_NONE && p.From.Type == obj.TYPE_NONE {
+			p.From.Type = obj.TYPE_REG
+			p.From.Reg = REGZERO
+			p.To.Type = obj.TYPE_MEM
+			p.To.Reg = REGLINK
+		}
+	case ABR,
+		ABSR:
+		if p.From.Type == obj.TYPE_NONE {
+			p.From.Type = obj.TYPE_REG
+			p.From.Reg = REGZERO
+		}
+	case ALDF:
+		if p.To.Type == obj.TYPE_FCONST {
+			f32 := float32(p.To.Val.(float64))
+			p.As = AFLDS
+			p.To.Type = obj.TYPE_MEM
+			p.To.Sym = ctxt.Float32Sym(f32)
+			p.To.Name = obj.NAME_EXTERN
+			p.To.Offset = 0
+		}
+	case ALDI:
+		if p.To.Type == obj.TYPE_FCONST {
+			f64 := float64(p.To.Val.(float64))
+			p.As = AFLDD
+			p.To.Type = obj.TYPE_MEM
+			p.To.Sym = ctxt.Float64Sym(f64)
+			p.To.Name = obj.NAME_EXTERN
+			p.To.Offset = 0
+		} else if p.To.Type == obj.TYPE_CONST && !isint16(p.To.Offset) {
+			p.As = ALDL
+			p.To.Type = obj.TYPE_MEM
+			p.To.Sym = ctxt.Int64Sym(p.To.Offset)
+			p.To.Name = obj.NAME_EXTERN
+			p.To.Offset = 0
+		}
+	/*case AIFMOVS,
+	AIFMOVD,
+	AFIMOVS,
+	AFIMOVD:
+	p.AddRestSource(obj.Addr{
+		Type: obj.TYPE_REG,
+		Reg:  REGZERO,
+	})*/
+	case AFCVTSD,
+		AFCVTDS,
+		AFCVTDL,
+		AFCVTLS,
+		AFCVTLD,
+		AFCVTLW,
+		AFCVTWL,
+		AFSQRTS,
+		AFSQRTD,
+		ACTLZ,
+		ACTTZ,
+		ACTPOP,
+		ASEXTB,
+		ASEXTH,
+		AFCVTDL_Z,
+		AFCVTDL_P,
+		AFCVTDL_G,
+		AFCVTDL_N:
+		p.AddRestSource(p.From)
+		p.From.Reg = REGZERO
+		p.From.Type = obj.TYPE_REG
+	}
+
+	// use in plugin mode or share mode
+	if c.ctxt.Flag_dynlink {
+		c.rewriteToUseGot(p)
+	}
+	c.insertCrossModule(p)
+}
+
+func (c *ctxt77) insertCrossModule(p *obj.Prog) {
+	if p.As != obj.ACALL || p.To.Sym == nil {
+		return
+	}
+
+	if p.To.Sym.Name == "runtime.deferreturn" && p.Mark&CHANGED == 0 {
+		p1 := insertLDGP(p, c.newprog, REGZERO)
+		p1.Mark |= NOSCHED
+		p2 := obj.Appendp(p1, c.newprog)
+		p2.As = p.As
+		p2.To = p.To
+		p2.From = p.From
+		p2.Mark |= CHANGED
+		obj.Nopout(p)
+	}
+}
+
+// Rewrite p, if necessary, to access global data via the global offset table.
+func (c *ctxt77) rewriteToUseGot(p *obj.Prog) {
+	if p.As == obj.ADUFFCOPY || p.As == obj.ADUFFZERO {
+		//     ADUFFxxx $offset
+		// becomes
+		//     MOVD runtime.duffxxx@GOT, REGTMP
+		//     LDI $offset, REGTMP
+		//     LDI LR, REGTMP
+		//     CALL LR
+		var sym *obj.LSym
+		if p.As == obj.ADUFFZERO {
+			sym = c.ctxt.Lookup("runtime.duffzero")
+		} else {
+			sym = c.ctxt.Lookup("runtime.duffcopy")
+		}
+		offset := p.To.Offset
+		p.As = AMOVD
+		p.From.Type = obj.TYPE_MEM
+		p.From.Name = obj.NAME_GOTREF
+		p.From.Sym = sym
+		p.To.Type = obj.TYPE_REG
+		p.To.Reg = REGTMP
+		p.To.Name = obj.NAME_NONE
+		p.To.Offset = 0
+		p.To.Sym = nil
+
+		p1 := obj.Appendp(p, c.newprog)
+		p1.As = ALDI
+		p1.From.Type = obj.TYPE_REG
+		p1.From.Reg = REGTMP
+		p1.AddRestSource(obj.Addr{Type: obj.TYPE_CONST, Offset: offset})
+		p1.To.Type = obj.TYPE_REG
+		p1.To.Reg = REGTMP
+
+		p2 := obj.Appendp(p, c.newprog)
+		p2.As = ALDI
+		p2.From.Type = obj.TYPE_REG
+		p2.From.Reg = REG_R27
+		p2.To.Type = obj.TYPE_REG
+		p2.To.Reg = REGTMP
+
+		p3 := obj.Appendp(p1, c.newprog)
+		p3.As = obj.ACALL
+		p3.To.Type = obj.TYPE_REG
+		p3.To.Reg = REG_R27
+	}
+
+	// We only care about global data: NAME_EXTERN means a global
+	// symbol in the Go sense, and p.Sym.Local is true for a few
+	// internally defined symbols.
+
+	if p.To.Type == obj.TYPE_ADDR && p.To.Name == obj.NAME_EXTERN && !p.To.Sym.Local() {
+		// SYMADDR $sym, Rx becomes SYMADDR sym@GOT, Rx
+		// SYMADDR $sym+<off>, Rx becomes SYMADDR sym@GOT, Rx; LDI <off>, Rx
+		if p.As != ASYMADDR {
+			c.ctxt.Diag("do not know how to handle symbol not symaddr in %v with -dynlink", p)
+		}
+		if p.From.Type != obj.TYPE_REG {
+			c.ctxt.Diag("do not know how to handle symbol address insn to non-register in %v with -dynlink", p)
+		}
+		p.To.Type = obj.TYPE_MEM
+		p.To.Name = obj.NAME_GOTREF
+		if p.From.Offset != 0 {
+			q := obj.Appendp(p, c.newprog)
+			q.As = ALDI
+			q.From = p.To
+			p.AddRestSource(obj.Addr{Type: obj.TYPE_CONST, Offset: p.From.Offset})
+			q.To = p.To
+		}
+	}
+	//  if p.GetFrom3() != nil && p.GetFrom3().Name == obj.NAME_EXTERN {
+	//    c.ctxt.Diag("don't know how to handle %v with -dynlink", p)
+	//  }
+
+	var source *obj.Addr
+	// LDx Ry, sym becomes LDL REGTMP, sym@GOT; LDx Ry, (REGTMP)
+	// STx Ry, sym becomes LDL REGTMP, sym@GOT; STx Ry, (REGTMP)
+	// An addition may be inserted between the two MOVs if there is an offset.
+	if p.From.Name == obj.NAME_EXTERN && !p.From.Sym.Local() {
+		if p.To.Name == obj.NAME_EXTERN && !p.To.Sym.Local() {
+			c.ctxt.Diag("cannot handle NAME_EXTERN on both sides in %v with -dynlink", p)
+		}
+		source = &p.From
+	} else if p.To.Name == obj.NAME_EXTERN && !p.To.Sym.Local() {
+		source = &p.To
+	} else {
+		return
+	}
+	// Simple symbol relocation no need places in got table
+	if p.As == obj.ATEXT || p.As == obj.AFUNCDATA || p.As == obj.ACALL || p.As == obj.ARET || p.As == obj.AJMP {
+		return
+	} // so as tls
+	if source.Sym.Type == objabi.STLSBSS {
+		return
+	}
+	if source.Type != obj.TYPE_MEM {
+		c.ctxt.Diag("don't know how to handle %v with -dynlink", p)
+	}
+	p1 := obj.Appendp(p, c.newprog)
+	p2 := obj.Appendp(p1, c.newprog)
+	p1.As = AMOVD
+	p1.From.Type = obj.TYPE_MEM
+	p1.From.Sym = source.Sym
+	p1.From.Name = obj.NAME_GOTREF
+	p1.To.Type = obj.TYPE_REG
+	p1.To.Reg = REGTMP
+
+	p2.As = p.As
+	p2.From = p.From
+	p2.To = p.To
+	if p.From.Name == obj.NAME_EXTERN {
+		p2.From.Reg = REGTMP
+		p2.From.Name = obj.NAME_NONE
+		p2.From.Sym = nil
+	} else if p.To.Name == obj.NAME_EXTERN {
+		p2.To.Reg = REGTMP
+		p2.To.Name = obj.NAME_NONE
+		p2.To.Sym = nil
+	} else {
+		return
+	}
+	obj.Nopout(p)
+}
+
+var LinkSW64 = obj.LinkArch{
+	Arch:           sys.ArchSW64,
+	Init:           buildop,
+	Preprocess:     preprocess,
+	Assemble:       span77,
+	Progedit:       progedit,
+	DWARFRegisters: SW64DWARFRegisters,
+}
+
+//单参数指令，且参数为目的数 ==>(Prog.To = a[0])
+//不在这个列表的则参数为源数 ==>(Prog.From = a[0])
+var unaryDst = map[obj.As]bool{}
diff --git a/src/cmd/internal/obj/util.go b/src/cmd/internal/obj/util.go
index 3a071c21..fdc642cf 100644
--- a/src/cmd/internal/obj/util.go
+++ b/src/cmd/internal/obj/util.go
@@ -513,6 +513,7 @@ const (
 	RBaseRISCV   = 15 * 1024 // range [15k, 16k)
 	RBaseWasm    = 16 * 1024
 	RBaseLOONG64 = 17 * 1024
+	RBaseSW64    = 28 * 1024 // range [28k, 29k)
 )
 
 // RegisterRegister binds a pretty-printer (Rconv) for register
diff --git a/src/cmd/internal/objabi/reloctype.go b/src/cmd/internal/objabi/reloctype.go
index 54429840..1afbadf8 100644
--- a/src/cmd/internal/objabi/reloctype.go
+++ b/src/cmd/internal/objabi/reloctype.go
@@ -365,6 +365,36 @@ const (
 	// symbol's DWARF compile unit.
 	R_ADDRCUOFF
 
+	// A 21 bit branch.
+	// R_SW64_BRADDR replace displacement value, e.g. [20:0] of control format instruction
+	R_SW64_BRADDR
+	R_SW64_GPDISP
+
+	/* The high 16 bits of the displacement from TP to the target.  */
+	R_SW64_TPRELHI
+	/* The low 16 bits of the displacement from TP to the target.  */
+	R_SW64_TPRELLO
+
+	/* Creates a 64-bit offset in the got for the displacement from TP to the target.  */
+	R_SW64_GOTTPREL
+
+	// R_SW64_HINT replace displacement value, e.g. [15:0] of JMP/CALL/RET
+	R_SW64_HINT
+
+	/* The high 16 bits of the displacement from GP to the target.  */
+	R_SW64_GPRELHIGH
+	/* The low 16 bits of the displacement from GP to the target.  */
+	R_SW64_GPRELLOW
+
+	/* Load address form GP to the target */
+	R_SW64_LITERAL_GOT
+	R_SW64_LITERAL
+
+	/*TODO:*/
+	R_SW64_ADDR
+	R_SW64_PCREL
+	R_CALLSW64
+
 	// R_WASMIMPORT resolves to the index of the WebAssembly function import.
 	R_WASMIMPORT
 
@@ -401,7 +431,7 @@ const (
 func (r RelocType) IsDirectCall() bool {
 	switch r {
 	case R_CALL, R_CALLARM, R_CALLARM64, R_CALLLOONG64, R_CALLMIPS, R_CALLPOWER,
-		R_RISCV_CALL, R_RISCV_JAL, R_RISCV_JAL_TRAMP:
+		R_RISCV_CALL, R_RISCV_JAL, R_RISCV_JAL_TRAMP, R_SW64_HINT:
 		return true
 	}
 	return false
diff --git a/src/cmd/internal/objabi/reloctype_string.go b/src/cmd/internal/objabi/reloctype_string.go
index c8923c0f..6d85b483 100644
--- a/src/cmd/internal/objabi/reloctype_string.go
+++ b/src/cmd/internal/objabi/reloctype_string.go
@@ -1,4 +1,4 @@
-// Code generated by "stringer -type=RelocType"; DO NOT EDIT.
+// Code generated by "stringer -type=RelocType reloctype.go"; DO NOT EDIT.
 
 package objabi
 
@@ -95,15 +95,28 @@ func _() {
 	_ = x[R_ADDRMIPSU-85]
 	_ = x[R_ADDRMIPSTLS-86]
 	_ = x[R_ADDRCUOFF-87]
-	_ = x[R_WASMIMPORT-88]
-	_ = x[R_XCOFFREF-89]
-	_ = x[R_PEIMAGEOFF-90]
-	_ = x[R_INITORDER-91]
+	_ = x[R_SW64_BRADDR-88]
+	_ = x[R_SW64_GPDISP-89]
+	_ = x[R_SW64_TPRELHI-90]
+	_ = x[R_SW64_TPRELLO-91]
+	_ = x[R_SW64_GOTTPREL-92]
+	_ = x[R_SW64_HINT-93]
+	_ = x[R_SW64_GPRELHIGH-94]
+	_ = x[R_SW64_GPRELLOW-95]
+	_ = x[R_SW64_LITERAL_GOT-96]
+	_ = x[R_SW64_LITERAL-97]
+	_ = x[R_SW64_ADDR-98]
+	_ = x[R_SW64_PCREL-99]
+	_ = x[R_CALLSW64-100]
+	_ = x[R_WASMIMPORT-101]
+	_ = x[R_XCOFFREF-102]
+	_ = x[R_PEIMAGEOFF-103]
+	_ = x[R_INITORDER-104]
 }
 
-const _RelocType_name = "R_ADDRR_ADDRPOWERR_ADDRARM64R_ADDRMIPSR_ADDROFFR_SIZER_CALLR_CALLARMR_CALLARM64R_CALLINDR_CALLPOWERR_CALLMIPSR_CONSTR_PCRELR_TLS_LER_TLS_IER_GOTOFFR_PLT0R_PLT1R_PLT2R_USEFIELDR_USETYPER_USEIFACER_USEIFACEMETHODR_USENAMEDMETHODR_METHODOFFR_KEEPR_POWER_TOCR_GOTPCRELR_JMPMIPSR_DWARFSECREFR_DWARFFILEREFR_ARM64_TLS_LER_ARM64_TLS_IER_ARM64_GOTPCRELR_ARM64_GOTR_ARM64_PCRELR_ARM64_PCREL_LDST8R_ARM64_PCREL_LDST16R_ARM64_PCREL_LDST32R_ARM64_PCREL_LDST64R_ARM64_LDST8R_ARM64_LDST16R_ARM64_LDST32R_ARM64_LDST64R_ARM64_LDST128R_POWER_TLS_LER_POWER_TLS_IER_POWER_TLSR_POWER_TLS_IE_PCREL34R_POWER_TLS_LE_TPREL34R_ADDRPOWER_DSR_ADDRPOWER_GOTR_ADDRPOWER_GOT_PCREL34R_ADDRPOWER_PCRELR_ADDRPOWER_TOCRELR_ADDRPOWER_TOCREL_DSR_ADDRPOWER_D34R_ADDRPOWER_PCREL34R_RISCV_JALR_RISCV_JAL_TRAMPR_RISCV_CALLR_RISCV_PCREL_ITYPER_RISCV_PCREL_STYPER_RISCV_TLS_IER_RISCV_TLS_LER_RISCV_GOT_HI20R_RISCV_PCREL_HI20R_RISCV_PCREL_LO12_IR_RISCV_PCREL_LO12_SR_RISCV_BRANCHR_RISCV_RVC_BRANCHR_RISCV_RVC_JUMPR_PCRELDBLR_ADDRLOONG64R_ADDRLOONG64UR_ADDRLOONG64TLSR_ADDRLOONG64TLSUR_CALLLOONG64R_LOONG64_TLS_IE_PCREL_HIR_LOONG64_TLS_IE_LOR_LOONG64_GOT_HIR_LOONG64_GOT_LOR_JMPLOONG64R_ADDRMIPSUR_ADDRMIPSTLSR_ADDRCUOFFR_WASMIMPORTR_XCOFFREFR_PEIMAGEOFFR_INITORDER"
+const _RelocType_name = "R_ADDRR_ADDRPOWERR_ADDRARM64R_ADDRMIPSR_ADDROFFR_SIZER_CALLR_CALLARMR_CALLARM64R_CALLINDR_CALLPOWERR_CALLMIPSR_CONSTR_PCRELR_TLS_LER_TLS_IER_GOTOFFR_PLT0R_PLT1R_PLT2R_USEFIELDR_USETYPER_USEIFACER_USEIFACEMETHODR_USENAMEDMETHODR_METHODOFFR_KEEPR_POWER_TOCR_GOTPCRELR_JMPMIPSR_DWARFSECREFR_DWARFFILEREFR_ARM64_TLS_LER_ARM64_TLS_IER_ARM64_GOTPCRELR_ARM64_GOTR_ARM64_PCRELR_ARM64_PCREL_LDST8R_ARM64_PCREL_LDST16R_ARM64_PCREL_LDST32R_ARM64_PCREL_LDST64R_ARM64_LDST8R_ARM64_LDST16R_ARM64_LDST32R_ARM64_LDST64R_ARM64_LDST128R_POWER_TLS_LER_POWER_TLS_IER_POWER_TLSR_POWER_TLS_IE_PCREL34R_POWER_TLS_LE_TPREL34R_ADDRPOWER_DSR_ADDRPOWER_GOTR_ADDRPOWER_GOT_PCREL34R_ADDRPOWER_PCRELR_ADDRPOWER_TOCRELR_ADDRPOWER_TOCREL_DSR_ADDRPOWER_D34R_ADDRPOWER_PCREL34R_RISCV_JALR_RISCV_JAL_TRAMPR_RISCV_CALLR_RISCV_PCREL_ITYPER_RISCV_PCREL_STYPER_RISCV_TLS_IER_RISCV_TLS_LER_RISCV_GOT_HI20R_RISCV_PCREL_HI20R_RISCV_PCREL_LO12_IR_RISCV_PCREL_LO12_SR_RISCV_BRANCHR_RISCV_RVC_BRANCHR_RISCV_RVC_JUMPR_PCRELDBLR_ADDRLOONG64R_ADDRLOONG64UR_ADDRLOONG64TLSR_ADDRLOONG64TLSUR_CALLLOONG64R_LOONG64_TLS_IE_PCREL_HIR_LOONG64_TLS_IE_LOR_LOONG64_GOT_HIR_LOONG64_GOT_LOR_JMPLOONG64R_ADDRMIPSUR_ADDRMIPSTLSR_ADDRCUOFFR_SW64_BRADDRR_SW64_GPDISPR_SW64_TPRELHIR_SW64_TPRELLOR_SW64_GOTTPRELR_SW64_HINTR_SW64_GPRELHIGHR_SW64_GPRELLOWR_SW64_LITERAL_GOTR_SW64_LITERALR_SW64_ADDRR_SW64_PCRELR_CALLSW64R_WASMIMPORTR_XCOFFREFR_PEIMAGEOFFR_INITORDER"
 
-var _RelocType_index = [...]uint16{0, 6, 17, 28, 38, 47, 53, 59, 68, 79, 88, 99, 109, 116, 123, 131, 139, 147, 153, 159, 165, 175, 184, 194, 210, 226, 237, 243, 254, 264, 273, 286, 300, 314, 328, 344, 355, 368, 387, 407, 427, 447, 460, 474, 488, 502, 517, 531, 545, 556, 578, 600, 614, 629, 652, 669, 687, 708, 723, 742, 753, 770, 782, 801, 820, 834, 848, 864, 882, 902, 922, 936, 954, 970, 980, 993, 1007, 1023, 1040, 1053, 1078, 1097, 1113, 1129, 1141, 1152, 1165, 1176, 1188, 1198, 1210, 1221}
+var _RelocType_index = [...]uint16{0, 6, 17, 28, 38, 47, 53, 59, 68, 79, 88, 99, 109, 116, 123, 131, 139, 147, 153, 159, 165, 175, 184, 194, 210, 226, 237, 243, 254, 264, 273, 286, 300, 314, 328, 344, 355, 368, 387, 407, 427, 447, 460, 474, 488, 502, 517, 531, 545, 556, 578, 600, 614, 629, 652, 669, 687, 708, 723, 742, 753, 770, 782, 801, 820, 834, 848, 864, 882, 902, 922, 936, 954, 970, 980, 993, 1007, 1023, 1040, 1053, 1078, 1097, 1113, 1129, 1141, 1152, 1165, 1176, 1189, 1202, 1216, 1230, 1245, 1256, 1272, 1287, 1305, 1319, 1330, 1342, 1352, 1364, 1374, 1386, 1397}
 
 func (i RelocType) String() string {
 	i -= 1
diff --git a/src/cmd/internal/objfile/disasm.go b/src/cmd/internal/objfile/disasm.go
index c298d7e1..7e21ff08 100644
--- a/src/cmd/internal/objfile/disasm.go
+++ b/src/cmd/internal/objfile/disasm.go
@@ -24,6 +24,7 @@ import (
 	"golang.org/x/arch/arm/armasm"
 	"golang.org/x/arch/arm64/arm64asm"
 	"golang.org/x/arch/ppc64/ppc64asm"
+	"golang.org/x/arch/sw64/sw64asm"
 	"golang.org/x/arch/x86/x86asm"
 )
 
@@ -383,6 +384,20 @@ func disasm_ppc64(code []byte, pc uint64, lookup lookupFunc, byteOrder binary.By
 	return text, size
 }
 
+func disasm_sw64(code []byte, pc uint64, lookup lookupFunc, byteOrder binary.ByteOrder, gnuAsm bool) (string, int) {
+        inst, err := sw64asm.Decode(code)
+        var text string
+        if err != nil {
+                text = "?"
+        } else if gnuAsm {
+	        text = fmt.Sprintf("%-36s // %s", sw64asm.GoSyntax(inst, pc, lookup, textReader{code, pc}), sw64asm.GNUSyntax(inst))
+
+        } else {
+                text = sw64asm.GoSyntax(inst, pc, lookup, textReader{code, pc})
+        }
+        return text, 4
+}
+
 var disasms = map[string]disasmFunc{
 	"386":     disasm_386,
 	"amd64":   disasm_amd64,
@@ -390,6 +405,7 @@ var disasms = map[string]disasmFunc{
 	"arm64":   disasm_arm64,
 	"ppc64":   disasm_ppc64,
 	"ppc64le": disasm_ppc64,
+	"sw64":    disasm_sw64,
 }
 
 var byteOrders = map[string]binary.ByteOrder{
@@ -400,6 +416,7 @@ var byteOrders = map[string]binary.ByteOrder{
 	"ppc64":   binary.BigEndian,
 	"ppc64le": binary.LittleEndian,
 	"s390x":   binary.BigEndian,
+	"sw64":    binary.LittleEndian,
 }
 
 type Liner interface {
diff --git a/src/cmd/internal/objfile/elf.go b/src/cmd/internal/objfile/elf.go
index f25e4a65..5b841505 100644
--- a/src/cmd/internal/objfile/elf.go
+++ b/src/cmd/internal/objfile/elf.go
@@ -127,7 +127,9 @@ func (f *elfFile) goarch() string {
 		return "ppc64"
 	case elf.EM_S390:
 		return "s390x"
-	}
+	case elf.EM_SW64:
+                return "sw64"
+        }
 	return ""
 }
 
diff --git a/src/cmd/internal/sys/arch.go b/src/cmd/internal/sys/arch.go
index 2e352841..43a3edb6 100644
--- a/src/cmd/internal/sys/arch.go
+++ b/src/cmd/internal/sys/arch.go
@@ -23,6 +23,7 @@ const (
 	RISCV64
 	S390X
 	Wasm
+	SW64
 )
 
 // Arch represents an individual architecture.
@@ -267,6 +268,20 @@ var ArchWasm = &Arch{
 	FixedFrameSize: 0,
 }
 
+var ArchSW64 = &Arch{
+        Name:           "sw64",
+        Family:         SW64,
+        ByteOrder:      binary.LittleEndian,
+        PtrSize:        8,
+        RegSize:        8,
+        MinLC:          4,
+	Alignment:      8,
+	CanMergeLoads:  false,
+	CanJumpTable:   true,
+	HasLR:          true,
+	FixedFrameSize: 8,
+}
+
 var Archs = [...]*Arch{
 	Arch386,
 	ArchAMD64,
@@ -282,4 +297,5 @@ var Archs = [...]*Arch{
 	ArchRISCV64,
 	ArchS390X,
 	ArchWasm,
+	ArchSW64,
 }
diff --git a/src/cmd/link/internal/ld/data.go b/src/cmd/link/internal/ld/data.go
index a5a0615c..c355314d 100644
--- a/src/cmd/link/internal/ld/data.go
+++ b/src/cmd/link/internal/ld/data.go
@@ -305,7 +305,7 @@ func (st *relocSymState) relocsym(s loader.Sym, P []byte) {
 			if target.IsExternal() && target.IsElf() {
 				nExtReloc++
 				o = 0
-				if !target.IsAMD64() {
+				if !target.IsAMD64() && !target.IsSW64() {
 					o = r.Add()
 				}
 				break
@@ -331,7 +331,7 @@ func (st *relocSymState) relocsym(s loader.Sym, P []byte) {
 			if target.IsExternal() && target.IsElf() {
 				nExtReloc++
 				o = 0
-				if !target.IsAMD64() {
+				if !target.IsAMD64() && !target.IsSW64() {
 					o = r.Add()
 				}
 				if target.Is386() {
@@ -369,7 +369,7 @@ func (st *relocSymState) relocsym(s loader.Sym, P []byte) {
 
 				o = xadd
 				if target.IsElf() {
-					if target.IsAMD64() {
+					if target.IsAMD64() || target.IsSW64() {
 						o = 0
 					}
 				} else if target.IsDarwin() {
@@ -440,7 +440,7 @@ func (st *relocSymState) relocsym(s loader.Sym, P []byte) {
 				xadd := r.Add() + ldr.SymValue(rs) - int64(ldr.SymSect(rs).Vaddr)
 
 				o = xadd
-				if target.IsElf() && target.IsAMD64() {
+				if target.IsElf() && (target.IsAMD64() || target.IsSW64()) {
 					o = 0
 				}
 				break
@@ -515,7 +515,7 @@ func (st *relocSymState) relocsym(s loader.Sym, P []byte) {
 
 				o = xadd
 				if target.IsElf() {
-					if target.IsAMD64() {
+					if target.IsAMD64() || target.IsSW64() {
 						o = 0
 					}
 				} else if target.IsDarwin() {
@@ -599,7 +599,15 @@ func (st *relocSymState) relocsym(s loader.Sym, P []byte) {
 			} else if o != int64(int32(o)) && o != int64(uint32(o)) {
 				st.err.Errorf(s, "non-pc-relative relocation address for %s is too big: %#x", ldr.SymName(rs), uint64(o))
 			}
-			target.Arch.ByteOrder.PutUint32(P[off:], uint32(o))
+			if target.IsSW64() && rt == objabi.R_SW64_GPDISP && !target.IsExternal() {
+				Hi := uint16(o >> 16)
+				Lo := uint16(o)
+				target.Arch.ByteOrder.PutUint16(P[off:], Hi)
+				target.Arch.ByteOrder.PutUint16(P[off+4:], Lo)
+
+			} else {
+				target.Arch.ByteOrder.PutUint32(P[off:], uint32(o))
+			}
 		case 8:
 			target.Arch.ByteOrder.PutUint64(P[off:], uint64(o))
 		}
diff --git a/src/cmd/link/internal/ld/deadcode.go b/src/cmd/link/internal/ld/deadcode.go
index 70b4a7ca..6736078b 100644
--- a/src/cmd/link/internal/ld/deadcode.go
+++ b/src/cmd/link/internal/ld/deadcode.go
@@ -310,6 +310,20 @@ func (d *deadcodePass) flood() {
 		}
 	}
 }
+// TODO: temporary solution, preferably add new relocation type
+func isSW64DirectCall(index int, relocs loader.Relocs) bool {
+	var reloc_types [3]objabi.RelocType;
+	for i := 0; i < 3; i++ {
+		reloc_types[i] = relocs.At(index + i).Type()
+	}
+	if  reloc_types[0] == objabi.R_SW64_GPRELHIGH && reloc_types[2] == objabi.R_SW64_HINT {
+		return true;
+	} else if reloc_types[0] == objabi.R_SW64_GPRELLOW && reloc_types[1] == objabi.R_SW64_HINT {
+		return true;
+	} else {
+		return false;
+	}
+}
 
 // mapinitcleanup walks all pkg init functions and looks for weak relocations
 // to mapinit symbols that are no longer reachable. It rewrites
@@ -321,7 +335,7 @@ func (d *deadcodePass) mapinitcleanup() {
 		for i := 0; i < relocs.Count(); i++ {
 			r := relocs.At(i)
 			rs := r.Sym()
-			if r.Weak() && r.Type().IsDirectCall() && !d.ldr.AttrReachable(rs) {
+			if r.Weak() && (r.Type().IsDirectCall() || isSW64DirectCall(i, relocs)) && !d.ldr.AttrReachable(rs) {
 				// double check to make sure target is indeed map.init
 				rsn := d.ldr.SymName(rs)
 				if !strings.Contains(rsn, "map.init") {
diff --git a/src/cmd/link/internal/ld/elf.go b/src/cmd/link/internal/ld/elf.go
index be9e2294..b7ba9da7 100644
--- a/src/cmd/link/internal/ld/elf.go
+++ b/src/cmd/link/internal/ld/elf.go
@@ -234,7 +234,7 @@ we write section and prog headers.
 func Elfinit(ctxt *Link) {
 	ctxt.IsELF = true
 
-	if ctxt.Arch.InFamily(sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X) {
+	if ctxt.Arch.InFamily(sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS64, sys.PPC64, sys.RISCV64, sys.S390X, sys.SW64) {
 		elfRelType = ".rela"
 	} else {
 		elfRelType = ".rel"
@@ -249,7 +249,7 @@ func Elfinit(ctxt *Link) {
 			ehdr.Flags = 2 /* Version 2 ABI */
 		}
 		fallthrough
-	case sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS64, sys.RISCV64:
+	case sys.AMD64, sys.ARM64, sys.Loong64, sys.MIPS64, sys.RISCV64, sys.SW64:
 		if ctxt.Arch.Family == sys.MIPS64 {
 			ehdr.Flags = 0x20000004 /* MIPS 3 CPIC */
 		}
@@ -979,7 +979,8 @@ func elfdynhash(ctxt *Link) {
 	}
 
 	// s390x (ELF64) hash table entries are 8 bytes
-	if ctxt.Arch.Family == sys.S390X {
+	// so as sw64 (ELF64)
+	if ctxt.Arch.Family == sys.S390X || ctxt.Arch.Family == sys.SW64 {
 		s.AddUint64(ctxt.Arch, uint64(nbucket))
 		s.AddUint64(ctxt.Arch, uint64(nsym))
 		for i := 0; i < nbucket; i++ {
@@ -1597,7 +1598,7 @@ func (ctxt *Link) doelf() {
 			dynamic.SetType(sym.SELFSECT)
 		}
 
-		if ctxt.IsS390X() {
+		if ctxt.IsS390X() || ctxt.IsSW64() {
 			// S390X uses .got instead of .got.plt
 			gotplt = got
 		}
@@ -1642,6 +1643,11 @@ func (ctxt *Link) doelf() {
 			Elfwritedynent(ctxt.Arch, dynamic, elf.DT_PPC64_OPT, 0)
 		}
 
+		if ctxt.IsSW64() {
+			// sw64 use DT_LOPROC to mark plt is read only
+			elfWriteDynEntSym(ctxt, dynamic, elf.DT_LOPROC, plt.Sym())
+                }
+
 		// Solaris dynamic linker can't handle an empty .rela.plt if
 		// DT_JMPREL is emitted so we have to defer generation of elf.DT_PLTREL,
 		// DT_PLTRELSZ, and elf.DT_JMPREL dynamic entries until after we know the
@@ -1801,6 +1807,8 @@ func asmbElf(ctxt *Link) {
 		eh.Machine = uint16(elf.EM_RISCV)
 	case sys.S390X:
 		eh.Machine = uint16(elf.EM_S390)
+	case sys.SW64:
+		eh.Machine = uint16(elf.EM_SW64)
 	}
 
 	elfreserve := int64(ELFRESERVE)
@@ -2087,7 +2095,7 @@ func asmbElf(ctxt *Link) {
 		sh = elfshname(".plt")
 		sh.Type = uint32(elf.SHT_PROGBITS)
 		sh.Flags = uint64(elf.SHF_ALLOC + elf.SHF_EXECINSTR)
-		if elf.Machine(eh.Machine) == elf.EM_X86_64 {
+		if elf.Machine(eh.Machine) == elf.EM_X86_64 || elf.Machine(eh.Machine) == elf.EM_SW64 {
 			sh.Entsize = 16
 		} else if elf.Machine(eh.Machine) == elf.EM_S390 {
 			sh.Entsize = 32
diff --git a/src/cmd/link/internal/ld/pcln.go b/src/cmd/link/internal/ld/pcln.go
index 5734b925..5f2de563 100644
--- a/src/cmd/link/internal/ld/pcln.go
+++ b/src/cmd/link/internal/ld/pcln.go
@@ -150,6 +150,8 @@ func computeDeferReturn(ctxt *Link, deferReturnSym, s loader.Sym) uint32 {
 					// no change
 				case sys.S390X:
 					deferreturn -= 2
+				case sys.SW64:
+					deferreturn -= 8
 				default:
 					panic(fmt.Sprint("Unhandled architecture:", target.Arch.Family))
 				}
diff --git a/src/cmd/link/internal/ld/target.go b/src/cmd/link/internal/ld/target.go
index d0ce99f3..ae0c9851 100644
--- a/src/cmd/link/internal/ld/target.go
+++ b/src/cmd/link/internal/ld/target.go
@@ -132,6 +132,10 @@ func (t *Target) IsWasm() bool {
 	return t.Arch.Family == sys.Wasm
 }
 
+func (t *Target) IsSW64() bool {
+	return t.Arch.Family == sys.SW64
+}
+
 //
 // OS Functions
 //
diff --git a/src/cmd/link/internal/loadelf/ldelf.go b/src/cmd/link/internal/loadelf/ldelf.go
index 82e7dc30..61661e25 100644
--- a/src/cmd/link/internal/loadelf/ldelf.go
+++ b/src/cmd/link/internal/loadelf/ldelf.go
@@ -385,6 +385,11 @@ func Load(l *loader.Loader, arch *sys.Arch, localSymVersion int, f *bio.Reader,
 		if mach != elf.EM_S390 || class != elf.ELFCLASS64 {
 			return errorf("elf object but not s390x")
 		}
+
+	case sys.SW64:
+		if mach != elf.EM_SW64 || class != elf.ELFCLASS64 {
+			return errorf("elf object but not sw64")
+		}
 	}
 
 	// load section list into memory.
@@ -991,6 +996,7 @@ func relSize(arch *sys.Arch, pn string, elftype uint32) (uint8, uint8, error) {
 		PPC64   = uint32(sys.PPC64)
 		RISCV64 = uint32(sys.RISCV64)
 		S390X   = uint32(sys.S390X)
+		SW64    = uint32(sys.SW64)
 	)
 
 	switch uint32(arch.Family) | elftype<<16 {
@@ -1054,6 +1060,12 @@ func relSize(arch *sys.Arch, pn string, elftype uint32) (uint8, uint8, error) {
 		return 1, 1, nil
 
 	case PPC64 | uint32(elf.R_PPC64_TOC16)<<16,
+		SW64 | uint32(elf.R_SW64_SREL16)<<16,
+		SW64 | uint32(39)<<16,
+		SW64 | uint32(40)<<16,
+		SW64 | uint32(elf.R_SW64_LITUSE)<<16,
+		SW64 | uint32(elf.R_SW64_HINT)<<16,
+		SW64 | uint32(elf.R_SW64_LITERAL_GOT)<<16,
 		S390X | uint32(elf.R_390_16)<<16,
 		S390X | uint32(elf.R_390_GOT16)<<16,
 		S390X | uint32(elf.R_390_PC16)<<16,
@@ -1097,6 +1109,13 @@ func relSize(arch *sys.Arch, pn string, elftype uint32) (uint8, uint8, error) {
 		I386 | uint32(elf.R_386_GOTOFF)<<16,
 		I386 | uint32(elf.R_386_GOTPC)<<16,
 		I386 | uint32(elf.R_386_GOT32X)<<16,
+		SW64 | uint32(elf.R_SW64_LITERAL)<<16,
+		SW64 | uint32(elf.R_SW64_GPRELHIGH)<<16,
+		SW64 | uint32(elf.R_SW64_GPRELLOW)<<16,
+		SW64 | uint32(elf.R_SW64_SREL32)<<16,
+		SW64 | uint32(elf.R_SW64_REFLONG)<<16,
+		SW64 | uint32(elf.R_SW64_BRADDR)<<16,
+		SW64 | uint32(elf.R_SW64_GPDISP)<<16,
 		PPC64 | uint32(elf.R_PPC64_REL24)<<16,
 		PPC64 | uint32(elf.R_PPC64_REL24_NOTOC)<<16,
 		PPC64 | uint32(elf.R_PPC64_REL24_P9NOTOC)<<16,
@@ -1119,6 +1138,7 @@ func relSize(arch *sys.Arch, pn string, elftype uint32) (uint8, uint8, error) {
 		PPC64 | uint32(elf.R_PPC64_PCREL34)<<16,
 		PPC64 | uint32(elf.R_PPC64_GOT_PCREL34)<<16,
 		PPC64 | uint32(elf.R_PPC64_PLT_PCREL34_NOTOC)<<16,
+		SW64  | uint32(elf.R_SW64_REFQUAD)<<16,
 		S390X | uint32(elf.R_390_GLOB_DAT)<<16,
 		S390X | uint32(elf.R_390_RELATIVE)<<16,
 		S390X | uint32(elf.R_390_GOTOFF)<<16,
diff --git a/src/cmd/link/internal/sw64/asm.go b/src/cmd/link/internal/sw64/asm.go
new file mode 100644
index 00000000..6cc51347
--- /dev/null
+++ b/src/cmd/link/internal/sw64/asm.go
@@ -0,0 +1,712 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package sw64
+
+import (
+	"cmd/internal/objabi"
+	"cmd/link/internal/ld"
+	"cmd/link/internal/loader"
+	"cmd/link/internal/sym"
+	"debug/elf"
+	"log"
+)
+
+var pltHeaderSize int64
+var internalLinkingCgo bool = false
+
+func gentext(ctxt *ld.Link, ldr *loader.Loader) {
+	initfunc, addmoduledata := ld.PrepareAddmoduledata(ctxt)
+	if initfunc == nil {
+		return
+	}
+
+	o := func(op uint32) {
+		initfunc.AddUint32(ctxt.Arch, op)
+	}
+
+	// 0000000000000000 <local.dso_init>:
+	// 0: 00 00 bb ff ldih ldih$r29,0($r27)
+	//  0: R_SW_64_GPDISP .text+0x4
+	// 4: 00 00 bd fb ldi $r29,0($r29)
+	o(0xffbb0000)
+	rel0, _ := initfunc.AddRel(objabi.R_SW64_GPDISP)
+	rel0.SetOff(0)
+	rel0.SetSiz(4)
+	rel0.SetAdd(4)
+	//TODO: how to find a new way to find pc symbol?
+	rel0.SetSym(ldr.LookupOrCreateSym("go:link.addmoduledata", 0))
+	o(0xfbbd0000)
+
+	// 8: 00 00 1d fc ldih  r0, 0(r29) <runtime.firstmoduledata>
+	//  0: R_SW_64_GPRELHI local.moduledata
+	// c: 00 00 00 f8 ldi r0, 0(r0)
+	//  4: R_SW_64_GPRELLO  local.moduledata
+	o(0xfc1d0000)
+	rel, _ := initfunc.AddRel(objabi.R_SW64_GPRELHIGH)
+	rel.SetOff(8)
+	rel.SetSiz(4)
+	rel.SetSym(ctxt.Moduledata)
+
+	o(0xf8000000)
+	rel1, _ := initfunc.AddRel(objabi.R_SW64_GPRELLOW)
+	rel1.SetOff(12)
+	rel1.SetSiz(4)
+	rel1.SetSym(ctxt.Moduledata)
+
+	// 10: 00 00 7d ff ldih r27, 0(r29) <runtime.addmoduledata>
+	//  8: R_SW_64_GPRELHI runtime.addmoduledata
+	// 14: 00 00 7b fb ldi r27, 0(r27) <runtime.addmoduledata>
+	//  12: R_SW_64_GPRELLO  runtime.addmoduledata
+	// 18: 00 00 fb 0f  jmp (r31),(r27),1
+	o(0xff7d0000)
+	rel2, _ := initfunc.AddRel(objabi.R_SW64_GPRELHIGH)
+	rel2.SetOff(16)
+	rel2.SetSiz(4)
+	rel2.SetSym(addmoduledata)
+	o(0xfb7b0000)
+	rel3, _ := initfunc.AddRel(objabi.R_SW64_GPRELLOW)
+	rel3.SetOff(20)
+	rel3.SetSiz(4)
+	rel3.SetSym(addmoduledata)
+	o(0x0ffb0000)
+
+	// filled nop
+	o(0x43ff075f)
+	o(0x43ff075f)
+	o(0x1bff0080) //unreachable
+}
+
+func adddynrel(target *ld.Target, ldr *loader.Loader, syms *ld.ArchSyms, s loader.Sym, r loader.Reloc, rIdx int) bool {
+	//TODO
+	targ := r.Sym()
+	var targType sym.SymKind
+	if targ != 0 {
+		targType = ldr.SymType(targ)
+	}
+
+	const pcrel = 1
+	switch r.Type() {
+	default:
+		if r.Type() >= objabi.ElfRelocOffset {
+			ldr.Errorf(s, "unexpected relocation type %d (%s)", r.Type(), sym.RelocName(target.Arch, r.Type()))
+			return false
+		}
+
+	case objabi.ElfRelocOffset + objabi.RelocType(elf.R_SW64_GPDISP):
+		if targType == sym.SDYNIMPORT {
+			ldr.Errorf(s, "unexpected relocation for dynamic symbol %s", ldr.SymName(targ))
+		}
+		su := ldr.MakeSymbolUpdater(s)
+		su.SetRelocType(rIdx, objabi.R_SW64_GPDISP)
+		su.SetRelocAdd(rIdx, r.Add()+4)
+		return true
+
+	// Handle relocations found in ELF object files.
+	case objabi.ElfRelocOffset + objabi.RelocType(elf.R_SW64_SREL16):
+		if targType == sym.SDYNIMPORT {
+			ldr.Errorf(s, "unexpected R_SW64_SREL16 relocation for dynamic symbol %s", ldr.SymName(targ))
+		}
+		su := ldr.MakeSymbolUpdater(s)
+		su.SetRelocType(rIdx, objabi.R_PCREL)
+		su.SetRelocAdd(rIdx, r.Add()+2)
+		return true
+
+	case objabi.ElfRelocOffset + objabi.RelocType(elf.R_SW64_SREL32):
+		if targType == sym.SDYNIMPORT {
+			ldr.Errorf(s, "unexpected R_SW64_SREL16 relocation for dynamic symbol %s", ldr.SymName(targ))
+		}
+		su := ldr.MakeSymbolUpdater(s)
+		su.SetRelocType(rIdx, objabi.R_PCREL)
+		su.SetRelocAdd(rIdx, r.Add()+4)
+		return true
+
+	case objabi.ElfRelocOffset + objabi.RelocType(elf.R_SW64_SREL64):
+		if targType == sym.SDYNIMPORT {
+			ldr.Errorf(s, "unexpected R_SW64_SREL64 relocation for dynamic symbol %s", ldr.SymName(targ))
+		}
+		su := ldr.MakeSymbolUpdater(s)
+		su.SetRelocType(rIdx, objabi.R_PCREL)
+		su.SetRelocAdd(rIdx, r.Add()+8)
+		return true
+
+	case objabi.ElfRelocOffset + objabi.RelocType(elf.R_SW64_BRADDR):
+		// TODO: do we need do something about it?
+		su := ldr.MakeSymbolUpdater(s)
+		su.SetRelocType(rIdx, objabi.R_SW64_BRADDR)
+		return true
+
+	case objabi.ElfRelocOffset + objabi.RelocType(elf.R_SW64_LITERAL_GOT):
+		// TODO:as literal_got doesn't achieve completily we just ignore it
+		return true
+
+	case objabi.ElfRelocOffset + objabi.RelocType(elf.R_SW64_LITUSE),
+		objabi.ElfRelocOffset + objabi.RelocType(elf.R_SW64_HINT):
+		// TODO:this is not necessary for reloc ignore it
+		return true
+
+	case objabi.ElfRelocOffset + objabi.RelocType(elf.R_SW64_LITERAL):
+		if targType == sym.SDYNIMPORT {
+			// have symbol
+			// literal need a plt slot in dynmic link
+			addpltsym(target, ldr, syms, targ)
+		}
+		su := ldr.MakeSymbolUpdater(s)
+		su.SetRelocType(rIdx, objabi.R_SW64_LITERAL)
+		// if LITERAL contant a reg call,
+		// it is already created a plt entry in .got,
+		// so we change target to it.
+		sv := ldr.SymGot(targ)
+		splt := ldr.SymPlt(targ)
+		if sv != -1 && splt != -1 {
+			su.SetRelocSym(rIdx, syms.GOT)
+			su.SetRelocAdd(rIdx, r.Add()+int64(ldr.SymGot(targ)))
+			return true
+		}
+		// fall back to using GOT
+		ld.AddGotSym(target, ldr, syms, targ, uint32(elf.R_SW64_GLOB_DAT))
+		su.SetRelocSym(rIdx, syms.GOT)
+		su.SetRelocAdd(rIdx, r.Add()+int64(ldr.SymGot(targ))+8)
+		return true
+
+	case objabi.ElfRelocOffset + objabi.RelocType(elf.R_SW64_GPRELHIGH),
+		objabi.ElfRelocOffset + objabi.RelocType(elf.R_SW64_GPRELLOW):
+		if targType == sym.SDYNIMPORT {
+			ldr.Errorf(s, "unexpected relocation for dynamic symbol %s", ldr.SymName(targ))
+		}
+		if targType == 0 || targType == sym.SXREF {
+			ldr.Errorf(s, "unknown symbol %s", ldr.SymName(targ))
+		}
+		var rel objabi.RelocType
+		if r.Type() == objabi.ElfRelocOffset+objabi.RelocType(elf.R_SW64_GPRELHIGH) {
+			rel = objabi.R_SW64_GPRELHIGH
+		} else {
+			rel = objabi.R_SW64_GPRELLOW
+		}
+		su := ldr.MakeSymbolUpdater(s)
+		su.SetRelocType(rIdx, rel)
+		return true
+
+	case objabi.ElfRelocOffset + objabi.RelocType(elf.R_SW64_REFLONG),
+		objabi.ElfRelocOffset + objabi.RelocType(elf.R_SW64_REFQUAD):
+		if targType == sym.SDYNIMPORT {
+			ldr.Errorf(s, "unexpected R_SW64_*ABS* relocation for dynamic symbol %s", ldr.SymName(targ))
+		}
+		su := ldr.MakeSymbolUpdater(s)
+		su.SetRelocType(rIdx, objabi.R_ADDR)
+		if target.IsPIE() && target.IsInternal() {
+			// For internal linking PIE, this R_ADDR relocation cannot
+			// be resolved statically. We need to generate a dynamic
+			// relocation. Let the code below handle it.
+			break
+		}
+		return true
+	}
+
+	// Reread the reloc to incorporate any changes in type above.
+	relocs := ldr.Relocs(s)
+	r = relocs.At(rIdx)
+
+	switch r.Type() {
+	case objabi.R_CALL,
+		objabi.R_PCREL:
+		if targType != sym.SDYNIMPORT {
+			// nothing to do, the relocation will be laid out in reloc
+			return true
+		}
+		if target.IsExternal() {
+			// External linker will do this relocation.
+			return true
+		}
+		// Internal linking.
+		if r.Add() != 0 {
+			ldr.Errorf(s, "PLT call with non-zero addend (%v)", r.Add())
+		}
+		// Build a PLT entry and change the relocation target to that entry.
+		addpltsym(target, ldr, syms, targ)
+		su := ldr.MakeSymbolUpdater(s)
+		su.SetRelocSym(rIdx, syms.PLT)
+		su.SetRelocAdd(rIdx, int64(ldr.SymPlt(targ)))
+		return true
+
+	case objabi.R_ADDR:
+		if ldr.SymType(s) == sym.STEXT {
+			// The code is asking for the address of an external
+			// function. We provide it with the address of the
+			// correspondent GOT symbol.
+			ld.AddGotSym(target, ldr, syms, targ, uint32(elf.R_SW64_GLOB_DAT))
+			su := ldr.MakeSymbolUpdater(s)
+			su.SetRelocSym(rIdx, syms.GOT)
+			su.SetRelocAdd(rIdx, r.Add()+int64(ldr.SymGot(targ)))
+			return true
+		}
+
+		// Process dynamic relocations for the data sections.
+		if target.IsPIE() && target.IsInternal() {
+			// When internally linking, generate dynamic relocations
+			// for all typical R_ADDR relocations. The exception
+			// are those R_ADDR that are created as part of generating
+			// the dynamic relocations and must be resolved statically.
+			//
+			// There are three phases relevant to understanding this:
+			//
+			//  dodata()  // we are here
+			//  address() // symbol address assignment
+			//  reloc()   // resolution of static R_ADDR relocs
+			//
+			// At this point symbol addresses have not been
+			// assigned yet (as the final size of the .rela section
+			// will affect the addresses), and so we cannot write
+			// the Elf64_Rela.r_offset now. Instead we delay it
+			// until after the 'address' phase of the linker is
+			// complete. We do this via Addaddrplus, which creates
+			// a new R_ADDR relocation which will be resolved in
+			// the 'reloc' phase.
+			//
+			// These synthetic static R_ADDR relocs must be skipped
+			// now, or else we will be caught in an infinite loop
+			// of generating synthetic relocs for our synthetic
+			// relocs.
+			//
+			// Furthermore, the rela sections contain dynamic
+			// relocations with R_ADDR relocations on
+			// Elf64_Rela.r_offset. This field should contain the
+			// symbol offset as determined by reloc(), not the
+			// final dynamically linked address as a dynamic
+			// relocation would provide.
+			switch ldr.SymName(s) {
+			case ".dynsym", ".rela", ".rela.plt", ".got.plt", ".dynamic":
+				return false
+			}
+		} else {
+			// Either internally linking a static executable,
+			// in which case we can resolve these relocations
+			// statically in the 'reloc' phase, or externally
+			// linking, in which case the relocation will be
+			// prepared in the 'reloc' phase and passed to the
+			// external linker in the 'asmb' phase.
+			if ldr.SymType(s) != sym.SDATA && ldr.SymType(s) != sym.SRODATA {
+				break
+			}
+		}
+
+		// Generate R_SW64_RELATIVE relocations for best
+		// efficiency in the dynamic linker.
+		//
+		// As noted above, symbol addresses have not been
+		// assigned yet, so we can't generate the final reloc
+		// entry yet. We ultimately want:
+		//
+		// r_offset = s + r.Off
+		// r_info = R_SW64_RELATIVE
+		// r_addend = targ + r.Add
+		//
+		// The dynamic linker will set *offset = base address +
+		// addend.
+		//
+		// AddAddrPlus is used for r_offset and r_addend to
+		// generate new R_ADDR relocations that will update
+		// these fields in the 'reloc' phase.
+		rela := ldr.MakeSymbolUpdater(syms.Rela)
+		rela.AddAddrPlus(target.Arch, s, int64(r.Off()))
+		if r.Siz() == 8 {
+			rela.AddUint64(target.Arch, elf.R_INFO(0, uint32(elf.R_SW64_RELATIVE)))
+		} else {
+			ldr.Errorf(s, "unexpected relocation for dynamic symbol %s", ldr.SymName(targ))
+		}
+		rela.AddAddrPlus(target.Arch, targ, int64(r.Add()))
+		// Not mark r done here. So we still apply it statically,
+		// so in the file content we'll also have the right offset
+		// to the relocation target. So it can be examined statically
+		// (e.g. go version).
+		return true
+	}
+
+	return false
+}
+
+func elfsetupplt(ctxt *ld.Link, ldr *loader.Loader, plt, gotplt *loader.SymbolBuilder, dynamic loader.Sym) {
+	internalLinkingCgo = true
+	if plt.Size() == 0 {
+		// TODO: this is a little different with gnu pltHeader
+
+		// rel offset
+		// subl  r27,r28,r25
+		plt.AddUint32(ctxt.Arch, 0x437c0139)
+
+		// set .got to r28
+		// ldi r28, 17(r28)
+		plt.AddUint32(ctxt.Arch, 0xfb9d8001)
+
+		// s4subl r25,r25,r25
+		plt.AddUint32(ctxt.Arch, 0x43390179)
+
+		// ldi r28, 32767(r28)
+		plt.AddUint32(ctxt.Arch, 0xfb9cffef)
+
+		// load resolver to jump target
+		// ldl r27,0(r28)
+		plt.AddUint32(ctxt.Arch, 0x8f7c0000)
+
+		// addl r25,r25,r25
+		plt.AddUint32(ctxt.Arch, 0x43390119)
+
+		// load map info to reg r28
+		// ldl r28,8(r28)
+		plt.AddUint32(ctxt.Arch, 0x8f9c0008)
+		// jmp $r31,($r27),1f27a0
+		plt.AddUint32(ctxt.Arch, 0x0ffb0000)
+
+		// br r28, .plt
+		plt.AddUint32(ctxt.Arch, 0x139ffff7)
+
+		// check gotplt.size == 0
+		if gotplt.Size() != 0 {
+			ctxt.Errorf(gotplt.Sym(), "got.plt is not empty at the very beginning")
+		}
+		pltHeaderSize = plt.Size()
+
+		// will be fill in ld.so
+		gotplt.AddUint64(ctxt.Arch, 0)
+		gotplt.AddUint64(ctxt.Arch, 0)
+	}
+	return
+}
+
+func elfreloc1(ctxt *ld.Link, out *ld.OutBuf, ldr *loader.Loader, s loader.Sym, r loader.ExtReloc, ri int, sectoff int64) bool {
+	out.Write64(uint64(sectoff))
+
+	elfsym := ld.ElfSymForReloc(ctxt, r.Xsym)
+	switch r.Type {
+	case objabi.R_SW64_HINT:
+		out.Write64(uint64(elf.R_SW64_HINT) | uint64(elfsym)<<32)
+	case objabi.R_SW64_GPDISP:
+		out.Write64(uint64(elf.R_SW64_GPDISP) | uint64(elfsym)<<32)
+	case objabi.R_SW64_BRADDR:
+		out.Write64(uint64(elf.R_SW64_BRADDR) | uint64(elfsym)<<32)
+	case objabi.R_SW64_GPRELHIGH:
+		out.Write64(uint64(elf.R_SW64_GPRELHIGH) | uint64(elfsym)<<32)
+	case objabi.R_SW64_GPRELLOW:
+		out.Write64(uint64(elf.R_SW64_GPRELLOW) | uint64(elfsym)<<32)
+	case objabi.R_SW64_LITERAL_GOT:
+		out.Write64(uint64(elf.R_SW64_LITERAL_GOT) | uint64(elfsym)<<32)
+	case objabi.R_SW64_ADDR:
+		out.Write64(uint64(elf.R_SW64_ADD_PCREL_HI_13) | uint64(elfsym)<<32)
+		out.Write64(uint64(r.Xadd))
+		out.Write64(uint64(sectoff + 4))
+		out.Write64(uint64(elf.R_SW64_ADD_ABS_LO_16) | uint64(elfsym)<<32)
+	case objabi.R_SW64_LITERAL:
+		out.Write64(uint64(elf.R_SW64_LITERAL) | uint64(elfsym)<<32)
+	case objabi.R_SW64_TPRELHI:
+		out.Write64(uint64(39) | uint64(elfsym)<<32)
+	case objabi.R_SW64_TPRELLO:
+		out.Write64(uint64(40) | uint64(elfsym)<<32)
+	case objabi.R_SW64_GOTTPREL:
+		out.Write64(uint64(37) | uint64(elfsym)<<32)
+	case objabi.R_ADDR, objabi.R_DWARFSECREF:
+		switch r.Size {
+		case 4:
+			out.Write64(uint64(elf.R_SW64_REFLONG) | uint64(elfsym)<<32)
+		case 8:
+			out.Write64(uint64(elf.R_SW64_REFQUAD) | uint64(elfsym)<<32)
+		default:
+			return false
+		}
+	case objabi.R_CALL, objabi.R_CALLIND:
+		return true
+	default:
+		return false
+	}
+	out.Write64(uint64(r.Xadd))
+	return true
+}
+
+func archreloc(target *ld.Target, ldr *loader.Loader, syms *ld.ArchSyms, r loader.Reloc, s loader.Sym, val int64) (o int64, nExtReloc int, ok bool) {
+	if target.IsExternal() {
+		switch r.Type() {
+		case
+			objabi.R_CALL, objabi.R_CALLIND,
+			objabi.R_SW64_GPDISP,
+			objabi.R_SW64_BRADDR,
+			objabi.R_SW64_HINT,
+			objabi.R_SW64_GOTTPREL,
+			objabi.R_SW64_GPRELHIGH, objabi.R_SW64_GPRELLOW,
+			objabi.R_SW64_LITERAL_GOT, objabi.R_SW64_LITERAL,
+			objabi.R_SW64_TPRELHI, objabi.R_SW64_TPRELLO:
+			return val, 1, true
+		default:
+			return val, 0, false
+		}
+	}
+
+	const isOk = true
+	const noExtReloc = 0
+	rs := r.Sym()
+	switch r.Type() {
+	case objabi.R_CALL, objabi.R_CALLIND:
+		return val, noExtReloc, isOk
+	case objabi.R_SW64_GPDISP:
+		pc := ldr.SymValue(rs) + int64(r.Off())
+		base := uint32(val) & 0xffff0000
+		var hi, lo int16
+		if internalLinkingCgo {
+			hi, lo = gpdispAddrDyn(pc, ldr, syms)
+		} else {
+			hi, lo = gpdispAddr(pc)
+		}
+
+		if base != uint32(val) {
+			log.Fatalf("The R_SW64_GPDISP %v has been broken in %v.", r, s)
+		}
+		val = int64((uint32(hi) << 16) + uint32(uint16(lo)))
+		return val, noExtReloc, isOk
+	case objabi.R_SW64_ADDR:
+		//		pc := ldr.SymValue(s) + int64(r.Off())
+		//		off := ldr.SymValue(rs) + r.Add() - pc
+		t := ldr.SymAddr(rs) + r.Add() - ((ldr.SymValue(s) + int64(r.Off())) &^ 0xffff)
+		//		println("symbol addr is", ldr.SymAddr(rs), r.Add())
+		//		println("symbol value is", ldr.SymValue(rs), r.Off())
+		//		println("pc is", pc)
+		//		println("off is", off)
+		//		println(" t is", t)
+		if t >= 1<<29 || t < -1<<29 {
+			ldr.Errorf(s, "program too large, address relocation distance = %d", t)
+		}
+
+		hi, lo := splitAddr(t)
+		var o0, o1 uint32
+
+		o0 = uint32(val)
+		o1 = uint32(val >> 32)
+
+		o0 |= uint32((uint32(hi) & 0xffff) << 13)
+		o1 |= uint32(uint32(lo) & 0xffff)
+
+		// when laid out, the instruction order must always be o1, o2.
+		return int64(o1)<<32 | int64(o0), noExtReloc, true
+
+	case objabi.R_SW64_TPRELHI, objabi.R_SW64_TPRELLO:
+		hi, lo := splitSymAddr(ldr, r, 16)
+		base := uint32(val) & 0xffff0000
+		if base != uint32(val) {
+			log.Fatalf("The R_SW64_TPRELLO/HI %v has been broken in %v.", r, s)
+		}
+		if r.Type() == objabi.R_SW64_TPRELHI {
+			val = int64(base + uint32(uint16(hi)))
+		} else {
+			val = int64(base + uint32(uint16(lo)))
+		}
+		return val, noExtReloc, isOk
+
+	case objabi.R_SW64_GOTTPREL:
+		base := uint32(val) & 0xffff0000
+		v := ldr.SymAddr(rs) + int64(2*target.Arch.PtrSize) + r.Add()
+		if base != uint32(val) {
+			log.Fatalf("The R_SW64_GOTTPREL %v has been broken in %v.", r, s)
+		}
+		val := int64(base + uint32(uint16(v)))
+		return val, noExtReloc, isOk
+
+	case objabi.R_SW64_GPRELLOW, objabi.R_SW64_GPRELHIGH:
+		var hi, lo int16
+		if internalLinkingCgo {
+			hi, lo = splitGPRelAddrDyn(ldr, r, syms)
+		} else {
+			hi, lo = splitGPRelAddr(ldr, r)
+		}
+		base := uint32(val) & 0xffff0000
+		if base != uint32(val) {
+			log.Fatalf("The R_SW64_GPRELxx %v has been broken in %v.", ldr.SymName(s), r, val, base)
+		}
+		if r.Type() == objabi.R_SW64_GPRELHIGH {
+			val = int64(base + uint32(uint16(hi)))
+		} else {
+			val = int64(base + uint32(uint16(lo)))
+		}
+		return val, noExtReloc, isOk
+
+	case objabi.R_SW64_BRADDR:
+		off := (ldr.SymValue(rs)+r.Add()-(ldr.SymValue(s)+int64(r.Off())))/4 - 1
+		mask := (int64(1) << 21) - 1
+		disp := (int64(1) << 20) - 1
+		if off > disp || off < -disp {
+			log.Fatalf("BRADDR from %s to %s is too long %v\n",
+				s, r.Sym(), off)
+		}
+		off &= mask
+		val = off + val
+		return val, noExtReloc, isOk
+
+	case objabi.R_CALLSW64:
+		off := ldr.SymValue(rs) + r.Add() - (ldr.SymValue(s) + int64(r.Off()))
+		if off > (1<<27) || off < -(1<<27) {
+			log.Fatalf("CALLSW64 from %s to %s is too long %v\n",
+				s, r.Sym(), off)
+		}
+		val |= ((off >> 2) & 0x3FFFFFF)
+		return val, noExtReloc, isOk
+
+	case objabi.R_SW64_HINT:
+		off := (ldr.SymValue(rs)+r.Add()-(ldr.SymValue(s)+int64(r.Off())))/4 - 1
+		mask := (int64(1) << 16) - 1
+		if int64(int16(off)) != off {
+			return val, noExtReloc, isOk
+		}
+		off &= mask
+		val = off + val
+		return val, noExtReloc, isOk
+	case objabi.R_SW64_LITERAL_GOT, objabi.R_SW64_LITERAL:
+		base := uint32(val) & 0xffff0000
+		//TODO: As we process off set in adddynrel, we try doing this
+		off := int64(r.Add()) - 8 - 32784
+		if off > 32768 {
+			log.Fatalf("off is too big, we can't handle it")
+		}
+		hi, lo := splitAddr(off)
+		if r.Type() == objabi.R_SW64_LITERAL_GOT {
+			val = int64(base + uint32(uint16(hi)))
+		} else {
+			val = int64(base + uint32(uint16(lo)))
+		}
+		return val, noExtReloc, isOk
+	}
+	return val, 0, false
+}
+
+func splitAddr(addr int64) (hi int16, lo int16) {
+	hi = int16(addr >> 16)
+	lo = int16(addr & 0xffff)
+	if lo < 0 {
+		hi = hi + 1
+		lo = int16(addr - int64(hi)<<16)
+	}
+	return
+}
+
+func gpAddr() int64 {
+	return 0x7fffffff
+}
+
+func gpDynmic(ldr *loader.Loader, syms *ld.ArchSyms) int64 {
+	return ldr.SymValue(syms.GOT) + 32784
+}
+
+func gpdispAddrDyn(pc int64, ldr *loader.Loader, syms *ld.ArchSyms) (hi int16, lo int16) {
+	addr := gpDynmic(ldr, syms) - pc
+	hi, lo = splitAddr(addr)
+	if int64(hi)<<16+int64(lo) != addr {
+		log.Fatalf("PC 0x%x is out of range when build GP displacement\n", pc)
+	}
+	return
+}
+
+func gpdispAddr(pc int64) (hi int16, lo int16) {
+	addr := gpAddr() - pc
+	hi, lo = splitAddr(addr)
+	if int64(hi)<<16+int64(lo) != addr {
+		log.Fatalf("PC 0x%x is out of range when build GP displacement\n", pc)
+	}
+	return
+}
+
+func splitGPRelAddr(ldr *loader.Loader, r loader.Reloc) (hi int16, lo int16) {
+	rs := r.Sym()
+	addr := ldr.SymValue(rs) + r.Add() - gpAddr()
+	hi, lo = splitAddr(addr)
+	if int64(hi)<<16+int64(lo) != addr {
+		log.Fatalf("Symbol %q is out of range when split GP relative address\n", r.Sym())
+	}
+	return
+}
+
+func splitGPRelAddrDyn(ldr *loader.Loader, r loader.Reloc, syms *ld.ArchSyms) (hi int16, lo int16) {
+	rs := r.Sym()
+	addr := ldr.SymValue(rs) + r.Add() - gpDynmic(ldr, syms)
+	hi, lo = splitAddr(addr)
+	if int64(hi)<<16+int64(lo) != addr {
+		log.Fatalf("Symbol %q is out of range when split GP relative address\n", r.Sym())
+	}
+	return
+}
+
+// splitSymaddr split address of s to two 16 signed bit
+func splitSymAddr(ldr *loader.Loader, r loader.Reloc, off int64) (hi int16, lo int16) {
+	rs := r.Sym()
+	addr := ldr.SymValue(rs) + r.Add() + off
+	hi, lo = splitAddr(addr)
+	if int64(hi)<<16+int64(lo) != addr {
+		log.Fatalf("Symbol %q is out of range when split symbol address\n",
+			r.Sym())
+	}
+	return
+}
+
+func archrelocvariant(*ld.Target, *loader.Loader, loader.Reloc, sym.RelocVariant, loader.Sym, int64, []byte) int64 {
+	log.Fatalf("unexpected relocation variant")
+	return -1
+}
+
+func extreloc(target *ld.Target, ldr *loader.Loader, r loader.Reloc, s loader.Sym) (loader.ExtReloc, bool) {
+	switch r.Type() {
+	case objabi.R_CALL, objabi.R_CALLIND,
+		objabi.R_SW64_GPDISP,
+		objabi.R_SW64_BRADDR,
+		objabi.R_SW64_HINT,
+		objabi.R_SW64_GOTTPREL,
+		objabi.R_SW64_LITERAL_GOT, objabi.R_SW64_LITERAL,
+		objabi.R_SW64_TPRELHI, objabi.R_SW64_TPRELLO:
+		return ld.ExtrelocViaOuterSym(ldr, r, s), true
+	case objabi.R_SW64_GPRELHIGH, objabi.R_SW64_GPRELLOW:
+		return ld.ExtrelocViaOuterSym(ldr, r, s), true
+	}
+	return loader.ExtReloc{}, false
+}
+
+func splitPCRelAddr(ldr *loader.Loader, r loader.Reloc) (hi int16, lo int16) {
+	rs := r.Sym()
+	addr := ldr.SymValue(rs) + r.Add() - gpAddr()
+	hi, lo = splitAddr(addr)
+	if int64(hi)<<16+int64(lo) != addr {
+		log.Fatalf("Symbol %q is out of range when split GP relative address\n", r.Sym())
+	}
+	return
+}
+
+func addpltsym(target *ld.Target, ldr *loader.Loader, syms *ld.ArchSyms, s loader.Sym) {
+	if ldr.SymPlt(s) >= 0 {
+		return
+	}
+
+	ld.Adddynsym(ldr, target, syms, s)
+
+	if target.IsElf() {
+		plt := ldr.MakeSymbolUpdater(syms.PLT)
+		got := ldr.MakeSymbolUpdater(syms.GOT)
+		rela := ldr.MakeSymbolUpdater(syms.RelaPLT)
+		if plt.Size() == 0 {
+			panic("plt is not set up")
+		}
+
+		// br $R28, pltHeaderEnd
+		disp := plt.Size() - pltHeaderSize + 8
+		br := 0x13e00000 | (-int32(disp/4) & 0x1fffff)
+		plt.AddUint32(target.Arch, uint32(br))
+
+		// got
+		// create got entry for extern jump
+		got.AddAddrPlus(target.Arch, plt.Sym(), plt.Size()-4)
+		ldr.SetGot(s, int32(got.Size()))
+
+		// rela
+		rela.AddAddrPlus(target.Arch, got.Sym(), got.Size()-8)
+		sDynid := ldr.SymDynid(s)
+
+		rela.AddUint64(target.Arch, elf.R_INFO(uint32(sDynid), uint32(elf.R_SW64_JMP_SLOT)))
+		rela.AddUint64(target.Arch, 0)
+
+		ldr.SetPlt(s, int32(plt.Size())-16)
+	} else {
+		ldr.Errorf(s, "addpltsym: unsupported binary format")
+	}
+}
diff --git a/src/cmd/link/internal/sw64/l.go b/src/cmd/link/internal/sw64/l.go
new file mode 100644
index 00000000..e43fbe5e
--- /dev/null
+++ b/src/cmd/link/internal/sw64/l.go
@@ -0,0 +1,17 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package sw64
+
+const (
+	maxAlign  = 32 // max data alignment
+	minAlign  = 1  // min data alignment
+	funcAlign = 16
+)
+
+/* Used by ../internal/ld/dwarf.go */
+const (
+	dwarfRegSP = 30
+	dwarfRegLR = 26
+)
diff --git a/src/cmd/link/internal/sw64/obj.go b/src/cmd/link/internal/sw64/obj.go
new file mode 100644
index 00000000..dea8bcb4
--- /dev/null
+++ b/src/cmd/link/internal/sw64/obj.go
@@ -0,0 +1,62 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package sw64
+
+import (
+	"cmd/internal/objabi"
+	"cmd/internal/sys"
+	"cmd/link/internal/ld"
+)
+
+func Init() (*sys.Arch, ld.Arch) {
+	arch := sys.ArchSW64
+
+	theArch := ld.Arch{
+		Funcalign:  funcAlign,
+		Maxalign:   maxAlign,
+		Minalign:   minAlign,
+		Dwarfregsp: dwarfRegSP,
+		Dwarfreglr: dwarfRegLR,
+
+		Archinit:         archinit,
+		Adddynrel:        adddynrel,
+		Archreloc:        archreloc,
+		Archrelocvariant: archrelocvariant,
+		Extreloc:         extreloc,
+		Gentext:          gentext,
+
+		ELF: ld.ELFArch{
+			Linuxdynld:	"/lib/ld-linux.so.2",
+			LinuxdynldMusl:	"/lib/ld-musl-sw_64.so.1",
+			Freebsddynld:	"XXX",
+			Openbsddynld:	"XXX",
+			Netbsddynld:	"XXX",
+			Solarisdynld:	"XXX",
+
+			Reloc1:	   elfreloc1,
+			RelocSize: 24,
+			SetupPLT:  elfsetupplt,
+		},
+	}
+
+	return arch, theArch
+}
+
+func archinit(ctxt *ld.Link) {
+	switch ctxt.HeadType {
+	default:
+		ld.Exitf("unknown -H option: %v", ctxt.HeadType)
+
+	case objabi.Hlinux: /* sw64 elf */
+		ld.Elfinit(ctxt)
+		ld.HEADR = ld.ELFRESERVE
+		if *ld.FlagRound == -1 {
+			*ld.FlagRound = 0x10000
+		}
+		if *ld.FlagTextAddr == -1 {
+			*ld.FlagTextAddr = ld.Rnd(0x10000, *ld.FlagRound) + int64(ld.HEADR)
+		}
+	}
+}
diff --git a/src/cmd/link/internal/sym/reloc.go b/src/cmd/link/internal/sym/reloc.go
index e614caa5..08d7903f 100644
--- a/src/cmd/link/internal/sym/reloc.go
+++ b/src/cmd/link/internal/sym/reloc.go
@@ -63,6 +63,8 @@ func RelocName(arch *sys.Arch, r objabi.RelocType) string {
 			return elf.R_390(nr).String()
 		case sys.RISCV64:
 			return elf.R_RISCV(nr).String()
+		case sys.SW64:
+                        return elf.R_SW64(nr).String()
 		default:
 			panic("unreachable")
 		}
diff --git a/src/cmd/link/main.go b/src/cmd/link/main.go
index 16e5a011..ea4259c4 100644
--- a/src/cmd/link/main.go
+++ b/src/cmd/link/main.go
@@ -16,6 +16,7 @@ import (
 	"cmd/link/internal/ppc64"
 	"cmd/link/internal/riscv64"
 	"cmd/link/internal/s390x"
+	"cmd/link/internal/sw64"
 	"cmd/link/internal/wasm"
 	"cmd/link/internal/x86"
 	"fmt"
@@ -68,6 +69,8 @@ func main() {
 		arch, theArch = s390x.Init()
 	case "wasm":
 		arch, theArch = wasm.Init()
+	case "sw64":
+                arch, theArch = sw64.Init()
 	}
 	ld.Main(arch, theArch)
 }
diff --git a/src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/gnu.go b/src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/gnu.go
new file mode 100644
index 00000000..618a7422
--- /dev/null
+++ b/src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/gnu.go
@@ -0,0 +1,35 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package sw64asm
+
+import (
+	"strings"
+)
+
+// GNUSyntax returns the GNU assembler syntax for the instruction, as defined by GNU binutils.
+// This form typically matches the syntax defined in the ARM Reference Manual.
+func GNUSyntax(inst Inst) string {
+	/*switch inst.Op {
+	case RET:
+		if r, ok := inst.Args[0].(Reg); ok && r == X30 {
+			return "ret"
+		}
+	case B:
+		if _, ok := inst.Args[0].(Cond); ok {
+			return strings.ToLower("b." + inst.Args[0].String() + " " + inst.Args[1].String())
+		}
+	case SYSL:
+		result := strings.ToLower(inst.String())
+		return strings.Replace(result, "c", "C", -1)
+	case DCPS1, DCPS2, DCPS3, CLREX:
+		return strings.ToLower(strings.TrimSpace(inst.String()))
+	case ISB:
+		if strings.Contains(inst.String(), "SY") {
+			result := strings.TrimSuffix(inst.String(), " SY")
+			return strings.ToLower(result)
+		}
+	}*/
+	return strings.ToLower("sw64 is not implement")
+}
diff --git a/src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/main.go b/src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/main.go
new file mode 100644
index 00000000..2cf3b5ff
--- /dev/null
+++ b/src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/main.go
@@ -0,0 +1,101 @@
+package sw64asm
+
+import (
+	"encoding/binary"
+	"fmt"
+	"io"
+)
+
+// An Inst is a single instruction.
+type Inst struct {
+	Op   OP       // Opcode mnemonic
+	Enc  uint32   // Raw encoding bits.
+	Args []string // Instruction arguments, in native SW64 order.
+}
+
+func immName(v uint32) string {
+	return fmt.Sprintf("$0x%x", v)
+}
+
+func memory(rno uint32, offset uint32) string {
+	return fmt.Sprintf("$%d(%s)", offset, iRegName(rno))
+}
+
+func targetName(pc uint64, name string, base int64) string {
+	if base == 0 {
+		return fmt.Sprintf("%x <%s>", pc, name)
+	} else {
+		return fmt.Sprintf("%x <%s+0x%x>", pc, name, base)
+	}
+}
+
+// Decode decodes the 4 bytes in src as a single instruction.
+func Decode(src []byte) (inst Inst, err error) {
+	if len(src) < 4 {
+		return Inst{}, nil
+	}
+	v := binary.LittleEndian.Uint32(src)
+	i := Inst{
+		Op:   ParseOPtable(v),
+		Enc:  v,
+		Args: make([]string, 0, 4),
+	}
+	return i, nil
+}
+
+func GoSyntax(i Inst, pc uint64, symname func(uint64) (string, uint64), text io.ReaderAt) string {
+	switch i.Op.Class {
+	case OPC_SYSCALL:
+		i.AddArg(immName(fetchBit(i.Enc, 0, 25)))
+	case OPC_CONTROL:
+		i.AddArg(i.RegNameAt(0)(fetchRa(i.Enc)))
+		pc_t := uint64(fetchBit(i.Enc, 0, 21)) + 4 + pc
+		name, base := symname(pc_t)
+		i.AddArg(targetName(pc_t, name, int64(pc_t-base)))
+	case OPC_MEMORY:
+		i.AddArg(i.RegNameAt(0)(fetchRa(i.Enc)))
+		i.AddArg(memory(fetchRb(i.Enc), fetchDisp(i.Enc)))
+	case OPC_FUNC_MEMORY:
+		i.AddArg(i.RegNameAt(0)(fetchRa(i.Enc)))
+		i.AddArg(memory(fetchRb(i.Enc), fetchDisp(i.Enc)))
+	case OPC_MISI_MEMORY:
+		i.AddArg(i.RegNameAt(0)(fetchRa(i.Enc)))
+	case OPC_ARITHMETIC:
+		i.AddArg(i.RegNameAt(0)(fetchRa(i.Enc)))
+		i.AddArg(i.RegNameAt(1)(fetchRb(i.Enc)))
+		i.AddArg(i.RegNameAt(2)(fetchBit(i.Enc, 0, 5)))
+	case OPC_ARITHMETIC_I:
+		i.AddArg(i.RegNameAt(0)(fetchRa(i.Enc)))
+		i.AddArg(immName(fetchBit(i.Enc, 13, 8)))
+		i.AddArg(i.RegNameAt(0)(fetchBit(i.Enc, 0, 5)))
+	case OPC_COMPLEX_ARITHMETIC:
+		i.AddArg(i.RegNameAt(0)(fetchRa(i.Enc)))
+		i.AddArg(i.RegNameAt(1)(fetchRb(i.Enc)))
+		i.AddArg(i.RegNameAt(2)(fetchBit(i.Enc, 5, 5)))
+		i.AddArg(i.RegNameAt(3)(fetchBit(i.Enc, 0, 5)))
+	case OPC_COMPLEX_ARITHMETIC_I:
+		i.AddArg(i.RegNameAt(0)(fetchRa(i.Enc)))
+		i.AddArg(immName(fetchBit(i.Enc, 13, 8)))
+		i.AddArg(i.RegNameAt(2)(fetchBit(i.Enc, 5, 5)))
+		i.AddArg(i.RegNameAt(3)(fetchBit(i.Enc, 0, 5)))
+	}
+
+	switch len(i.Args) {
+	case 0:
+		return fmt.Sprintf("%7s", i.Op.Name)
+	case 1:
+		return fmt.Sprintf("%7s  %3s", i.Op.Name, i.Args[0])
+	case 2:
+		return fmt.Sprintf("%7s  %3s, %v", i.Op.Name, i.Args[0], i.Args[1])
+	case 3:
+		return fmt.Sprintf("%7s  %3s, %v, %v", i.Op.Name, i.Args[0], i.Args[1], i.Args[2])
+	default:
+		return fmt.Sprintf("%7s  %3s, %v, %v", i.Op.Name, "?", "?", "?")
+	}
+}
+func (i *Inst) AddArg(arg string) {
+	if arg == "" {
+		return
+	}
+	i.Args = append(i.Args, arg)
+}
diff --git a/src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/op2str.go b/src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/op2str.go
new file mode 100644
index 00000000..8f97b44d
--- /dev/null
+++ b/src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/op2str.go
@@ -0,0 +1,377 @@
+package sw64asm
+
+import (
+	"fmt"
+	"strings"
+)
+
+var classTabs = map[int]int{
+	0x00: OPC_SYSCALL,
+	0x01: OPC_MEMORY,
+	0x02: OPC_MEMORY,
+	0x03: OPC_MEMORY,
+	0x04: OPC_CONTROL,
+	0x05: OPC_CONTROL,
+	0x06: OPC_MISI_MEMORY,
+	0x08: OPC_FUNC_MEMORY,
+	0x10: OPC_ARITHMETIC,
+	0x11: OPC_ARITHMETIC,
+	0x12: OPC_ARITHMETIC_I,
+	0x13: OPC_ARITHMETIC_I,
+	0x20: OPC_MEMORY,
+	0x21: OPC_MEMORY,
+	0x22: OPC_MEMORY,
+	0x23: OPC_MEMORY,
+	0x24: OPC_MEMORY,
+	0x25: OPC_MEMORY,
+	0x26: OPC_MEMORY,
+	0x27: OPC_MEMORY,
+	0x28: OPC_MEMORY,
+	0x29: OPC_MEMORY,
+	0x2A: OPC_MEMORY,
+	0x2B: OPC_MEMORY,
+	0x2C: OPC_MEMORY,
+	0x2D: OPC_MEMORY,
+	0x2E: OPC_MEMORY,
+	0x2F: OPC_MEMORY,
+	0x30: OPC_CONTROL,
+	0x31: OPC_CONTROL,
+	0x32: OPC_CONTROL,
+	0x33: OPC_CONTROL,
+	0x34: OPC_CONTROL,
+	0x35: OPC_CONTROL,
+	0x36: OPC_CONTROL,
+	0x37: OPC_CONTROL,
+	0x38: OPC_CONTROL,
+	0x39: OPC_CONTROL,
+	0x3A: OPC_CONTROL,
+	0x3B: OPC_CONTROL,
+	0x3C: OPC_CONTROL,
+	0x3D: OPC_CONTROL,
+	0x3e: OPC_MEMORY,
+	0x3f: OPC_MEMORY,
+	0x18: OPC_ARITHMETIC,
+	0x19: OPC_COMPLEX_ARITHMETIC,
+}
+
+//                op      fn   name
+var nameTabs = map[int]map[int]string{
+	0x00: {0x0: "SYSCALL/B", 0x1: "SYSCALL"},
+	0x01: {0x0: "CALL"},
+	0x02: {0x0: "RET"},
+	0x03: {0x0: "JMP"},
+	0x04: {0x0: "BR"},
+	0x05: {0x0: "BSR"},
+	0x06: {
+		0x0000: "MEMB",
+		0x0001: "IMEMB",
+		0x1000: "RD_F",
+		0x1020: "WR_F",
+	},
+	0x08: {
+		0x0: "LLDW",
+		0x1: "LLDL",
+		0x8: "LSTW",
+		0x9: "LSTL",
+	},
+	0x10: {
+		0x00: "ADDW",
+		0x01: "SUBW",
+		0x02: "S4ADDW",
+		0x03: "S4SUBW",
+		0x04: "S8ADDW",
+		0x05: "S8SUBW",
+		0x08: "ADDL",
+		0x09: "SUBL",
+		0x0a: "S4ADDL",
+		0x0b: "S4SUBL",
+		0x0c: "S8ADDL",
+		0x0d: "S8SUBL",
+		0x10: "MULW",
+		0x18: "MULL",
+		0x19: "UMULH",
+		0x28: "CMPEQ",
+		0x29: "CMPLT",
+		0x2a: "CMPLE",
+		0x2b: "CMPULT",
+		0x2c: "CMPULE",
+		0x38: "AND",
+		0x39: "BIC",
+		0x3a: "BIS",
+		0x3b: "ORNOT",
+		0x3c: "XOR",
+		0x3d: "EQV",
+		0x40: "INSLB",
+		0x41: "INSLH",
+		0x42: "INSLW",
+		0x43: "INSLL",
+		0x44: "INSHB",
+		0x45: "INSHH",
+		0x46: "INSHW",
+		0x47: "INSHL",
+		0x48: "SLL",
+		0x49: "SRL",
+		0x4a: "SRA",
+		0x50: "EXTLB",
+		0x51: "EXTLH",
+		0x52: "EXTLW",
+		0x53: "EXTLL",
+		0x54: "EXTHB",
+		0x55: "EXTHH",
+		0x56: "EXTHW",
+		0x57: "EXTHL",
+		0x58: "CTPOP",
+		0x59: "CTLZ",
+		0x5a: "CTTZ",
+		0x60: "MASKLB",
+		0x61: "MASKLH",
+		0x62: "MASKLW",
+		0x63: "MASKLL",
+		0x64: "MASKHB",
+		0x65: "MASKHH",
+		0x66: "MASKHW",
+		0x67: "MASKHL",
+		0x68: "ZAP",
+		0x69: "ZAPNOT",
+		0x6a: "SEXTB",
+		0x6b: "SEXTH",
+		0x6c: "CMPGEB",
+		0x70: "FIMOVS",
+		0x78: "FIMOVD",
+	},
+	0x11: {
+		0x0: "SELEQ",
+		0x1: "SELGE",
+		0x2: "SELGT",
+		0x3: "SELLE",
+		0x4: "SELLT",
+		0x5: "SELNE",
+		0x6: "SELLBC",
+		0x7: "SELLBS",
+	},
+	0x12: {
+		0x00: "ADDW",
+		0x01: "SUBW",
+		0x02: "S4ADDW",
+		0x03: "S4SUBW",
+		0x04: "S8ADDW",
+		0x05: "S8SUBW",
+		0x08: "ADDL",
+		0x09: "SUBL",
+		0x0a: "S4ADDL",
+		0x0b: "S4SUBL",
+		0x0c: "S8ADDL",
+		0x0d: "S8SUBL",
+		0x10: "MULW",
+		0x18: "MULL",
+		0x19: "UMULH",
+		0x28: "CMPEQ",
+		0x29: "CMPLT",
+		0x2a: "CMPLE",
+		0x2b: "CMPULT",
+		0x2c: "CMPULE",
+		0x38: "AND",
+		0x39: "BIC",
+		0x3a: "BIS",
+		0x3b: "ORNOT",
+		0x3c: "XOR",
+		0x3d: "EQV",
+		0x40: "INSLB",
+		0x41: "INSLH",
+		0x42: "INSLW",
+		0x43: "INSLL",
+		0x44: "INSHB",
+		0x45: "INSHH",
+		0x46: "INSHW",
+		0x47: "INSHL",
+		0x48: "SLL",
+		0x49: "SRL",
+		0x4a: "SRA",
+		0x50: "EXTLB",
+		0x51: "EXTLH",
+		0x52: "EXTLW",
+		0x53: "EXTLL",
+		0x54: "EXTHB",
+		0x55: "EXTHH",
+		0x56: "EXTHW",
+		0x57: "EXTHL",
+		0x60: "MASKLB",
+		0x61: "MASKLH",
+		0x62: "MASKLW",
+		0x63: "MASKLL",
+		0x64: "MASKHB",
+		0x65: "MASKHH",
+		0x66: "MASKHW",
+		0x67: "MASKHL",
+		0x68: "ZAP",
+		0x69: "ZAPNOT",
+		0x6a: "SEXTB",
+		0x6b: "SEXTH",
+		0x6c: "CMPGEB",
+	},
+	0x13: {
+		0x0: "SELEQ",
+		0x1: "SELGE",
+		0x2: "SELGT",
+		0x3: "SELLE",
+		0x4: "SELLT",
+		0x5: "SELNE",
+		0x6: "SELLBC",
+		0x7: "SELLBS",
+	},
+	0x20: {0: "LDBU"},
+	0x21: {0: "LDHU"},
+	0x22: {0: "LDW"},
+	0x23: {0: "LDL"},
+	0x24: {0: "LDL_U"},
+	0x25: {0: "PRI_LD"},
+	0x26: {0: "FLDS"},
+	0x27: {0: "FLDD"},
+	0x28: {0: "STB"},
+	0x29: {0: "STH"},
+	0x2A: {0: "STW"},
+	0x2B: {0: "STL"},
+	0x2C: {0: "STL_U"},
+	0x2D: {0: "PRI_ST"},
+	0x2E: {0: "FSTS"},
+	0x2F: {0: "FSTD"},
+	0x30: {0: "BEQ"},
+	0x31: {0: "BNE"},
+	0x32: {0: "BLT"},
+	0x33: {0: "BLE"},
+	0x34: {0: "BGT"},
+	0x35: {0: "BGE"},
+	0x36: {0: "BLBC"},
+	0x37: {0: "BLBS"},
+	0x38: {0: "FBEQ"},
+	0x39: {0: "FBNE"},
+	0x3A: {0: "FBLT"},
+	0x3B: {0: "FBLE"},
+	0x3C: {0: "FBGT"},
+	0x3D: {0: "FBGE"},
+	0x3e: {0: "LDI"},
+	0x3f: {0: "LDIH"},
+	0x18: {
+		0x00: "FADDS",
+		0x01: "FADDD",
+		0x02: "FSUBS",
+		0x03: "FSUBD",
+		0x04: "FMULS",
+		0x05: "FMULD",
+		0x06: "FDIVS",
+		0x07: "FDIVD",
+		0x08: "FSQRTS",
+		0x09: "FSQRTD",
+		0x10: "FCMPEQ",
+		0x11: "FCMPLE",
+		0x12: "FCMPLT",
+		0x13: "FCMPUN",
+		0x20: "FCVTSD",
+		0x21: "FCVTDS",
+		0x22: "FCVTDL_G",
+		0x23: "FCVTDL_P",
+		0x24: "FCVTDL_Z",
+		0x25: "FCVTDL_N",
+		0x27: "FCVTDL",
+		0x28: "FCVTWL",
+		0x29: "FCVTLW",
+		0x2D: "FCVTLS",
+		0x2F: "FCVTLD",
+		0x30: "FCPYS",
+		0x31: "FCPYSE",
+		0x32: "FCPYSN",
+		0x40: "IFMOVS",
+		0x41: "IFMOVD",
+		0x50: "RFPCR",
+		0x51: "WFPCR",
+		0x54: "SETFPEC0",
+		0x55: "SETFPEC1",
+		0x56: "SETFPEC2",
+		0x57: "SETFPEC3",
+	},
+	0x19: {
+		0x00: "FMAS",
+		0x01: "FMAD",
+		0x02: "FMSS",
+		0x03: "FMSD",
+		0x04: "FNMAS",
+		0x05: "FNMAD",
+		0x06: "FNMSS",
+		0x07: "FNMSD",
+	},
+}
+
+var __iRegName = make(map[uint32]string)
+
+func iRegName(v uint32) string {
+	if len(__iRegName) == 0 {
+		for i := uint32(0); i < 32; i++ {
+			switch i {
+			case 15:
+				__iRegName[i] = fmt.Sprintf("G")
+			case 25:
+				__iRegName[i] = fmt.Sprintf("CTXT")
+			case 26:
+				__iRegName[i] = fmt.Sprintf("RA")
+			case 28:
+				__iRegName[i] = fmt.Sprintf("TMP")
+			case 29:
+				__iRegName[i] = fmt.Sprintf("GP")
+			case 30:
+				__iRegName[i] = fmt.Sprintf("SP")
+			case 31:
+				__iRegName[i] = fmt.Sprintf("ZERO")
+			default:
+				__iRegName[i] = fmt.Sprintf("R%d", i)
+			}
+		}
+	}
+	return __iRegName[v]
+}
+
+var __fRegName = make(map[uint32]string)
+
+func fRegName(v uint32) string {
+	if len(__fRegName) == 0 {
+		for i := uint32(0); i < 32; i++ {
+			__fRegName[i] = fmt.Sprintf("F%d", i)
+		}
+	}
+	return __fRegName[v]
+}
+func nullName(_ uint32) string { return "" }
+
+func (i Inst) RegNameAt(pos int) func(uint32) string {
+	name := i.Op.Name
+
+	switch {
+	case name == "MEMB",
+		name == "IMEMB",
+		strings.HasPrefix(name, "SETFPEC"):
+		return nullName
+	case strings.HasPrefix(name, "FIMOV"):
+		switch pos {
+		case 0:
+			return fRegName
+		case 1:
+			return nullName
+		case 2:
+			return iRegName
+		}
+	case strings.HasPrefix(name, "IFMOV"):
+		switch pos {
+		case 0:
+			return iRegName
+		case 1:
+			return nullName
+		case 2:
+			return fRegName
+		}
+	default:
+		if name[0] == 'F' {
+			return fRegName
+		}
+	}
+
+	return iRegName
+}
diff --git a/src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/rawinst.go b/src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/rawinst.go
new file mode 100644
index 00000000..94a2745e
--- /dev/null
+++ b/src/cmd/vendor/golang.org/x/arch/sw64/sw64asm/rawinst.go
@@ -0,0 +1,88 @@
+package sw64asm
+
+import (
+	"fmt"
+)
+
+func ParseOPtable(raw uint32) OP {
+	op := fetchOpcode(raw)
+	class, ok := classTabs[int(op)]
+	if !ok {
+		return OP{
+			OPcode: int(op),
+			Name:   fmt.Sprintf("?0x%x", op),
+		}
+	}
+	fn := fetchFncode(raw, class)
+	name, ok := nameTabs[int(op)][int(fn)]
+	if !ok {
+		name = fmt.Sprintf("?0x%x:0x%x?", op, fn)
+	}
+	return OP{
+		OPcode:  int(op),
+		Fncode:  int(fn),
+		Name:    name,
+		Class:   class,
+		IsFloat: name[1] == 'F',
+	}
+}
+
+func fetchBit(v uint32, begin, width uint32) uint32 {
+	t := v >> begin
+	mask := (uint32(1) << width) - 1
+	return t & mask
+}
+
+func fetchOpcode(v uint32) uint32 { return fetchBit(v, 26, 6) }
+func fetchRa(v uint32) uint32     { return fetchBit(v, 21, 5) }
+func fetchRb(v uint32) uint32     { return fetchBit(v, 16, 5) }
+func fetchDisp(v uint32) uint32   { return fetchBit(v, 0, 16) }
+
+func fetchFncode(v uint32, c int) uint32 {
+	switch c {
+	case OPC_SYSCALL:
+		return fetchBit(v, 25, 1)
+	case OPC_ARITHMETIC,
+		OPC_ARITHMETIC_I:
+		return fetchBit(v, 5, 8)
+	case OPC_COMPLEX_ARITHMETIC,
+		OPC_COMPLEX_ARITHMETIC_I:
+		return fetchBit(v, 10, 6)
+	case OPC_MISI_MEMORY:
+		return fetchBit(v, 0, 16)
+	case OPC_FUNC_MEMORY:
+		return fetchBit(v, 12, 4)
+	case OPC_CONTROL,
+		OPC_MEMORY:
+		return 0
+	default:
+		panic(fmt.Sprintf("Invalid instruction for %v %v", v, c))
+	}
+}
+
+const (
+	OPC_NULL    = iota // 类别        |31  26|25 21|20 16|15       5|4   0|
+	OPC_SYSCALL        //系统调用指令, |Opcode|         Function           |
+	OPC_CONTROL        //转移控制指令, |Opcode| Ra  |       disp           |
+	OPC_MEMORY         //存储器指令,   |Opcode| Ra  | Rb  |  disp          |
+
+	OPC_MISI_MEMORY // 杂项指令       |Opcode| Ra  | Rb  |  Function       |
+
+	OPC_FUNC_MEMORY //带功能域的存     |Opcode| Ra  | Rb  | Function | disp |
+
+	OPC_ARITHMETIC   //简单运算指令, |Opcode| Ra  | Rb  | Function | RC  |
+	OPC_ARITHMETIC_I //简单运算指令, |Opcode| Ra  | Ib    |Function| RC  |
+	//                             |31  26|25 21|20   13|12     5|4   0|
+
+	OPC_COMPLEX_ARITHMETIC   // 浮点复合运算指令格式 |Opcode|  Fa  |  Fb  |Function | Fc  |Fd  |
+	OPC_COMPLEX_ARITHMETIC_I // 浮点复合运算指令格式 |Opcode|  Fa  |  Fb  |Function | Ib  |Fd  |
+	//                                            |31  26|25  21|20  16|15     10|9   5|4  0|
+)
+
+type OP struct {
+	OPcode  int
+	Fncode  int
+	Name    string
+	Class   int
+	IsFloat bool
+}
diff --git a/src/cmd/vendor/golang.org/x/sys/unix/asm_linux_sw64.s b/src/cmd/vendor/golang.org/x/sys/unix/asm_linux_sw64.s
new file mode 100644
index 00000000..4afa6ff5
--- /dev/null
+++ b/src/cmd/vendor/golang.org/x/sys/unix/asm_linux_sw64.s
@@ -0,0 +1,55 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build linux && sw64 && gc
+
+#include "textflag.h"
+
+//
+// System calls for sw64, Linux
+//
+// Just jump to package syscall's implementation for all these functions.
+// The runtime may know about them.
+
+#define SYSCALL SYS_CALL_B $131
+
+TEXT ·Syscall(SB),NOSPLIT|NOFRAME,$0-56
+	JMP	syscall·Syscall(SB)
+
+TEXT ·Syscall6(SB),NOSPLIT|NOFRAME,$0-80
+	JMP	syscall·Syscall6(SB)
+
+TEXT ·SyscallNoError(SB),NOSPLIT,$0-48
+	CALL	runtime·entersyscall(SB)
+	LDL	R16, a1+8(FP)
+	LDL	R17, a2+16(FP)
+	LDL	R18, a3+24(FP)
+	LDI	R19, ZERO
+	LDI	R20, ZERO
+	LDI	R21, ZERO
+	LDL	R0, trap+0(FP)	// syscall entry
+	SYSCALL
+	STL	R0, r1+32(FP)
+	STL	R20, r2+40(FP)
+	CALL	runtime·exitsyscall(SB)
+	RET
+
+TEXT ·RawSyscall(SB),NOSPLIT|NOFRAME,$0-56
+	JMP	syscall·RawSyscall(SB)
+
+TEXT ·RawSyscall6(SB),NOSPLIT|NOFRAME,$0-80
+	JMP	syscall·RawSyscall6(SB)
+
+TEXT ·RawSyscallNoError(SB),NOSPLIT|NOFRAME,$0-48
+	LDL	R16, a1+8(FP)
+	LDL	R17, a2+16(FP)
+	LDL	R18, a3+24(FP)
+	LDI	R19, ZERO
+	LDI	R20, ZERO
+	LDI	R21, ZERO
+	LDL	R0, trap+0(FP)	// syscall entry
+	SYSCALL
+	STL	R0, r1+32(FP)
+	STL	R20, r2+40(FP)
+	RET
diff --git a/src/cmd/vendor/golang.org/x/sys/unix/endian_little.go b/src/cmd/vendor/golang.org/x/sys/unix/endian_little.go
index b9f0e277..4b20b0a3 100644
--- a/src/cmd/vendor/golang.org/x/sys/unix/endian_little.go
+++ b/src/cmd/vendor/golang.org/x/sys/unix/endian_little.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 //
-//go:build 386 || amd64 || amd64p32 || alpha || arm || arm64 || loong64 || mipsle || mips64le || mips64p32le || nios2 || ppc64le || riscv || riscv64 || sh
+//go:build 386 || amd64 || amd64p32 || alpha || arm || arm64 || loong64 || mipsle || mips64le || mips64p32le || nios2 || ppc64le || riscv || riscv64 || sh || sw64
 
 package unix
 
diff --git a/src/cmd/vendor/golang.org/x/sys/unix/syscall_linux_sw64.go b/src/cmd/vendor/golang.org/x/sys/unix/syscall_linux_sw64.go
new file mode 100644
index 00000000..b3834cf8
--- /dev/null
+++ b/src/cmd/vendor/golang.org/x/sys/unix/syscall_linux_sw64.go
@@ -0,0 +1,158 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build linux && sw64
+
+package unix
+
+
+const (
+	//generate by handle in zerrors_linux_sw64.go
+	//_snyh_TODO: this should be generate by improving build script
+	TIOCGWINSZ = 0x40087468
+)
+
+const (
+	//ALL OF THIS constants are WORKAROUND, and should be removing
+	SYS_NEWFSTATAT = SYS_FSTATAT64
+)
+
+//sysnb	getxpid() (pid int, ppid int)
+// TODO(snyh):  correct handle Getppid and Getpid
+// currently manually remove the implements of Getpid and Getppid
+// in zsyscall_linux_sw64.go
+func Getpid() (pid int)   { pid, _ = getxpid(); return }
+func Getppid() (ppid int) { _, ppid = getxpid(); return }
+
+// TODO(snyh):  correct handle Utime
+func Utime(path string, buf *Utimbuf) error {
+	tv := [2]Timeval{
+		{Sec: buf.Actime},
+		{Sec: buf.Modtime},
+	}
+	return utimes(path, &tv)
+}
+
+//sys	Fstat64(fd int, st *Stat_t) (err error)
+//sys	Lstat64(path string, st *Stat_t) (err error)
+//sys	Stat64(path string, st *Stat_t) (err error)
+func Fstat(fd int, st *Stat_t) (err error)      { return Fstat64(fd, st) }
+func Lstat(path string, st *Stat_t) (err error) { return Lstat64(path, st) }
+func Stat(path string, st *Stat_t) (err error)  { return Stat64(path, st) }
+
+//sys	getxuid() (uid int, euid int)
+func Getuid() (uid int)   { uid, _ = getxuid(); return }
+func Geteuid() (euid int) { _, euid = getxuid(); return }
+
+//sys	getxgid() (gid int, egid int)
+func Getgid() (gid int)   { gid, _ = getxgid(); return }
+func Getegid() (egid int) { _, egid = getxgid(); return }
+
+//sys	Statfs(path string, buf *Statfs_t) (err error)
+//sys	Fstatfs(fd int, buf *Statfs_t) (err error)
+//sys	Fchown(fd int, uid int, gid int) (err error)
+//sys	Ftruncate(fd int, length int64) (err error)
+//sysnb	Getrlimit(resource int, rlim *Rlimit) (err error)
+//sys	Lchown(path string, uid int, gid int) (err error)
+//sys	Listen(s int, n int) (err error)
+//sys	pread(fd int, p []byte, offset int64) (n int, err error) = SYS_PREAD64
+//sys	pwrite(fd int, p []byte, offset int64) (n int, err error) = SYS_PWRITE64
+//sys	Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK
+//sys	sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)
+//sys	setfsgid(gid int) (prev int, err error)
+//sys	setfsuid(uid int) (prev int, err error)
+//sysnb	Setrlimit(resource int, rlim *Rlimit) (err error)
+//sys	Shutdown(fd int, how int) (err error)
+//sys	Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)
+
+//sys	SyncFileRange(fd int, off int64, n int64, flags int) (err error)
+//sys	Truncate(path string, length int64) (err error)
+//sys	accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)
+//sys	accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)
+//sys	bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)
+//sys	connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)
+//sysnb	getgroups(n int, list *_Gid_t) (nn int, err error)
+//sysnb	setgroups(n int, list *_Gid_t) (err error)
+//sys	getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)
+//sys	setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)
+//sysnb	socket(domain int, typ int, proto int) (fd int, err error)
+//sysnb	socketpair(domain int, typ int, proto int, fd *[2]int32) (err error)
+//sysnb	getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)
+//sysnb	getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)
+//sys	recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)
+//sys	sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)
+//sys	recvmsg(s int, msg *Msghdr, flags int) (n int, err error)
+//sys	sendmsg(s int, msg *Msghdr, flags int) (n int, err error)
+//sys	mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)
+
+//sysnb	Gettimeofday(tv *Timeval) (err error)
+
+func Time(t *Time_t) (tt Time_t, err error) {
+	var tv Timeval
+	err = Gettimeofday(&tv)
+	if err != nil {
+		return 0, err
+	}
+	if t != nil {
+		*t = Time_t(tv.Sec)
+	}
+	return Time_t(tv.Sec), nil
+}
+
+func setTimespec(sec, nsec int64) Timespec {
+	return Timespec{Sec: sec, Nsec: nsec}
+}
+
+func setTimeval(sec, usec int64) Timeval {
+	return Timeval{Sec: sec, Usec: usec}
+}
+
+func Ioperm(from int, num int, on int) (err error) {
+	return ENOSYS
+}
+
+func Iopl(level int) (err error) {
+	return ENOSYS
+}
+
+// func (r *PtraceRegs) PC() uint64 { return r.Epc }
+// func (r *PtraceRegs) SetPC(pc uint64) { r.Epc = pc }
+
+func (iov *Iovec) SetLen(length int) {
+	iov.Len = uint64(length)
+}
+
+func (msghdr *Msghdr) SetControllen(length int) {
+	msghdr.Controllen = uint64(length)
+}
+
+func (msghdr *Msghdr) SetIovlen(length int) {
+	msghdr.Iovlen = uint64(length)
+}
+
+func (cmsg *Cmsghdr) SetLen(length int) {
+	cmsg.Len = uint64(length)
+}
+
+
+//sys	EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error)
+//sys	Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64
+//sys	Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_NEWFSTATAT
+func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {
+	var ts *Timespec
+	if timeout != nil {
+		ts = &Timespec{Sec: timeout.Sec, Nsec: timeout.Usec * 1000}
+	}
+	return Pselect(nfd, r, w, e, ts, nil)
+}
+
+//sys	Ustat(dev int, ubuf *Ustat_t) (err error)
+//sys	futimesat(dirfd int, path string, times *[2]Timeval) (err error)
+//sys	utimes(path string, times *[2]Timeval) (err error)
+
+//sys	Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)
+
+func (rsa *RawSockaddrNFCLLCP) SetServiceNameLen(length int) {
+        rsa.Service_name_len = uint64(length)
+}
diff --git a/src/cmd/vendor/golang.org/x/sys/unix/zerrors_linux.go b/src/cmd/vendor/golang.org/x/sys/unix/zerrors_linux.go
index c73cfe2f..34f072aa 100644
--- a/src/cmd/vendor/golang.org/x/sys/unix/zerrors_linux.go
+++ b/src/cmd/vendor/golang.org/x/sys/unix/zerrors_linux.go
@@ -1,6 +1,6 @@
 // Code generated by mkmerge; DO NOT EDIT.
 
-//go:build linux
+//go:build linux && !sw64
 
 package unix
 
diff --git a/src/cmd/vendor/golang.org/x/sys/unix/zerrors_linux_sw64.go b/src/cmd/vendor/golang.org/x/sys/unix/zerrors_linux_sw64.go
new file mode 100644
index 00000000..6697cecb
--- /dev/null
+++ b/src/cmd/vendor/golang.org/x/sys/unix/zerrors_linux_sw64.go
@@ -0,0 +1,4367 @@
+// mkerrors.sh -Wall -Werror -static -I/tmp/sw64/include
+// Code generated by the command above; see README.md. DO NOT EDIT.
+
+//go:build sw64 && linux
+
+// Code generated by cmd/cgo -godefs; DO NOT EDIT.
+// cgo -godefs -- -Wall -Werror -static -I/tmp/sw64/include /home/zhangjh/git-source/go/sys/unix/_const.go
+
+package unix
+
+import "syscall"
+
+const (
+	AAFS_MAGIC					= 0x5a3c69f0
+	ADFS_SUPER_MAGIC				= 0xadf5
+	AFFS_SUPER_MAGIC				= 0xadff
+	AFS_FS_MAGIC					= 0x6b414653
+	AFS_SUPER_MAGIC					= 0x5346414f
+	AF_ALG						= 0x26
+	AF_APPLETALK					= 0x5
+	AF_ASH						= 0x12
+	AF_ATMPVC					= 0x8
+	AF_ATMSVC					= 0x14
+	AF_AX25						= 0x3
+	AF_BLUETOOTH					= 0x1f
+	AF_BRIDGE					= 0x7
+	AF_CAIF						= 0x25
+	AF_CAN						= 0x1d
+	AF_DECnet					= 0xc
+	AF_ECONET					= 0x13
+	AF_FILE						= 0x1
+	AF_IB						= 0x1b
+	AF_IEEE802154					= 0x24
+	AF_INET						= 0x2
+	AF_INET6					= 0xa
+	AF_IPX						= 0x4
+	AF_IRDA						= 0x17
+	AF_ISDN						= 0x22
+	AF_IUCV						= 0x20
+	AF_KCM						= 0x29
+	AF_KEY						= 0xf
+	AF_LLC						= 0x1a
+	AF_LOCAL					= 0x1
+	AF_MAX						= 0x2e
+	AF_MCTP						= 0x2d
+	AF_MPLS						= 0x1c
+	AF_NETBEUI					= 0xd
+	AF_NETLINK					= 0x10
+	AF_NETROM					= 0x6
+	AF_NFC						= 0x27
+	AF_PACKET					= 0x11
+	AF_PHONET					= 0x23
+	AF_PPPOX					= 0x18
+	AF_QIPCRTR					= 0x2a
+	AF_RDS						= 0x15
+	AF_ROSE						= 0xb
+	AF_ROUTE					= 0x10
+	AF_RXRPC					= 0x21
+	AF_SECURITY					= 0xe
+	AF_SMC						= 0x2b
+	AF_SNA						= 0x16
+	AF_TIPC						= 0x1e
+	AF_UNIX						= 0x1
+	AF_UNSPEC					= 0x0
+	AF_VSOCK					= 0x28
+	AF_WANPIPE					= 0x19
+	AF_X25						= 0x9
+	AF_XDP						= 0x2c
+	ALG_OP_DECRYPT					= 0x0
+	ALG_OP_ENCRYPT					= 0x1
+	ALG_SET_AEAD_ASSOCLEN				= 0x4
+	ALG_SET_AEAD_AUTHSIZE				= 0x5
+	ALG_SET_DRBG_ENTROPY				= 0x6
+	ALG_SET_IV					= 0x2
+	ALG_SET_KEY					= 0x1
+	ALG_SET_KEY_BY_KEY_SERIAL			= 0x7
+	ALG_SET_OP					= 0x3
+	ANON_INODE_FS_MAGIC				= 0x9041934
+	ARPHRD_6LOWPAN					= 0x339
+	ARPHRD_ADAPT					= 0x108
+	ARPHRD_APPLETLK					= 0x8
+	ARPHRD_ARCNET					= 0x7
+	ARPHRD_ASH					= 0x30d
+	ARPHRD_ATM					= 0x13
+	ARPHRD_AX25					= 0x3
+	ARPHRD_BIF					= 0x307
+	ARPHRD_CAIF					= 0x336
+	ARPHRD_CAN					= 0x118
+	ARPHRD_CHAOS					= 0x5
+	ARPHRD_CISCO					= 0x201
+	ARPHRD_CSLIP					= 0x101
+	ARPHRD_CSLIP6					= 0x103
+	ARPHRD_DDCMP					= 0x205
+	ARPHRD_DLCI					= 0xf
+	ARPHRD_ECONET					= 0x30e
+	ARPHRD_EETHER					= 0x2
+	ARPHRD_ETHER					= 0x1
+	ARPHRD_EUI64					= 0x1b
+	ARPHRD_FCAL					= 0x311
+	ARPHRD_FCFABRIC					= 0x313
+	ARPHRD_FCPL					= 0x312
+	ARPHRD_FCPP					= 0x310
+	ARPHRD_FDDI					= 0x306
+	ARPHRD_FRAD					= 0x302
+	ARPHRD_HDLC					= 0x201
+	ARPHRD_HIPPI					= 0x30c
+	ARPHRD_HWX25					= 0x110
+	ARPHRD_IEEE1394					= 0x18
+	ARPHRD_IEEE802					= 0x6
+	ARPHRD_IEEE80211				= 0x321
+	ARPHRD_IEEE80211_PRISM				= 0x322
+	ARPHRD_IEEE80211_RADIOTAP			= 0x323
+	ARPHRD_IEEE802154				= 0x324
+	ARPHRD_IEEE802154_MONITOR			= 0x325
+	ARPHRD_IEEE802_TR				= 0x320
+	ARPHRD_INFINIBAND				= 0x20
+	ARPHRD_IP6GRE					= 0x337
+	ARPHRD_IPDDP					= 0x309
+	ARPHRD_IPGRE					= 0x30a
+	ARPHRD_IRDA					= 0x30f
+	ARPHRD_LAPB					= 0x204
+	ARPHRD_LOCALTLK					= 0x305
+	ARPHRD_LOOPBACK					= 0x304
+	ARPHRD_MCTP					= 0x122
+	ARPHRD_METRICOM					= 0x17
+	ARPHRD_NETLINK					= 0x338
+	ARPHRD_NETROM					= 0x0
+	ARPHRD_NONE					= 0xfffe
+	ARPHRD_PHONET					= 0x334
+	ARPHRD_PHONET_PIPE				= 0x335
+	ARPHRD_PIMREG					= 0x30b
+	ARPHRD_PPP					= 0x200
+	ARPHRD_PRONET					= 0x4
+	ARPHRD_RAWHDLC					= 0x206
+	ARPHRD_RAWIP					= 0x207
+	ARPHRD_ROSE					= 0x10e
+	ARPHRD_RSRVD					= 0x104
+	ARPHRD_SIT					= 0x308
+	ARPHRD_SKIP					= 0x303
+	ARPHRD_SLIP					= 0x100
+	ARPHRD_SLIP6					= 0x102
+	ARPHRD_TUNNEL					= 0x300
+	ARPHRD_TUNNEL6					= 0x301
+	ARPHRD_VOID					= 0xffff
+	ARPHRD_VSOCKMON					= 0x33a
+	ARPHRD_X25					= 0x10f
+	AUDIT_ADD					= 0x3eb
+	AUDIT_ADD_RULE					= 0x3f3
+	AUDIT_ALWAYS					= 0x2
+	AUDIT_ANOM_ABEND				= 0x6a5
+	AUDIT_ANOM_CREAT				= 0x6a7
+	AUDIT_ANOM_LINK					= 0x6a6
+	AUDIT_ANOM_PROMISCUOUS				= 0x6a4
+	AUDIT_ARCH					= 0xb
+	AUDIT_ARCH_AARCH64				= 0xc00000b7
+	AUDIT_ARCH_ALPHA				= 0xc0009026
+	AUDIT_ARCH_ARCOMPACT				= 0x4000005d
+	AUDIT_ARCH_ARCOMPACTBE				= 0x5d
+	AUDIT_ARCH_ARCV2				= 0x400000c3
+	AUDIT_ARCH_ARCV2BE				= 0xc3
+	AUDIT_ARCH_ARM					= 0x40000028
+	AUDIT_ARCH_ARMEB				= 0x28
+	AUDIT_ARCH_C6X					= 0x4000008c
+	AUDIT_ARCH_C6XBE				= 0x8c
+	AUDIT_ARCH_CRIS					= 0x4000004c
+	AUDIT_ARCH_CSKY					= 0x400000fc
+	AUDIT_ARCH_FRV					= 0x5441
+	AUDIT_ARCH_H8300				= 0x2e
+	AUDIT_ARCH_HEXAGON				= 0xa4
+	AUDIT_ARCH_I386					= 0x40000003
+	AUDIT_ARCH_IA64					= 0xc0000032
+	AUDIT_ARCH_LOONGARCH32				= 0x40000102
+	AUDIT_ARCH_LOONGARCH64				= 0xc0000102
+	AUDIT_ARCH_M32R					= 0x58
+	AUDIT_ARCH_M68K					= 0x4
+	AUDIT_ARCH_MICROBLAZE				= 0xbd
+	AUDIT_ARCH_MIPS					= 0x8
+	AUDIT_ARCH_MIPS64				= 0x80000008
+	AUDIT_ARCH_MIPS64N32				= 0xa0000008
+	AUDIT_ARCH_MIPSEL				= 0x40000008
+	AUDIT_ARCH_MIPSEL64				= 0xc0000008
+	AUDIT_ARCH_MIPSEL64N32				= 0xe0000008
+	AUDIT_ARCH_NDS32				= 0x400000a7
+	AUDIT_ARCH_NDS32BE				= 0xa7
+	AUDIT_ARCH_NIOS2				= 0x40000071
+	AUDIT_ARCH_OPENRISC				= 0x5c
+	AUDIT_ARCH_PARISC				= 0xf
+	AUDIT_ARCH_PARISC64				= 0x8000000f
+	AUDIT_ARCH_PPC					= 0x14
+	AUDIT_ARCH_PPC64				= 0x80000015
+	AUDIT_ARCH_PPC64LE				= 0xc0000015
+	AUDIT_ARCH_RISCV32				= 0x400000f3
+	AUDIT_ARCH_RISCV64				= 0xc00000f3
+	AUDIT_ARCH_S390					= 0x16
+	AUDIT_ARCH_S390X				= 0x80000016
+	AUDIT_ARCH_SH					= 0x2a
+	AUDIT_ARCH_SH64					= 0x8000002a
+	AUDIT_ARCH_SHEL					= 0x4000002a
+	AUDIT_ARCH_SHEL64				= 0xc000002a
+	AUDIT_ARCH_SPARC				= 0x2
+	AUDIT_ARCH_SPARC64				= 0x8000002b
+	AUDIT_ARCH_SW64					= 0xc0009916
+	AUDIT_ARCH_TILEGX				= 0xc00000bf
+	AUDIT_ARCH_TILEGX32				= 0x400000bf
+	AUDIT_ARCH_TILEPRO				= 0x400000bc
+	AUDIT_ARCH_UNICORE				= 0x4000006e
+	AUDIT_ARCH_X86_64				= 0xc000003e
+	AUDIT_ARCH_XTENSA				= 0x5e
+	AUDIT_ARG0					= 0xc8
+	AUDIT_ARG1					= 0xc9
+	AUDIT_ARG2					= 0xca
+	AUDIT_ARG3					= 0xcb
+	AUDIT_AVC					= 0x578
+	AUDIT_AVC_PATH					= 0x57a
+	AUDIT_BITMASK_SIZE				= 0x40
+	AUDIT_BIT_MASK					= 0x8000000
+	AUDIT_BIT_TEST					= 0x48000000
+	AUDIT_BPF					= 0x536
+	AUDIT_BPRM_FCAPS				= 0x529
+	AUDIT_CAPSET					= 0x52a
+	AUDIT_CLASS_CHATTR				= 0x2
+	AUDIT_CLASS_CHATTR_32				= 0x3
+	AUDIT_CLASS_DIR_WRITE				= 0x0
+	AUDIT_CLASS_DIR_WRITE_32			= 0x1
+	AUDIT_CLASS_READ				= 0x4
+	AUDIT_CLASS_READ_32				= 0x5
+	AUDIT_CLASS_SIGNAL				= 0x8
+	AUDIT_CLASS_SIGNAL_32				= 0x9
+	AUDIT_CLASS_WRITE				= 0x6
+	AUDIT_CLASS_WRITE_32				= 0x7
+	AUDIT_COMPARE_AUID_TO_EUID			= 0x10
+	AUDIT_COMPARE_AUID_TO_FSUID			= 0xe
+	AUDIT_COMPARE_AUID_TO_OBJ_UID			= 0x5
+	AUDIT_COMPARE_AUID_TO_SUID			= 0xf
+	AUDIT_COMPARE_EGID_TO_FSGID			= 0x17
+	AUDIT_COMPARE_EGID_TO_OBJ_GID			= 0x4
+	AUDIT_COMPARE_EGID_TO_SGID			= 0x18
+	AUDIT_COMPARE_EUID_TO_FSUID			= 0x12
+	AUDIT_COMPARE_EUID_TO_OBJ_UID			= 0x3
+	AUDIT_COMPARE_EUID_TO_SUID			= 0x11
+	AUDIT_COMPARE_FSGID_TO_OBJ_GID			= 0x9
+	AUDIT_COMPARE_FSUID_TO_OBJ_UID			= 0x8
+	AUDIT_COMPARE_GID_TO_EGID			= 0x14
+	AUDIT_COMPARE_GID_TO_FSGID			= 0x15
+	AUDIT_COMPARE_GID_TO_OBJ_GID			= 0x2
+	AUDIT_COMPARE_GID_TO_SGID			= 0x16
+	AUDIT_COMPARE_SGID_TO_FSGID			= 0x19
+	AUDIT_COMPARE_SGID_TO_OBJ_GID			= 0x7
+	AUDIT_COMPARE_SUID_TO_FSUID			= 0x13
+	AUDIT_COMPARE_SUID_TO_OBJ_UID			= 0x6
+	AUDIT_COMPARE_UID_TO_AUID			= 0xa
+	AUDIT_COMPARE_UID_TO_EUID			= 0xb
+	AUDIT_COMPARE_UID_TO_FSUID			= 0xc
+	AUDIT_COMPARE_UID_TO_OBJ_UID			= 0x1
+	AUDIT_COMPARE_UID_TO_SUID			= 0xd
+	AUDIT_CONFIG_CHANGE				= 0x519
+	AUDIT_CWD					= 0x51b
+	AUDIT_DAEMON_ABORT				= 0x4b2
+	AUDIT_DAEMON_CONFIG				= 0x4b3
+	AUDIT_DAEMON_END				= 0x4b1
+	AUDIT_DAEMON_START				= 0x4b0
+	AUDIT_DEL					= 0x3ec
+	AUDIT_DEL_RULE					= 0x3f4
+	AUDIT_DEVMAJOR					= 0x64
+	AUDIT_DEVMINOR					= 0x65
+	AUDIT_DIR					= 0x6b
+	AUDIT_DM_CTRL					= 0x53a
+	AUDIT_DM_EVENT					= 0x53b
+	AUDIT_EGID					= 0x6
+	AUDIT_EOE					= 0x528
+	AUDIT_EQUAL					= 0x40000000
+	AUDIT_EUID					= 0x2
+	AUDIT_EVENT_LISTENER				= 0x537
+	AUDIT_EXE					= 0x70
+	AUDIT_EXECVE					= 0x51d
+	AUDIT_EXIT					= 0x67
+	AUDIT_FAIL_PANIC				= 0x2
+	AUDIT_FAIL_PRINTK				= 0x1
+	AUDIT_FAIL_SILENT				= 0x0
+	AUDIT_FANOTIFY					= 0x533
+	AUDIT_FD_PAIR					= 0x525
+	AUDIT_FEATURE_BITMAP_ALL			= 0x7f
+	AUDIT_FEATURE_BITMAP_BACKLOG_LIMIT		= 0x1
+	AUDIT_FEATURE_BITMAP_BACKLOG_WAIT_TIME		= 0x2
+	AUDIT_FEATURE_BITMAP_EXCLUDE_EXTEND		= 0x8
+	AUDIT_FEATURE_BITMAP_EXECUTABLE_PATH		= 0x4
+	AUDIT_FEATURE_BITMAP_FILTER_FS			= 0x40
+	AUDIT_FEATURE_BITMAP_LOST_RESET			= 0x20
+	AUDIT_FEATURE_BITMAP_SESSIONID_FILTER		= 0x10
+	AUDIT_FEATURE_CHANGE				= 0x530
+	AUDIT_FEATURE_LOGINUID_IMMUTABLE		= 0x1
+	AUDIT_FEATURE_ONLY_UNSET_LOGINUID		= 0x0
+	AUDIT_FEATURE_VERSION				= 0x1
+	AUDIT_FIELD_COMPARE				= 0x6f
+	AUDIT_FILETYPE					= 0x6c
+	AUDIT_FILTERKEY					= 0xd2
+	AUDIT_FILTER_ENTRY				= 0x2
+	AUDIT_FILTER_EXCLUDE				= 0x5
+	AUDIT_FILTER_EXIT				= 0x4
+	AUDIT_FILTER_FS					= 0x6
+	AUDIT_FILTER_PREPEND				= 0x10
+	AUDIT_FILTER_TASK				= 0x1
+	AUDIT_FILTER_TYPE				= 0x5
+	AUDIT_FILTER_URING_EXIT				= 0x7
+	AUDIT_FILTER_USER				= 0x0
+	AUDIT_FILTER_WATCH				= 0x3
+	AUDIT_FIRST_KERN_ANOM_MSG			= 0x6a4
+	AUDIT_FIRST_USER_MSG				= 0x44c
+	AUDIT_FIRST_USER_MSG2				= 0x834
+	AUDIT_FSGID					= 0x8
+	AUDIT_FSTYPE					= 0x1a
+	AUDIT_FSUID					= 0x4
+	AUDIT_GET					= 0x3e8
+	AUDIT_GET_FEATURE				= 0x3fb
+	AUDIT_GID					= 0x5
+	AUDIT_GREATER_THAN				= 0x20000000
+	AUDIT_GREATER_THAN_OR_EQUAL			= 0x60000000
+	AUDIT_INODE					= 0x66
+	AUDIT_INTEGRITY_DATA				= 0x708
+	AUDIT_INTEGRITY_EVM_XATTR			= 0x70e
+	AUDIT_INTEGRITY_HASH				= 0x70b
+	AUDIT_INTEGRITY_METADATA			= 0x709
+	AUDIT_INTEGRITY_PCR				= 0x70c
+	AUDIT_INTEGRITY_POLICY_RULE			= 0x70f
+	AUDIT_INTEGRITY_RULE				= 0x70d
+	AUDIT_INTEGRITY_STATUS				= 0x70a
+	AUDIT_IPC					= 0x517
+	AUDIT_IPC_SET_PERM				= 0x51f
+	AUDIT_KERNEL					= 0x7d0
+	AUDIT_KERNEL_OTHER				= 0x524
+	AUDIT_KERN_MODULE				= 0x532
+	AUDIT_LAST_FEATURE				= 0x1
+	AUDIT_LAST_KERN_ANOM_MSG			= 0x707
+	AUDIT_LAST_USER_MSG				= 0x4af
+	AUDIT_LAST_USER_MSG2				= 0xbb7
+	AUDIT_LESS_THAN					= 0x10000000
+	AUDIT_LESS_THAN_OR_EQUAL			= 0x50000000
+	AUDIT_LIST					= 0x3ea
+	AUDIT_LIST_RULES				= 0x3f5
+	AUDIT_LOGIN					= 0x3ee
+	AUDIT_LOGINUID					= 0x9
+	AUDIT_LOGINUID_SET				= 0x18
+	AUDIT_MAC_CALIPSO_ADD				= 0x58a
+	AUDIT_MAC_CALIPSO_DEL				= 0x58b
+	AUDIT_MAC_CIPSOV4_ADD				= 0x57f
+	AUDIT_MAC_CIPSOV4_DEL				= 0x580
+	AUDIT_MAC_CONFIG_CHANGE				= 0x57d
+	AUDIT_MAC_IPSEC_ADDSA				= 0x583
+	AUDIT_MAC_IPSEC_ADDSPD				= 0x585
+	AUDIT_MAC_IPSEC_DELSA				= 0x584
+	AUDIT_MAC_IPSEC_DELSPD				= 0x586
+	AUDIT_MAC_IPSEC_EVENT				= 0x587
+	AUDIT_MAC_MAP_ADD				= 0x581
+	AUDIT_MAC_MAP_DEL				= 0x582
+	AUDIT_MAC_POLICY_LOAD				= 0x57b
+	AUDIT_MAC_STATUS				= 0x57c
+	AUDIT_MAC_UNLBL_ALLOW				= 0x57e
+	AUDIT_MAC_UNLBL_STCADD				= 0x588
+	AUDIT_MAC_UNLBL_STCDEL				= 0x589
+	AUDIT_MAKE_EQUIV				= 0x3f7
+	AUDIT_MAX_FIELDS				= 0x40
+	AUDIT_MAX_FIELD_COMPARE				= 0x19
+	AUDIT_MAX_KEY_LEN				= 0x100
+	AUDIT_MESSAGE_TEXT_MAX				= 0x2170
+	AUDIT_MMAP					= 0x52b
+	AUDIT_MQ_GETSETATTR				= 0x523
+	AUDIT_MQ_NOTIFY					= 0x522
+	AUDIT_MQ_OPEN					= 0x520
+	AUDIT_MQ_SENDRECV				= 0x521
+	AUDIT_MSGTYPE					= 0xc
+	AUDIT_NEGATE					= 0x80000000
+	AUDIT_NETFILTER_CFG				= 0x52d
+	AUDIT_NETFILTER_PKT				= 0x52c
+	AUDIT_NEVER					= 0x0
+	AUDIT_NLGRP_MAX					= 0x1
+	AUDIT_NOT_EQUAL					= 0x30000000
+	AUDIT_NR_FILTERS				= 0x8
+	AUDIT_OBJ_GID					= 0x6e
+	AUDIT_OBJ_LEV_HIGH				= 0x17
+	AUDIT_OBJ_LEV_LOW				= 0x16
+	AUDIT_OBJ_PID					= 0x526
+	AUDIT_OBJ_ROLE					= 0x14
+	AUDIT_OBJ_TYPE					= 0x15
+	AUDIT_OBJ_UID					= 0x6d
+	AUDIT_OBJ_USER					= 0x13
+	AUDIT_OPENAT2					= 0x539
+	AUDIT_OPERATORS					= 0x78000000
+	AUDIT_PATH					= 0x516
+	AUDIT_PERM					= 0x6a
+	AUDIT_PERM_ATTR					= 0x8
+	AUDIT_PERM_EXEC					= 0x1
+	AUDIT_PERM_READ					= 0x4
+	AUDIT_PERM_WRITE				= 0x2
+	AUDIT_PERS					= 0xa
+	AUDIT_PID					= 0x0
+	AUDIT_POSSIBLE					= 0x1
+	AUDIT_PPID					= 0x12
+	AUDIT_PROCTITLE					= 0x52f
+	AUDIT_REPLACE					= 0x531
+	AUDIT_SADDR_FAM					= 0x71
+	AUDIT_SECCOMP					= 0x52e
+	AUDIT_SELINUX_ERR				= 0x579
+	AUDIT_SESSIONID					= 0x19
+	AUDIT_SET					= 0x3e9
+	AUDIT_SET_FEATURE				= 0x3fa
+	AUDIT_SGID					= 0x7
+	AUDIT_SID_UNSET					= 0xffffffff
+	AUDIT_SIGNAL_INFO				= 0x3f2
+	AUDIT_SOCKADDR					= 0x51a
+	AUDIT_SOCKETCALL				= 0x518
+	AUDIT_STATUS_BACKLOG_LIMIT			= 0x10
+	AUDIT_STATUS_BACKLOG_WAIT_TIME			= 0x20
+	AUDIT_STATUS_BACKLOG_WAIT_TIME_ACTUAL		= 0x80
+	AUDIT_STATUS_ENABLED				= 0x1
+	AUDIT_STATUS_FAILURE				= 0x2
+	AUDIT_STATUS_LOST				= 0x40
+	AUDIT_STATUS_PID				= 0x4
+	AUDIT_STATUS_RATE_LIMIT				= 0x8
+	AUDIT_SUBJ_CLR					= 0x11
+	AUDIT_SUBJ_ROLE					= 0xe
+	AUDIT_SUBJ_SEN					= 0x10
+	AUDIT_SUBJ_TYPE					= 0xf
+	AUDIT_SUBJ_USER					= 0xd
+	AUDIT_SUCCESS					= 0x68
+	AUDIT_SUID					= 0x3
+	AUDIT_SYSCALL					= 0x514
+	AUDIT_SYSCALL_CLASSES				= 0x10
+	AUDIT_TIME_ADJNTPVAL				= 0x535
+	AUDIT_TIME_INJOFFSET				= 0x534
+	AUDIT_TRIM					= 0x3f6
+	AUDIT_TTY					= 0x527
+	AUDIT_TTY_GET					= 0x3f8
+	AUDIT_TTY_SET					= 0x3f9
+	AUDIT_UID					= 0x1
+	AUDIT_UID_UNSET					= 0xffffffff
+	AUDIT_UNUSED_BITS				= 0x7fffc00
+	AUDIT_URINGOP					= 0x538
+	AUDIT_USER					= 0x3ed
+	AUDIT_USER_AVC					= 0x453
+	AUDIT_USER_TTY					= 0x464
+	AUDIT_VERSION_BACKLOG_LIMIT			= 0x1
+	AUDIT_VERSION_BACKLOG_WAIT_TIME			= 0x2
+	AUDIT_VERSION_LATEST				= 0x7f
+	AUDIT_WATCH					= 0x69
+	AUDIT_WATCH_INS					= 0x3ef
+	AUDIT_WATCH_LIST				= 0x3f1
+	AUDIT_WATCH_REM					= 0x3f0
+	AUTOFS_SUPER_MAGIC				= 0x187
+	B0						= 0x0
+	B1000000					= 0x17
+	B110						= 0x3
+	B115200						= 0x11
+	B1152000					= 0x18
+	B1200						= 0x9
+	B134						= 0x4
+	B150						= 0x5
+	B1500000					= 0x19
+	B1800						= 0xa
+	B19200						= 0xe
+	B200						= 0x6
+	B2000000					= 0x1a
+	B230400						= 0x12
+	B2400						= 0xb
+	B2500000					= 0x1b
+	B300						= 0x7
+	B3000000					= 0x1c
+	B3500000					= 0x1d
+	B38400						= 0xf
+	B4000000					= 0x1e
+	B460800						= 0x13
+	B4800						= 0xc
+	B50						= 0x1
+	B500000						= 0x14
+	B57600						= 0x10
+	B576000						= 0x15
+	B600						= 0x8
+	B75						= 0x2
+	B921600						= 0x16
+	B9600						= 0xd
+	BDEVFS_MAGIC					= 0x62646576
+	BINDERFS_SUPER_MAGIC				= 0x6c6f6f70
+	BINFMTFS_MAGIC					= 0x42494e4d
+	BLKALIGNOFF					= 0x2000127a
+	BLKBSZGET					= 0x40081270
+	BLKBSZSET					= 0x80081271
+	BLKDISCARD					= 0x20001277
+	BLKDISCARDZEROES				= 0x2000127c
+	BLKFLSBUF					= 0x20001261
+	BLKFRAGET					= 0x20001265
+	BLKFRASET					= 0x20001264
+	BLKGETDISKSEQ					= 0x40081280
+	BLKGETSIZE					= 0x20001260
+	BLKGETSIZE64					= 0x40081272
+	BLKIOMIN					= 0x20001278
+	BLKIOOPT					= 0x20001279
+	BLKPBSZGET					= 0x2000127b
+	BLKRAGET					= 0x20001263
+	BLKRASET					= 0x20001262
+	BLKROGET					= 0x2000125e
+	BLKROSET					= 0x2000125d
+	BLKROTATIONAL					= 0x2000127e
+	BLKRRPART					= 0x2000125f
+	BLKSECDISCARD					= 0x2000127d
+	BLKSECTGET					= 0x20001267
+	BLKSECTSET					= 0x20001266
+	BLKSSZGET					= 0x20001268
+	BLKZEROOUT					= 0x2000127f
+	BOTHER						= 0x1f
+	BPF_A						= 0x10
+	BPF_ABS						= 0x20
+	BPF_ADD						= 0x0
+	BPF_ALU						= 0x4
+	BPF_ALU64					= 0x7
+	BPF_AND						= 0x50
+	BPF_ARSH					= 0xc0
+	BPF_ATOMIC					= 0xc0
+	BPF_B						= 0x10
+	BPF_BUILD_ID_SIZE				= 0x14
+	BPF_CALL					= 0x80
+	BPF_CMPXCHG					= 0xf1
+	BPF_DIV						= 0x30
+	BPF_DW						= 0x18
+	BPF_END						= 0xd0
+	BPF_EXIT					= 0x90
+	BPF_FETCH					= 0x1
+	BPF_FROM_BE					= 0x8
+	BPF_FROM_LE					= 0x0
+	BPF_FS_MAGIC					= 0xcafe4a11
+	BPF_F_AFTER					= 0x10
+	BPF_F_ALLOW_MULTI				= 0x2
+	BPF_F_ALLOW_OVERRIDE				= 0x1
+	BPF_F_ANY_ALIGNMENT				= 0x2
+	BPF_F_BEFORE					= 0x8
+	BPF_F_ID					= 0x20
+	BPF_F_NETFILTER_IP_DEFRAG			= 0x1
+	BPF_F_QUERY_EFFECTIVE				= 0x1
+	BPF_F_REPLACE					= 0x4
+	BPF_F_SLEEPABLE					= 0x10
+	BPF_F_STRICT_ALIGNMENT				= 0x1
+	BPF_F_TEST_RND_HI32				= 0x4
+	BPF_F_TEST_RUN_ON_CPU				= 0x1
+	BPF_F_TEST_STATE_FREQ				= 0x8
+	BPF_F_TEST_XDP_LIVE_FRAMES			= 0x2
+	BPF_F_XDP_DEV_BOUND_ONLY			= 0x40
+	BPF_F_XDP_HAS_FRAGS				= 0x20
+	BPF_H						= 0x8
+	BPF_IMM						= 0x0
+	BPF_IND						= 0x40
+	BPF_JA						= 0x0
+	BPF_JEQ						= 0x10
+	BPF_JGE						= 0x30
+	BPF_JGT						= 0x20
+	BPF_JLE						= 0xb0
+	BPF_JLT						= 0xa0
+	BPF_JMP						= 0x5
+	BPF_JMP32					= 0x6
+	BPF_JNE						= 0x50
+	BPF_JSET					= 0x40
+	BPF_JSGE					= 0x70
+	BPF_JSGT					= 0x60
+	BPF_JSLE					= 0xd0
+	BPF_JSLT					= 0xc0
+	BPF_K						= 0x0
+	BPF_LD						= 0x0
+	BPF_LDX						= 0x1
+	BPF_LEN						= 0x80
+	BPF_LL_OFF					= -0x200000
+	BPF_LSH						= 0x60
+	BPF_MAJOR_VERSION				= 0x1
+	BPF_MAXINSNS					= 0x1000
+	BPF_MEM						= 0x60
+	BPF_MEMSX					= 0x80
+	BPF_MEMWORDS					= 0x10
+	BPF_MINOR_VERSION				= 0x1
+	BPF_MISC					= 0x7
+	BPF_MOD						= 0x90
+	BPF_MOV						= 0xb0
+	BPF_MSH						= 0xa0
+	BPF_MUL						= 0x20
+	BPF_NEG						= 0x80
+	BPF_NET_OFF					= -0x100000
+	BPF_OBJ_NAME_LEN				= 0x10
+	BPF_OR						= 0x40
+	BPF_PSEUDO_BTF_ID				= 0x3
+	BPF_PSEUDO_CALL					= 0x1
+	BPF_PSEUDO_FUNC					= 0x4
+	BPF_PSEUDO_KFUNC_CALL				= 0x2
+	BPF_PSEUDO_MAP_FD				= 0x1
+	BPF_PSEUDO_MAP_IDX				= 0x5
+	BPF_PSEUDO_MAP_IDX_VALUE			= 0x6
+	BPF_PSEUDO_MAP_VALUE				= 0x2
+	BPF_RET						= 0x6
+	BPF_RSH						= 0x70
+	BPF_ST						= 0x2
+	BPF_STX						= 0x3
+	BPF_SUB						= 0x10
+	BPF_TAG_SIZE					= 0x8
+	BPF_TAX						= 0x0
+	BPF_TO_BE					= 0x8
+	BPF_TO_LE					= 0x0
+	BPF_TXA						= 0x80
+	BPF_W						= 0x0
+	BPF_X						= 0x8
+	BPF_XADD					= 0xc0
+	BPF_XCHG					= 0xe1
+	BPF_XOR						= 0xa0
+	BRKINT						= 0x2
+	BS0						= 0x0
+	BS1						= 0x8000
+	BSDLY						= 0x8000
+	BTRFS_SUPER_MAGIC				= 0x9123683e
+	BTRFS_TEST_MAGIC				= 0x73727279
+	BUS_BLUETOOTH					= 0x5
+	BUS_HIL						= 0x4
+	BUS_USB						= 0x3
+	BUS_VIRTUAL					= 0x6
+	CAN_BCM						= 0x2
+	CAN_BUS_OFF_THRESHOLD				= 0x100
+	CAN_CTRLMODE_3_SAMPLES				= 0x4
+	CAN_CTRLMODE_BERR_REPORTING			= 0x10
+	CAN_CTRLMODE_CC_LEN8_DLC			= 0x100
+	CAN_CTRLMODE_FD					= 0x20
+	CAN_CTRLMODE_FD_NON_ISO				= 0x80
+	CAN_CTRLMODE_LISTENONLY				= 0x2
+	CAN_CTRLMODE_LOOPBACK				= 0x1
+	CAN_CTRLMODE_ONE_SHOT				= 0x8
+	CAN_CTRLMODE_PRESUME_ACK			= 0x40
+	CAN_CTRLMODE_TDC_AUTO				= 0x200
+	CAN_CTRLMODE_TDC_MANUAL				= 0x400
+	CAN_EFF_FLAG					= 0x80000000
+	CAN_EFF_ID_BITS					= 0x1d
+	CAN_EFF_MASK					= 0x1fffffff
+	CAN_ERROR_PASSIVE_THRESHOLD			= 0x80
+	CAN_ERROR_WARNING_THRESHOLD			= 0x60
+	CAN_ERR_ACK					= 0x20
+	CAN_ERR_BUSERROR				= 0x80
+	CAN_ERR_BUSOFF					= 0x40
+	CAN_ERR_CNT					= 0x200
+	CAN_ERR_CRTL					= 0x4
+	CAN_ERR_CRTL_ACTIVE				= 0x40
+	CAN_ERR_CRTL_RX_OVERFLOW			= 0x1
+	CAN_ERR_CRTL_RX_PASSIVE				= 0x10
+	CAN_ERR_CRTL_RX_WARNING				= 0x4
+	CAN_ERR_CRTL_TX_OVERFLOW			= 0x2
+	CAN_ERR_CRTL_TX_PASSIVE				= 0x20
+	CAN_ERR_CRTL_TX_WARNING				= 0x8
+	CAN_ERR_CRTL_UNSPEC				= 0x0
+	CAN_ERR_DLC					= 0x8
+	CAN_ERR_FLAG					= 0x20000000
+	CAN_ERR_LOSTARB					= 0x2
+	CAN_ERR_LOSTARB_UNSPEC				= 0x0
+	CAN_ERR_MASK					= 0x1fffffff
+	CAN_ERR_PROT					= 0x8
+	CAN_ERR_PROT_ACTIVE				= 0x40
+	CAN_ERR_PROT_BIT				= 0x1
+	CAN_ERR_PROT_BIT0				= 0x8
+	CAN_ERR_PROT_BIT1				= 0x10
+	CAN_ERR_PROT_FORM				= 0x2
+	CAN_ERR_PROT_LOC_ACK				= 0x19
+	CAN_ERR_PROT_LOC_ACK_DEL			= 0x1b
+	CAN_ERR_PROT_LOC_CRC_DEL			= 0x18
+	CAN_ERR_PROT_LOC_CRC_SEQ			= 0x8
+	CAN_ERR_PROT_LOC_DATA				= 0xa
+	CAN_ERR_PROT_LOC_DLC				= 0xb
+	CAN_ERR_PROT_LOC_EOF				= 0x1a
+	CAN_ERR_PROT_LOC_ID04_00			= 0xe
+	CAN_ERR_PROT_LOC_ID12_05			= 0xf
+	CAN_ERR_PROT_LOC_ID17_13			= 0x7
+	CAN_ERR_PROT_LOC_ID20_18			= 0x6
+	CAN_ERR_PROT_LOC_ID28_21			= 0x2
+	CAN_ERR_PROT_LOC_IDE				= 0x5
+	CAN_ERR_PROT_LOC_INTERM				= 0x12
+	CAN_ERR_PROT_LOC_RES0				= 0x9
+	CAN_ERR_PROT_LOC_RES1				= 0xd
+	CAN_ERR_PROT_LOC_RTR				= 0xc
+	CAN_ERR_PROT_LOC_SOF				= 0x3
+	CAN_ERR_PROT_LOC_SRTR				= 0x4
+	CAN_ERR_PROT_LOC_UNSPEC				= 0x0
+	CAN_ERR_PROT_OVERLOAD				= 0x20
+	CAN_ERR_PROT_STUFF				= 0x4
+	CAN_ERR_PROT_TX					= 0x80
+	CAN_ERR_PROT_UNSPEC				= 0x0
+	CAN_ERR_RESTARTED				= 0x100
+	CAN_ERR_TRX					= 0x10
+	CAN_ERR_TRX_CANH_NO_WIRE			= 0x4
+	CAN_ERR_TRX_CANH_SHORT_TO_BAT			= 0x5
+	CAN_ERR_TRX_CANH_SHORT_TO_GND			= 0x7
+	CAN_ERR_TRX_CANH_SHORT_TO_VCC			= 0x6
+	CAN_ERR_TRX_CANL_NO_WIRE			= 0x40
+	CAN_ERR_TRX_CANL_SHORT_TO_BAT			= 0x50
+	CAN_ERR_TRX_CANL_SHORT_TO_CANH			= 0x80
+	CAN_ERR_TRX_CANL_SHORT_TO_GND			= 0x70
+	CAN_ERR_TRX_CANL_SHORT_TO_VCC			= 0x60
+	CAN_ERR_TRX_UNSPEC				= 0x0
+	CAN_ERR_TX_TIMEOUT				= 0x1
+	CAN_INV_FILTER					= 0x20000000
+	CAN_ISOTP					= 0x6
+	CAN_J1939					= 0x7
+	CAN_MAX_DLC					= 0x8
+	CAN_MAX_DLEN					= 0x8
+	CAN_MAX_RAW_DLC					= 0xf
+	CAN_MCNET					= 0x5
+	CAN_MTU						= 0x10
+	CAN_NPROTO					= 0x8
+	CAN_RAW						= 0x1
+	CAN_RAW_FILTER_MAX				= 0x200
+	CAN_RTR_FLAG					= 0x40000000
+	CAN_SFF_ID_BITS					= 0xb
+	CAN_SFF_MASK					= 0x7ff
+	CAN_TERMINATION_DISABLED			= 0x0
+	CAN_TP16					= 0x3
+	CAN_TP20					= 0x4
+	CAP_AUDIT_CONTROL				= 0x1e
+	CAP_AUDIT_READ					= 0x25
+	CAP_AUDIT_WRITE					= 0x1d
+	CAP_BLOCK_SUSPEND				= 0x24
+	CAP_BPF						= 0x27
+	CAP_CHECKPOINT_RESTORE				= 0x28
+	CAP_CHOWN					= 0x0
+	CAP_DAC_OVERRIDE				= 0x1
+	CAP_DAC_READ_SEARCH				= 0x2
+	CAP_FOWNER					= 0x3
+	CAP_FSETID					= 0x4
+	CAP_IPC_LOCK					= 0xe
+	CAP_IPC_OWNER					= 0xf
+	CAP_KILL					= 0x5
+	CAP_LAST_CAP					= 0x28
+	CAP_LEASE					= 0x1c
+	CAP_LINUX_IMMUTABLE				= 0x9
+	CAP_MAC_ADMIN					= 0x21
+	CAP_MAC_OVERRIDE				= 0x20
+	CAP_MKNOD					= 0x1b
+	CAP_NET_ADMIN					= 0xc
+	CAP_NET_BIND_SERVICE				= 0xa
+	CAP_NET_BROADCAST				= 0xb
+	CAP_NET_RAW					= 0xd
+	CAP_PERFMON					= 0x26
+	CAP_SETFCAP					= 0x1f
+	CAP_SETGID					= 0x6
+	CAP_SETPCAP					= 0x8
+	CAP_SETUID					= 0x7
+	CAP_SYSLOG					= 0x22
+	CAP_SYS_ADMIN					= 0x15
+	CAP_SYS_BOOT					= 0x16
+	CAP_SYS_CHROOT					= 0x12
+	CAP_SYS_MODULE					= 0x10
+	CAP_SYS_NICE					= 0x17
+	CAP_SYS_PACCT					= 0x14
+	CAP_SYS_PTRACE					= 0x13
+	CAP_SYS_RAWIO					= 0x11
+	CAP_SYS_RESOURCE				= 0x18
+	CAP_SYS_TIME					= 0x19
+	CAP_SYS_TTY_CONFIG				= 0x1a
+	CAP_WAKE_ALARM					= 0x23
+	CBAUD						= 0x1f
+	CBAUDEX						= 0x0
+	CEPH_SUPER_MAGIC				= 0xc36400
+	CFLUSH						= 0xf
+	CGROUP2_SUPER_MAGIC				= 0x63677270
+	CGROUP_SUPER_MAGIC				= 0x27e0eb
+	CIBAUD						= 0x1f0000
+	CIFS_SUPER_MAGIC				= 0xff534d42
+	CLOCAL						= 0x8000
+	CLOCK_BOOTTIME					= 0x7
+	CLOCK_BOOTTIME_ALARM				= 0x9
+	CLOCK_DEFAULT					= 0x0
+	CLOCK_EXT					= 0x1
+	CLOCK_INT					= 0x2
+	CLOCK_MONOTONIC					= 0x1
+	CLOCK_MONOTONIC_COARSE				= 0x6
+	CLOCK_MONOTONIC_RAW				= 0x4
+	CLOCK_PROCESS_CPUTIME_ID			= 0x2
+	CLOCK_REALTIME					= 0x0
+	CLOCK_REALTIME_ALARM				= 0x8
+	CLOCK_REALTIME_COARSE				= 0x5
+	CLOCK_TAI					= 0xb
+	CLOCK_THREAD_CPUTIME_ID				= 0x3
+	CLOCK_TXFROMRX					= 0x4
+	CLOCK_TXINT					= 0x3
+	CLONE_ARGS_SIZE_VER0				= 0x40
+	CLONE_ARGS_SIZE_VER1				= 0x50
+	CLONE_ARGS_SIZE_VER2				= 0x58
+	CLONE_CHILD_CLEARTID				= 0x200000
+	CLONE_CHILD_SETTID				= 0x1000000
+	CLONE_CLEAR_SIGHAND				= 0x100000000
+	CLONE_DETACHED					= 0x400000
+	CLONE_FILES					= 0x400
+	CLONE_FS					= 0x200
+	CLONE_INTO_CGROUP				= 0x200000000
+	CLONE_IO					= 0x80000000
+	CLONE_NEWCGROUP					= 0x2000000
+	CLONE_NEWIPC					= 0x8000000
+	CLONE_NEWNET					= 0x40000000
+	CLONE_NEWNS					= 0x20000
+	CLONE_NEWPID					= 0x20000000
+	CLONE_NEWTIME					= 0x80
+	CLONE_NEWUSER					= 0x10000000
+	CLONE_NEWUTS					= 0x4000000
+	CLONE_PARENT					= 0x8000
+	CLONE_PARENT_SETTID				= 0x100000
+	CLONE_PIDFD					= 0x1000
+	CLONE_PTRACE					= 0x2000
+	CLONE_SETTLS					= 0x80000
+	CLONE_SIGHAND					= 0x800
+	CLONE_SYSVSEM					= 0x40000
+	CLONE_THREAD					= 0x10000
+	CLONE_UNTRACED					= 0x800000
+	CLONE_VFORK					= 0x4000
+	CLONE_VM					= 0x100
+	CMSPAR						= 0x40000000
+	CODA_SUPER_MAGIC				= 0x73757245
+	CR0						= 0x0
+	CR1						= 0x1000
+	CR2						= 0x2000
+	CR3						= 0x3000
+	CRAMFS_MAGIC					= 0x28cd3d45
+	CRDLY						= 0x3000
+	CREAD						= 0x800
+	CRTSCTS						= 0x80000000
+	CRYPTO_MAX_NAME					= 0x40
+	CRYPTO_MSG_MAX					= 0x15
+	CRYPTO_NR_MSGTYPES				= 0x6
+	CRYPTO_REPORT_MAXSIZE				= 0x160
+	CS5						= 0x0
+	CS6						= 0x100
+	CS7						= 0x200
+	CS8						= 0x300
+	CSIGNAL						= 0xff
+	CSIZE						= 0x300
+	CSTART						= 0x11
+	CSTATUS						= 0x0
+	CSTOP						= 0x13
+	CSTOPB						= 0x400
+	CSUSP						= 0x1a
+	DAXFS_MAGIC					= 0x64646178
+	DEBUGFS_MAGIC					= 0x64626720
+	DEVLINK_CMD_ESWITCH_MODE_GET			= 0x1d
+	DEVLINK_CMD_ESWITCH_MODE_SET			= 0x1e
+	DEVLINK_FLASH_OVERWRITE_IDENTIFIERS		= 0x2
+	DEVLINK_FLASH_OVERWRITE_SETTINGS		= 0x1
+	DEVLINK_GENL_MCGRP_CONFIG_NAME			= "config"
+	DEVLINK_GENL_NAME				= "devlink"
+	DEVLINK_GENL_VERSION				= 0x1
+	DEVLINK_PORT_FN_CAP_IPSEC_CRYPTO		= 0x4
+	DEVLINK_PORT_FN_CAP_IPSEC_PACKET		= 0x8
+	DEVLINK_PORT_FN_CAP_MIGRATABLE			= 0x2
+	DEVLINK_PORT_FN_CAP_ROCE			= 0x1
+	DEVLINK_SB_THRESHOLD_TO_ALPHA_MAX		= 0x14
+	DEVLINK_SUPPORTED_FLASH_OVERWRITE_SECTIONS	= 0x3
+	DEVMEM_MAGIC					= 0x454d444d
+	DEVPTS_SUPER_MAGIC				= 0x1cd1
+	DMA_BUF_MAGIC					= 0x444d4142
+	DM_ACTIVE_PRESENT_FLAG				= 0x20
+	DM_BUFFER_FULL_FLAG				= 0x100
+	DM_CONTROL_NODE					= "control"
+	DM_DATA_OUT_FLAG				= 0x10000
+	DM_DEFERRED_REMOVE				= 0x20000
+	DM_DEV_ARM_POLL					= 0xc138fd10
+	DM_DEV_CREATE					= 0xc138fd03
+	DM_DEV_REMOVE					= 0xc138fd04
+	DM_DEV_RENAME					= 0xc138fd05
+	DM_DEV_SET_GEOMETRY				= 0xc138fd0f
+	DM_DEV_STATUS					= 0xc138fd07
+	DM_DEV_SUSPEND					= 0xc138fd06
+	DM_DEV_WAIT					= 0xc138fd08
+	DM_DIR						= "mapper"
+	DM_GET_TARGET_VERSION				= 0xc138fd11
+	DM_IMA_MEASUREMENT_FLAG				= 0x80000
+	DM_INACTIVE_PRESENT_FLAG			= 0x40
+	DM_INTERNAL_SUSPEND_FLAG			= 0x40000
+	DM_IOCTL					= 0xfd
+	DM_LIST_DEVICES					= 0xc138fd02
+	DM_LIST_VERSIONS				= 0xc138fd0d
+	DM_MAX_TYPE_NAME				= 0x10
+	DM_NAME_LEN					= 0x80
+	DM_NAME_LIST_FLAG_DOESNT_HAVE_UUID		= 0x2
+	DM_NAME_LIST_FLAG_HAS_UUID			= 0x1
+	DM_NOFLUSH_FLAG					= 0x800
+	DM_PERSISTENT_DEV_FLAG				= 0x8
+	DM_QUERY_INACTIVE_TABLE_FLAG			= 0x1000
+	DM_READONLY_FLAG				= 0x1
+	DM_REMOVE_ALL					= 0xc138fd01
+	DM_SECURE_DATA_FLAG				= 0x8000
+	DM_SKIP_BDGET_FLAG				= 0x200
+	DM_SKIP_LOCKFS_FLAG				= 0x400
+	DM_STATUS_TABLE_FLAG				= 0x10
+	DM_SUSPEND_FLAG					= 0x2
+	DM_TABLE_CLEAR					= 0xc138fd0a
+	DM_TABLE_DEPS					= 0xc138fd0b
+	DM_TABLE_LOAD					= 0xc138fd09
+	DM_TABLE_STATUS					= 0xc138fd0c
+	DM_TARGET_MSG					= 0xc138fd0e
+	DM_UEVENT_GENERATED_FLAG			= 0x2000
+	DM_UUID_FLAG					= 0x4000
+	DM_UUID_LEN					= 0x81
+	DM_VERSION					= 0xc138fd00
+	DM_VERSION_EXTRA				= "-ioctl (2023-03-01)"
+	DM_VERSION_MAJOR				= 0x4
+	DM_VERSION_MINOR				= 0x30
+	DM_VERSION_PATCHLEVEL				= 0x0
+	DT_BLK						= 0x6
+	DT_CHR						= 0x2
+	DT_DIR						= 0x4
+	DT_FIFO						= 0x1
+	DT_LNK						= 0xa
+	DT_REG						= 0x8
+	DT_SOCK						= 0xc
+	DT_UNKNOWN					= 0x0
+	DT_WHT						= 0xe
+	ECCGETLAYOUT					= 0x41484d11
+	ECCGETSTATS					= 0x40104d12
+	ECHO						= 0x8
+	ECHOCTL						= 0x40
+	ECHOE						= 0x2
+	ECHOK						= 0x4
+	ECHOKE						= 0x1
+	ECHONL						= 0x10
+	ECHOPRT						= 0x20
+	ECRYPTFS_SUPER_MAGIC				= 0xf15f
+	EFD_CLOEXEC					= 0x200000
+	EFD_NONBLOCK					= 0x4
+	EFD_SEMAPHORE					= 0x1
+	EFIVARFS_MAGIC					= 0xde5e81e4
+	EFS_SUPER_MAGIC					= 0x414a53
+	EM_386						= 0x3
+	EM_486						= 0x6
+	EM_68K						= 0x4
+	EM_860						= 0x7
+	EM_88K						= 0x5
+	EM_AARCH64					= 0xb7
+	EM_ALPHA					= 0x9026
+	EM_ALTERA_NIOS2					= 0x71
+	EM_ARCOMPACT					= 0x5d
+	EM_ARCV2					= 0xc3
+	EM_ARM						= 0x28
+	EM_BLACKFIN					= 0x6a
+	EM_BPF						= 0xf7
+	EM_CRIS						= 0x4c
+	EM_CSKY						= 0xfc
+	EM_CYGNUS_M32R					= 0x9041
+	EM_CYGNUS_MN10300				= 0xbeef
+	EM_FRV						= 0x5441
+	EM_H8_300					= 0x2e
+	EM_HEXAGON					= 0xa4
+	EM_IA_64					= 0x32
+	EM_LOONGARCH					= 0x102
+	EM_M32						= 0x1
+	EM_M32R						= 0x58
+	EM_MICROBLAZE					= 0xbd
+	EM_MIPS						= 0x8
+	EM_MIPS_RS3_LE					= 0xa
+	EM_MIPS_RS4_BE					= 0xa
+	EM_MN10300					= 0x59
+	EM_NDS32					= 0xa7
+	EM_NONE						= 0x0
+	EM_OPENRISC					= 0x5c
+	EM_PARISC					= 0xf
+	EM_PPC						= 0x14
+	EM_PPC64					= 0x15
+	EM_RISCV					= 0xf3
+	EM_S390						= 0x16
+	EM_S390_OLD					= 0xa390
+	EM_SH						= 0x2a
+	EM_SPARC					= 0x2
+	EM_SPARC32PLUS					= 0x12
+	EM_SPARCV9					= 0x2b
+	EM_SPU						= 0x17
+	EM_SW64						= 0x9916
+	EM_TILEGX					= 0xbf
+	EM_TILEPRO					= 0xbc
+	EM_TI_C6000					= 0x8c
+	EM_UNICORE					= 0x6e
+	EM_X86_64					= 0x3e
+	EM_XTENSA					= 0x5e
+	ENCODING_DEFAULT				= 0x0
+	ENCODING_FM_MARK				= 0x3
+	ENCODING_FM_SPACE				= 0x4
+	ENCODING_MANCHESTER				= 0x5
+	ENCODING_NRZ					= 0x1
+	ENCODING_NRZI					= 0x2
+	EPOLLERR					= 0x8
+	EPOLLET						= 0x80000000
+	EPOLLEXCLUSIVE					= 0x10000000
+	EPOLLHUP					= 0x10
+	EPOLLIN						= 0x1
+	EPOLLMSG					= 0x400
+	EPOLLONESHOT					= 0x40000000
+	EPOLLOUT					= 0x4
+	EPOLLPRI					= 0x2
+	EPOLLRDBAND					= 0x80
+	EPOLLRDHUP					= 0x2000
+	EPOLLRDNORM					= 0x40
+	EPOLLWAKEUP					= 0x20000000
+	EPOLLWRBAND					= 0x200
+	EPOLLWRNORM					= 0x100
+	EPOLL_CLOEXEC					= 0x200000
+	EPOLL_CTL_ADD					= 0x1
+	EPOLL_CTL_DEL					= 0x2
+	EPOLL_CTL_MOD					= 0x3
+	EROFS_SUPER_MAGIC_V1				= 0xe0f5e1e2
+	ESP_V4_FLOW					= 0xa
+	ESP_V6_FLOW					= 0xc
+	ETHER_FLOW					= 0x12
+	ETHTOOL_BUSINFO_LEN				= 0x20
+	ETHTOOL_EROMVERS_LEN				= 0x20
+	ETHTOOL_FEC_AUTO				= 0x2
+	ETHTOOL_FEC_BASER				= 0x10
+	ETHTOOL_FEC_LLRS				= 0x20
+	ETHTOOL_FEC_NONE				= 0x1
+	ETHTOOL_FEC_OFF					= 0x4
+	ETHTOOL_FEC_RS					= 0x8
+	ETHTOOL_FLAG_ALL				= 0x7
+	ETHTOOL_FLAG_COMPACT_BITSETS			= 0x1
+	ETHTOOL_FLAG_OMIT_REPLY				= 0x2
+	ETHTOOL_FLAG_STATS				= 0x4
+	ETHTOOL_FLASHDEV				= 0x33
+	ETHTOOL_FLASH_MAX_FILENAME			= 0x80
+	ETHTOOL_FWVERS_LEN				= 0x20
+	ETHTOOL_F_COMPAT				= 0x4
+	ETHTOOL_F_UNSUPPORTED				= 0x1
+	ETHTOOL_F_WISH					= 0x2
+	ETHTOOL_GCHANNELS				= 0x3c
+	ETHTOOL_GCOALESCE				= 0xe
+	ETHTOOL_GDRVINFO				= 0x3
+	ETHTOOL_GEEE					= 0x44
+	ETHTOOL_GEEPROM					= 0xb
+	ETHTOOL_GENL_NAME				= "ethtool"
+	ETHTOOL_GENL_VERSION				= 0x1
+	ETHTOOL_GET_DUMP_DATA				= 0x40
+	ETHTOOL_GET_DUMP_FLAG				= 0x3f
+	ETHTOOL_GET_TS_INFO				= 0x41
+	ETHTOOL_GFEATURES				= 0x3a
+	ETHTOOL_GFECPARAM				= 0x50
+	ETHTOOL_GFLAGS					= 0x25
+	ETHTOOL_GGRO					= 0x2b
+	ETHTOOL_GGSO					= 0x23
+	ETHTOOL_GLINK					= 0xa
+	ETHTOOL_GLINKSETTINGS				= 0x4c
+	ETHTOOL_GMODULEEEPROM				= 0x43
+	ETHTOOL_GMODULEINFO				= 0x42
+	ETHTOOL_GMSGLVL					= 0x7
+	ETHTOOL_GPAUSEPARAM				= 0x12
+	ETHTOOL_GPERMADDR				= 0x20
+	ETHTOOL_GPFLAGS					= 0x27
+	ETHTOOL_GPHYSTATS				= 0x4a
+	ETHTOOL_GREGS					= 0x4
+	ETHTOOL_GRINGPARAM				= 0x10
+	ETHTOOL_GRSSH					= 0x46
+	ETHTOOL_GRXCLSRLALL				= 0x30
+	ETHTOOL_GRXCLSRLCNT				= 0x2e
+	ETHTOOL_GRXCLSRULE				= 0x2f
+	ETHTOOL_GRXCSUM					= 0x14
+	ETHTOOL_GRXFH					= 0x29
+	ETHTOOL_GRXFHINDIR				= 0x38
+	ETHTOOL_GRXNTUPLE				= 0x36
+	ETHTOOL_GRXRINGS				= 0x2d
+	ETHTOOL_GSET					= 0x1
+	ETHTOOL_GSG					= 0x18
+	ETHTOOL_GSSET_INFO				= 0x37
+	ETHTOOL_GSTATS					= 0x1d
+	ETHTOOL_GSTRINGS				= 0x1b
+	ETHTOOL_GTSO					= 0x1e
+	ETHTOOL_GTUNABLE				= 0x48
+	ETHTOOL_GTXCSUM					= 0x16
+	ETHTOOL_GUFO					= 0x21
+	ETHTOOL_GWOL					= 0x5
+	ETHTOOL_MCGRP_MONITOR_NAME			= "monitor"
+	ETHTOOL_NWAY_RST				= 0x9
+	ETHTOOL_PERQUEUE				= 0x4b
+	ETHTOOL_PHYS_ID					= 0x1c
+	ETHTOOL_PHY_EDPD_DFLT_TX_MSECS			= 0xffff
+	ETHTOOL_PHY_EDPD_DISABLE			= 0x0
+	ETHTOOL_PHY_EDPD_NO_TX				= 0xfffe
+	ETHTOOL_PHY_FAST_LINK_DOWN_OFF			= 0xff
+	ETHTOOL_PHY_FAST_LINK_DOWN_ON			= 0x0
+	ETHTOOL_PHY_GTUNABLE				= 0x4e
+	ETHTOOL_PHY_STUNABLE				= 0x4f
+	ETHTOOL_RESET					= 0x34
+	ETHTOOL_RXNTUPLE_ACTION_CLEAR			= -0x2
+	ETHTOOL_RXNTUPLE_ACTION_DROP			= -0x1
+	ETHTOOL_RX_FLOW_SPEC_RING			= 0xffffffff
+	ETHTOOL_RX_FLOW_SPEC_RING_VF			= 0xff00000000
+	ETHTOOL_RX_FLOW_SPEC_RING_VF_OFF		= 0x20
+	ETHTOOL_SCHANNELS				= 0x3d
+	ETHTOOL_SCOALESCE				= 0xf
+	ETHTOOL_SEEE					= 0x45
+	ETHTOOL_SEEPROM					= 0xc
+	ETHTOOL_SET_DUMP				= 0x3e
+	ETHTOOL_SFEATURES				= 0x3b
+	ETHTOOL_SFECPARAM				= 0x51
+	ETHTOOL_SFLAGS					= 0x26
+	ETHTOOL_SGRO					= 0x2c
+	ETHTOOL_SGSO					= 0x24
+	ETHTOOL_SLINKSETTINGS				= 0x4d
+	ETHTOOL_SMSGLVL					= 0x8
+	ETHTOOL_SPAUSEPARAM				= 0x13
+	ETHTOOL_SPFLAGS					= 0x28
+	ETHTOOL_SRINGPARAM				= 0x11
+	ETHTOOL_SRSSH					= 0x47
+	ETHTOOL_SRXCLSRLDEL				= 0x31
+	ETHTOOL_SRXCLSRLINS				= 0x32
+	ETHTOOL_SRXCSUM					= 0x15
+	ETHTOOL_SRXFH					= 0x2a
+	ETHTOOL_SRXFHINDIR				= 0x39
+	ETHTOOL_SRXNTUPLE				= 0x35
+	ETHTOOL_SSET					= 0x2
+	ETHTOOL_SSG					= 0x19
+	ETHTOOL_STSO					= 0x1f
+	ETHTOOL_STUNABLE				= 0x49
+	ETHTOOL_STXCSUM					= 0x17
+	ETHTOOL_SUFO					= 0x22
+	ETHTOOL_SWOL					= 0x6
+	ETHTOOL_TEST					= 0x1a
+	ETH_P_1588					= 0x88f7
+	ETH_P_8021AD					= 0x88a8
+	ETH_P_8021AH					= 0x88e7
+	ETH_P_8021Q					= 0x8100
+	ETH_P_80221					= 0x8917
+	ETH_P_802_2					= 0x4
+	ETH_P_802_3					= 0x1
+	ETH_P_802_3_MIN					= 0x600
+	ETH_P_802_EX1					= 0x88b5
+	ETH_P_AARP					= 0x80f3
+	ETH_P_AF_IUCV					= 0xfbfb
+	ETH_P_ALL					= 0x3
+	ETH_P_AOE					= 0x88a2
+	ETH_P_ARCNET					= 0x1a
+	ETH_P_ARP					= 0x806
+	ETH_P_ATALK					= 0x809b
+	ETH_P_ATMFATE					= 0x8884
+	ETH_P_ATMMPOA					= 0x884c
+	ETH_P_AX25					= 0x2
+	ETH_P_BATMAN					= 0x4305
+	ETH_P_BPQ					= 0x8ff
+	ETH_P_CAIF					= 0xf7
+	ETH_P_CAN					= 0xc
+	ETH_P_CANFD					= 0xd
+	ETH_P_CANXL					= 0xe
+	ETH_P_CFM					= 0x8902
+	ETH_P_CONTROL					= 0x16
+	ETH_P_CUST					= 0x6006
+	ETH_P_DDCMP					= 0x6
+	ETH_P_DEC					= 0x6000
+	ETH_P_DIAG					= 0x6005
+	ETH_P_DNA_DL					= 0x6001
+	ETH_P_DNA_RC					= 0x6002
+	ETH_P_DNA_RT					= 0x6003
+	ETH_P_DSA					= 0x1b
+	ETH_P_DSA_8021Q					= 0xdadb
+	ETH_P_DSA_A5PSW					= 0xe001
+	ETH_P_ECONET					= 0x18
+	ETH_P_EDSA					= 0xdada
+	ETH_P_ERSPAN					= 0x88be
+	ETH_P_ERSPAN2					= 0x22eb
+	ETH_P_ETHERCAT					= 0x88a4
+	ETH_P_FCOE					= 0x8906
+	ETH_P_FIP					= 0x8914
+	ETH_P_HDLC					= 0x19
+	ETH_P_HSR					= 0x892f
+	ETH_P_IBOE					= 0x8915
+	ETH_P_IEEE802154				= 0xf6
+	ETH_P_IEEEPUP					= 0xa00
+	ETH_P_IEEEPUPAT					= 0xa01
+	ETH_P_IFE					= 0xed3e
+	ETH_P_IP					= 0x800
+	ETH_P_IPV6					= 0x86dd
+	ETH_P_IPX					= 0x8137
+	ETH_P_IRDA					= 0x17
+	ETH_P_LAT					= 0x6004
+	ETH_P_LINK_CTL					= 0x886c
+	ETH_P_LLDP					= 0x88cc
+	ETH_P_LOCALTALK					= 0x9
+	ETH_P_LOOP					= 0x60
+	ETH_P_LOOPBACK					= 0x9000
+	ETH_P_MACSEC					= 0x88e5
+	ETH_P_MAP					= 0xf9
+	ETH_P_MCTP					= 0xfa
+	ETH_P_MOBITEX					= 0x15
+	ETH_P_MPLS_MC					= 0x8848
+	ETH_P_MPLS_UC					= 0x8847
+	ETH_P_MRP					= 0x88e3
+	ETH_P_MVRP					= 0x88f5
+	ETH_P_NCSI					= 0x88f8
+	ETH_P_NSH					= 0x894f
+	ETH_P_PAE					= 0x888e
+	ETH_P_PAUSE					= 0x8808
+	ETH_P_PHONET					= 0xf5
+	ETH_P_PPPTALK					= 0x10
+	ETH_P_PPP_DISC					= 0x8863
+	ETH_P_PPP_MP					= 0x8
+	ETH_P_PPP_SES					= 0x8864
+	ETH_P_PREAUTH					= 0x88c7
+	ETH_P_PROFINET					= 0x8892
+	ETH_P_PRP					= 0x88fb
+	ETH_P_PUP					= 0x200
+	ETH_P_PUPAT					= 0x201
+	ETH_P_QINQ1					= 0x9100
+	ETH_P_QINQ2					= 0x9200
+	ETH_P_QINQ3					= 0x9300
+	ETH_P_RARP					= 0x8035
+	ETH_P_REALTEK					= 0x8899
+	ETH_P_SCA					= 0x6007
+	ETH_P_SLOW					= 0x8809
+	ETH_P_SNAP					= 0x5
+	ETH_P_TDLS					= 0x890d
+	ETH_P_TEB					= 0x6558
+	ETH_P_TIPC					= 0x88ca
+	ETH_P_TRAILER					= 0x1c
+	ETH_P_TR_802_2					= 0x11
+	ETH_P_TSN					= 0x22f0
+	ETH_P_WAN_PPP					= 0x7
+	ETH_P_WCCP					= 0x883e
+	ETH_P_X25					= 0x805
+	ETH_P_XDSA					= 0xf8
+	EV_ABS						= 0x3
+	EV_CNT						= 0x20
+	EV_FF						= 0x15
+	EV_FF_STATUS					= 0x17
+	EV_KEY						= 0x1
+	EV_LED						= 0x11
+	EV_MAX						= 0x1f
+	EV_MSC						= 0x4
+	EV_PWR						= 0x16
+	EV_REL						= 0x2
+	EV_REP						= 0x14
+	EV_SND						= 0x12
+	EV_SW						= 0x5
+	EV_SYN						= 0x0
+	EV_VERSION					= 0x10001
+	EXABYTE_ENABLE_NEST				= 0xf0
+	EXFAT_SUPER_MAGIC				= 0x2011bab0
+	EXT2_SUPER_MAGIC				= 0xef53
+	EXT3_SUPER_MAGIC				= 0xef53
+	EXT4_SUPER_MAGIC				= 0xef53
+	EXTA						= 0xe
+	EXTB						= 0xf
+	EXTPROC						= 0x10000000
+	F2FS_SUPER_MAGIC				= 0xf2f52010
+	FALLOC_FL_COLLAPSE_RANGE			= 0x8
+	FALLOC_FL_INSERT_RANGE				= 0x20
+	FALLOC_FL_KEEP_SIZE				= 0x1
+	FALLOC_FL_NO_HIDE_STALE				= 0x4
+	FALLOC_FL_PUNCH_HOLE				= 0x2
+	FALLOC_FL_UNSHARE_RANGE				= 0x40
+	FALLOC_FL_ZERO_RANGE				= 0x10
+	FANOTIFY_METADATA_VERSION			= 0x3
+	FAN_ACCESS					= 0x1
+	FAN_ACCESS_PERM					= 0x20000
+	FAN_ALLOW					= 0x1
+	FAN_ALL_CLASS_BITS				= 0xc
+	FAN_ALL_EVENTS					= 0x3b
+	FAN_ALL_INIT_FLAGS				= 0x3f
+	FAN_ALL_MARK_FLAGS				= 0xff
+	FAN_ALL_OUTGOING_EVENTS				= 0x3403b
+	FAN_ALL_PERM_EVENTS				= 0x30000
+	FAN_ATTRIB					= 0x4
+	FAN_AUDIT					= 0x10
+	FAN_CLASS_CONTENT				= 0x4
+	FAN_CLASS_NOTIF					= 0x0
+	FAN_CLASS_PRE_CONTENT				= 0x8
+	FAN_CLOEXEC					= 0x1
+	FAN_CLOSE					= 0x18
+	FAN_CLOSE_NOWRITE				= 0x10
+	FAN_CLOSE_WRITE					= 0x8
+	FAN_CREATE					= 0x100
+	FAN_DELETE					= 0x200
+	FAN_DELETE_SELF					= 0x400
+	FAN_DENY					= 0x2
+	FAN_ENABLE_AUDIT				= 0x40
+	FAN_EPIDFD					= -0x2
+	FAN_EVENT_INFO_TYPE_DFID			= 0x3
+	FAN_EVENT_INFO_TYPE_DFID_NAME			= 0x2
+	FAN_EVENT_INFO_TYPE_ERROR			= 0x5
+	FAN_EVENT_INFO_TYPE_FID				= 0x1
+	FAN_EVENT_INFO_TYPE_NEW_DFID_NAME		= 0xc
+	FAN_EVENT_INFO_TYPE_OLD_DFID_NAME		= 0xa
+	FAN_EVENT_INFO_TYPE_PIDFD			= 0x4
+	FAN_EVENT_METADATA_LEN				= 0x18
+	FAN_EVENT_ON_CHILD				= 0x8000000
+	FAN_FS_ERROR					= 0x8000
+	FAN_INFO					= 0x20
+	FAN_MARK_ADD					= 0x1
+	FAN_MARK_DONT_FOLLOW				= 0x4
+	FAN_MARK_EVICTABLE				= 0x200
+	FAN_MARK_FILESYSTEM				= 0x100
+	FAN_MARK_FLUSH					= 0x80
+	FAN_MARK_IGNORE					= 0x400
+	FAN_MARK_IGNORED_MASK				= 0x20
+	FAN_MARK_IGNORED_SURV_MODIFY			= 0x40
+	FAN_MARK_IGNORE_SURV				= 0x440
+	FAN_MARK_INODE					= 0x0
+	FAN_MARK_MOUNT					= 0x10
+	FAN_MARK_ONLYDIR				= 0x8
+	FAN_MARK_REMOVE					= 0x2
+	FAN_MODIFY					= 0x2
+	FAN_MOVE					= 0xc0
+	FAN_MOVED_FROM					= 0x40
+	FAN_MOVED_TO					= 0x80
+	FAN_MOVE_SELF					= 0x800
+	FAN_NOFD					= -0x1
+	FAN_NONBLOCK					= 0x2
+	FAN_NOPIDFD					= -0x1
+	FAN_ONDIR					= 0x40000000
+	FAN_OPEN					= 0x20
+	FAN_OPEN_EXEC					= 0x1000
+	FAN_OPEN_EXEC_PERM				= 0x40000
+	FAN_OPEN_PERM					= 0x10000
+	FAN_Q_OVERFLOW					= 0x4000
+	FAN_RENAME					= 0x10000000
+	FAN_REPORT_DFID_NAME				= 0xc00
+	FAN_REPORT_DFID_NAME_TARGET			= 0x1e00
+	FAN_REPORT_DIR_FID				= 0x400
+	FAN_REPORT_FID					= 0x200
+	FAN_REPORT_NAME					= 0x800
+	FAN_REPORT_PIDFD				= 0x80
+	FAN_REPORT_TARGET_FID				= 0x1000
+	FAN_REPORT_TID					= 0x100
+	FAN_RESPONSE_INFO_AUDIT_RULE			= 0x1
+	FAN_RESPONSE_INFO_NONE				= 0x0
+	FAN_UNLIMITED_MARKS				= 0x20
+	FAN_UNLIMITED_QUEUE				= 0x10
+	FD_CLOEXEC					= 0x1
+	FD_SETSIZE					= 0x400
+	FF0						= 0x0
+	FF1						= 0x4000
+	FFDLY						= 0x4000
+	FIB_RULE_DEV_DETACHED				= 0x8
+	FIB_RULE_FIND_SADDR				= 0x10000
+	FIB_RULE_IIF_DETACHED				= 0x8
+	FIB_RULE_INVERT					= 0x2
+	FIB_RULE_OIF_DETACHED				= 0x10
+	FIB_RULE_PERMANENT				= 0x1
+	FIB_RULE_UNRESOLVED				= 0x4
+	FICLONE						= 0x80049409
+	FICLONERANGE					= 0x8020940d
+	FIDEDUPERANGE					= 0xc0189436
+	FLUSHO						= 0x800000
+	FSCRYPT_KEY_DESCRIPTOR_SIZE			= 0x8
+	FSCRYPT_KEY_DESC_PREFIX				= "fscrypt:"
+	FSCRYPT_KEY_DESC_PREFIX_SIZE			= 0x8
+	FSCRYPT_KEY_IDENTIFIER_SIZE			= 0x10
+	FSCRYPT_KEY_REMOVAL_STATUS_FLAG_FILES_BUSY	= 0x1
+	FSCRYPT_KEY_REMOVAL_STATUS_FLAG_OTHER_USERS	= 0x2
+	FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR		= 0x1
+	FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER		= 0x2
+	FSCRYPT_KEY_STATUS_ABSENT			= 0x1
+	FSCRYPT_KEY_STATUS_FLAG_ADDED_BY_SELF		= 0x1
+	FSCRYPT_KEY_STATUS_INCOMPLETELY_REMOVED		= 0x3
+	FSCRYPT_KEY_STATUS_PRESENT			= 0x2
+	FSCRYPT_MAX_KEY_SIZE				= 0x40
+	FSCRYPT_MODE_ADIANTUM				= 0x9
+	FSCRYPT_MODE_AES_128_CBC			= 0x5
+	FSCRYPT_MODE_AES_128_CTS			= 0x6
+	FSCRYPT_MODE_AES_256_CTS			= 0x4
+	FSCRYPT_MODE_AES_256_HCTR2			= 0xa
+	FSCRYPT_MODE_AES_256_XTS			= 0x1
+	FSCRYPT_MODE_SM4_CTS				= 0x8
+	FSCRYPT_MODE_SM4_XTS				= 0x7
+	FSCRYPT_POLICY_FLAGS_PAD_16			= 0x2
+	FSCRYPT_POLICY_FLAGS_PAD_32			= 0x3
+	FSCRYPT_POLICY_FLAGS_PAD_4			= 0x0
+	FSCRYPT_POLICY_FLAGS_PAD_8			= 0x1
+	FSCRYPT_POLICY_FLAGS_PAD_MASK			= 0x3
+	FSCRYPT_POLICY_FLAG_DIRECT_KEY			= 0x4
+	FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32		= 0x10
+	FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64		= 0x8
+	FSCRYPT_POLICY_V1				= 0x0
+	FSCRYPT_POLICY_V2				= 0x2
+	FS_ENCRYPTION_MODE_ADIANTUM			= 0x9
+	FS_ENCRYPTION_MODE_AES_128_CBC			= 0x5
+	FS_ENCRYPTION_MODE_AES_128_CTS			= 0x6
+	FS_ENCRYPTION_MODE_AES_256_CBC			= 0x3
+	FS_ENCRYPTION_MODE_AES_256_CTS			= 0x4
+	FS_ENCRYPTION_MODE_AES_256_GCM			= 0x2
+	FS_ENCRYPTION_MODE_AES_256_XTS			= 0x1
+	FS_ENCRYPTION_MODE_INVALID			= 0x0
+	FS_IOC_ADD_ENCRYPTION_KEY			= 0xc0506617
+	FS_IOC_ENABLE_VERITY				= 0x80806685
+	FS_IOC_GETFLAGS					= 0x40086601
+	FS_IOC_GET_ENCRYPTION_KEY_STATUS		= 0xc080661a
+	FS_IOC_GET_ENCRYPTION_NONCE			= 0x4010661b
+	FS_IOC_GET_ENCRYPTION_POLICY			= 0x800c6615
+	FS_IOC_GET_ENCRYPTION_POLICY_EX			= 0xc0096616
+	FS_IOC_GET_ENCRYPTION_PWSALT			= 0x80106614
+	FS_IOC_MEASURE_VERITY				= 0xc0046686
+	FS_IOC_READ_VERITY_METADATA			= 0xc0286687
+	FS_IOC_REMOVE_ENCRYPTION_KEY			= 0xc0406618
+	FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS		= 0xc0406619
+	FS_IOC_SETFLAGS					= 0x80086602
+	FS_IOC_SET_ENCRYPTION_POLICY			= 0x400c6613
+	FS_KEY_DESCRIPTOR_SIZE				= 0x8
+	FS_KEY_DESC_PREFIX				= "fscrypt:"
+	FS_KEY_DESC_PREFIX_SIZE				= 0x8
+	FS_MAX_KEY_SIZE					= 0x40
+	FS_POLICY_FLAGS_PAD_16				= 0x2
+	FS_POLICY_FLAGS_PAD_32				= 0x3
+	FS_POLICY_FLAGS_PAD_4				= 0x0
+	FS_POLICY_FLAGS_PAD_8				= 0x1
+	FS_POLICY_FLAGS_PAD_MASK			= 0x3
+	FS_POLICY_FLAGS_VALID				= 0x7
+	FS_VERITY_FL					= 0x100000
+	FS_VERITY_HASH_ALG_SHA256			= 0x1
+	FS_VERITY_HASH_ALG_SHA512			= 0x2
+	FS_VERITY_METADATA_TYPE_DESCRIPTOR		= 0x2
+	FS_VERITY_METADATA_TYPE_MERKLE_TREE		= 0x1
+	FS_VERITY_METADATA_TYPE_SIGNATURE		= 0x3
+	FUSE_SUPER_MAGIC				= 0x65735546
+	FUTEXFS_SUPER_MAGIC				= 0xbad1dea
+	F_ADD_SEALS					= 0x409
+	F_DUPFD						= 0x0
+	F_DUPFD_CLOEXEC					= 0x406
+	F_EXLCK						= 0x10
+	F_GETFD						= 0x1
+	F_GETFL						= 0x3
+	F_GETLEASE					= 0x401
+	F_GETLK						= 0x7
+	F_GETLK64					= 0x7
+	F_GETOWN					= 0x6
+	F_GETOWN_EX					= 0x10
+	F_GETPIPE_SZ					= 0x408
+	F_GETSIG					= 0xb
+	F_GET_FILE_RW_HINT				= 0x40d
+	F_GET_RW_HINT					= 0x40b
+	F_GET_SEALS					= 0x40a
+	F_LOCK						= 0x1
+	F_NOTIFY					= 0x402
+	F_OFD_GETLK					= 0x24
+	F_OFD_SETLK					= 0x25
+	F_OFD_SETLKW					= 0x26
+	F_OK						= 0x0
+	F_RDLCK						= 0x1
+	F_SEAL_FUTURE_WRITE				= 0x10
+	F_SEAL_GROW					= 0x4
+	F_SEAL_SEAL					= 0x1
+	F_SEAL_SHRINK					= 0x2
+	F_SEAL_WRITE					= 0x8
+	F_SETFD						= 0x2
+	F_SETFL						= 0x4
+	F_SETLEASE					= 0x400
+	F_SETLK						= 0x8
+	F_SETLK64					= 0x8
+	F_SETLKW					= 0x9
+	F_SETLKW64					= 0x9
+	F_SETOWN					= 0x5
+	F_SETOWN_EX					= 0xf
+	F_SETPIPE_SZ					= 0x407
+	F_SETSIG					= 0xa
+	F_SET_FILE_RW_HINT				= 0x40e
+	F_SET_RW_HINT					= 0x40c
+	F_SHLCK						= 0x20
+	F_TEST						= 0x3
+	F_TLOCK						= 0x2
+	F_ULOCK						= 0x0
+	F_UNLCK						= 0x8
+	F_WRLCK						= 0x2
+	GENL_ADMIN_PERM					= 0x1
+	GENL_CMD_CAP_DO					= 0x2
+	GENL_CMD_CAP_DUMP				= 0x4
+	GENL_CMD_CAP_HASPOL				= 0x8
+	GENL_HDRLEN					= 0x4
+	GENL_ID_CTRL					= 0x10
+	GENL_ID_PMCRAID					= 0x12
+	GENL_ID_VFS_DQUOT				= 0x11
+	GENL_MAX_ID					= 0x3ff
+	GENL_MIN_ID					= 0x10
+	GENL_NAMSIZ					= 0x10
+	GENL_START_ALLOC				= 0x13
+	GENL_UNS_ADMIN_PERM				= 0x10
+	GRND_INSECURE					= 0x4
+	GRND_NONBLOCK					= 0x1
+	GRND_RANDOM					= 0x2
+	HDIO_DRIVE_CMD					= 0x31f
+	HDIO_DRIVE_CMD_AEB				= 0x31e
+	HDIO_DRIVE_CMD_HDR_SIZE				= 0x4
+	HDIO_DRIVE_HOB_HDR_SIZE				= 0x8
+	HDIO_DRIVE_RESET				= 0x31c
+	HDIO_DRIVE_TASK					= 0x31e
+	HDIO_DRIVE_TASKFILE				= 0x31d
+	HDIO_DRIVE_TASK_HDR_SIZE			= 0x8
+	HDIO_GETGEO					= 0x301
+	HDIO_GET_32BIT					= 0x309
+	HDIO_GET_ACOUSTIC				= 0x30f
+	HDIO_GET_ADDRESS				= 0x310
+	HDIO_GET_BUSSTATE				= 0x31a
+	HDIO_GET_DMA					= 0x30b
+	HDIO_GET_IDENTITY				= 0x30d
+	HDIO_GET_KEEPSETTINGS				= 0x308
+	HDIO_GET_MULTCOUNT				= 0x304
+	HDIO_GET_NICE					= 0x30c
+	HDIO_GET_NOWERR					= 0x30a
+	HDIO_GET_QDMA					= 0x305
+	HDIO_GET_UNMASKINTR				= 0x302
+	HDIO_GET_WCACHE					= 0x30e
+	HDIO_OBSOLETE_IDENTITY				= 0x307
+	HDIO_SCAN_HWIF					= 0x328
+	HDIO_SET_32BIT					= 0x324
+	HDIO_SET_ACOUSTIC				= 0x32c
+	HDIO_SET_ADDRESS				= 0x32f
+	HDIO_SET_BUSSTATE				= 0x32d
+	HDIO_SET_DMA					= 0x326
+	HDIO_SET_KEEPSETTINGS				= 0x323
+	HDIO_SET_MULTCOUNT				= 0x321
+	HDIO_SET_NICE					= 0x329
+	HDIO_SET_NOWERR					= 0x325
+	HDIO_SET_PIO_MODE				= 0x327
+	HDIO_SET_QDMA					= 0x32e
+	HDIO_SET_UNMASKINTR				= 0x322
+	HDIO_SET_WCACHE					= 0x32b
+	HDIO_SET_XFER					= 0x306
+	HDIO_TRISTATE_HWIF				= 0x31b
+	HDIO_UNREGISTER_HWIF				= 0x32a
+	HIDIOCGRAWINFO					= 0x40084803
+	HIDIOCGRDESC					= 0x50044802
+	HIDIOCGRDESCSIZE				= 0x40044801
+	HID_MAX_DESCRIPTOR_SIZE				= 0x1000
+	HOSTFS_SUPER_MAGIC				= 0xc0ffee
+	HPFS_SUPER_MAGIC				= 0xf995e849
+	HUGETLBFS_MAGIC					= 0x958458f6
+	HUPCL						= 0x4000
+	IBSHIFT						= 0x10
+	ICANON						= 0x100
+	ICRNL						= 0x100
+	IEXTEN						= 0x400
+	IFA_F_DADFAILED					= 0x8
+	IFA_F_DEPRECATED				= 0x20
+	IFA_F_HOMEADDRESS				= 0x10
+	IFA_F_MANAGETEMPADDR				= 0x100
+	IFA_F_MCAUTOJOIN				= 0x400
+	IFA_F_NODAD					= 0x2
+	IFA_F_NOPREFIXROUTE				= 0x200
+	IFA_F_OPTIMISTIC				= 0x4
+	IFA_F_PERMANENT					= 0x80
+	IFA_F_SECONDARY					= 0x1
+	IFA_F_STABLE_PRIVACY				= 0x800
+	IFA_F_TEMPORARY					= 0x1
+	IFA_F_TENTATIVE					= 0x40
+	IFA_MAX						= 0xb
+	IFF_ALLMULTI					= 0x200
+	IFF_ATTACH_QUEUE				= 0x200
+	IFF_AUTOMEDIA					= 0x4000
+	IFF_BROADCAST					= 0x2
+	IFF_DEBUG					= 0x4
+	IFF_DETACH_QUEUE				= 0x400
+	IFF_DORMANT					= 0x20000
+	IFF_DYNAMIC					= 0x8000
+	IFF_ECHO					= 0x40000
+	IFF_LOOPBACK					= 0x8
+	IFF_LOWER_UP					= 0x10000
+	IFF_MASTER					= 0x400
+	IFF_MULTICAST					= 0x1000
+	IFF_MULTI_QUEUE					= 0x100
+	IFF_NAPI					= 0x10
+	IFF_NAPI_FRAGS					= 0x20
+	IFF_NOARP					= 0x80
+	IFF_NOFILTER					= 0x1000
+	IFF_NOTRAILERS					= 0x20
+	IFF_NO_CARRIER					= 0x40
+	IFF_NO_PI					= 0x1000
+	IFF_ONE_QUEUE					= 0x2000
+	IFF_PERSIST					= 0x800
+	IFF_POINTOPOINT					= 0x10
+	IFF_PORTSEL					= 0x2000
+	IFF_PROMISC					= 0x100
+	IFF_RUNNING					= 0x40
+	IFF_SLAVE					= 0x800
+	IFF_TAP						= 0x2
+	IFF_TUN						= 0x1
+	IFF_TUN_EXCL					= 0x8000
+	IFF_UP						= 0x1
+	IFF_VNET_HDR					= 0x4000
+	IFF_VOLATILE					= 0x70c5a
+	IFNAMSIZ					= 0x10
+	IGNBRK						= 0x1
+	IGNCR						= 0x80
+	IGNPAR						= 0x4
+	IMAXBEL						= 0x2000
+	INLCR						= 0x40
+	INPCK						= 0x10
+	IN_ACCESS					= 0x1
+	IN_ALL_EVENTS					= 0xfff
+	IN_ATTRIB					= 0x4
+	IN_CLASSA_HOST					= 0xffffff
+	IN_CLASSA_MAX					= 0x80
+	IN_CLASSA_NET					= 0xff000000
+	IN_CLASSA_NSHIFT				= 0x18
+	IN_CLASSB_HOST					= 0xffff
+	IN_CLASSB_MAX					= 0x10000
+	IN_CLASSB_NET					= 0xffff0000
+	IN_CLASSB_NSHIFT				= 0x10
+	IN_CLASSC_HOST					= 0xff
+	IN_CLASSC_NET					= 0xffffff00
+	IN_CLASSC_NSHIFT				= 0x8
+	IN_CLOEXEC					= 0x200000
+	IN_CLOSE					= 0x18
+	IN_CLOSE_NOWRITE				= 0x10
+	IN_CLOSE_WRITE					= 0x8
+	IN_CREATE					= 0x100
+	IN_DELETE					= 0x200
+	IN_DELETE_SELF					= 0x400
+	IN_DONT_FOLLOW					= 0x2000000
+	IN_EXCL_UNLINK					= 0x4000000
+	IN_IGNORED					= 0x8000
+	IN_ISDIR					= 0x40000000
+	IN_LOOPBACKNET					= 0x7f
+	IN_MASK_ADD					= 0x20000000
+	IN_MASK_CREATE					= 0x10000000
+	IN_MODIFY					= 0x2
+	IN_MOVE						= 0xc0
+	IN_MOVED_FROM					= 0x40
+	IN_MOVED_TO					= 0x80
+	IN_MOVE_SELF					= 0x800
+	IN_NONBLOCK					= 0x4
+	IN_ONESHOT					= 0x80000000
+	IN_ONLYDIR					= 0x1000000
+	IN_OPEN						= 0x20
+	IN_Q_OVERFLOW					= 0x4000
+	IN_UNMOUNT					= 0x2000
+	IOCTL_VM_SOCKETS_GET_LOCAL_CID			= 0x200007b9
+	IPPROTO_AH					= 0x33
+	IPPROTO_BEETPH					= 0x5e
+	IPPROTO_COMP					= 0x6c
+	IPPROTO_DCCP					= 0x21
+	IPPROTO_DSTOPTS					= 0x3c
+	IPPROTO_EGP					= 0x8
+	IPPROTO_ENCAP					= 0x62
+	IPPROTO_ESP					= 0x32
+	IPPROTO_ETHERNET				= 0x8f
+	IPPROTO_FRAGMENT				= 0x2c
+	IPPROTO_GRE					= 0x2f
+	IPPROTO_HOPOPTS					= 0x0
+	IPPROTO_ICMP					= 0x1
+	IPPROTO_ICMPV6					= 0x3a
+	IPPROTO_IDP					= 0x16
+	IPPROTO_IGMP					= 0x2
+	IPPROTO_IP					= 0x0
+	IPPROTO_IPIP					= 0x4
+	IPPROTO_IPV6					= 0x29
+	IPPROTO_L2TP					= 0x73
+	IPPROTO_MH					= 0x87
+	IPPROTO_MPLS					= 0x89
+	IPPROTO_MPTCP					= 0x106
+	IPPROTO_MTP					= 0x5c
+	IPPROTO_NONE					= 0x3b
+	IPPROTO_PIM					= 0x67
+	IPPROTO_PUP					= 0xc
+	IPPROTO_RAW					= 0xff
+	IPPROTO_ROUTING					= 0x2b
+	IPPROTO_RSVP					= 0x2e
+	IPPROTO_SCTP					= 0x84
+	IPPROTO_TCP					= 0x6
+	IPPROTO_TP					= 0x1d
+	IPPROTO_UDP					= 0x11
+	IPPROTO_UDPLITE					= 0x88
+	IPV6_2292DSTOPTS				= 0x4
+	IPV6_2292HOPLIMIT				= 0x8
+	IPV6_2292HOPOPTS				= 0x3
+	IPV6_2292PKTINFO				= 0x2
+	IPV6_2292PKTOPTIONS				= 0x6
+	IPV6_2292RTHDR					= 0x5
+	IPV6_ADDRFORM					= 0x1
+	IPV6_ADDR_PREFERENCES				= 0x48
+	IPV6_ADD_MEMBERSHIP				= 0x14
+	IPV6_AUTHHDR					= 0xa
+	IPV6_AUTOFLOWLABEL				= 0x46
+	IPV6_CHECKSUM					= 0x7
+	IPV6_DONTFRAG					= 0x3e
+	IPV6_DROP_MEMBERSHIP				= 0x15
+	IPV6_DSTOPTS					= 0x3b
+	IPV6_FLOW					= 0x11
+	IPV6_FREEBIND					= 0x4e
+	IPV6_HDRINCL					= 0x24
+	IPV6_HOPLIMIT					= 0x34
+	IPV6_HOPOPTS					= 0x36
+	IPV6_IPSEC_POLICY				= 0x22
+	IPV6_JOIN_ANYCAST				= 0x1b
+	IPV6_JOIN_GROUP					= 0x14
+	IPV6_LEAVE_ANYCAST				= 0x1c
+	IPV6_LEAVE_GROUP				= 0x15
+	IPV6_MINHOPCOUNT				= 0x49
+	IPV6_MTU					= 0x18
+	IPV6_MTU_DISCOVER				= 0x17
+	IPV6_MULTICAST_ALL				= 0x1d
+	IPV6_MULTICAST_HOPS				= 0x12
+	IPV6_MULTICAST_IF				= 0x11
+	IPV6_MULTICAST_LOOP				= 0x13
+	IPV6_NEXTHOP					= 0x9
+	IPV6_ORIGDSTADDR				= 0x4a
+	IPV6_PATHMTU					= 0x3d
+	IPV6_PKTINFO					= 0x32
+	IPV6_PMTUDISC_DO				= 0x2
+	IPV6_PMTUDISC_DONT				= 0x0
+	IPV6_PMTUDISC_INTERFACE				= 0x4
+	IPV6_PMTUDISC_OMIT				= 0x5
+	IPV6_PMTUDISC_PROBE				= 0x3
+	IPV6_PMTUDISC_WANT				= 0x1
+	IPV6_RECVDSTOPTS				= 0x3a
+	IPV6_RECVERR					= 0x19
+	IPV6_RECVERR_RFC4884				= 0x1f
+	IPV6_RECVFRAGSIZE				= 0x4d
+	IPV6_RECVHOPLIMIT				= 0x33
+	IPV6_RECVHOPOPTS				= 0x35
+	IPV6_RECVORIGDSTADDR				= 0x4a
+	IPV6_RECVPATHMTU				= 0x3c
+	IPV6_RECVPKTINFO				= 0x31
+	IPV6_RECVRTHDR					= 0x38
+	IPV6_RECVTCLASS					= 0x42
+	IPV6_ROUTER_ALERT				= 0x16
+	IPV6_ROUTER_ALERT_ISOLATE			= 0x1e
+	IPV6_RTHDR					= 0x39
+	IPV6_RTHDRDSTOPTS				= 0x37
+	IPV6_RTHDR_LOOSE				= 0x0
+	IPV6_RTHDR_STRICT				= 0x1
+	IPV6_RTHDR_TYPE_0				= 0x0
+	IPV6_RXDSTOPTS					= 0x3b
+	IPV6_RXHOPOPTS					= 0x36
+	IPV6_TCLASS					= 0x43
+	IPV6_TRANSPARENT				= 0x4b
+	IPV6_UNICAST_HOPS				= 0x10
+	IPV6_UNICAST_IF					= 0x4c
+	IPV6_USER_FLOW					= 0xe
+	IPV6_V6ONLY					= 0x1a
+	IPV6_XFRM_POLICY				= 0x23
+	IP_ADD_MEMBERSHIP				= 0x23
+	IP_ADD_SOURCE_MEMBERSHIP			= 0x27
+	IP_BIND_ADDRESS_NO_PORT				= 0x18
+	IP_BLOCK_SOURCE					= 0x26
+	IP_CHECKSUM					= 0x17
+	IP_DEFAULT_MULTICAST_LOOP			= 0x1
+	IP_DEFAULT_MULTICAST_TTL			= 0x1
+	IP_DF						= 0x4000
+	IP_DROP_MEMBERSHIP				= 0x24
+	IP_DROP_SOURCE_MEMBERSHIP			= 0x28
+	IP_FREEBIND					= 0xf
+	IP_HDRINCL					= 0x3
+	IP_IPSEC_POLICY					= 0x10
+	IP_LOCAL_PORT_RANGE				= 0x33
+	IP_MAXPACKET					= 0xffff
+	IP_MAX_MEMBERSHIPS				= 0x14
+	IP_MF						= 0x2000
+	IP_MINTTL					= 0x15
+	IP_MSFILTER					= 0x29
+	IP_MSS						= 0x240
+	IP_MTU						= 0xe
+	IP_MTU_DISCOVER					= 0xa
+	IP_MULTICAST_ALL				= 0x31
+	IP_MULTICAST_IF					= 0x20
+	IP_MULTICAST_LOOP				= 0x22
+	IP_MULTICAST_TTL				= 0x21
+	IP_NODEFRAG					= 0x16
+	IP_OFFMASK					= 0x1fff
+	IP_OPTIONS					= 0x4
+	IP_ORIGDSTADDR					= 0x14
+	IP_PASSSEC					= 0x12
+	IP_PKTINFO					= 0x8
+	IP_PKTOPTIONS					= 0x9
+	IP_PMTUDISC					= 0xa
+	IP_PMTUDISC_DO					= 0x2
+	IP_PMTUDISC_DONT				= 0x0
+	IP_PMTUDISC_INTERFACE				= 0x4
+	IP_PMTUDISC_OMIT				= 0x5
+	IP_PMTUDISC_PROBE				= 0x3
+	IP_PMTUDISC_WANT				= 0x1
+	IP_RECVERR					= 0xb
+	IP_RECVERR_RFC4884				= 0x1a
+	IP_RECVFRAGSIZE					= 0x19
+	IP_RECVOPTS					= 0x6
+	IP_RECVORIGDSTADDR				= 0x14
+	IP_RECVRETOPTS					= 0x7
+	IP_RECVTOS					= 0xd
+	IP_RECVTTL					= 0xc
+	IP_RETOPTS					= 0x7
+	IP_RF						= 0x8000
+	IP_ROUTER_ALERT					= 0x5
+	IP_TOS						= 0x1
+	IP_TRANSPARENT					= 0x13
+	IP_TTL						= 0x2
+	IP_UNBLOCK_SOURCE				= 0x25
+	IP_UNICAST_IF					= 0x32
+	IP_USER_FLOW					= 0xd
+	IP_XFRM_POLICY					= 0x11
+	ISIG						= 0x80
+	ISOFS_SUPER_MAGIC				= 0x9660
+	ISTRIP						= 0x20
+	ITIMER_PROF					= 0x2
+	ITIMER_REAL					= 0x0
+	ITIMER_VIRTUAL					= 0x1
+	IUCLC						= 0x1000
+	IUTF8						= 0x4000
+	IXANY						= 0x800
+	IXOFF						= 0x400
+	IXON						= 0x200
+	JFFS2_SUPER_MAGIC				= 0x72b6
+	KCMPROTO_CONNECTED				= 0x0
+	KCM_RECV_DISABLE				= 0x1
+	KEXEC_ARCH_386					= 0x30000
+	KEXEC_ARCH_68K					= 0x40000
+	KEXEC_ARCH_AARCH64				= 0xb70000
+	KEXEC_ARCH_ARM					= 0x280000
+	KEXEC_ARCH_DEFAULT				= 0x0
+	KEXEC_ARCH_IA_64				= 0x320000
+	KEXEC_ARCH_LOONGARCH				= 0x1020000
+	KEXEC_ARCH_MASK					= 0xffff0000
+	KEXEC_ARCH_MIPS					= 0x80000
+	KEXEC_ARCH_MIPS_LE				= 0xa0000
+	KEXEC_ARCH_PARISC				= 0xf0000
+	KEXEC_ARCH_PPC					= 0x140000
+	KEXEC_ARCH_PPC64				= 0x150000
+	KEXEC_ARCH_RISCV				= 0xf30000
+	KEXEC_ARCH_S390					= 0x160000
+	KEXEC_ARCH_SH					= 0x2a0000
+	KEXEC_ARCH_SW64					= 0x99160000
+	KEXEC_ARCH_X86_64				= 0x3e0000
+	KEXEC_FILE_NO_INITRAMFS				= 0x4
+	KEXEC_FILE_ON_CRASH				= 0x2
+	KEXEC_FILE_UNLOAD				= 0x1
+	KEXEC_ON_CRASH					= 0x1
+	KEXEC_PRESERVE_CONTEXT				= 0x2
+	KEXEC_SEGMENT_MAX				= 0x10
+	KEXEC_UPDATE_ELFCOREHDR				= 0x4
+	KEYCTL_ASSUME_AUTHORITY				= 0x10
+	KEYCTL_CAPABILITIES				= 0x1f
+	KEYCTL_CAPS0_BIG_KEY				= 0x10
+	KEYCTL_CAPS0_CAPABILITIES			= 0x1
+	KEYCTL_CAPS0_DIFFIE_HELLMAN			= 0x4
+	KEYCTL_CAPS0_INVALIDATE				= 0x20
+	KEYCTL_CAPS0_MOVE				= 0x80
+	KEYCTL_CAPS0_PERSISTENT_KEYRINGS		= 0x2
+	KEYCTL_CAPS0_PUBLIC_KEY				= 0x8
+	KEYCTL_CAPS0_RESTRICT_KEYRING			= 0x40
+	KEYCTL_CAPS1_NOTIFICATIONS			= 0x4
+	KEYCTL_CAPS1_NS_KEYRING_NAME			= 0x1
+	KEYCTL_CAPS1_NS_KEY_TAG				= 0x2
+	KEYCTL_CHOWN					= 0x4
+	KEYCTL_CLEAR					= 0x7
+	KEYCTL_DESCRIBE					= 0x6
+	KEYCTL_DH_COMPUTE				= 0x17
+	KEYCTL_GET_KEYRING_ID				= 0x0
+	KEYCTL_GET_PERSISTENT				= 0x16
+	KEYCTL_GET_SECURITY				= 0x11
+	KEYCTL_INSTANTIATE				= 0xc
+	KEYCTL_INSTANTIATE_IOV				= 0x14
+	KEYCTL_INVALIDATE				= 0x15
+	KEYCTL_JOIN_SESSION_KEYRING			= 0x1
+	KEYCTL_LINK					= 0x8
+	KEYCTL_MOVE					= 0x1e
+	KEYCTL_MOVE_EXCL				= 0x1
+	KEYCTL_NEGATE					= 0xd
+	KEYCTL_PKEY_DECRYPT				= 0x1a
+	KEYCTL_PKEY_ENCRYPT				= 0x19
+	KEYCTL_PKEY_QUERY				= 0x18
+	KEYCTL_PKEY_SIGN				= 0x1b
+	KEYCTL_PKEY_VERIFY				= 0x1c
+	KEYCTL_READ					= 0xb
+	KEYCTL_REJECT					= 0x13
+	KEYCTL_RESTRICT_KEYRING				= 0x1d
+	KEYCTL_REVOKE					= 0x3
+	KEYCTL_SEARCH					= 0xa
+	KEYCTL_SESSION_TO_PARENT			= 0x12
+	KEYCTL_SETPERM					= 0x5
+	KEYCTL_SET_REQKEY_KEYRING			= 0xe
+	KEYCTL_SET_TIMEOUT				= 0xf
+	KEYCTL_SUPPORTS_DECRYPT				= 0x2
+	KEYCTL_SUPPORTS_ENCRYPT				= 0x1
+	KEYCTL_SUPPORTS_SIGN				= 0x4
+	KEYCTL_SUPPORTS_VERIFY				= 0x8
+	KEYCTL_UNLINK					= 0x9
+	KEYCTL_UPDATE					= 0x2
+	KEYCTL_WATCH_KEY				= 0x20
+	KEY_REQKEY_DEFL_DEFAULT				= 0x0
+	KEY_REQKEY_DEFL_GROUP_KEYRING			= 0x6
+	KEY_REQKEY_DEFL_NO_CHANGE			= -0x1
+	KEY_REQKEY_DEFL_PROCESS_KEYRING			= 0x2
+	KEY_REQKEY_DEFL_REQUESTOR_KEYRING		= 0x7
+	KEY_REQKEY_DEFL_SESSION_KEYRING			= 0x3
+	KEY_REQKEY_DEFL_THREAD_KEYRING			= 0x1
+	KEY_REQKEY_DEFL_USER_KEYRING			= 0x4
+	KEY_REQKEY_DEFL_USER_SESSION_KEYRING		= 0x5
+	KEY_SPEC_GROUP_KEYRING				= -0x6
+	KEY_SPEC_PROCESS_KEYRING			= -0x2
+	KEY_SPEC_REQKEY_AUTH_KEY			= -0x7
+	KEY_SPEC_REQUESTOR_KEYRING			= -0x8
+	KEY_SPEC_SESSION_KEYRING			= -0x3
+	KEY_SPEC_THREAD_KEYRING				= -0x1
+	KEY_SPEC_USER_KEYRING				= -0x4
+	KEY_SPEC_USER_SESSION_KEYRING			= -0x5
+	LINUX_REBOOT_CMD_CAD_OFF			= 0x0
+	LINUX_REBOOT_CMD_CAD_ON				= 0x89abcdef
+	LINUX_REBOOT_CMD_HALT				= 0xcdef0123
+	LINUX_REBOOT_CMD_KEXEC				= 0x45584543
+	LINUX_REBOOT_CMD_POWER_OFF			= 0x4321fedc
+	LINUX_REBOOT_CMD_RESTART			= 0x1234567
+	LINUX_REBOOT_CMD_RESTART2			= 0xa1b2c3d4
+	LINUX_REBOOT_CMD_SW_SUSPEND			= 0xd000fce2
+	LINUX_REBOOT_MAGIC1				= 0xfee1dead
+	LINUX_REBOOT_MAGIC2				= 0x28121969
+	LOCK_EX						= 0x2
+	LOCK_NB						= 0x4
+	LOCK_SH						= 0x1
+	LOCK_UN						= 0x8
+	LOOP_CLR_FD					= 0x4c01
+	LOOP_CONFIGURE					= 0x4c0a
+	LOOP_CTL_ADD					= 0x4c80
+	LOOP_CTL_GET_FREE				= 0x4c82
+	LOOP_CTL_REMOVE					= 0x4c81
+	LOOP_GET_STATUS					= 0x4c03
+	LOOP_GET_STATUS64				= 0x4c05
+	LOOP_SET_BLOCK_SIZE				= 0x4c09
+	LOOP_SET_CAPACITY				= 0x4c07
+	LOOP_SET_DIRECT_IO				= 0x4c08
+	LOOP_SET_FD					= 0x4c00
+	LOOP_SET_STATUS					= 0x4c02
+	LOOP_SET_STATUS64				= 0x4c04
+	LOOP_SET_STATUS_CLEARABLE_FLAGS			= 0x4
+	LOOP_SET_STATUS_SETTABLE_FLAGS			= 0xc
+	LO_KEY_SIZE					= 0x20
+	LO_NAME_SIZE					= 0x40
+	LWTUNNEL_IP6_MAX				= 0x8
+	LWTUNNEL_IP_MAX					= 0x8
+	LWTUNNEL_IP_OPTS_MAX				= 0x3
+	LWTUNNEL_IP_OPT_ERSPAN_MAX			= 0x4
+	LWTUNNEL_IP_OPT_GENEVE_MAX			= 0x3
+	LWTUNNEL_IP_OPT_VXLAN_MAX			= 0x1
+	MADV_COLD					= 0x14
+	MADV_COLLAPSE					= 0x19
+	MADV_DODUMP					= 0x11
+	MADV_DOFORK					= 0xb
+	MADV_DONTDUMP					= 0x10
+	MADV_DONTFORK					= 0xa
+	MADV_DONTNEED					= 0x6
+	MADV_DONTNEED_LOCKED				= 0x18
+	MADV_FREE					= 0x8
+	MADV_HUGEPAGE					= 0xe
+	MADV_HWPOISON					= 0x64
+	MADV_KEEPONFORK					= 0x13
+	MADV_MERGEABLE					= 0xc
+	MADV_NOHUGEPAGE					= 0xf
+	MADV_NORMAL					= 0x0
+	MADV_PAGEOUT					= 0x15
+	MADV_POPULATE_READ				= 0x16
+	MADV_POPULATE_WRITE				= 0x17
+	MADV_RANDOM					= 0x1
+	MADV_REMOVE					= 0x9
+	MADV_SEQUENTIAL					= 0x2
+	MADV_UNMERGEABLE				= 0xd
+	MADV_WILLNEED					= 0x3
+	MADV_WIPEONFORK					= 0x12
+	MAP_ANON					= 0x10
+	MAP_ANONYMOUS					= 0x10
+	MAP_DENYWRITE					= 0x2000
+	MAP_EXECUTABLE					= 0x4000
+	MAP_FILE					= 0x0
+	MAP_FIXED					= 0x100
+	MAP_FIXED_NOREPLACE				= 0x200000
+	MAP_GROWSDOWN					= 0x1000
+	MAP_HUGETLB					= 0x100000
+	MAP_HUGE_MASK					= 0x3f
+	MAP_HUGE_SHIFT					= 0x1a
+	MAP_LOCKED					= 0x8000
+	MAP_NONBLOCK					= 0x40000
+	MAP_NORESERVE					= 0x10000
+	MAP_POPULATE					= 0x20000
+	MAP_PRIVATE					= 0x2
+	MAP_SHARED					= 0x1
+	MAP_SHARED_VALIDATE				= 0x3
+	MAP_STACK					= 0x80000
+	MAP_TYPE					= 0xf
+	MCAST_BLOCK_SOURCE				= 0x2b
+	MCAST_EXCLUDE					= 0x0
+	MCAST_INCLUDE					= 0x1
+	MCAST_JOIN_GROUP				= 0x2a
+	MCAST_JOIN_SOURCE_GROUP				= 0x2e
+	MCAST_LEAVE_GROUP				= 0x2d
+	MCAST_LEAVE_SOURCE_GROUP			= 0x2f
+	MCAST_MSFILTER					= 0x30
+	MCAST_UNBLOCK_SOURCE				= 0x2c
+	MCL_CURRENT					= 0x2000
+	MCL_FUTURE					= 0x4000
+	MCL_ONFAULT					= 0x8000
+	MEMERASE					= 0x80084d02
+	MEMERASE64					= 0x80104d14
+	MEMGETBADBLOCK					= 0x80084d0b
+	MEMGETINFO					= 0x40204d01
+	MEMGETOOBSEL					= 0x40c84d0a
+	MEMGETREGIONCOUNT				= 0x40044d07
+	MEMGETREGIONINFO				= 0xc0104d08
+	MEMISLOCKED					= 0x40084d17
+	MEMLOCK						= 0x80084d05
+	MEMREAD						= 0xc0404d1a
+	MEMREADOOB					= 0xc0104d04
+	MEMREADOOB64					= 0xc0184d16
+	MEMSETBADBLOCK					= 0x80084d0c
+	MEMUNLOCK					= 0x80084d06
+	MEMWRITE					= 0xc0304d18
+	MEMWRITEOOB					= 0xc0104d03
+	MEMWRITEOOB64					= 0xc0184d15
+	MFD_ALLOW_SEALING				= 0x2
+	MFD_CLOEXEC					= 0x1
+	MFD_EXEC					= 0x10
+	MFD_HUGETLB					= 0x4
+	MFD_HUGE_16GB					= 0x88000000
+	MFD_HUGE_16MB					= 0x60000000
+	MFD_HUGE_1GB					= 0x78000000
+	MFD_HUGE_1MB					= 0x50000000
+	MFD_HUGE_256MB					= 0x70000000
+	MFD_HUGE_2GB					= 0x7c000000
+	MFD_HUGE_2MB					= 0x54000000
+	MFD_HUGE_32MB					= 0x64000000
+	MFD_HUGE_512KB					= 0x4c000000
+	MFD_HUGE_512MB					= 0x74000000
+	MFD_HUGE_64KB					= 0x40000000
+	MFD_HUGE_8MB					= 0x5c000000
+	MFD_HUGE_MASK					= 0x3f
+	MFD_HUGE_SHIFT					= 0x1a
+	MFD_NOEXEC_SEAL					= 0x8
+	MINIX2_SUPER_MAGIC				= 0x2468
+	MINIX2_SUPER_MAGIC2				= 0x2478
+	MINIX3_SUPER_MAGIC				= 0x4d5a
+	MINIX_SUPER_MAGIC				= 0x137f
+	MINIX_SUPER_MAGIC2				= 0x138f
+	MNT_DETACH					= 0x2
+	MNT_EXPIRE					= 0x4
+	MNT_FORCE					= 0x1
+	MODULE_INIT_COMPRESSED_FILE			= 0x4
+	MODULE_INIT_IGNORE_MODVERSIONS			= 0x1
+	MODULE_INIT_IGNORE_VERMAGIC			= 0x2
+	MOUNT_ATTR_IDMAP				= 0x100000
+	MOUNT_ATTR_NOATIME				= 0x10
+	MOUNT_ATTR_NODEV				= 0x4
+	MOUNT_ATTR_NODIRATIME				= 0x80
+	MOUNT_ATTR_NOEXEC				= 0x8
+	MOUNT_ATTR_NOSUID				= 0x2
+	MOUNT_ATTR_NOSYMFOLLOW				= 0x200000
+	MOUNT_ATTR_RDONLY				= 0x1
+	MOUNT_ATTR_RELATIME				= 0x0
+	MOUNT_ATTR_SIZE_VER0				= 0x20
+	MOUNT_ATTR_STRICTATIME				= 0x20
+	MOUNT_ATTR__ATIME				= 0x70
+	MREMAP_DONTUNMAP				= 0x4
+	MREMAP_FIXED					= 0x2
+	MREMAP_MAYMOVE					= 0x1
+	MSDOS_SUPER_MAGIC				= 0x4d44
+	MSG_BATCH					= 0x40000
+	MSG_CMSG_CLOEXEC				= 0x40000000
+	MSG_CONFIRM					= 0x800
+	MSG_CTRUNC					= 0x8
+	MSG_DONTROUTE					= 0x4
+	MSG_DONTWAIT					= 0x40
+	MSG_EOR						= 0x80
+	MSG_ERRQUEUE					= 0x2000
+	MSG_FASTOPEN					= 0x20000000
+	MSG_FIN						= 0x200
+	MSG_MORE					= 0x8000
+	MSG_NOSIGNAL					= 0x4000
+	MSG_OOB						= 0x1
+	MSG_PEEK					= 0x2
+	MSG_PROXY					= 0x10
+	MSG_RST						= 0x1000
+	MSG_SYN						= 0x400
+	MSG_TRUNC					= 0x20
+	MSG_TRYHARD					= 0x4
+	MSG_WAITALL					= 0x100
+	MSG_WAITFORONE					= 0x10000
+	MSG_ZEROCOPY					= 0x4000000
+	MS_ACTIVE					= 0x40000000
+	MS_ASYNC					= 0x1
+	MS_BIND						= 0x1000
+	MS_BORN						= 0x20000000
+	MS_DIRSYNC					= 0x80
+	MS_INVALIDATE					= 0x4
+	MS_I_VERSION					= 0x800000
+	MS_KERNMOUNT					= 0x400000
+	MS_LAZYTIME					= 0x2000000
+	MS_MANDLOCK					= 0x40
+	MS_MGC_MSK					= 0xffff0000
+	MS_MGC_VAL					= 0xc0ed0000
+	MS_MOVE						= 0x2000
+	MS_NOATIME					= 0x400
+	MS_NODEV					= 0x4
+	MS_NODIRATIME					= 0x800
+	MS_NOEXEC					= 0x8
+	MS_NOREMOTELOCK					= 0x8000000
+	MS_NOSEC					= 0x10000000
+	MS_NOSUID					= 0x2
+	MS_NOSYMFOLLOW					= 0x100
+	MS_NOUSER					= -0x80000000
+	MS_POSIXACL					= 0x10000
+	MS_PRIVATE					= 0x40000
+	MS_RDONLY					= 0x1
+	MS_REC						= 0x4000
+	MS_RELATIME					= 0x200000
+	MS_REMOUNT					= 0x20
+	MS_RMT_MASK					= 0x2800051
+	MS_SHARED					= 0x100000
+	MS_SILENT					= 0x8000
+	MS_SLAVE					= 0x80000
+	MS_STRICTATIME					= 0x1000000
+	MS_SUBMOUNT					= 0x4000000
+	MS_SYNC						= 0x2
+	MS_SYNCHRONOUS					= 0x10
+	MS_UNBINDABLE					= 0x20000
+	MS_VERBOSE					= 0x8000
+	MTDFILEMODE					= 0x20004d13
+	MTD_ABSENT					= 0x0
+	MTD_BIT_WRITEABLE				= 0x800
+	MTD_CAP_NANDFLASH				= 0x400
+	MTD_CAP_NORFLASH				= 0xc00
+	MTD_CAP_NVRAM					= 0x1c00
+	MTD_CAP_RAM					= 0x1c00
+	MTD_CAP_ROM					= 0x0
+	MTD_DATAFLASH					= 0x6
+	MTD_INODE_FS_MAGIC				= 0x11307854
+	MTD_MAX_ECCPOS_ENTRIES				= 0x40
+	MTD_MAX_OOBFREE_ENTRIES				= 0x8
+	MTD_MLCNANDFLASH				= 0x8
+	MTD_NANDECC_AUTOPLACE				= 0x2
+	MTD_NANDECC_AUTOPL_USR				= 0x4
+	MTD_NANDECC_OFF					= 0x0
+	MTD_NANDECC_PLACE				= 0x1
+	MTD_NANDECC_PLACEONLY				= 0x3
+	MTD_NANDFLASH					= 0x4
+	MTD_NORFLASH					= 0x3
+	MTD_NO_ERASE					= 0x1000
+	MTD_OTP_FACTORY					= 0x1
+	MTD_OTP_OFF					= 0x0
+	MTD_OTP_USER					= 0x2
+	MTD_POWERUP_LOCK				= 0x2000
+	MTD_RAM						= 0x1
+	MTD_ROM						= 0x2
+	MTD_SLC_ON_MLC_EMULATION			= 0x4000
+	MTD_UBIVOLUME					= 0x7
+	MTD_WRITEABLE					= 0x400
+	NAME_MAX					= 0xff
+	NCP_SUPER_MAGIC					= 0x564c
+	NETLINK_ADD_MEMBERSHIP				= 0x1
+	NETLINK_AUDIT					= 0x9
+	NETLINK_BROADCAST_ERROR				= 0x4
+	NETLINK_CAP_ACK					= 0xa
+	NETLINK_CONNECTOR				= 0xb
+	NETLINK_CRYPTO					= 0x15
+	NETLINK_DNRTMSG					= 0xe
+	NETLINK_DROP_MEMBERSHIP				= 0x2
+	NETLINK_ECRYPTFS				= 0x13
+	NETLINK_EXT_ACK					= 0xb
+	NETLINK_FIB_LOOKUP				= 0xa
+	NETLINK_FIREWALL				= 0x3
+	NETLINK_GENERIC					= 0x10
+	NETLINK_GET_STRICT_CHK				= 0xc
+	NETLINK_INET_DIAG				= 0x4
+	NETLINK_IP6_FW					= 0xd
+	NETLINK_ISCSI					= 0x8
+	NETLINK_KOBJECT_UEVENT				= 0xf
+	NETLINK_LISTEN_ALL_NSID				= 0x8
+	NETLINK_LIST_MEMBERSHIPS			= 0x9
+	NETLINK_NETFILTER				= 0xc
+	NETLINK_NFLOG					= 0x5
+	NETLINK_NO_ENOBUFS				= 0x5
+	NETLINK_PKTINFO					= 0x3
+	NETLINK_RDMA					= 0x14
+	NETLINK_ROUTE					= 0x0
+	NETLINK_RX_RING					= 0x6
+	NETLINK_SCSITRANSPORT				= 0x12
+	NETLINK_SELINUX					= 0x7
+	NETLINK_SMC					= 0x16
+	NETLINK_SOCK_DIAG				= 0x4
+	NETLINK_TX_RING					= 0x7
+	NETLINK_UNUSED					= 0x1
+	NETLINK_USERSOCK				= 0x2
+	NETLINK_XFRM					= 0x6
+	NETNSA_MAX					= 0x5
+	NETNSA_NSID_NOT_ASSIGNED			= -0x1
+	NFC_ATR_REQ_GB_MAXSIZE				= 0x30
+	NFC_ATR_REQ_MAXSIZE				= 0x40
+	NFC_ATR_RES_GB_MAXSIZE				= 0x2f
+	NFC_ATR_RES_MAXSIZE				= 0x40
+	NFC_COMM_ACTIVE					= 0x0
+	NFC_COMM_PASSIVE				= 0x1
+	NFC_DEVICE_NAME_MAXSIZE				= 0x8
+	NFC_DIRECTION_RX				= 0x0
+	NFC_DIRECTION_TX				= 0x1
+	NFC_FIRMWARE_NAME_MAXSIZE			= 0x20
+	NFC_GB_MAXSIZE					= 0x30
+	NFC_GENL_MCAST_EVENT_NAME			= "events"
+	NFC_GENL_NAME					= "nfc"
+	NFC_GENL_VERSION				= 0x1
+	NFC_HEADER_SIZE					= 0x1
+	NFC_ISO15693_UID_MAXSIZE			= 0x8
+	NFC_LLCP_MAX_SERVICE_NAME			= 0x3f
+	NFC_LLCP_MIUX					= 0x1
+	NFC_LLCP_REMOTE_LTO				= 0x3
+	NFC_LLCP_REMOTE_MIU				= 0x2
+	NFC_LLCP_REMOTE_RW				= 0x4
+	NFC_LLCP_RW					= 0x0
+	NFC_NFCID1_MAXSIZE				= 0xa
+	NFC_NFCID2_MAXSIZE				= 0x8
+	NFC_NFCID3_MAXSIZE				= 0xa
+	NFC_PROTO_FELICA				= 0x3
+	NFC_PROTO_FELICA_MASK				= 0x8
+	NFC_PROTO_ISO14443				= 0x4
+	NFC_PROTO_ISO14443_B				= 0x6
+	NFC_PROTO_ISO14443_B_MASK			= 0x40
+	NFC_PROTO_ISO14443_MASK				= 0x10
+	NFC_PROTO_ISO15693				= 0x7
+	NFC_PROTO_ISO15693_MASK				= 0x80
+	NFC_PROTO_JEWEL					= 0x1
+	NFC_PROTO_JEWEL_MASK				= 0x2
+	NFC_PROTO_MAX					= 0x8
+	NFC_PROTO_MIFARE				= 0x2
+	NFC_PROTO_MIFARE_MASK				= 0x4
+	NFC_PROTO_NFC_DEP				= 0x5
+	NFC_PROTO_NFC_DEP_MASK				= 0x20
+	NFC_RAW_HEADER_SIZE				= 0x2
+	NFC_RF_INITIATOR				= 0x0
+	NFC_RF_NONE					= 0x2
+	NFC_RF_TARGET					= 0x1
+	NFC_SENSB_RES_MAXSIZE				= 0xc
+	NFC_SENSF_RES_MAXSIZE				= 0x12
+	NFC_SE_DISABLED					= 0x0
+	NFC_SE_EMBEDDED					= 0x2
+	NFC_SE_ENABLED					= 0x1
+	NFC_SE_UICC					= 0x1
+	NFC_SOCKPROTO_LLCP				= 0x1
+	NFC_SOCKPROTO_MAX				= 0x2
+	NFC_SOCKPROTO_RAW				= 0x0
+	NFDBITS						= 0x40
+	NFNETLINK_V0					= 0x0
+	NFNLGRP_ACCT_QUOTA				= 0x8
+	NFNLGRP_CONNTRACK_DESTROY			= 0x3
+	NFNLGRP_CONNTRACK_EXP_DESTROY			= 0x6
+	NFNLGRP_CONNTRACK_EXP_NEW			= 0x4
+	NFNLGRP_CONNTRACK_EXP_UPDATE			= 0x5
+	NFNLGRP_CONNTRACK_NEW				= 0x1
+	NFNLGRP_CONNTRACK_UPDATE			= 0x2
+	NFNLGRP_MAX					= 0x9
+	NFNLGRP_NFTABLES				= 0x7
+	NFNLGRP_NFTRACE					= 0x9
+	NFNLGRP_NONE					= 0x0
+	NFNL_BATCH_MAX					= 0x1
+	NFNL_MSG_BATCH_BEGIN				= 0x10
+	NFNL_MSG_BATCH_END				= 0x11
+	NFNL_NFA_NEST					= 0x8000
+	NFNL_SUBSYS_ACCT				= 0x7
+	NFNL_SUBSYS_COUNT				= 0xd
+	NFNL_SUBSYS_CTHELPER				= 0x9
+	NFNL_SUBSYS_CTNETLINK				= 0x1
+	NFNL_SUBSYS_CTNETLINK_EXP			= 0x2
+	NFNL_SUBSYS_CTNETLINK_TIMEOUT			= 0x8
+	NFNL_SUBSYS_HOOK				= 0xc
+	NFNL_SUBSYS_IPSET				= 0x6
+	NFNL_SUBSYS_NFTABLES				= 0xa
+	NFNL_SUBSYS_NFT_COMPAT				= 0xb
+	NFNL_SUBSYS_NONE				= 0x0
+	NFNL_SUBSYS_OSF					= 0x5
+	NFNL_SUBSYS_QUEUE				= 0x3
+	NFNL_SUBSYS_ULOG				= 0x4
+	NFS_SUPER_MAGIC					= 0x6969
+	NILFS_SUPER_MAGIC				= 0x3434
+	NL0						= 0x0
+	NL1						= 0x100
+	NL2						= 0x200
+	NL3						= 0x300
+	NLA_ALIGNTO					= 0x4
+	NLA_F_NESTED					= 0x8000
+	NLA_F_NET_BYTEORDER				= 0x4000
+	NLA_HDRLEN					= 0x4
+	NLDLY						= 0x300
+	NLMSG_ALIGNTO					= 0x4
+	NLMSG_DONE					= 0x3
+	NLMSG_ERROR					= 0x2
+	NLMSG_HDRLEN					= 0x10
+	NLMSG_MIN_TYPE					= 0x10
+	NLMSG_NOOP					= 0x1
+	NLMSG_OVERRUN					= 0x4
+	NLM_F_ACK					= 0x4
+	NLM_F_ACK_TLVS					= 0x200
+	NLM_F_APPEND					= 0x800
+	NLM_F_ATOMIC					= 0x400
+	NLM_F_BULK					= 0x200
+	NLM_F_CAPPED					= 0x100
+	NLM_F_CREATE					= 0x400
+	NLM_F_DUMP					= 0x300
+	NLM_F_DUMP_FILTERED				= 0x20
+	NLM_F_DUMP_INTR					= 0x10
+	NLM_F_ECHO					= 0x8
+	NLM_F_EXCL					= 0x200
+	NLM_F_MATCH					= 0x200
+	NLM_F_MULTI					= 0x2
+	NLM_F_NONREC					= 0x100
+	NLM_F_REPLACE					= 0x100
+	NLM_F_REQUEST					= 0x1
+	NLM_F_ROOT					= 0x100
+	NOFLSH						= 0x80000000
+	NSFS_MAGIC					= 0x6e736673
+	NS_GET_NSTYPE					= 0x2000b703
+	NS_GET_OWNER_UID				= 0x2000b704
+	NS_GET_PARENT					= 0x2000b702
+	NS_GET_USERNS					= 0x2000b701
+	OCFS2_SUPER_MAGIC				= 0x7461636f
+	OCRNL						= 0x8
+	OFDEL						= 0x80
+	OFILL						= 0x40
+	OLCUC						= 0x4
+	ONLCR						= 0x2
+	ONLRET						= 0x20
+	ONOCR						= 0x10
+	OPENPROM_SUPER_MAGIC				= 0x9fa1
+	OPOST						= 0x1
+	OTPERASE					= 0x800c4d19
+	OTPGETREGIONCOUNT				= 0x80044d0e
+	OTPGETREGIONINFO				= 0x800c4d0f
+	OTPLOCK						= 0x400c4d10
+	OTPSELECT					= 0x40044d0d
+	OVERLAYFS_SUPER_MAGIC				= 0x794c7630
+	O_ACCMODE					= 0x3
+	O_APPEND					= 0x8
+	O_ASYNC						= 0x2000
+	O_CLOEXEC					= 0x200000
+	O_CREAT						= 0x200
+	O_DIRECT					= 0x80000
+	O_DIRECTORY					= 0x8000
+	O_DSYNC						= 0x4000
+	O_EXCL						= 0x800
+	O_FSYNC						= 0x404000
+	O_LARGEFILE					= 0x0
+	O_NDELAY					= 0x4
+	O_NOATIME					= 0x100000
+	O_NOCTTY					= 0x1000
+	O_NOFOLLOW					= 0x10000
+	O_NONBLOCK					= 0x4
+	O_PATH						= 0x800000
+	O_RDONLY					= 0x0
+	O_RDWR						= 0x2
+	O_RSYNC						= 0x404000
+	O_SYNC						= 0x404000
+	O_TMPFILE					= 0x1008000
+	O_TRUNC						= 0x400
+	O_WRONLY					= 0x1
+	PACKET_ADD_MEMBERSHIP				= 0x1
+	PACKET_AUXDATA					= 0x8
+	PACKET_BROADCAST				= 0x1
+	PACKET_COPY_THRESH				= 0x7
+	PACKET_DROP_MEMBERSHIP				= 0x2
+	PACKET_FANOUT					= 0x12
+	PACKET_FANOUT_CBPF				= 0x6
+	PACKET_FANOUT_CPU				= 0x2
+	PACKET_FANOUT_DATA				= 0x16
+	PACKET_FANOUT_EBPF				= 0x7
+	PACKET_FANOUT_FLAG_DEFRAG			= 0x8000
+	PACKET_FANOUT_FLAG_IGNORE_OUTGOING		= 0x4000
+	PACKET_FANOUT_FLAG_ROLLOVER			= 0x1000
+	PACKET_FANOUT_FLAG_UNIQUEID			= 0x2000
+	PACKET_FANOUT_HASH				= 0x0
+	PACKET_FANOUT_LB				= 0x1
+	PACKET_FANOUT_QM				= 0x5
+	PACKET_FANOUT_RND				= 0x4
+	PACKET_FANOUT_ROLLOVER				= 0x3
+	PACKET_FASTROUTE				= 0x6
+	PACKET_HDRLEN					= 0xb
+	PACKET_HOST					= 0x0
+	PACKET_IGNORE_OUTGOING				= 0x17
+	PACKET_KERNEL					= 0x7
+	PACKET_LOOPBACK					= 0x5
+	PACKET_LOSS					= 0xe
+	PACKET_MR_ALLMULTI				= 0x2
+	PACKET_MR_MULTICAST				= 0x0
+	PACKET_MR_PROMISC				= 0x1
+	PACKET_MR_UNICAST				= 0x3
+	PACKET_MULTICAST				= 0x2
+	PACKET_ORIGDEV					= 0x9
+	PACKET_OTHERHOST				= 0x3
+	PACKET_OUTGOING					= 0x4
+	PACKET_QDISC_BYPASS				= 0x14
+	PACKET_RECV_OUTPUT				= 0x3
+	PACKET_RESERVE					= 0xc
+	PACKET_ROLLOVER_STATS				= 0x15
+	PACKET_RX_RING					= 0x5
+	PACKET_STATISTICS				= 0x6
+	PACKET_TIMESTAMP				= 0x11
+	PACKET_TX_HAS_OFF				= 0x13
+	PACKET_TX_RING					= 0xd
+	PACKET_TX_TIMESTAMP				= 0x10
+	PACKET_USER					= 0x6
+	PACKET_VERSION					= 0xa
+	PACKET_VNET_HDR					= 0xf
+	PACKET_VNET_HDR_SZ				= 0x18
+	PARENB						= 0x1000
+	PARITY_CRC16_PR0				= 0x2
+	PARITY_CRC16_PR0_CCITT				= 0x4
+	PARITY_CRC16_PR1				= 0x3
+	PARITY_CRC16_PR1_CCITT				= 0x5
+	PARITY_CRC32_PR0_CCITT				= 0x6
+	PARITY_CRC32_PR1_CCITT				= 0x7
+	PARITY_DEFAULT					= 0x0
+	PARITY_NONE					= 0x1
+	PARMRK						= 0x8
+	PARODD						= 0x2000
+	PENDIN						= 0x20000000
+	PERF_ATTR_SIZE_VER0				= 0x40
+	PERF_ATTR_SIZE_VER1				= 0x48
+	PERF_ATTR_SIZE_VER2				= 0x50
+	PERF_ATTR_SIZE_VER3				= 0x60
+	PERF_ATTR_SIZE_VER4				= 0x68
+	PERF_ATTR_SIZE_VER5				= 0x70
+	PERF_ATTR_SIZE_VER6				= 0x78
+	PERF_ATTR_SIZE_VER7				= 0x80
+	PERF_ATTR_SIZE_VER8				= 0x88
+	PERF_AUX_FLAG_COLLISION				= 0x8
+	PERF_AUX_FLAG_CORESIGHT_FORMAT_CORESIGHT	= 0x0
+	PERF_AUX_FLAG_CORESIGHT_FORMAT_RAW		= 0x100
+	PERF_AUX_FLAG_OVERWRITE				= 0x2
+	PERF_AUX_FLAG_PARTIAL				= 0x4
+	PERF_AUX_FLAG_PMU_FORMAT_TYPE_MASK		= 0xff00
+	PERF_AUX_FLAG_TRUNCATED				= 0x1
+	PERF_BR_ARM64_DEBUG_DATA			= 0x7
+	PERF_BR_ARM64_DEBUG_EXIT			= 0x5
+	PERF_BR_ARM64_DEBUG_HALT			= 0x4
+	PERF_BR_ARM64_DEBUG_INST			= 0x6
+	PERF_BR_ARM64_FIQ				= 0x3
+	PERF_EVENT_IOC_DISABLE				= 0x20002401
+	PERF_EVENT_IOC_ENABLE				= 0x20002400
+	PERF_EVENT_IOC_ID				= 0x40082407
+	PERF_EVENT_IOC_MODIFY_ATTRIBUTES		= 0x8008240b
+	PERF_EVENT_IOC_PAUSE_OUTPUT			= 0x80042409
+	PERF_EVENT_IOC_PERIOD				= 0x80082404
+	PERF_EVENT_IOC_QUERY_BPF			= 0xc008240a
+	PERF_EVENT_IOC_REFRESH				= 0x20002402
+	PERF_EVENT_IOC_RESET				= 0x20002403
+	PERF_EVENT_IOC_SET_BPF				= 0x80042408
+	PERF_EVENT_IOC_SET_FILTER			= 0x80082406
+	PERF_EVENT_IOC_SET_OUTPUT			= 0x20002405
+	PERF_FLAG_FD_CLOEXEC				= 0x8
+	PERF_FLAG_FD_NO_GROUP				= 0x1
+	PERF_FLAG_FD_OUTPUT				= 0x2
+	PERF_FLAG_PID_CGROUP				= 0x4
+	PERF_HW_EVENT_MASK				= 0xffffffff
+	PERF_MAX_CONTEXTS_PER_STACK			= 0x8
+	PERF_MAX_STACK_DEPTH				= 0x7f
+	PERF_MEM_BLK_ADDR				= 0x4
+	PERF_MEM_BLK_DATA				= 0x2
+	PERF_MEM_BLK_NA					= 0x1
+	PERF_MEM_BLK_SHIFT				= 0x28
+	PERF_MEM_HOPS_0					= 0x1
+	PERF_MEM_HOPS_1					= 0x2
+	PERF_MEM_HOPS_2					= 0x3
+	PERF_MEM_HOPS_3					= 0x4
+	PERF_MEM_HOPS_SHIFT				= 0x2b
+	PERF_MEM_LOCK_LOCKED				= 0x2
+	PERF_MEM_LOCK_NA				= 0x1
+	PERF_MEM_LOCK_SHIFT				= 0x18
+	PERF_MEM_LVLNUM_ANY_CACHE			= 0xb
+	PERF_MEM_LVLNUM_CXL				= 0x9
+	PERF_MEM_LVLNUM_IO				= 0xa
+	PERF_MEM_LVLNUM_L1				= 0x1
+	PERF_MEM_LVLNUM_L2				= 0x2
+	PERF_MEM_LVLNUM_L3				= 0x3
+	PERF_MEM_LVLNUM_L4				= 0x4
+	PERF_MEM_LVLNUM_LFB				= 0xc
+	PERF_MEM_LVLNUM_NA				= 0xf
+	PERF_MEM_LVLNUM_PMEM				= 0xe
+	PERF_MEM_LVLNUM_RAM				= 0xd
+	PERF_MEM_LVLNUM_SHIFT				= 0x21
+	PERF_MEM_LVLNUM_UNC				= 0x8
+	PERF_MEM_LVL_HIT				= 0x2
+	PERF_MEM_LVL_IO					= 0x1000
+	PERF_MEM_LVL_L1					= 0x8
+	PERF_MEM_LVL_L2					= 0x20
+	PERF_MEM_LVL_L3					= 0x40
+	PERF_MEM_LVL_LFB				= 0x10
+	PERF_MEM_LVL_LOC_RAM				= 0x80
+	PERF_MEM_LVL_MISS				= 0x4
+	PERF_MEM_LVL_NA					= 0x1
+	PERF_MEM_LVL_REM_CCE1				= 0x400
+	PERF_MEM_LVL_REM_CCE2				= 0x800
+	PERF_MEM_LVL_REM_RAM1				= 0x100
+	PERF_MEM_LVL_REM_RAM2				= 0x200
+	PERF_MEM_LVL_SHIFT				= 0x5
+	PERF_MEM_LVL_UNC				= 0x2000
+	PERF_MEM_OP_EXEC				= 0x10
+	PERF_MEM_OP_LOAD				= 0x2
+	PERF_MEM_OP_NA					= 0x1
+	PERF_MEM_OP_PFETCH				= 0x8
+	PERF_MEM_OP_SHIFT				= 0x0
+	PERF_MEM_OP_STORE				= 0x4
+	PERF_MEM_REMOTE_REMOTE				= 0x1
+	PERF_MEM_REMOTE_SHIFT				= 0x25
+	PERF_MEM_SNOOPX_FWD				= 0x1
+	PERF_MEM_SNOOPX_PEER				= 0x2
+	PERF_MEM_SNOOPX_SHIFT				= 0x26
+	PERF_MEM_SNOOP_HIT				= 0x4
+	PERF_MEM_SNOOP_HITM				= 0x10
+	PERF_MEM_SNOOP_MISS				= 0x8
+	PERF_MEM_SNOOP_NA				= 0x1
+	PERF_MEM_SNOOP_NONE				= 0x2
+	PERF_MEM_SNOOP_SHIFT				= 0x13
+	PERF_MEM_TLB_HIT				= 0x2
+	PERF_MEM_TLB_L1					= 0x8
+	PERF_MEM_TLB_L2					= 0x10
+	PERF_MEM_TLB_MISS				= 0x4
+	PERF_MEM_TLB_NA					= 0x1
+	PERF_MEM_TLB_OS					= 0x40
+	PERF_MEM_TLB_SHIFT				= 0x1a
+	PERF_MEM_TLB_WK					= 0x20
+	PERF_PMU_TYPE_SHIFT				= 0x20
+	PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER		= 0x1
+	PERF_RECORD_MISC_COMM_EXEC			= 0x2000
+	PERF_RECORD_MISC_CPUMODE_MASK			= 0x7
+	PERF_RECORD_MISC_CPUMODE_UNKNOWN		= 0x0
+	PERF_RECORD_MISC_EXACT_IP			= 0x4000
+	PERF_RECORD_MISC_EXT_RESERVED			= 0x8000
+	PERF_RECORD_MISC_FORK_EXEC			= 0x2000
+	PERF_RECORD_MISC_GUEST_KERNEL			= 0x4
+	PERF_RECORD_MISC_GUEST_USER			= 0x5
+	PERF_RECORD_MISC_HYPERVISOR			= 0x3
+	PERF_RECORD_MISC_KERNEL				= 0x1
+	PERF_RECORD_MISC_MMAP_BUILD_ID			= 0x4000
+	PERF_RECORD_MISC_MMAP_DATA			= 0x2000
+	PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT		= 0x1000
+	PERF_RECORD_MISC_SWITCH_OUT			= 0x2000
+	PERF_RECORD_MISC_SWITCH_OUT_PREEMPT		= 0x4000
+	PERF_RECORD_MISC_USER				= 0x2
+	PERF_SAMPLE_BRANCH_PLM_ALL			= 0x7
+	PERF_SAMPLE_WEIGHT_TYPE				= 0x1004000
+	PIPEFS_MAGIC					= 0x50495045
+	PPPIOCATTACH					= 0x8004743d
+	PPPIOCATTCHAN					= 0x80047438
+	PPPIOCBRIDGECHAN				= 0x80047435
+	PPPIOCCONNECT					= 0x8004743a
+	PPPIOCDETACH					= 0x8004743c
+	PPPIOCDISCONN					= 0x20007439
+	PPPIOCGASYNCMAP					= 0x40047458
+	PPPIOCGCHAN					= 0x40047437
+	PPPIOCGDEBUG					= 0x40047441
+	PPPIOCGFLAGS					= 0x4004745a
+	PPPIOCGIDLE					= 0x4010743f
+	PPPIOCGIDLE32					= 0x4008743f
+	PPPIOCGIDLE64					= 0x4010743f
+	PPPIOCGL2TPSTATS				= 0x40487436
+	PPPIOCGMRU					= 0x40047453
+	PPPIOCGNPMODE					= 0xc008744c
+	PPPIOCGRASYNCMAP				= 0x40047455
+	PPPIOCGUNIT					= 0x40047456
+	PPPIOCGXASYNCMAP				= 0x40207450
+	PPPIOCNEWUNIT					= 0xc004743e
+	PPPIOCSACTIVE					= 0x80107446
+	PPPIOCSASYNCMAP					= 0x80047457
+	PPPIOCSCOMPRESS					= 0x8010744d
+	PPPIOCSDEBUG					= 0x80047440
+	PPPIOCSFLAGS					= 0x80047459
+	PPPIOCSMAXCID					= 0x80047451
+	PPPIOCSMRRU					= 0x8004743b
+	PPPIOCSMRU					= 0x80047452
+	PPPIOCSNPMODE					= 0x8008744b
+	PPPIOCSPASS					= 0x80107447
+	PPPIOCSRASYNCMAP				= 0x80047454
+	PPPIOCSXASYNCMAP				= 0x8020744f
+	PPPIOCUNBRIDGECHAN				= 0x20007434
+	PPPIOCXFERUNIT					= 0x2000744e
+	PRIO_PGRP					= 0x1
+	PRIO_PROCESS					= 0x0
+	PRIO_USER					= 0x2
+	PROC_SUPER_MAGIC				= 0x9fa0
+	PROT_EXEC					= 0x4
+	PROT_GROWSDOWN					= 0x1000000
+	PROT_GROWSUP					= 0x2000000
+	PROT_NONE					= 0x0
+	PROT_READ					= 0x1
+	PROT_WRITE					= 0x2
+	PR_CAPBSET_DROP					= 0x18
+	PR_CAPBSET_READ					= 0x17
+	PR_CAP_AMBIENT					= 0x2f
+	PR_CAP_AMBIENT_CLEAR_ALL			= 0x4
+	PR_CAP_AMBIENT_IS_SET				= 0x1
+	PR_CAP_AMBIENT_LOWER				= 0x3
+	PR_CAP_AMBIENT_RAISE				= 0x2
+	PR_ENDIAN_BIG					= 0x0
+	PR_ENDIAN_LITTLE				= 0x1
+	PR_ENDIAN_PPC_LITTLE				= 0x2
+	PR_FPEMU_NOPRINT				= 0x1
+	PR_FPEMU_SIGFPE					= 0x2
+	PR_FP_EXC_ASYNC					= 0x2
+	PR_FP_EXC_DISABLED				= 0x0
+	PR_FP_EXC_DIV					= 0x10000
+	PR_FP_EXC_INV					= 0x100000
+	PR_FP_EXC_NONRECOV				= 0x1
+	PR_FP_EXC_OVF					= 0x20000
+	PR_FP_EXC_PRECISE				= 0x3
+	PR_FP_EXC_RES					= 0x80000
+	PR_FP_EXC_SW_ENABLE				= 0x80
+	PR_FP_EXC_UND					= 0x40000
+	PR_FP_MODE_FR					= 0x1
+	PR_FP_MODE_FRE					= 0x2
+	PR_GET_AUXV					= 0x41555856
+	PR_GET_CHILD_SUBREAPER				= 0x25
+	PR_GET_DUMPABLE					= 0x3
+	PR_GET_ENDIAN					= 0x13
+	PR_GET_FPEMU					= 0x9
+	PR_GET_FPEXC					= 0xb
+	PR_GET_FP_MODE					= 0x2e
+	PR_GET_IO_FLUSHER				= 0x3a
+	PR_GET_KEEPCAPS					= 0x7
+	PR_GET_MDWE					= 0x42
+	PR_GET_MEMORY_MERGE				= 0x44
+	PR_GET_NAME					= 0x10
+	PR_GET_NO_NEW_PRIVS				= 0x27
+	PR_GET_PDEATHSIG				= 0x2
+	PR_GET_SECCOMP					= 0x15
+	PR_GET_SECUREBITS				= 0x1b
+	PR_GET_SPECULATION_CTRL				= 0x34
+	PR_GET_TAGGED_ADDR_CTRL				= 0x38
+	PR_GET_THP_DISABLE				= 0x2a
+	PR_GET_TID_ADDRESS				= 0x28
+	PR_GET_TIMERSLACK				= 0x1e
+	PR_GET_TIMING					= 0xd
+	PR_GET_TSC					= 0x19
+	PR_GET_UNALIGN					= 0x5
+	PR_MCE_KILL					= 0x21
+	PR_MCE_KILL_CLEAR				= 0x0
+	PR_MCE_KILL_DEFAULT				= 0x2
+	PR_MCE_KILL_EARLY				= 0x1
+	PR_MCE_KILL_GET					= 0x22
+	PR_MCE_KILL_LATE				= 0x0
+	PR_MCE_KILL_SET					= 0x1
+	PR_MDWE_REFUSE_EXEC_GAIN			= 0x1
+	PR_MPX_DISABLE_MANAGEMENT			= 0x2c
+	PR_MPX_ENABLE_MANAGEMENT			= 0x2b
+	PR_MTE_TAG_MASK					= 0x7fff8
+	PR_MTE_TAG_SHIFT				= 0x3
+	PR_MTE_TCF_ASYNC				= 0x4
+	PR_MTE_TCF_MASK					= 0x6
+	PR_MTE_TCF_NONE					= 0x0
+	PR_MTE_TCF_SHIFT				= 0x1
+	PR_MTE_TCF_SYNC					= 0x2
+	PR_PAC_APDAKEY					= 0x4
+	PR_PAC_APDBKEY					= 0x8
+	PR_PAC_APGAKEY					= 0x10
+	PR_PAC_APIAKEY					= 0x1
+	PR_PAC_APIBKEY					= 0x2
+	PR_PAC_GET_ENABLED_KEYS				= 0x3d
+	PR_PAC_RESET_KEYS				= 0x36
+	PR_PAC_SET_ENABLED_KEYS				= 0x3c
+	PR_RISCV_V_GET_CONTROL				= 0x46
+	PR_RISCV_V_SET_CONTROL				= 0x45
+	PR_RISCV_V_VSTATE_CTRL_CUR_MASK			= 0x3
+	PR_RISCV_V_VSTATE_CTRL_DEFAULT			= 0x0
+	PR_RISCV_V_VSTATE_CTRL_INHERIT			= 0x10
+	PR_RISCV_V_VSTATE_CTRL_MASK			= 0x1f
+	PR_RISCV_V_VSTATE_CTRL_NEXT_MASK		= 0xc
+	PR_RISCV_V_VSTATE_CTRL_OFF			= 0x1
+	PR_RISCV_V_VSTATE_CTRL_ON			= 0x2
+	PR_SCHED_CORE					= 0x3e
+	PR_SCHED_CORE_CREATE				= 0x1
+	PR_SCHED_CORE_GET				= 0x0
+	PR_SCHED_CORE_MAX				= 0x4
+	PR_SCHED_CORE_SCOPE_PROCESS_GROUP		= 0x2
+	PR_SCHED_CORE_SCOPE_THREAD			= 0x0
+	PR_SCHED_CORE_SCOPE_THREAD_GROUP		= 0x1
+	PR_SCHED_CORE_SHARE_FROM			= 0x3
+	PR_SCHED_CORE_SHARE_TO				= 0x2
+	PR_SET_CHILD_SUBREAPER				= 0x24
+	PR_SET_DUMPABLE					= 0x4
+	PR_SET_ENDIAN					= 0x14
+	PR_SET_FPEMU					= 0xa
+	PR_SET_FPEXC					= 0xc
+	PR_SET_FP_MODE					= 0x2d
+	PR_SET_IO_FLUSHER				= 0x39
+	PR_SET_KEEPCAPS					= 0x8
+	PR_SET_MDWE					= 0x41
+	PR_SET_MEMORY_MERGE				= 0x43
+	PR_SET_MM					= 0x23
+	PR_SET_MM_ARG_END				= 0x9
+	PR_SET_MM_ARG_START				= 0x8
+	PR_SET_MM_AUXV					= 0xc
+	PR_SET_MM_BRK					= 0x7
+	PR_SET_MM_END_CODE				= 0x2
+	PR_SET_MM_END_DATA				= 0x4
+	PR_SET_MM_ENV_END				= 0xb
+	PR_SET_MM_ENV_START				= 0xa
+	PR_SET_MM_EXE_FILE				= 0xd
+	PR_SET_MM_MAP					= 0xe
+	PR_SET_MM_MAP_SIZE				= 0xf
+	PR_SET_MM_START_BRK				= 0x6
+	PR_SET_MM_START_CODE				= 0x1
+	PR_SET_MM_START_DATA				= 0x3
+	PR_SET_MM_START_STACK				= 0x5
+	PR_SET_NAME					= 0xf
+	PR_SET_NO_NEW_PRIVS				= 0x26
+	PR_SET_PDEATHSIG				= 0x1
+	PR_SET_PTRACER					= 0x59616d61
+	PR_SET_PTRACER_ANY				= 0xffffffffffffffff
+	PR_SET_SECCOMP					= 0x16
+	PR_SET_SECUREBITS				= 0x1c
+	PR_SET_SPECULATION_CTRL				= 0x35
+	PR_SET_SYSCALL_USER_DISPATCH			= 0x3b
+	PR_SET_TAGGED_ADDR_CTRL				= 0x37
+	PR_SET_THP_DISABLE				= 0x29
+	PR_SET_TIMERSLACK				= 0x1d
+	PR_SET_TIMING					= 0xe
+	PR_SET_TSC					= 0x1a
+	PR_SET_UNALIGN					= 0x6
+	PR_SET_VMA					= 0x53564d41
+	PR_SET_VMA_ANON_NAME				= 0x0
+	PR_SME_GET_VL					= 0x40
+	PR_SME_SET_VL					= 0x3f
+	PR_SME_SET_VL_ONEXEC				= 0x40000
+	PR_SME_VL_INHERIT				= 0x20000
+	PR_SME_VL_LEN_MASK				= 0xffff
+	PR_SPEC_DISABLE					= 0x4
+	PR_SPEC_DISABLE_NOEXEC				= 0x10
+	PR_SPEC_ENABLE					= 0x2
+	PR_SPEC_FORCE_DISABLE				= 0x8
+	PR_SPEC_INDIRECT_BRANCH				= 0x1
+	PR_SPEC_L1D_FLUSH				= 0x2
+	PR_SPEC_NOT_AFFECTED				= 0x0
+	PR_SPEC_PRCTL					= 0x1
+	PR_SPEC_STORE_BYPASS				= 0x0
+	PR_SVE_GET_VL					= 0x33
+	PR_SVE_SET_VL					= 0x32
+	PR_SVE_SET_VL_ONEXEC				= 0x40000
+	PR_SVE_VL_INHERIT				= 0x20000
+	PR_SVE_VL_LEN_MASK				= 0xffff
+	PR_SYS_DISPATCH_OFF				= 0x0
+	PR_SYS_DISPATCH_ON				= 0x1
+	PR_TAGGED_ADDR_ENABLE				= 0x1
+	PR_TASK_PERF_EVENTS_DISABLE			= 0x1f
+	PR_TASK_PERF_EVENTS_ENABLE			= 0x20
+	PR_TIMING_STATISTICAL				= 0x0
+	PR_TIMING_TIMESTAMP				= 0x1
+	PR_TSC_ENABLE					= 0x1
+	PR_TSC_SIGSEGV					= 0x2
+	PR_UNALIGN_NOPRINT				= 0x1
+	PR_UNALIGN_SIGBUS				= 0x2
+	PSTOREFS_MAGIC					= 0x6165676c
+	PTRACE_ATTACH					= 0x10
+	PTRACE_CONT					= 0x7
+	PTRACE_DETACH					= 0x11
+	PTRACE_EVENTMSG_SYSCALL_ENTRY			= 0x1
+	PTRACE_EVENTMSG_SYSCALL_EXIT			= 0x2
+	PTRACE_EVENT_CLONE				= 0x3
+	PTRACE_EVENT_EXEC				= 0x4
+	PTRACE_EVENT_EXIT				= 0x6
+	PTRACE_EVENT_FORK				= 0x1
+	PTRACE_EVENT_SECCOMP				= 0x7
+	PTRACE_EVENT_STOP				= 0x80
+	PTRACE_EVENT_VFORK				= 0x2
+	PTRACE_EVENT_VFORK_DONE				= 0x5
+	PTRACE_GETEVENTMSG				= 0x4201
+	PTRACE_GETREGS					= 0xc
+	PTRACE_GETREGSET				= 0x4204
+	PTRACE_GETSIGINFO				= 0x4202
+	PTRACE_GETSIGMASK				= 0x420a
+	PTRACE_GET_RSEQ_CONFIGURATION			= 0x420f
+	PTRACE_GET_SYSCALL_INFO				= 0x420e
+	PTRACE_GET_SYSCALL_USER_DISPATCH_CONFIG		= 0x4211
+	PTRACE_INTERRUPT				= 0x4207
+	PTRACE_KILL					= 0x8
+	PTRACE_LISTEN					= 0x4208
+	PTRACE_O_EXITKILL				= 0x100000
+	PTRACE_O_MASK					= 0x3000ff
+	PTRACE_O_SUSPEND_SECCOMP			= 0x200000
+	PTRACE_O_TRACECLONE				= 0x8
+	PTRACE_O_TRACEEXEC				= 0x10
+	PTRACE_O_TRACEEXIT				= 0x40
+	PTRACE_O_TRACEFORK				= 0x2
+	PTRACE_O_TRACESECCOMP				= 0x80
+	PTRACE_O_TRACESYSGOOD				= 0x1
+	PTRACE_O_TRACEVFORK				= 0x4
+	PTRACE_O_TRACEVFORKDONE				= 0x20
+	PTRACE_PEEKDATA					= 0x2
+	PTRACE_PEEKSIGINFO				= 0x4209
+	PTRACE_PEEKSIGINFO_SHARED			= 0x1
+	PTRACE_PEEKTEXT					= 0x1
+	PTRACE_PEEKUSR					= 0x3
+	PTRACE_POKEDATA					= 0x5
+	PTRACE_POKETEXT					= 0x4
+	PTRACE_POKEUSR					= 0x6
+	PTRACE_SECCOMP_GET_FILTER			= 0x420c
+	PTRACE_SECCOMP_GET_METADATA			= 0x420d
+	PTRACE_SEIZE					= 0x4206
+	PTRACE_SETOPTIONS				= 0x4200
+	PTRACE_SETREGS					= 0xd
+	PTRACE_SETREGSET				= 0x4205
+	PTRACE_SETSIGINFO				= 0x4203
+	PTRACE_SETSIGMASK				= 0x420b
+	PTRACE_SET_SYSCALL_USER_DISPATCH_CONFIG		= 0x4210
+	PTRACE_SINGLESTEP				= 0x9
+	PTRACE_SYSCALL					= 0x18
+	PTRACE_SYSCALL_INFO_ENTRY			= 0x1
+	PTRACE_SYSCALL_INFO_EXIT			= 0x2
+	PTRACE_SYSCALL_INFO_NONE			= 0x0
+	PTRACE_SYSCALL_INFO_SECCOMP			= 0x3
+	PTRACE_TRACEME					= 0x0
+	PT_DA_MASK					= 0xa4
+	PT_DA_MATCH					= 0xa3
+	PT_DC_CTL					= 0xa7
+	PT_DV_MASK					= 0xa6
+	PT_DV_MATCH					= 0xa5
+	PT_F31_V1					= 0x62
+	PT_F31_V2					= 0x82
+	PT_FPCR						= 0x3f
+	PT_FPREG_BASE					= 0x20
+	PT_FPREG_END					= 0x3e
+	PT_IA_MASK					= 0xa9
+	PT_IA_MATCH					= 0xa8
+	PT_IDA_MASK					= 0xac
+	PT_IDA_MATCH					= 0xab
+	PT_IV_MATCH					= 0xaa
+	PT_MATCH_CTL					= 0xa7
+	PT_PC						= 0x40
+	PT_REG_BASE					= 0x0
+	PT_REG_END					= 0x1e
+	PT_TP						= 0x41
+	PT_UNIQUE					= 0x41
+	PT_VECREG_BASE					= 0x43
+	PT_VECREG_END					= 0xa1
+	P_ALL						= 0x0
+	P_PGID						= 0x2
+	P_PID						= 0x1
+	P_PIDFD						= 0x3
+	QNX4_SUPER_MAGIC				= 0x2f
+	QNX6_SUPER_MAGIC				= 0x68191122
+	RAMFS_MAGIC					= 0x858458f6
+	RAW_PAYLOAD_DIGITAL				= 0x3
+	RAW_PAYLOAD_HCI					= 0x2
+	RAW_PAYLOAD_LLCP				= 0x0
+	RAW_PAYLOAD_NCI					= 0x1
+	RAW_PAYLOAD_PROPRIETARY				= 0x4
+	RDTGROUP_SUPER_MAGIC				= 0x7655821
+	REISERFS_SUPER_MAGIC				= 0x52654973
+	RENAME_EXCHANGE					= 0x2
+	RENAME_NOREPLACE				= 0x1
+	RENAME_WHITEOUT					= 0x4
+	RLIMIT_AS					= 0x7
+	RLIMIT_CORE					= 0x4
+	RLIMIT_CPU					= 0x0
+	RLIMIT_DATA					= 0x2
+	RLIMIT_FSIZE					= 0x1
+	RLIMIT_LOCKS					= 0xa
+	RLIMIT_MEMLOCK					= 0x9
+	RLIMIT_MSGQUEUE					= 0xc
+	RLIMIT_NICE					= 0xd
+	RLIMIT_NOFILE					= 0x6
+	RLIMIT_NPROC					= 0x8
+	RLIMIT_RSS					= 0x5
+	RLIMIT_RTPRIO					= 0xe
+	RLIMIT_RTTIME					= 0xf
+	RLIMIT_SIGPENDING				= 0xb
+	RLIMIT_STACK					= 0x3
+	RLIM_INFINITY					= 0xffffffffffffffff
+	RNDADDENTROPY					= 0x80085203
+	RNDADDTOENTCNT					= 0x80045201
+	RNDCLEARPOOL					= 0x20005206
+	RNDGETENTCNT					= 0x40045200
+	RNDGETPOOL					= 0x40085202
+	RNDRESEEDCRNG					= 0x20005207
+	RNDZAPENTCNT					= 0x20005204
+	RTAX_ADVMSS					= 0x8
+	RTAX_CC_ALGO					= 0x10
+	RTAX_CWND					= 0x7
+	RTAX_FASTOPEN_NO_COOKIE				= 0x11
+	RTAX_FEATURES					= 0xc
+	RTAX_FEATURE_ALLFRAG				= 0x8
+	RTAX_FEATURE_ECN				= 0x1
+	RTAX_FEATURE_MASK				= 0xf
+	RTAX_FEATURE_SACK				= 0x2
+	RTAX_FEATURE_TIMESTAMP				= 0x4
+	RTAX_HOPLIMIT					= 0xa
+	RTAX_INITCWND					= 0xb
+	RTAX_INITRWND					= 0xe
+	RTAX_LOCK					= 0x1
+	RTAX_MAX					= 0x11
+	RTAX_MTU					= 0x2
+	RTAX_QUICKACK					= 0xf
+	RTAX_REORDERING					= 0x9
+	RTAX_RTO_MIN					= 0xd
+	RTAX_RTT					= 0x4
+	RTAX_RTTVAR					= 0x5
+	RTAX_SSTHRESH					= 0x6
+	RTAX_UNSPEC					= 0x0
+	RTAX_WINDOW					= 0x3
+	RTA_ALIGNTO					= 0x4
+	RTA_MAX						= 0x1e
+	RTCF_DIRECTSRC					= 0x4000000
+	RTCF_DOREDIRECT					= 0x1000000
+	RTCF_LOG					= 0x2000000
+	RTCF_MASQ					= 0x400000
+	RTCF_NAT					= 0x800000
+	RTCF_VALVE					= 0x200000
+	RTC_AF						= 0x20
+	RTC_AIE_OFF					= 0x20007002
+	RTC_AIE_ON					= 0x20007001
+	RTC_ALM_READ					= 0x40247008
+	RTC_ALM_SET					= 0x80247007
+	RTC_BSM_DIRECT					= 0x1
+	RTC_BSM_DISABLED				= 0x0
+	RTC_BSM_LEVEL					= 0x2
+	RTC_BSM_STANDBY					= 0x3
+	RTC_EPOCH_READ					= 0x4008700d
+	RTC_EPOCH_SET					= 0x8008700e
+	RTC_FEATURE_ALARM				= 0x0
+	RTC_FEATURE_ALARM_RES_2S			= 0x3
+	RTC_FEATURE_ALARM_RES_MINUTE			= 0x1
+	RTC_FEATURE_ALARM_WAKEUP_ONLY			= 0x7
+	RTC_FEATURE_BACKUP_SWITCH_MODE			= 0x6
+	RTC_FEATURE_CNT					= 0x8
+	RTC_FEATURE_CORRECTION				= 0x5
+	RTC_FEATURE_NEED_WEEK_DAY			= 0x2
+	RTC_FEATURE_UPDATE_INTERRUPT			= 0x4
+	RTC_IRQF					= 0x80
+	RTC_IRQP_READ					= 0x4008700b
+	RTC_IRQP_SET					= 0x8008700c
+	RTC_MAX_FREQ					= 0x2000
+	RTC_PARAM_BACKUP_SWITCH_MODE			= 0x2
+	RTC_PARAM_CORRECTION				= 0x1
+	RTC_PARAM_FEATURES				= 0x0
+	RTC_PARAM_GET					= 0x80187013
+	RTC_PARAM_SET					= 0x80187014
+	RTC_PF						= 0x40
+	RTC_PIE_OFF					= 0x20007006
+	RTC_PIE_ON					= 0x20007005
+	RTC_PLL_GET					= 0x40207011
+	RTC_PLL_SET					= 0x80207012
+	RTC_RD_TIME					= 0x40247009
+	RTC_SET_TIME					= 0x8024700a
+	RTC_UF						= 0x10
+	RTC_UIE_OFF					= 0x20007004
+	RTC_UIE_ON					= 0x20007003
+	RTC_VL_CLR					= 0x20007014
+	RTC_VL_READ					= 0x40047013
+	RTC_WIE_OFF					= 0x20007010
+	RTC_WIE_ON					= 0x2000700f
+	RTC_WKALM_RD					= 0x40287010
+	RTC_WKALM_SET					= 0x8028700f
+	RTF_ADDRCLASSMASK				= 0xf8000000
+	RTF_ADDRCONF					= 0x40000
+	RTF_ALLONLINK					= 0x20000
+	RTF_BROADCAST					= 0x10000000
+	RTF_CACHE					= 0x1000000
+	RTF_DEFAULT					= 0x10000
+	RTF_DYNAMIC					= 0x10
+	RTF_FLOW					= 0x2000000
+	RTF_GATEWAY					= 0x2
+	RTF_HOST					= 0x4
+	RTF_INTERFACE					= 0x40000000
+	RTF_IRTT					= 0x100
+	RTF_LINKRT					= 0x100000
+	RTF_LOCAL					= 0x80000000
+	RTF_MODIFIED					= 0x20
+	RTF_MSS						= 0x40
+	RTF_MTU						= 0x40
+	RTF_MULTICAST					= 0x20000000
+	RTF_NAT						= 0x8000000
+	RTF_NOFORWARD					= 0x1000
+	RTF_NONEXTHOP					= 0x200000
+	RTF_NOPMTUDISC					= 0x4000
+	RTF_POLICY					= 0x4000000
+	RTF_REINSTATE					= 0x8
+	RTF_REJECT					= 0x200
+	RTF_STATIC					= 0x400
+	RTF_THROW					= 0x2000
+	RTF_UP						= 0x1
+	RTF_WINDOW					= 0x80
+	RTF_XRESOLVE					= 0x800
+	RTMGRP_DECnet_IFADDR				= 0x1000
+	RTMGRP_DECnet_ROUTE				= 0x4000
+	RTMGRP_IPV4_IFADDR				= 0x10
+	RTMGRP_IPV4_MROUTE				= 0x20
+	RTMGRP_IPV4_ROUTE				= 0x40
+	RTMGRP_IPV4_RULE				= 0x80
+	RTMGRP_IPV6_IFADDR				= 0x100
+	RTMGRP_IPV6_IFINFO				= 0x800
+	RTMGRP_IPV6_MROUTE				= 0x200
+	RTMGRP_IPV6_PREFIX				= 0x20000
+	RTMGRP_IPV6_ROUTE				= 0x400
+	RTMGRP_LINK					= 0x1
+	RTMGRP_NEIGH					= 0x4
+	RTMGRP_NOTIFY					= 0x2
+	RTMGRP_TC					= 0x8
+	RTM_BASE					= 0x10
+	RTM_DELACTION					= 0x31
+	RTM_DELADDR					= 0x15
+	RTM_DELADDRLABEL				= 0x49
+	RTM_DELCHAIN					= 0x65
+	RTM_DELLINK					= 0x11
+	RTM_DELLINKPROP					= 0x6d
+	RTM_DELMDB					= 0x55
+	RTM_DELNEIGH					= 0x1d
+	RTM_DELNETCONF					= 0x51
+	RTM_DELNEXTHOP					= 0x69
+	RTM_DELNEXTHOPBUCKET				= 0x75
+	RTM_DELNSID					= 0x59
+	RTM_DELQDISC					= 0x25
+	RTM_DELROUTE					= 0x19
+	RTM_DELRULE					= 0x21
+	RTM_DELTCLASS					= 0x29
+	RTM_DELTFILTER					= 0x2d
+	RTM_DELTUNNEL					= 0x79
+	RTM_DELVLAN					= 0x71
+	RTM_F_CLONED					= 0x200
+	RTM_F_EQUALIZE					= 0x400
+	RTM_F_FIB_MATCH					= 0x2000
+	RTM_F_LOOKUP_TABLE				= 0x1000
+	RTM_F_NOTIFY					= 0x100
+	RTM_F_OFFLOAD					= 0x4000
+	RTM_F_OFFLOAD_FAILED				= 0x20000000
+	RTM_F_PREFIX					= 0x800
+	RTM_F_TRAP					= 0x8000
+	RTM_GETACTION					= 0x32
+	RTM_GETADDR					= 0x16
+	RTM_GETADDRLABEL				= 0x4a
+	RTM_GETANYCAST					= 0x3e
+	RTM_GETCHAIN					= 0x66
+	RTM_GETDCB					= 0x4e
+	RTM_GETLINK					= 0x12
+	RTM_GETLINKPROP					= 0x6e
+	RTM_GETMDB					= 0x56
+	RTM_GETMULTICAST				= 0x3a
+	RTM_GETNEIGH					= 0x1e
+	RTM_GETNEIGHTBL					= 0x42
+	RTM_GETNETCONF					= 0x52
+	RTM_GETNEXTHOP					= 0x6a
+	RTM_GETNEXTHOPBUCKET				= 0x76
+	RTM_GETNSID					= 0x5a
+	RTM_GETQDISC					= 0x26
+	RTM_GETROUTE					= 0x1a
+	RTM_GETRULE					= 0x22
+	RTM_GETSTATS					= 0x5e
+	RTM_GETTCLASS					= 0x2a
+	RTM_GETTFILTER					= 0x2e
+	RTM_GETTUNNEL					= 0x7a
+	RTM_GETVLAN					= 0x72
+	RTM_MAX						= 0x7b
+	RTM_NEWACTION					= 0x30
+	RTM_NEWADDR					= 0x14
+	RTM_NEWADDRLABEL				= 0x48
+	RTM_NEWCACHEREPORT				= 0x60
+	RTM_NEWCHAIN					= 0x64
+	RTM_NEWLINK					= 0x10
+	RTM_NEWLINKPROP					= 0x6c
+	RTM_NEWMDB					= 0x54
+	RTM_NEWNDUSEROPT				= 0x44
+	RTM_NEWNEIGH					= 0x1c
+	RTM_NEWNEIGHTBL					= 0x40
+	RTM_NEWNETCONF					= 0x50
+	RTM_NEWNEXTHOP					= 0x68
+	RTM_NEWNEXTHOPBUCKET				= 0x74
+	RTM_NEWNSID					= 0x58
+	RTM_NEWNVLAN					= 0x70
+	RTM_NEWPREFIX					= 0x34
+	RTM_NEWQDISC					= 0x24
+	RTM_NEWROUTE					= 0x18
+	RTM_NEWRULE					= 0x20
+	RTM_NEWSTATS					= 0x5c
+	RTM_NEWTCLASS					= 0x28
+	RTM_NEWTFILTER					= 0x2c
+	RTM_NEWTUNNEL					= 0x78
+	RTM_NR_FAMILIES					= 0x1b
+	RTM_NR_MSGTYPES					= 0x6c
+	RTM_SETDCB					= 0x4f
+	RTM_SETLINK					= 0x13
+	RTM_SETNEIGHTBL					= 0x43
+	RTM_SETSTATS					= 0x5f
+	RTNH_ALIGNTO					= 0x4
+	RTNH_COMPARE_MASK				= 0x59
+	RTNH_F_DEAD					= 0x1
+	RTNH_F_LINKDOWN					= 0x10
+	RTNH_F_OFFLOAD					= 0x8
+	RTNH_F_ONLINK					= 0x4
+	RTNH_F_PERVASIVE				= 0x2
+	RTNH_F_TRAP					= 0x40
+	RTNH_F_UNRESOLVED				= 0x20
+	RTN_MAX						= 0xb
+	RTPROT_BABEL					= 0x2a
+	RTPROT_BGP					= 0xba
+	RTPROT_BIRD					= 0xc
+	RTPROT_BOOT					= 0x3
+	RTPROT_DHCP					= 0x10
+	RTPROT_DNROUTED					= 0xd
+	RTPROT_EIGRP					= 0xc0
+	RTPROT_GATED					= 0x8
+	RTPROT_ISIS					= 0xbb
+	RTPROT_KEEPALIVED				= 0x12
+	RTPROT_KERNEL					= 0x2
+	RTPROT_MROUTED					= 0x11
+	RTPROT_MRT					= 0xa
+	RTPROT_NTK					= 0xf
+	RTPROT_OPENR					= 0x63
+	RTPROT_OSPF					= 0xbc
+	RTPROT_RA					= 0x9
+	RTPROT_REDIRECT					= 0x1
+	RTPROT_RIP					= 0xbd
+	RTPROT_STATIC					= 0x4
+	RTPROT_UNSPEC					= 0x0
+	RTPROT_XORP					= 0xe
+	RTPROT_ZEBRA					= 0xb
+	RT_CLASS_DEFAULT				= 0xfd
+	RT_CLASS_LOCAL					= 0xff
+	RT_CLASS_MAIN					= 0xfe
+	RT_CLASS_MAX					= 0xff
+	RT_CLASS_UNSPEC					= 0x0
+	RUSAGE_CHILDREN					= -0x1
+	RUSAGE_SELF					= 0x0
+	RUSAGE_THREAD					= 0x1
+	RWF_APPEND					= 0x10
+	RWF_DSYNC					= 0x2
+	RWF_HIPRI					= 0x1
+	RWF_NOWAIT					= 0x8
+	RWF_SUPPORTED					= 0x1f
+	RWF_SYNC					= 0x4
+	RWF_WRITE_LIFE_NOT_SET				= 0x0
+	SCHED_BATCH					= 0x3
+	SCHED_DEADLINE					= 0x6
+	SCHED_FIFO					= 0x1
+	SCHED_FLAG_ALL					= 0x7f
+	SCHED_FLAG_DL_OVERRUN				= 0x4
+	SCHED_FLAG_KEEP_ALL				= 0x18
+	SCHED_FLAG_KEEP_PARAMS				= 0x10
+	SCHED_FLAG_KEEP_POLICY				= 0x8
+	SCHED_FLAG_RECLAIM				= 0x2
+	SCHED_FLAG_RESET_ON_FORK			= 0x1
+	SCHED_FLAG_UTIL_CLAMP				= 0x60
+	SCHED_FLAG_UTIL_CLAMP_MAX			= 0x40
+	SCHED_FLAG_UTIL_CLAMP_MIN			= 0x20
+	SCHED_IDLE					= 0x5
+	SCHED_NORMAL					= 0x0
+	SCHED_RESET_ON_FORK				= 0x40000000
+	SCHED_RR					= 0x2
+	SCM_CREDENTIALS					= 0x2
+	SCM_RIGHTS					= 0x1
+	SCM_TIMESTAMP					= 0x1d
+	SCM_TIMESTAMPING				= 0x25
+	SCM_TIMESTAMPING_OPT_STATS			= 0x36
+	SCM_TIMESTAMPING_PKTINFO			= 0x3a
+	SCM_TIMESTAMPNS					= 0x23
+	SCM_TXTIME					= 0x3d
+	SCM_WIFI_STATUS					= 0x29
+	SC_LOG_FLUSH					= 0x100000
+	SECCOMP_MODE_DISABLED				= 0x0
+	SECCOMP_MODE_FILTER				= 0x2
+	SECCOMP_MODE_STRICT				= 0x1
+	SECRETMEM_MAGIC					= 0x5345434d
+	SECURITYFS_MAGIC				= 0x73636673
+	SEEK_CUR					= 0x1
+	SEEK_DATA					= 0x3
+	SEEK_END					= 0x2
+	SEEK_HOLE					= 0x4
+	SEEK_MAX					= 0x4
+	SEEK_SET					= 0x0
+	SELINUX_MAGIC					= 0xf97cff8c
+	SFD_CLOEXEC					= 0x200000
+	SFD_NONBLOCK					= 0x4
+	SHUT_RD						= 0x0
+	SHUT_RDWR					= 0x2
+	SHUT_WR						= 0x1
+	SIOCADDDLCI					= 0x8980
+	SIOCADDMULTI					= 0x8931
+	SIOCADDRT					= 0x890b
+	SIOCATMARK					= 0x40047307
+	SIOCBONDCHANGEACTIVE				= 0x8995
+	SIOCBONDENSLAVE					= 0x8990
+	SIOCBONDINFOQUERY				= 0x8994
+	SIOCBONDRELEASE					= 0x8991
+	SIOCBONDSETHWADDR				= 0x8992
+	SIOCBONDSLAVEINFOQUERY				= 0x8993
+	SIOCBRADDBR					= 0x89a0
+	SIOCBRADDIF					= 0x89a2
+	SIOCBRDELBR					= 0x89a1
+	SIOCBRDELIF					= 0x89a3
+	SIOCDARP					= 0x8953
+	SIOCDELDLCI					= 0x8981
+	SIOCDELMULTI					= 0x8932
+	SIOCDELRT					= 0x890c
+	SIOCDEVPRIVATE					= 0x89f0
+	SIOCDIFADDR					= 0x8936
+	SIOCDRARP					= 0x8960
+	SIOCETHTOOL					= 0x8946
+	SIOCGARP					= 0x8954
+	SIOCGETLINKNAME					= 0x89e0
+	SIOCGETNODEID					= 0x89e1
+	SIOCGHWTSTAMP					= 0x89b1
+	SIOCGIFADDR					= 0x8915
+	SIOCGIFBR					= 0x8940
+	SIOCGIFBRDADDR					= 0x8919
+	SIOCGIFCONF					= 0x8912
+	SIOCGIFCOUNT					= 0x8938
+	SIOCGIFDSTADDR					= 0x8917
+	SIOCGIFENCAP					= 0x8925
+	SIOCGIFFLAGS					= 0x8913
+	SIOCGIFHWADDR					= 0x8927
+	SIOCGIFINDEX					= 0x8933
+	SIOCGIFMAP					= 0x8970
+	SIOCGIFMEM					= 0x891f
+	SIOCGIFMETRIC					= 0x891d
+	SIOCGIFMTU					= 0x8921
+	SIOCGIFNAME					= 0x8910
+	SIOCGIFNETMASK					= 0x891b
+	SIOCGIFPFLAGS					= 0x8935
+	SIOCGIFSLAVE					= 0x8929
+	SIOCGIFTXQLEN					= 0x8942
+	SIOCGIFVLAN					= 0x8982
+	SIOCGMIIPHY					= 0x8947
+	SIOCGMIIREG					= 0x8948
+	SIOCGPGRP					= 0x40047309
+	SIOCGPPPCSTATS					= 0x89f2
+	SIOCGPPPSTATS					= 0x89f0
+	SIOCGPPPVER					= 0x89f1
+	SIOCGRARP					= 0x8961
+	SIOCGSKNS					= 0x894c
+	SIOCGSTAMP					= 0x8906
+	SIOCGSTAMPNS					= 0x8907
+	SIOCGSTAMPNS_NEW				= 0x40108907
+	SIOCGSTAMPNS_OLD				= 0x8907
+	SIOCGSTAMP_NEW					= 0x40108906
+	SIOCGSTAMP_OLD					= 0x8906
+	SIOCINQ						= 0x4004667f
+	SIOCKCMATTACH					= 0x89e0
+	SIOCKCMCLONE					= 0x89e2
+	SIOCKCMUNATTACH					= 0x89e1
+	SIOCOUTQ					= 0x40047473
+	SIOCOUTQNSD					= 0x894b
+	SIOCPROTOPRIVATE				= 0x89e0
+	SIOCRTMSG					= 0x890d
+	SIOCSARP					= 0x8955
+	SIOCSHWTSTAMP					= 0x89b0
+	SIOCSIFADDR					= 0x8916
+	SIOCSIFBR					= 0x8941
+	SIOCSIFBRDADDR					= 0x891a
+	SIOCSIFDSTADDR					= 0x8918
+	SIOCSIFENCAP					= 0x8926
+	SIOCSIFFLAGS					= 0x8914
+	SIOCSIFHWADDR					= 0x8924
+	SIOCSIFHWBROADCAST				= 0x8937
+	SIOCSIFLINK					= 0x8911
+	SIOCSIFMAP					= 0x8971
+	SIOCSIFMEM					= 0x8920
+	SIOCSIFMETRIC					= 0x891e
+	SIOCSIFMTU					= 0x8922
+	SIOCSIFNAME					= 0x8923
+	SIOCSIFNETMASK					= 0x891c
+	SIOCSIFPFLAGS					= 0x8934
+	SIOCSIFSLAVE					= 0x8930
+	SIOCSIFTXQLEN					= 0x8943
+	SIOCSIFVLAN					= 0x8983
+	SIOCSMIIREG					= 0x8949
+	SIOCSPGRP					= 0x80047308
+	SIOCSRARP					= 0x8962
+	SIOCWANDEV					= 0x894a
+	SMACK_MAGIC					= 0x43415d53
+	SMART_AUTOSAVE					= 0xd2
+	SMART_AUTO_OFFLINE				= 0xdb
+	SMART_DISABLE					= 0xd9
+	SMART_ENABLE					= 0xd8
+	SMART_HCYL_PASS					= 0xc2
+	SMART_IMMEDIATE_OFFLINE				= 0xd4
+	SMART_LCYL_PASS					= 0x4f
+	SMART_READ_LOG_SECTOR				= 0xd5
+	SMART_READ_THRESHOLDS				= 0xd1
+	SMART_READ_VALUES				= 0xd0
+	SMART_SAVE					= 0xd3
+	SMART_STATUS					= 0xda
+	SMART_WRITE_LOG_SECTOR				= 0xd6
+	SMART_WRITE_THRESHOLDS				= 0xd7
+	SMB2_SUPER_MAGIC				= 0xfe534d42
+	SMB_SUPER_MAGIC					= 0x517b
+	SOCKFS_MAGIC					= 0x534f434b
+	SOCK_BUF_LOCK_MASK				= 0x3
+	SOCK_CLOEXEC					= 0x200000
+	SOCK_DCCP					= 0x6
+	SOCK_DGRAM					= 0x2
+	SOCK_IOC_TYPE					= 0x89
+	SOCK_NONBLOCK					= 0x40000000
+	SOCK_PACKET					= 0xa
+	SOCK_RAW					= 0x3
+	SOCK_RCVBUF_LOCK				= 0x2
+	SOCK_RDM					= 0x4
+	SOCK_SEQPACKET					= 0x5
+	SOCK_SNDBUF_LOCK				= 0x1
+	SOCK_STREAM					= 0x1
+	SOCK_TXREHASH_DEFAULT				= 0xff
+	SOCK_TXREHASH_DISABLED				= 0x0
+	SOCK_TXREHASH_ENABLED				= 0x1
+	SOL_AAL						= 0x109
+	SOL_ALG						= 0x117
+	SOL_ATM						= 0x108
+	SOL_CAIF					= 0x116
+	SOL_CAN_BASE					= 0x64
+	SOL_CAN_RAW					= 0x65
+	SOL_DCCP					= 0x10d
+	SOL_DECNET					= 0x105
+	SOL_ICMPV6					= 0x3a
+	SOL_IP						= 0x0
+	SOL_IPV6					= 0x29
+	SOL_IRDA					= 0x10a
+	SOL_IUCV					= 0x115
+	SOL_KCM						= 0x119
+	SOL_LLC						= 0x10c
+	SOL_MCTP					= 0x11d
+	SOL_MPTCP					= 0x11c
+	SOL_NETBEUI					= 0x10b
+	SOL_NETLINK					= 0x10e
+	SOL_NFC						= 0x118
+	SOL_PACKET					= 0x107
+	SOL_PNPIPE					= 0x113
+	SOL_PPPOL2TP					= 0x111
+	SOL_RAW						= 0xff
+	SOL_RDS						= 0x114
+	SOL_RXRPC					= 0x110
+	SOL_SMC						= 0x11e
+	SOL_SOCKET					= 0xffff
+	SOL_TCP						= 0x6
+	SOL_TIPC					= 0x10f
+	SOL_TLS						= 0x11a
+	SOL_UDP						= 0x11
+	SOL_X25						= 0x106
+	SOL_XDP						= 0x11b
+	SOMAXCONN					= 0x1000
+	SO_ACCEPTCONN					= 0x1014
+	SO_ATTACH_BPF					= 0x32
+	SO_ATTACH_FILTER				= 0x1a
+	SO_ATTACH_REUSEPORT_CBPF			= 0x33
+	SO_ATTACH_REUSEPORT_EBPF			= 0x34
+	SO_BINDTODEVICE					= 0x19
+	SO_BINDTOIFINDEX				= 0x3e
+	SO_BPF_EXTENSIONS				= 0x30
+	SO_BROADCAST					= 0x20
+	SO_BSDCOMPAT					= 0xe
+	SO_BUF_LOCK					= 0x48
+	SO_BUSY_POLL					= 0x2e
+	SO_BUSY_POLL_BUDGET				= 0x46
+	SO_CNX_ADVICE					= 0x35
+	SO_COOKIE					= 0x39
+	SO_DEBUG					= 0x1
+	SO_DETACH_BPF					= 0x1b
+	SO_DETACH_FILTER				= 0x1b
+	SO_DETACH_REUSEPORT_BPF				= 0x44
+	SO_DOMAIN					= 0x1029
+	SO_DONTROUTE					= 0x10
+	SO_EE_CODE_TXTIME_INVALID_PARAM			= 0x1
+	SO_EE_CODE_TXTIME_MISSED			= 0x2
+	SO_EE_CODE_ZEROCOPY_COPIED			= 0x1
+	SO_EE_ORIGIN_ICMP				= 0x2
+	SO_EE_ORIGIN_ICMP6				= 0x3
+	SO_EE_ORIGIN_LOCAL				= 0x1
+	SO_EE_ORIGIN_NONE				= 0x0
+	SO_EE_ORIGIN_TIMESTAMPING			= 0x4
+	SO_EE_ORIGIN_TXSTATUS				= 0x4
+	SO_EE_ORIGIN_TXTIME				= 0x6
+	SO_EE_ORIGIN_ZEROCOPY				= 0x5
+	SO_EE_RFC4884_FLAG_INVALID			= 0x1
+	SO_ERROR					= 0x1007
+	SO_GET_FILTER					= 0x1a
+	SO_INCOMING_CPU					= 0x31
+	SO_INCOMING_NAPI_ID				= 0x38
+	SO_KEEPALIVE					= 0x8
+	SO_LINGER					= 0x80
+	SO_LOCK_FILTER					= 0x2c
+	SO_MARK						= 0x24
+	SO_MAX_PACING_RATE				= 0x2f
+	SO_MEMINFO					= 0x37
+	SO_NETNS_COOKIE					= 0x47
+	SO_NOFCS					= 0x2b
+	SO_NO_CHECK					= 0xb
+	SO_OOBINLINE					= 0x100
+	SO_PASSCRED					= 0x11
+	SO_PASSPIDFD					= 0x4c
+	SO_PASSSEC					= 0x22
+	SO_PEEK_OFF					= 0x2a
+	SO_PEERCRED					= 0x12
+	SO_PEERGROUPS					= 0x3b
+	SO_PEERNAME					= 0x1c
+	SO_PEERPIDFD					= 0x4d
+	SO_PEERSEC					= 0x1e
+	SO_PREFER_BUSY_POLL				= 0x45
+	SO_PRIORITY					= 0xc
+	SO_PROTOCOL					= 0x1028
+	SO_RCVBUF					= 0x1002
+	SO_RCVBUFFORCE					= 0x100b
+	SO_RCVLOWAT					= 0x1010
+	SO_RCVMARK					= 0x4b
+	SO_RCVTIMEO					= 0x1012
+	SO_RCVTIMEO_NEW					= 0x42
+	SO_RCVTIMEO_OLD					= 0x1012
+	SO_RESERVE_MEM					= 0x49
+	SO_REUSEADDR					= 0x4
+	SO_REUSEPORT					= 0x200
+	SO_RXQ_OVFL					= 0x28
+	SO_SECURITY_AUTHENTICATION			= 0x13
+	SO_SECURITY_ENCRYPTION_NETWORK			= 0x15
+	SO_SECURITY_ENCRYPTION_TRANSPORT		= 0x14
+	SO_SELECT_ERR_QUEUE				= 0x2d
+	SO_SNDBUF					= 0x1001
+	SO_SNDBUFFORCE					= 0x100a
+	SO_SNDLOWAT					= 0x1011
+	SO_SNDTIMEO					= 0x1013
+	SO_SNDTIMEO_NEW					= 0x43
+	SO_SNDTIMEO_OLD					= 0x1013
+	SO_TIMESTAMP					= 0x1d
+	SO_TIMESTAMPING					= 0x25
+	SO_TIMESTAMPING_NEW				= 0x41
+	SO_TIMESTAMPING_OLD				= 0x25
+	SO_TIMESTAMPNS					= 0x23
+	SO_TIMESTAMPNS_NEW				= 0x40
+	SO_TIMESTAMPNS_OLD				= 0x23
+	SO_TIMESTAMP_NEW				= 0x3f
+	SO_TIMESTAMP_OLD				= 0x1d
+	SO_TXREHASH					= 0x4a
+	SO_TXTIME					= 0x3d
+	SO_TYPE						= 0x1008
+	SO_VM_SOCKETS_BUFFER_MAX_SIZE			= 0x2
+	SO_VM_SOCKETS_BUFFER_MIN_SIZE			= 0x1
+	SO_VM_SOCKETS_BUFFER_SIZE			= 0x0
+	SO_VM_SOCKETS_CONNECT_TIMEOUT			= 0x6
+	SO_VM_SOCKETS_CONNECT_TIMEOUT_NEW		= 0x8
+	SO_VM_SOCKETS_CONNECT_TIMEOUT_OLD		= 0x6
+	SO_VM_SOCKETS_NONBLOCK_TXRX			= 0x7
+	SO_VM_SOCKETS_PEER_HOST_VM_ID			= 0x3
+	SO_VM_SOCKETS_TRUSTED				= 0x5
+	SO_WIFI_STATUS					= 0x29
+	SO_ZEROCOPY					= 0x3c
+	SPLICE_F_GIFT					= 0x8
+	SPLICE_F_MORE					= 0x4
+	SPLICE_F_MOVE					= 0x1
+	SPLICE_F_NONBLOCK				= 0x2
+	SQUASHFS_MAGIC					= 0x73717368
+	STACK_END_MAGIC					= 0x57ac6e9d
+	STATX_ALL					= 0xfff
+	STATX_ATIME					= 0x20
+	STATX_ATTR_APPEND				= 0x20
+	STATX_ATTR_AUTOMOUNT				= 0x1000
+	STATX_ATTR_COMPRESSED				= 0x4
+	STATX_ATTR_DAX					= 0x200000
+	STATX_ATTR_ENCRYPTED				= 0x800
+	STATX_ATTR_IMMUTABLE				= 0x10
+	STATX_ATTR_MOUNT_ROOT				= 0x2000
+	STATX_ATTR_NODUMP				= 0x40
+	STATX_ATTR_VERITY				= 0x100000
+	STATX_BASIC_STATS				= 0x7ff
+	STATX_BLOCKS					= 0x400
+	STATX_BTIME					= 0x800
+	STATX_CTIME					= 0x80
+	STATX_DIOALIGN					= 0x2000
+	STATX_GID					= 0x10
+	STATX_INO					= 0x100
+	STATX_MNT_ID					= 0x1000
+	STATX_MODE					= 0x2
+	STATX_MTIME					= 0x40
+	STATX_NLINK					= 0x4
+	STATX_SIZE					= 0x200
+	STATX_TYPE					= 0x1
+	STATX_UID					= 0x8
+	STATX__RESERVED					= 0x80000000
+	SYNC_FILE_RANGE_WAIT_AFTER			= 0x4
+	SYNC_FILE_RANGE_WAIT_BEFORE			= 0x1
+	SYNC_FILE_RANGE_WRITE				= 0x2
+	SYNC_FILE_RANGE_WRITE_AND_WAIT			= 0x7
+	SYSFS_MAGIC					= 0x62656572
+	S_BLKSIZE					= 0x200
+	S_IEXEC						= 0x40
+	S_IFBLK						= 0x6000
+	S_IFCHR						= 0x2000
+	S_IFDIR						= 0x4000
+	S_IFIFO						= 0x1000
+	S_IFLNK						= 0xa000
+	S_IFMT						= 0xf000
+	S_IFREG						= 0x8000
+	S_IFSOCK					= 0xc000
+	S_IREAD						= 0x100
+	S_IRGRP						= 0x20
+	S_IROTH						= 0x4
+	S_IRUSR						= 0x100
+	S_IRWXG						= 0x38
+	S_IRWXO						= 0x7
+	S_IRWXU						= 0x1c0
+	S_ISGID						= 0x400
+	S_ISUID						= 0x800
+	S_ISVTX						= 0x200
+	S_IWGRP						= 0x10
+	S_IWOTH						= 0x2
+	S_IWRITE					= 0x80
+	S_IWUSR						= 0x80
+	S_IXGRP						= 0x8
+	S_IXOTH						= 0x1
+	S_IXUSR						= 0x40
+	TAB0						= 0x0
+	TAB1						= 0x400
+	TAB2						= 0x800
+	TAB3						= 0xc00
+	TABDLY						= 0xc00
+	TASKSTATS_CMD_ATTR_MAX				= 0x4
+	TASKSTATS_CMD_MAX				= 0x2
+	TASKSTATS_GENL_NAME				= "TASKSTATS"
+	TASKSTATS_GENL_VERSION				= 0x1
+	TASKSTATS_TYPE_MAX				= 0x6
+	TASKSTATS_VERSION				= 0xe
+	TCFLSH						= 0x2000741f
+	TCGETA						= 0x40127417
+	TCGETS						= 0x402c7413
+	TCGETS2						= 0x402c542a
+	TCIFLUSH					= 0x0
+	TCIOFF						= 0x2
+	TCIOFLUSH					= 0x2
+	TCION						= 0x3
+	TCOFLUSH					= 0x1
+	TCOOFF						= 0x0
+	TCOON						= 0x1
+	TCPOPT_EOL					= 0x0
+	TCPOPT_MAXSEG					= 0x2
+	TCPOPT_NOP					= 0x1
+	TCPOPT_SACK					= 0x5
+	TCPOPT_SACK_PERMITTED				= 0x4
+	TCPOPT_TIMESTAMP				= 0x8
+	TCPOPT_TSTAMP_HDR				= 0x101080a
+	TCPOPT_WINDOW					= 0x3
+	TCP_CC_INFO					= 0x1a
+	TCP_CM_INQ					= 0x24
+	TCP_CONGESTION					= 0xd
+	TCP_COOKIE_IN_ALWAYS				= 0x1
+	TCP_COOKIE_MAX					= 0x10
+	TCP_COOKIE_MIN					= 0x8
+	TCP_COOKIE_OUT_NEVER				= 0x2
+	TCP_COOKIE_PAIR_SIZE				= 0x20
+	TCP_COOKIE_TRANSACTIONS				= 0xf
+	TCP_CORK					= 0x3
+	TCP_DEFER_ACCEPT				= 0x9
+	TCP_FASTOPEN					= 0x17
+	TCP_FASTOPEN_CONNECT				= 0x1e
+	TCP_FASTOPEN_KEY				= 0x21
+	TCP_FASTOPEN_NO_COOKIE				= 0x22
+	TCP_INFO					= 0xb
+	TCP_INQ						= 0x24
+	TCP_KEEPCNT					= 0x6
+	TCP_KEEPIDLE					= 0x4
+	TCP_KEEPINTVL					= 0x5
+	TCP_LINGER2					= 0x8
+	TCP_MAXSEG					= 0x2
+	TCP_MAXWIN					= 0xffff
+	TCP_MAX_WINSHIFT				= 0xe
+	TCP_MD5SIG					= 0xe
+	TCP_MD5SIG_EXT					= 0x20
+	TCP_MD5SIG_FLAG_PREFIX				= 0x1
+	TCP_MD5SIG_MAXKEYLEN				= 0x50
+	TCP_MSS						= 0x200
+	TCP_MSS_DEFAULT					= 0x218
+	TCP_MSS_DESIRED					= 0x4c4
+	TCP_NODELAY					= 0x1
+	TCP_NOTSENT_LOWAT				= 0x19
+	TCP_QUEUE_SEQ					= 0x15
+	TCP_QUICKACK					= 0xc
+	TCP_REPAIR					= 0x13
+	TCP_REPAIR_OFF					= 0x0
+	TCP_REPAIR_OFF_NO_WP				= -0x1
+	TCP_REPAIR_ON					= 0x1
+	TCP_REPAIR_OPTIONS				= 0x16
+	TCP_REPAIR_QUEUE				= 0x14
+	TCP_REPAIR_WINDOW				= 0x1d
+	TCP_SAVED_SYN					= 0x1c
+	TCP_SAVE_SYN					= 0x1b
+	TCP_SYNCNT					= 0x7
+	TCP_S_DATA_IN					= 0x4
+	TCP_S_DATA_OUT					= 0x8
+	TCP_THIN_DUPACK					= 0x11
+	TCP_THIN_LINEAR_TIMEOUTS			= 0x10
+	TCP_TIMESTAMP					= 0x18
+	TCP_TX_DELAY					= 0x25
+	TCP_ULP						= 0x1f
+	TCP_USER_TIMEOUT				= 0x12
+	TCP_V4_FLOW					= 0x1
+	TCP_V6_FLOW					= 0x5
+	TCP_WINDOW_CLAMP				= 0xa
+	TCP_ZEROCOPY_RECEIVE				= 0x23
+	TCSAFLUSH					= 0x2
+	TCSBRK						= 0x2000741d
+	TCSBRKP						= 0x5425
+	TCSETA						= 0x80127418
+	TCSETAF						= 0x8012741c
+	TCSETAW						= 0x80127419
+	TCSETS						= 0x802c7414
+	TCSETS2						= 0x802c542b
+	TCSETSF						= 0x802c7416
+	TCSETSF2					= 0x802c542d
+	TCSETSW						= 0x802c7415
+	TCSETSW2					= 0x802c542c
+	TCXONC						= 0x2000741e
+	TFD_CLOEXEC					= 0x200000
+	TFD_NONBLOCK					= 0x4
+	TFD_TIMER_ABSTIME				= 0x1
+	TFD_TIMER_CANCEL_ON_SET				= 0x2
+	TIMER_ABSTIME					= 0x1
+	TIOCCBRK					= 0x5428
+	TIOCCONS					= 0x541d
+	TIOCEXCL					= 0x540c
+	TIOCGDEV					= 0x40045432
+	TIOCGETD					= 0x5424
+	TIOCGEXCL					= 0x40045440
+	TIOCGICOUNT					= 0x545d
+	TIOCGLCKTRMIOS					= 0x5456
+	TIOCGPGRP					= 0x40047477
+	TIOCGPKT					= 0x40045438
+	TIOCGPTLCK					= 0x40045439
+	TIOCGPTN					= 0x40045430
+	TIOCGPTPEER					= 0x20005441
+	TIOCGSERIAL					= 0x541e
+	TIOCGSID					= 0x5429
+	TIOCGSOFTCAR					= 0x5419
+	TIOCLINUX					= 0x541c
+	TIOCMBIC					= 0x5417
+	TIOCMBIS					= 0x5416
+	TIOCMGET					= 0x5415
+	TIOCMIWAIT					= 0x545c
+	TIOCMSET					= 0x5418
+	TIOCM_CAR					= 0x40
+	TIOCM_CD					= 0x40
+	TIOCM_CTS					= 0x20
+	TIOCM_DSR					= 0x100
+	TIOCM_DTR					= 0x2
+	TIOCM_LE					= 0x1
+	TIOCM_LOOP					= 0x8000
+	TIOCM_OUT1					= 0x2000
+	TIOCM_OUT2					= 0x4000
+	TIOCM_RI					= 0x80
+	TIOCM_RNG					= 0x80
+	TIOCM_RTS					= 0x4
+	TIOCM_SR					= 0x10
+	TIOCM_ST					= 0x8
+	TIOCNOTTY					= 0x5422
+	TIOCNXCL					= 0x540d
+	TIOCOUTQ					= 0x40047473
+	TIOCPKT						= 0x5420
+	TIOCPKT_DATA					= 0x0
+	TIOCPKT_DOSTOP					= 0x20
+	TIOCPKT_FLUSHREAD				= 0x1
+	TIOCPKT_FLUSHWRITE				= 0x2
+	TIOCPKT_IOCTL					= 0x40
+	TIOCPKT_NOSTOP					= 0x10
+	TIOCPKT_START					= 0x8
+	TIOCPKT_STOP					= 0x4
+	TIOCSBRK					= 0x5427
+	TIOCSCTTY					= 0x540e
+	TIOCSERCONFIG					= 0x5453
+	TIOCSERGETLSR					= 0x5459
+	TIOCSERGETMULTI					= 0x545a
+	TIOCSERGSTRUCT					= 0x5458
+	TIOCSERGWILD					= 0x5454
+	TIOCSERSETMULTI					= 0x545b
+	TIOCSERSWILD					= 0x5455
+	TIOCSER_TEMT					= 0x1
+	TIOCSETD					= 0x5423
+	TIOCSIG						= 0x80045436
+	TIOCSLCKTRMIOS					= 0x5457
+	TIOCSPGRP					= 0x80047476
+	TIOCSPTLCK					= 0x80045431
+	TIOCSSERIAL					= 0x541f
+	TIOCSSOFTCAR					= 0x541a
+	TIOCSTART					= 0x2000746e
+	TIOCSTI						= 0x5412
+	TIOCSTOP					= 0x2000746f
+	TIOCVHANGUP					= 0x5437
+	TIPC_ADDR_ID					= 0x3
+	TIPC_ADDR_MCAST					= 0x1
+	TIPC_ADDR_NAME					= 0x2
+	TIPC_ADDR_NAMESEQ				= 0x1
+	TIPC_AEAD_ALG_NAME				= 0x20
+	TIPC_AEAD_KEYLEN_MAX				= 0x24
+	TIPC_AEAD_KEYLEN_MIN				= 0x14
+	TIPC_AEAD_KEY_SIZE_MAX				= 0x48
+	TIPC_CFG_SRV					= 0x0
+	TIPC_CLUSTER_BITS				= 0xc
+	TIPC_CLUSTER_MASK				= 0xfff000
+	TIPC_CLUSTER_OFFSET				= 0xc
+	TIPC_CLUSTER_SIZE				= 0xfff
+	TIPC_CONN_SHUTDOWN				= 0x5
+	TIPC_CONN_TIMEOUT				= 0x82
+	TIPC_CRITICAL_IMPORTANCE			= 0x3
+	TIPC_DESTNAME					= 0x3
+	TIPC_DEST_DROPPABLE				= 0x81
+	TIPC_ERRINFO					= 0x1
+	TIPC_ERR_NO_NAME				= 0x1
+	TIPC_ERR_NO_NODE				= 0x3
+	TIPC_ERR_NO_PORT				= 0x2
+	TIPC_ERR_OVERLOAD				= 0x4
+	TIPC_GROUP_JOIN					= 0x87
+	TIPC_GROUP_LEAVE				= 0x88
+	TIPC_GROUP_LOOPBACK				= 0x1
+	TIPC_GROUP_MEMBER_EVTS				= 0x2
+	TIPC_HIGH_IMPORTANCE				= 0x2
+	TIPC_IMPORTANCE					= 0x7f
+	TIPC_LINK_STATE					= 0x2
+	TIPC_LOW_IMPORTANCE				= 0x0
+	TIPC_MAX_BEARER_NAME				= 0x20
+	TIPC_MAX_IF_NAME				= 0x10
+	TIPC_MAX_LINK_NAME				= 0x44
+	TIPC_MAX_MEDIA_NAME				= 0x10
+	TIPC_MAX_USER_MSG_SIZE				= 0x101d0
+	TIPC_MCAST_BROADCAST				= 0x85
+	TIPC_MCAST_REPLICAST				= 0x86
+	TIPC_MEDIUM_IMPORTANCE				= 0x1
+	TIPC_NODEID_LEN					= 0x10
+	TIPC_NODELAY					= 0x8a
+	TIPC_NODE_BITS					= 0xc
+	TIPC_NODE_MASK					= 0xfff
+	TIPC_NODE_OFFSET				= 0x0
+	TIPC_NODE_RECVQ_DEPTH				= 0x83
+	TIPC_NODE_SIZE					= 0xfff
+	TIPC_NODE_STATE					= 0x0
+	TIPC_OK						= 0x0
+	TIPC_PUBLISHED					= 0x1
+	TIPC_REKEYING_NOW				= 0xffffffff
+	TIPC_RESERVED_TYPES				= 0x40
+	TIPC_RETDATA					= 0x2
+	TIPC_SERVICE_ADDR				= 0x2
+	TIPC_SERVICE_RANGE				= 0x1
+	TIPC_SOCKET_ADDR				= 0x3
+	TIPC_SOCK_RECVQ_DEPTH				= 0x84
+	TIPC_SOCK_RECVQ_USED				= 0x89
+	TIPC_SRC_DROPPABLE				= 0x80
+	TIPC_SUBSCR_TIMEOUT				= 0x3
+	TIPC_SUB_CANCEL					= 0x4
+	TIPC_SUB_PORTS					= 0x1
+	TIPC_SUB_SERVICE				= 0x2
+	TIPC_TOP_SRV					= 0x1
+	TIPC_WAIT_FOREVER				= 0xffffffff
+	TIPC_WITHDRAWN					= 0x2
+	TIPC_ZONE_BITS					= 0x8
+	TIPC_ZONE_CLUSTER_MASK				= 0xfffff000
+	TIPC_ZONE_MASK					= 0xff000000
+	TIPC_ZONE_OFFSET				= 0x18
+	TIPC_ZONE_SCOPE					= 0x1
+	TIPC_ZONE_SIZE					= 0xff
+	TMPFS_MAGIC					= 0x1021994
+	TOSTOP						= 0x400000
+	TPACKET_ALIGNMENT				= 0x10
+	TPACKET_HDRLEN					= 0x34
+	TP_STATUS_AVAILABLE				= 0x0
+	TP_STATUS_BLK_TMO				= 0x20
+	TP_STATUS_COPY					= 0x2
+	TP_STATUS_CSUMNOTREADY				= 0x8
+	TP_STATUS_CSUM_VALID				= 0x80
+	TP_STATUS_GSO_TCP				= 0x100
+	TP_STATUS_KERNEL				= 0x0
+	TP_STATUS_LOSING				= 0x4
+	TP_STATUS_SENDING				= 0x2
+	TP_STATUS_SEND_REQUEST				= 0x1
+	TP_STATUS_TS_RAW_HARDWARE			= 0x80000000
+	TP_STATUS_TS_SOFTWARE				= 0x20000000
+	TP_STATUS_TS_SYS_HARDWARE			= 0x40000000
+	TP_STATUS_USER					= 0x1
+	TP_STATUS_VLAN_TPID_VALID			= 0x40
+	TP_STATUS_VLAN_VALID				= 0x10
+	TP_STATUS_WRONG_FORMAT				= 0x4
+	TRACEFS_MAGIC					= 0x74726163
+	TS_COMM_LEN					= 0x20
+	TUNATTACHFILTER					= 0x801054d5
+	TUNDETACHFILTER					= 0x801054d6
+	TUNGETDEVNETNS					= 0x200054e3
+	TUNGETFEATURES					= 0x400454cf
+	TUNGETFILTER					= 0x401054db
+	TUNGETIFF					= 0x400454d2
+	TUNGETSNDBUF					= 0x400454d3
+	TUNGETVNETBE					= 0x400454df
+	TUNGETVNETHDRSZ					= 0x400454d7
+	TUNGETVNETLE					= 0x400454dd
+	TUNSETCARRIER					= 0x800454e2
+	TUNSETDEBUG					= 0x800454c9
+	TUNSETFILTEREBPF				= 0x400454e1
+	TUNSETGROUP					= 0x800454ce
+	TUNSETIFF					= 0x800454ca
+	TUNSETIFINDEX					= 0x800454da
+	TUNSETLINK					= 0x800454cd
+	TUNSETNOCSUM					= 0x800454c8
+	TUNSETOFFLOAD					= 0x800454d0
+	TUNSETOWNER					= 0x800454cc
+	TUNSETPERSIST					= 0x800454cb
+	TUNSETQUEUE					= 0x800454d9
+	TUNSETSNDBUF					= 0x800454d4
+	TUNSETSTEERINGEBPF				= 0x400454e0
+	TUNSETTXFILTER					= 0x800454d1
+	TUNSETVNETBE					= 0x800454de
+	TUNSETVNETHDRSZ					= 0x800454d8
+	TUNSETVNETLE					= 0x800454dc
+	UBI_IOCATT					= 0x80186f40
+	UBI_IOCDET					= 0x80046f41
+	UBI_IOCEBCH					= 0x80044f02
+	UBI_IOCEBER					= 0x80044f01
+	UBI_IOCEBISMAP					= 0x40044f05
+	UBI_IOCEBMAP					= 0x80084f03
+	UBI_IOCEBUNMAP					= 0x80044f04
+	UBI_IOCMKVOL					= 0x80986f00
+	UBI_IOCRMVOL					= 0x80046f01
+	UBI_IOCRNVOL					= 0x91106f03
+	UBI_IOCRPEB					= 0x80046f04
+	UBI_IOCRSVOL					= 0x800c6f02
+	UBI_IOCSETVOLPROP				= 0x80104f06
+	UBI_IOCSPEB					= 0x80046f05
+	UBI_IOCVOLCRBLK					= 0x80804f07
+	UBI_IOCVOLRMBLK					= 0x20004f08
+	UBI_IOCVOLUP					= 0x80084f00
+	UDF_SUPER_MAGIC					= 0x15013346
+	UDP_CORK					= 0x1
+	UDP_ENCAP					= 0x64
+	UDP_ENCAP_ESPINUDP				= 0x2
+	UDP_ENCAP_ESPINUDP_NON_IKE			= 0x1
+	UDP_ENCAP_GTP0					= 0x4
+	UDP_ENCAP_GTP1U					= 0x5
+	UDP_ENCAP_L2TPINUDP				= 0x3
+	UDP_GRO						= 0x68
+	UDP_NO_CHECK6_RX				= 0x66
+	UDP_NO_CHECK6_TX				= 0x65
+	UDP_SEGMENT					= 0x67
+	UDP_V4_FLOW					= 0x2
+	UDP_V6_FLOW					= 0x6
+	UMOUNT_NOFOLLOW					= 0x8
+	USBDEVICE_SUPER_MAGIC				= 0x9fa2
+	UTIME_NOW					= 0x3fffffff
+	UTIME_OMIT					= 0x3ffffffe
+	V9FS_MAGIC					= 0x1021997
+	VDISCARD					= 0xf
+	VEOF						= 0x0
+	VEOL						= 0x1
+	VEOL2						= 0x2
+	VERASE						= 0x3
+	VINTR						= 0x8
+	VKILL						= 0x5
+	VLNEXT						= 0xe
+	VMADDR_CID_ANY					= 0xffffffff
+	VMADDR_CID_HOST					= 0x2
+	VMADDR_CID_HYPERVISOR				= 0x0
+	VMADDR_CID_LOCAL				= 0x1
+	VMADDR_FLAG_TO_HOST				= 0x1
+	VMADDR_PORT_ANY					= 0xffffffff
+	VMIN						= 0x10
+	VM_SOCKETS_INVALID_VERSION			= 0xffffffff
+	VQUIT						= 0x9
+	VREPRINT					= 0x6
+	VSTART						= 0xc
+	VSTOP						= 0xd
+	VSUSP						= 0xa
+	VSWTC						= 0x7
+	VT0						= 0x0
+	VT1						= 0x10000
+	VTDLY						= 0x10000
+	VTIME						= 0x11
+	VWERASE						= 0x4
+	WAKE_MAGIC					= 0x20
+	WALL						= 0x40000000
+	WCLONE						= 0x80000000
+	WCONTINUED					= 0x8
+	WDIOC_GETBOOTSTATUS				= 0x40045702
+	WDIOC_GETPRETIMEOUT				= 0x40045709
+	WDIOC_GETSTATUS					= 0x40045701
+	WDIOC_GETSUPPORT				= 0x40285700
+	WDIOC_GETTEMP					= 0x40045703
+	WDIOC_GETTIMELEFT				= 0x4004570a
+	WDIOC_GETTIMEOUT				= 0x40045707
+	WDIOC_KEEPALIVE					= 0x40045705
+	WDIOC_SETOPTIONS				= 0x40045704
+	WDIOC_SETPRETIMEOUT				= 0xc0045708
+	WDIOC_SETTIMEOUT				= 0xc0045706
+	WDIOF_ALARMONLY					= 0x400
+	WDIOF_CARDRESET					= 0x20
+	WDIOF_EXTERN1					= 0x4
+	WDIOF_EXTERN2					= 0x8
+	WDIOF_FANFAULT					= 0x2
+	WDIOF_KEEPALIVEPING				= 0x8000
+	WDIOF_MAGICCLOSE				= 0x100
+	WDIOF_OVERHEAT					= 0x1
+	WDIOF_POWEROVER					= 0x40
+	WDIOF_POWERUNDER				= 0x10
+	WDIOF_PRETIMEOUT				= 0x200
+	WDIOF_SETTIMEOUT				= 0x80
+	WDIOF_UNKNOWN					= -0x1
+	WDIOS_DISABLECARD				= 0x1
+	WDIOS_ENABLECARD				= 0x2
+	WDIOS_TEMPPANIC					= 0x4
+	WDIOS_UNKNOWN					= -0x1
+	WEXITED						= 0x4
+	WGALLOWEDIP_A_MAX				= 0x3
+	WGDEVICE_A_MAX					= 0x8
+	WGPEER_A_MAX					= 0xa
+	WG_CMD_MAX					= 0x1
+	WG_GENL_NAME					= "wireguard"
+	WG_GENL_VERSION					= 0x1
+	WG_KEY_LEN					= 0x20
+	WIN_ACKMEDIACHANGE				= 0xdb
+	WIN_CHECKPOWERMODE1				= 0xe5
+	WIN_CHECKPOWERMODE2				= 0x98
+	WIN_DEVICE_RESET				= 0x8
+	WIN_DIAGNOSE					= 0x90
+	WIN_DOORLOCK					= 0xde
+	WIN_DOORUNLOCK					= 0xdf
+	WIN_DOWNLOAD_MICROCODE				= 0x92
+	WIN_FLUSH_CACHE					= 0xe7
+	WIN_FLUSH_CACHE_EXT				= 0xea
+	WIN_FORMAT					= 0x50
+	WIN_GETMEDIASTATUS				= 0xda
+	WIN_IDENTIFY					= 0xec
+	WIN_IDENTIFY_DMA				= 0xee
+	WIN_IDLEIMMEDIATE				= 0xe1
+	WIN_INIT					= 0x60
+	WIN_MEDIAEJECT					= 0xed
+	WIN_MULTREAD					= 0xc4
+	WIN_MULTREAD_EXT				= 0x29
+	WIN_MULTWRITE					= 0xc5
+	WIN_MULTWRITE_EXT				= 0x39
+	WIN_NOP						= 0x0
+	WIN_PACKETCMD					= 0xa0
+	WIN_PIDENTIFY					= 0xa1
+	WIN_POSTBOOT					= 0xdc
+	WIN_PREBOOT					= 0xdd
+	WIN_QUEUED_SERVICE				= 0xa2
+	WIN_READ					= 0x20
+	WIN_READDMA					= 0xc8
+	WIN_READDMA_EXT					= 0x25
+	WIN_READDMA_ONCE				= 0xc9
+	WIN_READDMA_QUEUED				= 0xc7
+	WIN_READDMA_QUEUED_EXT				= 0x26
+	WIN_READ_BUFFER					= 0xe4
+	WIN_READ_EXT					= 0x24
+	WIN_READ_LONG					= 0x22
+	WIN_READ_LONG_ONCE				= 0x23
+	WIN_READ_NATIVE_MAX				= 0xf8
+	WIN_READ_NATIVE_MAX_EXT				= 0x27
+	WIN_READ_ONCE					= 0x21
+	WIN_RECAL					= 0x10
+	WIN_RESTORE					= 0x10
+	WIN_SECURITY_DISABLE				= 0xf6
+	WIN_SECURITY_ERASE_PREPARE			= 0xf3
+	WIN_SECURITY_ERASE_UNIT				= 0xf4
+	WIN_SECURITY_FREEZE_LOCK			= 0xf5
+	WIN_SECURITY_SET_PASS				= 0xf1
+	WIN_SECURITY_UNLOCK				= 0xf2
+	WIN_SEEK					= 0x70
+	WIN_SETFEATURES					= 0xef
+	WIN_SETIDLE1					= 0xe3
+	WIN_SETIDLE2					= 0x97
+	WIN_SETMULT					= 0xc6
+	WIN_SET_MAX					= 0xf9
+	WIN_SET_MAX_EXT					= 0x37
+	WIN_SLEEPNOW1					= 0xe6
+	WIN_SLEEPNOW2					= 0x99
+	WIN_SMART					= 0xb0
+	WIN_SPECIFY					= 0x91
+	WIN_SRST					= 0x8
+	WIN_STANDBY					= 0xe2
+	WIN_STANDBY2					= 0x96
+	WIN_STANDBYNOW1					= 0xe0
+	WIN_STANDBYNOW2					= 0x94
+	WIN_VERIFY					= 0x40
+	WIN_VERIFY_EXT					= 0x42
+	WIN_VERIFY_ONCE					= 0x41
+	WIN_WRITE					= 0x30
+	WIN_WRITEDMA					= 0xca
+	WIN_WRITEDMA_EXT				= 0x35
+	WIN_WRITEDMA_ONCE				= 0xcb
+	WIN_WRITEDMA_QUEUED				= 0xcc
+	WIN_WRITEDMA_QUEUED_EXT				= 0x36
+	WIN_WRITE_BUFFER				= 0xe8
+	WIN_WRITE_EXT					= 0x34
+	WIN_WRITE_LONG					= 0x32
+	WIN_WRITE_LONG_ONCE				= 0x33
+	WIN_WRITE_ONCE					= 0x31
+	WIN_WRITE_SAME					= 0xe9
+	WIN_WRITE_VERIFY				= 0x3c
+	WNOHANG						= 0x1
+	WNOTHREAD					= 0x20000000
+	WNOWAIT						= 0x1000000
+	WORDSIZE					= 0x40
+	WSTOPPED					= 0x2
+	WUNTRACED					= 0x2
+	XATTR_CREATE					= 0x1
+	XATTR_REPLACE					= 0x2
+	XCASE						= 0x4000
+	XDP_COPY					= 0x2
+	XDP_FLAGS_DRV_MODE				= 0x4
+	XDP_FLAGS_HW_MODE				= 0x8
+	XDP_FLAGS_MASK					= 0x1f
+	XDP_FLAGS_MODES					= 0xe
+	XDP_FLAGS_REPLACE				= 0x10
+	XDP_FLAGS_SKB_MODE				= 0x2
+	XDP_FLAGS_UPDATE_IF_NOEXIST			= 0x1
+	XDP_MMAP_OFFSETS				= 0x1
+	XDP_OPTIONS					= 0x8
+	XDP_OPTIONS_ZEROCOPY				= 0x1
+	XDP_PACKET_HEADROOM				= 0x100
+	XDP_PGOFF_RX_RING				= 0x0
+	XDP_PGOFF_TX_RING				= 0x80000000
+	XDP_PKT_CONTD					= 0x1
+	XDP_RING_NEED_WAKEUP				= 0x1
+	XDP_RX_RING					= 0x2
+	XDP_SHARED_UMEM					= 0x1
+	XDP_STATISTICS					= 0x7
+	XDP_TX_RING					= 0x3
+	XDP_UMEM_COMPLETION_RING			= 0x6
+	XDP_UMEM_FILL_RING				= 0x5
+	XDP_UMEM_PGOFF_COMPLETION_RING			= 0x180000000
+	XDP_UMEM_PGOFF_FILL_RING			= 0x100000000
+	XDP_UMEM_REG					= 0x4
+	XDP_UMEM_UNALIGNED_CHUNK_FLAG			= 0x1
+	XDP_USE_NEED_WAKEUP				= 0x8
+	XDP_USE_SG					= 0x10
+	XDP_ZEROCOPY					= 0x4
+	XENFS_SUPER_MAGIC				= 0xabba1974
+	XFS_SUPER_MAGIC					= 0x58465342
+	XTABS						= 0xc00
+	ZONEFS_MAGIC					= 0x5a4f4653
+	_HIDIOCGRAWNAME					= 0x40804804
+	_HIDIOCGRAWNAME_LEN				= 0x80
+	_HIDIOCGRAWPHYS					= 0x40404805
+	_HIDIOCGRAWPHYS_LEN				= 0x40
+	_HIDIOCGRAWUNIQ					= 0x40404808
+	_HIDIOCGRAWUNIQ_LEN				= 0x40
+)
+
+// Errors
+const (
+	E2BIG						= syscall.Errno( 0x7)
+	EACCES						= syscall.Errno( 0xd)
+	EADDRINUSE					= syscall.Errno( 0x30)
+	EADDRNOTAVAIL					= syscall.Errno( 0x31)
+	EADV						= syscall.Errno( 0x6b)
+	EAFNOSUPPORT					= syscall.Errno( 0x2f)
+	EAGAIN						= syscall.Errno( 0x23)
+	EALREADY					= syscall.Errno( 0x25)
+	EBADE						= syscall.Errno( 0x61)
+	EBADF						= syscall.Errno( 0x9)
+	EBADFD						= syscall.Errno( 0x72)
+	EBADMSG						= syscall.Errno( 0x54)
+	EBADR						= syscall.Errno( 0x62)
+	EBADRQC						= syscall.Errno( 0x65)
+	EBADSLT						= syscall.Errno( 0x66)
+	EBFONT						= syscall.Errno( 0x68)
+	EBUSY						= syscall.Errno( 0x10)
+	ECANCELED					= syscall.Errno( 0x83)
+	ECHILD						= syscall.Errno( 0xa)
+	ECHRNG						= syscall.Errno( 0x58)
+	ECOMM						= syscall.Errno( 0x6d)
+	ECONNABORTED					= syscall.Errno( 0x35)
+	ECONNREFUSED					= syscall.Errno( 0x3d)
+	ECONNRESET					= syscall.Errno( 0x36)
+	EDEADLK						= syscall.Errno( 0xb)
+	EDEADLOCK					= syscall.Errno( 0xb)
+	EDESTADDRREQ					= syscall.Errno( 0x27)
+	EDOM						= syscall.Errno( 0x21)
+	EDOTDOT						= syscall.Errno( 0x6f)
+	EDQUOT						= syscall.Errno( 0x45)
+	EEXIST						= syscall.Errno( 0x11)
+	EFAULT						= syscall.Errno( 0xe)
+	EFBIG						= syscall.Errno( 0x1b)
+	EHOSTDOWN					= syscall.Errno( 0x40)
+	EHOSTUNREACH					= syscall.Errno( 0x41)
+	EHWPOISON					= syscall.Errno( 0x8b)
+	EIDRM						= syscall.Errno( 0x51)
+	EILSEQ						= syscall.Errno( 0x74)
+	EINPROGRESS					= syscall.Errno( 0x24)
+	EINTR						= syscall.Errno( 0x4)
+	EINVAL						= syscall.Errno( 0x16)
+	EIO						= syscall.Errno( 0x5)
+	EISCONN						= syscall.Errno( 0x38)
+	EISDIR						= syscall.Errno( 0x15)
+	EISNAM						= syscall.Errno( 0x78)
+	EKEYEXPIRED					= syscall.Errno( 0x85)
+	EKEYREJECTED					= syscall.Errno( 0x87)
+	EKEYREVOKED					= syscall.Errno( 0x86)
+	EL2HLT						= syscall.Errno( 0x60)
+	EL2NSYNC					= syscall.Errno( 0x59)
+	EL3HLT						= syscall.Errno( 0x5a)
+	EL3RST						= syscall.Errno( 0x5b)
+	ELIBACC						= syscall.Errno( 0x7a)
+	ELIBBAD						= syscall.Errno( 0x7b)
+	ELIBEXEC					= syscall.Errno( 0x7e)
+	ELIBMAX						= syscall.Errno( 0x7d)
+	ELIBSCN						= syscall.Errno( 0x7c)
+	ELNRNG						= syscall.Errno( 0x5d)
+	ELOOP						= syscall.Errno( 0x3e)
+	EMEDIUMTYPE					= syscall.Errno( 0x82)
+	EMFILE						= syscall.Errno( 0x18)
+	EMLINK						= syscall.Errno( 0x1f)
+	EMSGSIZE					= syscall.Errno( 0x28)
+	EMULTIHOP					= syscall.Errno( 0x6e)
+	ENAMETOOLONG					= syscall.Errno( 0x3f)
+	ENAVAIL						= syscall.Errno( 0x77)
+	ENETDOWN					= syscall.Errno( 0x32)
+	ENETRESET					= syscall.Errno( 0x34)
+	ENETUNREACH					= syscall.Errno( 0x33)
+	ENFILE						= syscall.Errno( 0x17)
+	ENOANO						= syscall.Errno( 0x64)
+	ENOBUFS						= syscall.Errno( 0x37)
+	ENOCSI						= syscall.Errno( 0x5f)
+	ENODATA						= syscall.Errno( 0x56)
+	ENODEV						= syscall.Errno( 0x13)
+	ENOENT						= syscall.Errno( 0x2)
+	ENOEXEC						= syscall.Errno( 0x8)
+	ENOKEY						= syscall.Errno( 0x84)
+	ENOLCK						= syscall.Errno( 0x4d)
+	ENOLINK						= syscall.Errno( 0x6a)
+	ENOMEDIUM					= syscall.Errno( 0x81)
+	ENOMEM						= syscall.Errno( 0xc)
+	ENOMSG						= syscall.Errno( 0x50)
+	ENONET						= syscall.Errno( 0x69)
+	ENOPKG						= syscall.Errno( 0x5c)
+	ENOPROTOOPT					= syscall.Errno( 0x2a)
+	ENOSPC						= syscall.Errno( 0x1c)
+	ENOSR						= syscall.Errno( 0x52)
+	ENOSTR						= syscall.Errno( 0x57)
+	ENOSYS						= syscall.Errno( 0x4e)
+	ENOTBLK						= syscall.Errno( 0xf)
+	ENOTCONN					= syscall.Errno( 0x39)
+	ENOTDIR						= syscall.Errno( 0x14)
+	ENOTEMPTY					= syscall.Errno( 0x42)
+	ENOTNAM						= syscall.Errno( 0x76)
+	ENOTRECOVERABLE					= syscall.Errno( 0x89)
+	ENOTSOCK					= syscall.Errno( 0x26)
+	ENOTSUP						= syscall.Errno( 0x2d)
+	ENOTTY						= syscall.Errno( 0x19)
+	ENOTUNIQ					= syscall.Errno( 0x71)
+	ENXIO						= syscall.Errno( 0x6)
+	EOPNOTSUPP					= syscall.Errno( 0x2d)
+	EOVERFLOW					= syscall.Errno( 0x70)
+	EOWNERDEAD					= syscall.Errno( 0x88)
+	EPERM						= syscall.Errno( 0x1)
+	EPFNOSUPPORT					= syscall.Errno( 0x2e)
+	EPIPE						= syscall.Errno( 0x20)
+	EPROTO						= syscall.Errno( 0x55)
+	EPROTONOSUPPORT					= syscall.Errno( 0x2b)
+	EPROTOTYPE					= syscall.Errno( 0x29)
+	ERANGE						= syscall.Errno( 0x22)
+	EREMCHG						= syscall.Errno( 0x73)
+	EREMOTE						= syscall.Errno( 0x47)
+	EREMOTEIO					= syscall.Errno( 0x79)
+	ERESTART					= syscall.Errno( 0x7f)
+	ERFKILL						= syscall.Errno( 0x8a)
+	EROFS						= syscall.Errno( 0x1e)
+	ESHUTDOWN					= syscall.Errno( 0x3a)
+	ESOCKTNOSUPPORT					= syscall.Errno( 0x2c)
+	ESPIPE						= syscall.Errno( 0x1d)
+	ESRCH						= syscall.Errno( 0x3)
+	ESRMNT						= syscall.Errno( 0x6c)
+	ESTALE						= syscall.Errno( 0x46)
+	ESTRPIPE					= syscall.Errno( 0x80)
+	ETIME						= syscall.Errno( 0x53)
+	ETIMEDOUT					= syscall.Errno( 0x3c)
+	ETOOMANYREFS					= syscall.Errno( 0x3b)
+	ETXTBSY						= syscall.Errno( 0x1a)
+	EUCLEAN						= syscall.Errno( 0x75)
+	EUNATCH						= syscall.Errno( 0x5e)
+	EUSERS						= syscall.Errno( 0x44)
+	EWOULDBLOCK					= syscall.Errno( 0x23)
+	EXDEV						= syscall.Errno( 0x12)
+	EXFULL						= syscall.Errno( 0x63)
+)
+
+// Signals
+const (
+	SIGABRT						= syscall.Signal( 0x6)
+	SIGALRM						= syscall.Signal( 0xe)
+	SIGBUS						= syscall.Signal( 0xa)
+	SIGCHLD						= syscall.Signal( 0x14)
+	SIGCLD						= syscall.Signal( 0x14)
+	SIGCONT						= syscall.Signal( 0x13)
+	SIGEMT						= syscall.Signal( 0x7)
+	SIGFPE						= syscall.Signal( 0x8)
+	SIGHUP						= syscall.Signal( 0x1)
+	SIGILL						= syscall.Signal( 0x4)
+	SIGINFO						= syscall.Signal( 0x1d)
+	SIGINT						= syscall.Signal( 0x2)
+	SIGIO						= syscall.Signal( 0x17)
+	SIGIOT						= syscall.Signal( 0x6)
+	SIGKILL						= syscall.Signal( 0x9)
+	SIGPIPE						= syscall.Signal( 0xd)
+	SIGPOLL						= syscall.Signal( 0x17)
+	SIGPROF						= syscall.Signal( 0x1b)
+	SIGPWR						= syscall.Signal( 0x1d)
+	SIGQUIT						= syscall.Signal( 0x3)
+	SIGSEGV						= syscall.Signal( 0xb)
+	SIGSTOP						= syscall.Signal( 0x11)
+	SIGSYS						= syscall.Signal( 0xc)
+	SIGTERM						= syscall.Signal( 0xf)
+	SIGTRAP						= syscall.Signal( 0x5)
+	SIGTSTP						= syscall.Signal( 0x12)
+	SIGTTIN						= syscall.Signal( 0x15)
+	SIGTTOU						= syscall.Signal( 0x16)
+	SIGURG						= syscall.Signal( 0x10)
+	SIGUSR1						= syscall.Signal( 0x1e)
+	SIGUSR2						= syscall.Signal( 0x1f)
+	SIGVTALRM					= syscall.Signal( 0x1a)
+	SIGWINCH					= syscall.Signal( 0x1c)
+	SIGXCPU						= syscall.Signal( 0x18)
+	SIGXFSZ						= syscall.Signal( 0x19)
+)
+
+
+// Error table
+var errorList = [...]struct {
+	num  syscall.Errno
+	name string
+	desc string
+} {
+	{ 1, "EPERM", "operation not permitted" },
+	{ 2, "ENOENT", "no such file or directory" },
+	{ 3, "ESRCH", "no such process" },
+	{ 4, "EINTR", "interrupted system call" },
+	{ 5, "EIO", "input/output error" },
+	{ 6, "ENXIO", "no such device or address" },
+	{ 7, "E2BIG", "argument list too long" },
+	{ 8, "ENOEXEC", "exec format error" },
+	{ 9, "EBADF", "bad file descriptor" },
+	{ 10, "ECHILD", "no child processes" },
+	{ 11, "EDEADLK", "resource deadlock avoided" },
+	{ 12, "ENOMEM", "cannot allocate memory" },
+	{ 13, "EACCES", "permission denied" },
+	{ 14, "EFAULT", "bad address" },
+	{ 15, "ENOTBLK", "block device required" },
+	{ 16, "EBUSY", "device or resource busy" },
+	{ 17, "EEXIST", "file exists" },
+	{ 18, "EXDEV", "invalid cross-device link" },
+	{ 19, "ENODEV", "no such device" },
+	{ 20, "ENOTDIR", "not a directory" },
+	{ 21, "EISDIR", "is a directory" },
+	{ 22, "EINVAL", "invalid argument" },
+	{ 23, "ENFILE", "too many open files in system" },
+	{ 24, "EMFILE", "too many open files" },
+	{ 25, "ENOTTY", "inappropriate ioctl for device" },
+	{ 26, "ETXTBSY", "text file busy" },
+	{ 27, "EFBIG", "file too large" },
+	{ 28, "ENOSPC", "no space left on device" },
+	{ 29, "ESPIPE", "illegal seek" },
+	{ 30, "EROFS", "read-only file system" },
+	{ 31, "EMLINK", "too many links" },
+	{ 32, "EPIPE", "broken pipe" },
+	{ 33, "EDOM", "numerical argument out of domain" },
+	{ 34, "ERANGE", "numerical result out of range" },
+	{ 35, "EAGAIN", "resource temporarily unavailable" },
+	{ 36, "EINPROGRESS", "operation now in progress" },
+	{ 37, "EALREADY", "operation already in progress" },
+	{ 38, "ENOTSOCK", "socket operation on non-socket" },
+	{ 39, "EDESTADDRREQ", "destination address required" },
+	{ 40, "EMSGSIZE", "message too long" },
+	{ 41, "EPROTOTYPE", "protocol wrong type for socket" },
+	{ 42, "ENOPROTOOPT", "protocol not available" },
+	{ 43, "EPROTONOSUPPORT", "protocol not supported" },
+	{ 44, "ESOCKTNOSUPPORT", "socket type not supported" },
+	{ 45, "ENOTSUP", "operation not supported" },
+	{ 46, "EPFNOSUPPORT", "protocol family not supported" },
+	{ 47, "EAFNOSUPPORT", "address family not supported by protocol" },
+	{ 48, "EADDRINUSE", "address already in use" },
+	{ 49, "EADDRNOTAVAIL", "cannot assign requested address" },
+	{ 50, "ENETDOWN", "network is down" },
+	{ 51, "ENETUNREACH", "network is unreachable" },
+	{ 52, "ENETRESET", "network dropped connection on reset" },
+	{ 53, "ECONNABORTED", "software caused connection abort" },
+	{ 54, "ECONNRESET", "connection reset by peer" },
+	{ 55, "ENOBUFS", "no buffer space available" },
+	{ 56, "EISCONN", "transport endpoint is already connected" },
+	{ 57, "ENOTCONN", "transport endpoint is not connected" },
+	{ 58, "ESHUTDOWN", "cannot send after transport endpoint shutdown" },
+	{ 59, "ETOOMANYREFS", "too many references: cannot splice" },
+	{ 60, "ETIMEDOUT", "connection timed out" },
+	{ 61, "ECONNREFUSED", "connection refused" },
+	{ 62, "ELOOP", "too many levels of symbolic links" },
+	{ 63, "ENAMETOOLONG", "file name too long" },
+	{ 64, "EHOSTDOWN", "host is down" },
+	{ 65, "EHOSTUNREACH", "no route to host" },
+	{ 66, "ENOTEMPTY", "directory not empty" },
+	{ 68, "EUSERS", "too many users" },
+	{ 69, "EDQUOT", "disk quota exceeded" },
+	{ 70, "ESTALE", "stale file handle" },
+	{ 71, "EREMOTE", "object is remote" },
+	{ 77, "ENOLCK", "no locks available" },
+	{ 78, "ENOSYS", "function not implemented" },
+	{ 80, "ENOMSG", "no message of desired type" },
+	{ 81, "EIDRM", "identifier removed" },
+	{ 82, "ENOSR", "out of streams resources" },
+	{ 83, "ETIME", "timer expired" },
+	{ 84, "EBADMSG", "bad message" },
+	{ 85, "EPROTO", "protocol error" },
+	{ 86, "ENODATA", "no data available" },
+	{ 87, "ENOSTR", "device not a stream" },
+	{ 88, "ECHRNG", "channel number out of range" },
+	{ 89, "EL2NSYNC", "level 2 not synchronized" },
+	{ 90, "EL3HLT", "level 3 halted" },
+	{ 91, "EL3RST", "level 3 reset" },
+	{ 92, "ENOPKG", "package not installed" },
+	{ 93, "ELNRNG", "link number out of range" },
+	{ 94, "EUNATCH", "protocol driver not attached" },
+	{ 95, "ENOCSI", "no CSI structure available" },
+	{ 96, "EL2HLT", "level 2 halted" },
+	{ 97, "EBADE", "invalid exchange" },
+	{ 98, "EBADR", "invalid request descriptor" },
+	{ 99, "EXFULL", "exchange full" },
+	{ 100, "ENOANO", "no anode" },
+	{ 101, "EBADRQC", "invalid request code" },
+	{ 102, "EBADSLT", "invalid slot" },
+	{ 104, "EBFONT", "bad font file format" },
+	{ 105, "ENONET", "machine is not on the network" },
+	{ 106, "ENOLINK", "link has been severed" },
+	{ 107, "EADV", "advertise error" },
+	{ 108, "ESRMNT", "srmount error" },
+	{ 109, "ECOMM", "communication error on send" },
+	{ 110, "EMULTIHOP", "multihop attempted" },
+	{ 111, "EDOTDOT", "RFS specific error" },
+	{ 112, "EOVERFLOW", "value too large for defined data type" },
+	{ 113, "ENOTUNIQ", "name not unique on network" },
+	{ 114, "EBADFD", "file descriptor in bad state" },
+	{ 115, "EREMCHG", "remote address changed" },
+	{ 116, "EILSEQ", "invalid or incomplete multibyte or wide character" },
+	{ 117, "EUCLEAN", "structure needs cleaning" },
+	{ 118, "ENOTNAM", "not a XENIX named type file" },
+	{ 119, "ENAVAIL", "no XENIX semaphores available" },
+	{ 120, "EISNAM", "is a named type file" },
+	{ 121, "EREMOTEIO", "remote I/O error" },
+	{ 122, "ELIBACC", "can not access a needed shared library" },
+	{ 123, "ELIBBAD", "accessing a corrupted shared library" },
+	{ 124, "ELIBSCN", ".lib section in a.out corrupted" },
+	{ 125, "ELIBMAX", "attempting to link in too many shared libraries" },
+	{ 126, "ELIBEXEC", "cannot exec a shared library directly" },
+	{ 127, "ERESTART", "interrupted system call should be restarted" },
+	{ 128, "ESTRPIPE", "streams pipe error" },
+	{ 129, "ENOMEDIUM", "no medium found" },
+	{ 130, "EMEDIUMTYPE", "wrong medium type" },
+	{ 131, "ECANCELED", "operation canceled" },
+	{ 132, "ENOKEY", "required key not available" },
+	{ 133, "EKEYEXPIRED", "key has expired" },
+	{ 134, "EKEYREVOKED", "key has been revoked" },
+	{ 135, "EKEYREJECTED", "key was rejected by service" },
+	{ 136, "EOWNERDEAD", "owner died" },
+	{ 137, "ENOTRECOVERABLE", "state not recoverable" },
+	{ 138, "ERFKILL", "operation not possible due to RF-kill" },
+	{ 139, "EHWPOISON", "memory page has hardware error" },
+}
+
+
+
+// Signal table
+var signalList = [...]struct {
+	num  syscall.Signal
+	name string
+	desc string
+} {
+	{ 1, "SIGHUP", "hangup" },
+	{ 2, "SIGINT", "interrupt" },
+	{ 3, "SIGQUIT", "quit" },
+	{ 4, "SIGILL", "illegal instruction" },
+	{ 5, "SIGTRAP", "trace/breakpoint trap" },
+	{ 6, "SIGABRT", "aborted" },
+	{ 7, "SIGEMT", "EMT trap" },
+	{ 8, "SIGFPE", "floating point exception" },
+	{ 9, "SIGKILL", "killed" },
+	{ 10, "SIGBUS", "bus error" },
+	{ 11, "SIGSEGV", "segmentation fault" },
+	{ 12, "SIGSYS", "bad system call" },
+	{ 13, "SIGPIPE", "broken pipe" },
+	{ 14, "SIGALRM", "alarm clock" },
+	{ 15, "SIGTERM", "terminated" },
+	{ 16, "SIGURG", "urgent I/O condition" },
+	{ 17, "SIGSTOP", "stopped (signal)" },
+	{ 18, "SIGTSTP", "stopped" },
+	{ 19, "SIGCONT", "continued" },
+	{ 20, "SIGCHLD", "child exited" },
+	{ 21, "SIGTTIN", "stopped (tty input)" },
+	{ 22, "SIGTTOU", "stopped (tty output)" },
+	{ 23, "SIGIO", "I/O possible" },
+	{ 24, "SIGXCPU", "CPU time limit exceeded" },
+	{ 25, "SIGXFSZ", "file size limit exceeded" },
+	{ 26, "SIGVTALRM", "virtual timer expired" },
+	{ 27, "SIGPROF", "profiling timer expired" },
+	{ 28, "SIGWINCH", "window changed" },
+	{ 29, "SIGINFO", "power failure" },
+	{ 30, "SIGUSR1", "user defined signal 1" },
+	{ 31, "SIGUSR2", "user defined signal 2" },
+}
diff --git a/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux.go b/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux.go
index 1488d271..3b03db4c 100644
--- a/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux.go
+++ b/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux.go
@@ -1,6 +1,6 @@
 // Code generated by mkmerge; DO NOT EDIT.
 
-//go:build linux
+//go:build linux && !sw64
 
 package unix
 
diff --git a/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_sw64.go b/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_sw64.go
new file mode 100644
index 00000000..e48470c0
--- /dev/null
+++ b/src/cmd/vendor/golang.org/x/sys/unix/zsyscall_linux_sw64.go
@@ -0,0 +1,2812 @@
+// go run mksyscall.go -tags linux,sw64 syscall_linux.go syscall_linux_sw64.go
+// Code generated by the command above; see README.md. DO NOT EDIT.
+
+//go:build linux && sw64
+
+package unix
+
+import (
+	"syscall"
+	"unsafe"
+)
+
+var _ syscall.Errno
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func FanotifyInit(flags uint, event_f_flags uint) (fd int, err error) {
+	r0, _, e1 := Syscall(SYS_FANOTIFY_INIT, uintptr(flags), uintptr(event_f_flags), 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func fanotifyMark(fd int, flags uint, mask uint64, dirFd int, pathname *byte) (err error) {
+	_, _, e1 := Syscall6(SYS_FANOTIFY_MARK, uintptr(fd), uintptr(flags), uintptr(mask), uintptr(dirFd), uintptr(unsafe.Pointer(pathname)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func fchmodat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func fchmodat2(dirfd int, path string, mode uint32, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_FCHMODAT2, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func ioctl(fd int, req uint, arg uintptr) (err error) {
+	_, _, e1 := Syscall(SYS_IOCTL, uintptr(fd), uintptr(req), uintptr(arg))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func ioctlPtr(fd int, req uint, arg unsafe.Pointer) (err error) {
+	_, _, e1 := Syscall(SYS_IOCTL, uintptr(fd), uintptr(req), uintptr(arg))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(oldpath)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(newpath)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func openat2(dirfd int, path string, open_how *OpenHow, size int) (fd int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall6(SYS_OPENAT2, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(open_how)), uintptr(size), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func pipe2(p *[2]_C_int, flags int) (err error) {
+	_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) {
+	r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Readlinkat(dirfd int, path string, buf []byte) (n int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 unsafe.Pointer
+	if len(buf) > 0 {
+		_p1 = unsafe.Pointer(&buf[0])
+	} else {
+		_p1 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Symlinkat(oldpath string, newdirfd int, newpath string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(oldpath)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(newpath)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Unlinkat(dirfd int, path string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func utimensat(dirfd int, path string, times *[2]Timespec, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getcwd(buf []byte) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(buf) > 0 {
+		_p0 = unsafe.Pointer(&buf[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) {
+	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)
+	wpid = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Waitid(idType int, id int, info *Siginfo, options int, rusage *Rusage) (err error) {
+	_, _, e1 := Syscall6(SYS_WAITID, uintptr(idType), uintptr(id), uintptr(unsafe.Pointer(info)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) {
+	r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)
+	ret = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func KeyctlBuffer(cmd int, arg2 int, buf []byte, arg5 int) (ret int, err error) {
+	var _p0 unsafe.Pointer
+	if len(buf) > 0 {
+		_p0 = unsafe.Pointer(&buf[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)
+	ret = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func keyctlJoin(cmd int, arg2 string) (ret int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(arg2)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)
+	ret = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(arg3)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(arg4)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)
+	ret = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func keyctlIOV(cmd int, arg2 int, payload []Iovec, arg5 int) (err error) {
+	var _p0 unsafe.Pointer
+	if len(payload) > 0 {
+		_p0 = unsafe.Pointer(&payload[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func keyctlDH(cmd int, arg2 *KeyctlDHParams, buf []byte) (ret int, err error) {
+	var _p0 unsafe.Pointer
+	if len(buf) > 0 {
+		_p0 = unsafe.Pointer(&buf[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)
+	ret = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func keyctlRestrictKeyringByType(cmd int, arg2 int, keyType string, restriction string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(keyType)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(restriction)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func keyctlRestrictKeyring(cmd int, arg2 int) (err error) {
+	_, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func ptrace(request int, pid int, addr uintptr, data uintptr) (err error) {
+	_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func ptracePtr(request int, pid int, addr uintptr, data unsafe.Pointer) (err error) {
+	_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(arg)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(source)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(target)
+	if err != nil {
+		return
+	}
+	var _p2 *byte
+	_p2, err = BytePtrFromString(fstype)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func mountSetattr(dirfd int, pathname string, flags uint, attr *MountAttr, size uintptr) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(pathname)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_MOUNT_SETATTR, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(unsafe.Pointer(attr)), uintptr(size), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Acct(path string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func AddKey(keyType string, description string, payload []byte, ringid int) (id int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(keyType)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(description)
+	if err != nil {
+		return
+	}
+	var _p2 unsafe.Pointer
+	if len(payload) > 0 {
+		_p2 = unsafe.Pointer(&payload[0])
+	} else {
+		_p2 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)
+	id = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Adjtimex(buf *Timex) (state int, err error) {
+	r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)
+	state = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Capget(hdr *CapUserHeader, data *CapUserData) (err error) {
+	_, _, e1 := RawSyscall(SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Capset(hdr *CapUserHeader, data *CapUserData) (err error) {
+	_, _, e1 := RawSyscall(SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Chdir(path string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Chroot(path string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func ClockAdjtime(clockid int32, buf *Timex) (state int, err error) {
+	r0, _, e1 := Syscall(SYS_CLOCK_ADJTIME, uintptr(clockid), uintptr(unsafe.Pointer(buf)), 0)
+	state = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func ClockGetres(clockid int32, res *Timespec) (err error) {
+	_, _, e1 := Syscall(SYS_CLOCK_GETRES, uintptr(clockid), uintptr(unsafe.Pointer(res)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func ClockGettime(clockid int32, time *Timespec) (err error) {
+	_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func ClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error) {
+	_, _, e1 := Syscall6(SYS_CLOCK_NANOSLEEP, uintptr(clockid), uintptr(flags), uintptr(unsafe.Pointer(request)), uintptr(unsafe.Pointer(remain)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Close(fd int) (err error) {
+	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func CloseRange(first uint, last uint, flags uint) (err error) {
+	_, _, e1 := Syscall(SYS_CLOSE_RANGE, uintptr(first), uintptr(last), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) {
+	r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func DeleteModule(name string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(name)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_DELETE_MODULE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Dup(oldfd int) (fd int, err error) {
+	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Dup3(oldfd int, newfd int, flags int) (err error) {
+	_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func EpollCreate1(flag int) (fd int, err error) {
+	r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) {
+	_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Eventfd(initval uint, flags int) (fd int, err error) {
+	r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Exit(code int) {
+	SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fallocate(fd int, mode uint32, off int64, len int64) (err error) {
+	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fchdir(fd int) (err error) {
+	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fchmod(fd int, mode uint32) (err error) {
+	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fdatasync(fd int) (err error) {
+	_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(attr)
+	if err != nil {
+		return
+	}
+	var _p1 unsafe.Pointer
+	if len(dest) > 0 {
+		_p1 = unsafe.Pointer(&dest[0])
+	} else {
+		_p1 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), 0, 0)
+	sz = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func FinitModule(fd int, params string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FINIT_MODULE, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Flistxattr(fd int, dest []byte) (sz int, err error) {
+	var _p0 unsafe.Pointer
+	if len(dest) > 0 {
+		_p0 = unsafe.Pointer(&dest[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_FLISTXATTR, uintptr(fd), uintptr(_p0), uintptr(len(dest)))
+	sz = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Flock(fd int, how int) (err error) {
+	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fremovexattr(fd int, attr string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(attr)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fsetxattr(fd int, attr string, dest []byte, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(attr)
+	if err != nil {
+		return
+	}
+	var _p1 unsafe.Pointer
+	if len(dest) > 0 {
+		_p1 = unsafe.Pointer(&dest[0])
+	} else {
+		_p1 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fsync(fd int) (err error) {
+	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fsmount(fd int, flags int, mountAttrs int) (fsfd int, err error) {
+	r0, _, e1 := Syscall(SYS_FSMOUNT, uintptr(fd), uintptr(flags), uintptr(mountAttrs))
+	fsfd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fsopen(fsName string, flags int) (fd int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(fsName)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall(SYS_FSOPEN, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fspick(dirfd int, pathName string, flags int) (fd int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(pathName)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall(SYS_FSPICK, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getdents(fd int, buf []byte) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(buf) > 0 {
+		_p0 = unsafe.Pointer(&buf[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getpgid(pid int) (pgid int, err error) {
+	r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)
+	pgid = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getpriority(which int, who int) (prio int, err error) {
+	r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)
+	prio = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getrandom(buf []byte, flags int) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(buf) > 0 {
+		_p0 = unsafe.Pointer(&buf[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getrusage(who int, rusage *Rusage) (err error) {
+	_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getsid(pid int) (sid int, err error) {
+	r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)
+	sid = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Gettid() (tid int) {
+	r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)
+	tid = int(r0)
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getxattr(path string, attr string, dest []byte) (sz int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(attr)
+	if err != nil {
+		return
+	}
+	var _p2 unsafe.Pointer
+	if len(dest) > 0 {
+		_p2 = unsafe.Pointer(&dest[0])
+	} else {
+		_p2 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)
+	sz = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func InitModule(moduleImage []byte, params string) (err error) {
+	var _p0 unsafe.Pointer
+	if len(moduleImage) > 0 {
+		_p0 = unsafe.Pointer(&moduleImage[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(params)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_INIT_MODULE, uintptr(_p0), uintptr(len(moduleImage)), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(pathname)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))
+	watchdesc = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func InotifyInit1(flags int) (fd int, err error) {
+	r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) {
+	r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)
+	success = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Kill(pid int, sig syscall.Signal) (err error) {
+	_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Klogctl(typ int, buf []byte) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(buf) > 0 {
+		_p0 = unsafe.Pointer(&buf[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Lgetxattr(path string, attr string, dest []byte) (sz int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(attr)
+	if err != nil {
+		return
+	}
+	var _p2 unsafe.Pointer
+	if len(dest) > 0 {
+		_p2 = unsafe.Pointer(&dest[0])
+	} else {
+		_p2 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)
+	sz = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Listxattr(path string, dest []byte) (sz int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 unsafe.Pointer
+	if len(dest) > 0 {
+		_p1 = unsafe.Pointer(&dest[0])
+	} else {
+		_p1 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))
+	sz = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Llistxattr(path string, dest []byte) (sz int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 unsafe.Pointer
+	if len(dest) > 0 {
+		_p1 = unsafe.Pointer(&dest[0])
+	} else {
+		_p1 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))
+	sz = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Lremovexattr(path string, attr string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(attr)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Lsetxattr(path string, attr string, data []byte, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(attr)
+	if err != nil {
+		return
+	}
+	var _p2 unsafe.Pointer
+	if len(data) > 0 {
+		_p2 = unsafe.Pointer(&data[0])
+	} else {
+		_p2 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func MemfdCreate(name string, flags int) (fd int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(name)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall(SYS_MEMFD_CREATE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Mkdirat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func MoveMount(fromDirfd int, fromPathName string, toDirfd int, toPathName string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(fromPathName)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(toPathName)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_MOVE_MOUNT, uintptr(fromDirfd), uintptr(unsafe.Pointer(_p0)), uintptr(toDirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Nanosleep(time *Timespec, leftover *Timespec) (err error) {
+	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func OpenTree(dfd int, fileName string, flags uint) (r int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(fileName)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall(SYS_OPEN_TREE, uintptr(dfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	r = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) {
+	r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func PivotRoot(newroot string, putold string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(newroot)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(putold)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) {
+	_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func pselect6(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *sigset_argpack) (n int, err error) {
+	r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func read(fd int, p []byte) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(p) > 0 {
+		_p0 = unsafe.Pointer(&p[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(_p0), uintptr(len(p)))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Removexattr(path string, attr string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(attr)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(oldpath)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(newpath)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_RENAMEAT2, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(keyType)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(description)
+	if err != nil {
+		return
+	}
+	var _p2 *byte
+	_p2, err = BytePtrFromString(callback)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)
+	id = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Setdomainname(p []byte) (err error) {
+	var _p0 unsafe.Pointer
+	if len(p) > 0 {
+		_p0 = unsafe.Pointer(&p[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Sethostname(p []byte) (err error) {
+	var _p0 unsafe.Pointer
+	if len(p) > 0 {
+		_p0 = unsafe.Pointer(&p[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Setpgid(pid int, pgid int) (err error) {
+	_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Setsid() (pid int, err error) {
+	r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)
+	pid = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Settimeofday(tv *Timeval) (err error) {
+	_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Setns(fd int, nstype int) (err error) {
+	_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Setpriority(which int, who int, prio int) (err error) {
+	_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Setxattr(path string, attr string, data []byte, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(attr)
+	if err != nil {
+		return
+	}
+	var _p2 unsafe.Pointer
+	if len(data) > 0 {
+		_p2 = unsafe.Pointer(&data[0])
+	} else {
+		_p2 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func signalfd(fd int, sigmask *Sigset_t, maskSize uintptr, flags int) (newfd int, err error) {
+	r0, _, e1 := Syscall6(SYS_SIGNALFD4, uintptr(fd), uintptr(unsafe.Pointer(sigmask)), uintptr(maskSize), uintptr(flags), 0, 0)
+	newfd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Sync() {
+	SyscallNoError(SYS_SYNC, 0, 0, 0)
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Syncfs(fd int) (err error) {
+	_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Sysinfo(info *Sysinfo_t) (err error) {
+	_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Tee(rfd int, wfd int, len int, flags int) (n int64, err error) {
+	r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)
+	n = int64(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func TimerfdCreate(clockid int, flags int) (fd int, err error) {
+	r0, _, e1 := RawSyscall(SYS_TIMERFD_CREATE, uintptr(clockid), uintptr(flags), 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func TimerfdGettime(fd int, currValue *ItimerSpec) (err error) {
+	_, _, e1 := RawSyscall(SYS_TIMERFD_GETTIME, uintptr(fd), uintptr(unsafe.Pointer(currValue)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func TimerfdSettime(fd int, flags int, newValue *ItimerSpec, oldValue *ItimerSpec) (err error) {
+	_, _, e1 := RawSyscall6(SYS_TIMERFD_SETTIME, uintptr(fd), uintptr(flags), uintptr(unsafe.Pointer(newValue)), uintptr(unsafe.Pointer(oldValue)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Tgkill(tgid int, tid int, sig syscall.Signal) (err error) {
+	_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Times(tms *Tms) (ticks uintptr, err error) {
+	r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)
+	ticks = uintptr(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Umask(mask int) (oldmask int) {
+	r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)
+	oldmask = int(r0)
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Uname(buf *Utsname) (err error) {
+	_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Unmount(target string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(target)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Unshare(flags int) (err error) {
+	_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func write(fd int, p []byte) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(p) > 0 {
+		_p0 = unsafe.Pointer(&p[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func exitThread(code int) (err error) {
+	_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func readv(fd int, iovs []Iovec) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(iovs) > 0 {
+		_p0 = unsafe.Pointer(&iovs[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_READV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func writev(fd int, iovs []Iovec) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(iovs) > 0 {
+		_p0 = unsafe.Pointer(&iovs[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_WRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func preadv(fd int, iovs []Iovec, offs_l uintptr, offs_h uintptr) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(iovs) > 0 {
+		_p0 = unsafe.Pointer(&iovs[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_PREADV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func pwritev(fd int, iovs []Iovec, offs_l uintptr, offs_h uintptr) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(iovs) > 0 {
+		_p0 = unsafe.Pointer(&iovs[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_PWRITEV, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func preadv2(fd int, iovs []Iovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(iovs) > 0 {
+		_p0 = unsafe.Pointer(&iovs[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_PREADV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func pwritev2(fd int, iovs []Iovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(iovs) > 0 {
+		_p0 = unsafe.Pointer(&iovs[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_PWRITEV2, uintptr(fd), uintptr(_p0), uintptr(len(iovs)), uintptr(offs_l), uintptr(offs_h), uintptr(flags))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func munmap(addr uintptr, length uintptr) (err error) {
+	_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func mremap(oldaddr uintptr, oldlength uintptr, newlength uintptr, flags int, newaddr uintptr) (xaddr uintptr, err error) {
+	r0, _, e1 := Syscall6(SYS_MREMAP, uintptr(oldaddr), uintptr(oldlength), uintptr(newlength), uintptr(flags), uintptr(newaddr), 0)
+	xaddr = uintptr(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Madvise(b []byte, advice int) (err error) {
+	var _p0 unsafe.Pointer
+	if len(b) > 0 {
+		_p0 = unsafe.Pointer(&b[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Mprotect(b []byte, prot int) (err error) {
+	var _p0 unsafe.Pointer
+	if len(b) > 0 {
+		_p0 = unsafe.Pointer(&b[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Mlock(b []byte) (err error) {
+	var _p0 unsafe.Pointer
+	if len(b) > 0 {
+		_p0 = unsafe.Pointer(&b[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Mlockall(flags int) (err error) {
+	_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Msync(b []byte, flags int) (err error) {
+	var _p0 unsafe.Pointer
+	if len(b) > 0 {
+		_p0 = unsafe.Pointer(&b[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Munlock(b []byte) (err error) {
+	var _p0 unsafe.Pointer
+	if len(b) > 0 {
+		_p0 = unsafe.Pointer(&b[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Munlockall() (err error) {
+	_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func faccessat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Faccessat2(dirfd int, path string, mode uint32, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_FACCESSAT2, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func nameToHandleAt(dirFD int, pathname string, fh *fileHandle, mountID *_C_int, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(pathname)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_NAME_TO_HANDLE_AT, uintptr(dirFD), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(fh)), uintptr(unsafe.Pointer(mountID)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func openByHandleAt(mountFD int, fh *fileHandle, flags int) (fd int, err error) {
+	r0, _, e1 := Syscall(SYS_OPEN_BY_HANDLE_AT, uintptr(mountFD), uintptr(unsafe.Pointer(fh)), uintptr(flags))
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func ProcessVMReadv(pid int, localIov []Iovec, remoteIov []RemoteIovec, flags uint) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(localIov) > 0 {
+		_p0 = unsafe.Pointer(&localIov[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	var _p1 unsafe.Pointer
+	if len(remoteIov) > 0 {
+		_p1 = unsafe.Pointer(&remoteIov[0])
+	} else {
+		_p1 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_PROCESS_VM_READV, uintptr(pid), uintptr(_p0), uintptr(len(localIov)), uintptr(_p1), uintptr(len(remoteIov)), uintptr(flags))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func ProcessVMWritev(pid int, localIov []Iovec, remoteIov []RemoteIovec, flags uint) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(localIov) > 0 {
+		_p0 = unsafe.Pointer(&localIov[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	var _p1 unsafe.Pointer
+	if len(remoteIov) > 0 {
+		_p1 = unsafe.Pointer(&remoteIov[0])
+	} else {
+		_p1 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_PROCESS_VM_WRITEV, uintptr(pid), uintptr(_p0), uintptr(len(localIov)), uintptr(_p1), uintptr(len(remoteIov)), uintptr(flags))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func PidfdOpen(pid int, flags int) (fd int, err error) {
+	r0, _, e1 := Syscall(SYS_PIDFD_OPEN, uintptr(pid), uintptr(flags), 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func PidfdGetfd(pidfd int, targetfd int, flags int) (fd int, err error) {
+	r0, _, e1 := Syscall(SYS_PIDFD_GETFD, uintptr(pidfd), uintptr(targetfd), uintptr(flags))
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func PidfdSendSignal(pidfd int, sig Signal, info *Siginfo, flags int) (err error) {
+	_, _, e1 := Syscall6(SYS_PIDFD_SEND_SIGNAL, uintptr(pidfd), uintptr(sig), uintptr(unsafe.Pointer(info)), uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func shmat(id int, addr uintptr, flag int) (ret uintptr, err error) {
+	r0, _, e1 := Syscall(SYS_SHMAT, uintptr(id), uintptr(addr), uintptr(flag))
+	ret = uintptr(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func shmctl(id int, cmd int, buf *SysvShmDesc) (result int, err error) {
+	r0, _, e1 := Syscall(SYS_SHMCTL, uintptr(id), uintptr(cmd), uintptr(unsafe.Pointer(buf)))
+	result = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func shmdt(addr uintptr) (err error) {
+	_, _, e1 := Syscall(SYS_SHMDT, uintptr(addr), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func shmget(key int, size int, flag int) (id int, err error) {
+	r0, _, e1 := Syscall(SYS_SHMGET, uintptr(key), uintptr(size), uintptr(flag))
+	id = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getitimer(which int, currValue *Itimerval) (err error) {
+	_, _, e1 := Syscall(SYS_GETITIMER, uintptr(which), uintptr(unsafe.Pointer(currValue)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func setitimer(which int, newValue *Itimerval, oldValue *Itimerval) (err error) {
+	_, _, e1 := Syscall(SYS_SETITIMER, uintptr(which), uintptr(unsafe.Pointer(newValue)), uintptr(unsafe.Pointer(oldValue)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func rtSigprocmask(how int, set *Sigset_t, oldset *Sigset_t, sigsetsize uintptr) (err error) {
+	_, _, e1 := RawSyscall6(SYS_RT_SIGPROCMASK, uintptr(how), uintptr(unsafe.Pointer(set)), uintptr(unsafe.Pointer(oldset)), uintptr(sigsetsize), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getresuid(ruid *_C_int, euid *_C_int, suid *_C_int) {
+	RawSyscallNoError(SYS_GETRESUID, uintptr(unsafe.Pointer(ruid)), uintptr(unsafe.Pointer(euid)), uintptr(unsafe.Pointer(suid)))
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getresgid(rgid *_C_int, egid *_C_int, sgid *_C_int) {
+	RawSyscallNoError(SYS_GETRESGID, uintptr(unsafe.Pointer(rgid)), uintptr(unsafe.Pointer(egid)), uintptr(unsafe.Pointer(sgid)))
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func schedSetattr(pid int, attr *SchedAttr, flags uint) (err error) {
+	_, _, e1 := Syscall(SYS_SCHED_SETATTR, uintptr(pid), uintptr(unsafe.Pointer(attr)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func schedGetattr(pid int, attr *SchedAttr, size uint, flags uint) (err error) {
+	_, _, e1 := Syscall6(SYS_SCHED_GETATTR, uintptr(pid), uintptr(unsafe.Pointer(attr)), uintptr(size), uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Cachestat(fd uint, crange *CachestatRange, cstat *Cachestat_t, flags uint) (err error) {
+	_, _, e1 := Syscall6(SYS_CACHESTAT, uintptr(fd), uintptr(unsafe.Pointer(crange)), uintptr(unsafe.Pointer(cstat)), uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getxpid() (pid int, ppid int) {
+	r0, r1 := RawSyscallNoError(SYS_GETXPID, 0, 0, 0)
+	pid = int(r0)
+	ppid = int(r1)
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fstat64(fd int, st *Stat_t) (err error) {
+	_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(st)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Lstat64(path string, st *Stat_t) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Stat64(path string, st *Stat_t) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getxuid() (uid int, euid int) {
+	r0, r1 := SyscallNoError(SYS_GETXUID, 0, 0, 0)
+	uid = int(r0)
+	euid = int(r1)
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getxgid() (gid int, egid int) {
+	r0, r1 := SyscallNoError(SYS_GETXGID, 0, 0, 0)
+	gid = int(r0)
+	egid = int(r1)
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Statfs(path string, buf *Statfs_t) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fstatfs(fd int, buf *Statfs_t) (err error) {
+	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fchown(fd int, uid int, gid int) (err error) {
+	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Ftruncate(fd int, length int64) (err error) {
+	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getrlimit(resource int, rlim *Rlimit) (err error) {
+	_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Lchown(path string, uid int, gid int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Listen(s int, n int) (err error) {
+	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func pread(fd int, p []byte, offset int64) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(p) > 0 {
+		_p0 = unsafe.Pointer(&p[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func pwrite(fd int, p []byte, offset int64) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(p) > 0 {
+		_p0 = unsafe.Pointer(&p[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Seek(fd int, offset int64, whence int) (off int64, err error) {
+	r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))
+	off = int64(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
+	r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)
+	written = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func setfsgid(gid int) (prev int, err error) {
+	r0, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)
+	prev = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func setfsuid(uid int) (prev int, err error) {
+	r0, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)
+	prev = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Shutdown(fd int, how int) (err error) {
+	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) {
+	r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))
+	n = int64(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func SyncFileRange(fd int, off int64, n int64, flags int) (err error) {
+	_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Truncate(path string, length int64) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) {
+	r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) {
+	r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
+	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
+	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getgroups(n int, list *_Gid_t) (nn int, err error) {
+	r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
+	nn = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func setgroups(n int, list *_Gid_t) (err error) {
+	_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) {
+	_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) {
+	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func socket(domain int, typ int, proto int) (fd int, err error) {
+	r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) {
+	_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
+	_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
+	_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(p) > 0 {
+		_p0 = unsafe.Pointer(&p[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) {
+	var _p0 unsafe.Pointer
+	if len(buf) > 0 {
+		_p0 = unsafe.Pointer(&buf[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func recvmsg(s int, msg *Msghdr, flags int) (n int, err error) {
+	r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func sendmsg(s int, msg *Msghdr, flags int) (n int, err error) {
+	r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) {
+	r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))
+	xaddr = uintptr(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Gettimeofday(tv *Timeval) (err error) {
+	_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(events) > 0 {
+		_p0 = unsafe.Pointer(&events[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fadvise(fd int, offset int64, length int64, advice int) (err error) {
+	_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Ustat(dev int, ubuf *Ustat_t) (err error) {
+	_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func futimesat(dirfd int, path string, times *[2]Timeval) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func utimes(path string, times *[2]Timeval) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(oldpath)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(newpath)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
diff --git a/src/cmd/vendor/golang.org/x/sys/unix/zsysnum_linux_sw64.go b/src/cmd/vendor/golang.org/x/sys/unix/zsysnum_linux_sw64.go
new file mode 100644
index 00000000..b29b5ddf
--- /dev/null
+++ b/src/cmd/vendor/golang.org/x/sys/unix/zsysnum_linux_sw64.go
@@ -0,0 +1,383 @@
+// go run linux/mksysnum.go -Wall -Werror -static -I/tmp/sw64/include /tmp/sw64/include/asm/unistd.h
+// Code generated by the command above; see README.md. DO NOT EDIT.
+
+//go:build sw64 && linux
+
+package unix
+
+const (
+	SYS_EXIT                    = 1
+	SYS_FORK                    = 2
+	SYS_READ                    = 3
+	SYS_WRITE                   = 4
+	SYS_CLOSE                   = 6
+	SYS_LINK                    = 9
+	SYS_UNLINK                  = 10
+	SYS_CHDIR                   = 12
+	SYS_FCHDIR                  = 13
+	SYS_MKNOD                   = 14
+	SYS_CHMOD                   = 15
+	SYS_CHOWN                   = 16
+	SYS_BRK                     = 17
+	SYS_LSEEK                   = 19
+	SYS_GETXPID                 = 20
+	SYS_UMOUNT2                 = 22
+	SYS_SETUID                  = 23
+	SYS_GETXUID                 = 24
+	SYS_PTRACE                  = 26
+	SYS_ACCESS                  = 33
+	SYS_SYNC                    = 36
+	SYS_KILL                    = 37
+	SYS_SETPGID                 = 39
+	SYS_DUP                     = 41
+	SYS_PIPE                    = 42
+	SYS_OPEN                    = 45
+	SYS_GETXGID                 = 47
+	SYS_ODD_SIGPROCMASK         = 48
+	SYS_ACCT                    = 51
+	SYS_SIGPENDING              = 52
+	SYS_IOCTL                   = 54
+	SYS_SYMLINK                 = 57
+	SYS_READLINK                = 58
+	SYS_EXECVE                  = 59
+	SYS_UMASK                   = 60
+	SYS_CHROOT                  = 61
+	SYS_GETPGRP                 = 63
+	SYS_VFORK                   = 66
+	SYS_STAT                    = 67
+	SYS_LSTAT                   = 68
+	SYS_MMAP                    = 71
+	SYS_MUNMAP                  = 73
+	SYS_MPROTECT                = 74
+	SYS_MADVISE                 = 75
+	SYS_VHANGUP                 = 76
+	SYS_GETGROUPS               = 79
+	SYS_SETGROUPS               = 80
+	SYS_SETPGRP                 = 82
+	SYS_GETHOSTNAME             = 87
+	SYS_SETHOSTNAME             = 88
+	SYS_DUP2                    = 90
+	SYS_FSTAT                   = 91
+	SYS_FCNTL                   = 92
+	SYS_POLL                    = 94
+	SYS_FSYNC                   = 95
+	SYS_SETPRIORITY             = 96
+	SYS_SOCKET                  = 97
+	SYS_CONNECT                 = 98
+	SYS_ACCEPT                  = 99
+	SYS_ODD_GETPRIORITY         = 100
+	SYS_SEND                    = 101
+	SYS_RECV                    = 102
+	SYS_SIGRETURN               = 103
+	SYS_BIND                    = 104
+	SYS_SETSOCKOPT              = 105
+	SYS_LISTEN                  = 106
+	SYS_SIGSUSPEND              = 111
+	SYS_RECVMSG                 = 113
+	SYS_SENDMSG                 = 114
+	SYS_GETSOCKOPT              = 118
+	SYS_SOCKETCALL              = 119
+	SYS_READV                   = 120
+	SYS_WRITEV                  = 121
+	SYS_FCHOWN                  = 123
+	SYS_FCHMOD                  = 124
+	SYS_RECVFROM                = 125
+	SYS_SETREUID                = 126
+	SYS_SETREGID                = 127
+	SYS_RENAME                  = 128
+	SYS_TRUNCATE                = 129
+	SYS_FTRUNCATE               = 130
+	SYS_FLOCK                   = 131
+	SYS_SETGID                  = 132
+	SYS_SENDTO                  = 133
+	SYS_SHUTDOWN                = 134
+	SYS_SOCKETPAIR              = 135
+	SYS_MKDIR                   = 136
+	SYS_RMDIR                   = 137
+	SYS_GETPEERNAME             = 141
+	SYS_GETRLIMIT               = 144
+	SYS_SETRLIMIT               = 145
+	SYS_SETSID                  = 147
+	SYS_QUOTACTL                = 148
+	SYS_GETSOCKNAME             = 150
+	SYS_SIGACTION               = 156
+	SYS_SETDOMAINNAME           = 166
+	SYS_BPF                     = 170
+	SYS_USERFAULTFD             = 171
+	SYS_MEMBARRIER              = 172
+	SYS_MLOCK2                  = 173
+	SYS_GETPID                  = 174
+	SYS_GETPPID                 = 175
+	SYS_GETUID                  = 176
+	SYS_GETEUID                 = 177
+	SYS_GETGID                  = 178
+	SYS_GETEGID                 = 179
+	SYS_EPOLL_PWAIT2            = 180
+	SYS_MOUNT_SETATTR           = 181
+	SYS_QUOTACTL_FD             = 182
+	SYS_LANDLOCK_CREATE_RULESET = 183
+	SYS_LANDLOCK_ADD_RULE       = 184
+	SYS_LANDLOCK_RESTRICT_SELF  = 185
+	SYS_PROCESS_MRELEASE        = 187
+	SYS_FUTEX_WAITV             = 188
+	SYS_SET_MEMPOLICY_HOME_NODE = 189
+	SYS_CACHESTAT               = 190
+	SYS_FCHMODAT2               = 191
+	SYS_MSGCTL                  = 200
+	SYS_MSGGET                  = 201
+	SYS_MSGRCV                  = 202
+	SYS_MSGSND                  = 203
+	SYS_SEMCTL                  = 204
+	SYS_SEMGET                  = 205
+	SYS_SEMOP                   = 206
+	SYS_LCHOWN                  = 208
+	SYS_SHMAT                   = 209
+	SYS_SHMCTL                  = 210
+	SYS_SHMDT                   = 211
+	SYS_SHMGET                  = 212
+	SYS_MSYNC                   = 217
+	SYS_STATFS64                = 229
+	SYS_FSTATFS64               = 230
+	SYS_GETPGID                 = 233
+	SYS_GETSID                  = 234
+	SYS_SIGALTSTACK             = 235
+	SYS_SYSFS                   = 254
+	SYS_GETSYSINFO              = 256
+	SYS_SETSYSINFO              = 257
+	SYS_PIDFD_SEND_SIGNAL       = 271
+	SYS_IO_URING_SETUP          = 272
+	SYS_IO_URING_ENTER          = 273
+	SYS_IO_URING_REGISTER       = 274
+	SYS_OPEN_TREE               = 275
+	SYS_MOVE_MOUNT              = 276
+	SYS_FSOPEN                  = 277
+	SYS_FSCONFIG                = 278
+	SYS_FSMOUNT                 = 279
+	SYS_FSPICK                  = 280
+	SYS_PIDFD_OPEN              = 281
+	SYS_CLONE3                  = 282
+	SYS_CLOSE_RANGE             = 283
+	SYS_OPENAT2                 = 284
+	SYS_PIDFD_GETFD             = 285
+	SYS_FACCESSAT2              = 286
+	SYS_PROCESS_MADVISE         = 287
+	SYS_PKEY_MPROTECT           = 288
+	SYS_PKEY_ALLOC              = 289
+	SYS_PKEY_FREE               = 290
+	SYS_GETPRIORITY             = 298
+	SYS_SIGPROCMASK             = 299
+	SYS_BDFLUSH                 = 300
+	SYS_MOUNT                   = 302
+	SYS_SWAPOFF                 = 304
+	SYS_GETDENTS                = 305
+	SYS_CREATE_MODULE           = 306
+	SYS_INIT_MODULE             = 307
+	SYS_DELETE_MODULE           = 308
+	SYS_GET_KERNEL_SYMS         = 309
+	SYS_SYSLOG                  = 310
+	SYS_REBOOT                  = 311
+	SYS_CLONE                   = 312
+	SYS_USELIB                  = 313
+	SYS_MLOCK                   = 314
+	SYS_MUNLOCK                 = 315
+	SYS_MLOCKALL                = 316
+	SYS_MUNLOCKALL              = 317
+	SYS_SYSINFO                 = 318
+	SYS_OLDUMOUNT               = 321
+	SYS_SWAPON                  = 322
+	SYS_TIMES                   = 323
+	SYS_PERSONALITY             = 324
+	SYS_SETFSUID                = 325
+	SYS_SETFSGID                = 326
+	SYS_USTAT                   = 327
+	SYS_STATFS                  = 328
+	SYS_FSTATFS                 = 329
+	SYS_SCHED_SETPARAM          = 330
+	SYS_SCHED_GETPARAM          = 331
+	SYS_SCHED_SETSCHEDULER      = 332
+	SYS_SCHED_GETSCHEDULER      = 333
+	SYS_SCHED_YIELD             = 334
+	SYS_SCHED_GET_PRIORITY_MAX  = 335
+	SYS_SCHED_GET_PRIORITY_MIN  = 336
+	SYS_SCHED_RR_GET_INTERVAL   = 337
+	SYS_AFS_SYSCALL             = 338
+	SYS_UNAME                   = 339
+	SYS_NANOSLEEP               = 340
+	SYS_MREMAP                  = 341
+	SYS_NFSSERVCTL              = 342
+	SYS_SETRESUID               = 343
+	SYS_GETRESUID               = 344
+	SYS_PCICONFIG_READ          = 345
+	SYS_PCICONFIG_WRITE         = 346
+	SYS_QUERY_MODULE            = 347
+	SYS_PRCTL                   = 348
+	SYS_PREAD64                 = 349
+	SYS_PWRITE64                = 350
+	SYS_RT_SIGRETURN            = 351
+	SYS_RT_SIGACTION            = 352
+	SYS_RT_SIGPROCMASK          = 353
+	SYS_RT_SIGPENDING           = 354
+	SYS_RT_SIGTIMEDWAIT         = 355
+	SYS_RT_SIGQUEUEINFO         = 356
+	SYS_RT_SIGSUSPEND           = 357
+	SYS_SELECT                  = 358
+	SYS_GETTIMEOFDAY            = 359
+	SYS_SETTIMEOFDAY            = 360
+	SYS_GETITIMER               = 361
+	SYS_SETITIMER               = 362
+	SYS_UTIMES                  = 363
+	SYS_GETRUSAGE               = 364
+	SYS_WAIT4                   = 365
+	SYS_ADJTIMEX                = 366
+	SYS_GETCWD                  = 367
+	SYS_CAPGET                  = 368
+	SYS_CAPSET                  = 369
+	SYS_SENDFILE                = 370
+	SYS_SETRESGID               = 371
+	SYS_GETRESGID               = 372
+	SYS_DIPC                    = 373
+	SYS_PIVOT_ROOT              = 374
+	SYS_MINCORE                 = 375
+	SYS_PCICONFIG_IOBASE        = 376
+	SYS_GETDENTS64              = 377
+	SYS_GETTID                  = 378
+	SYS_READAHEAD               = 379
+	SYS_TKILL                   = 381
+	SYS_SETXATTR                = 382
+	SYS_LSETXATTR               = 383
+	SYS_FSETXATTR               = 384
+	SYS_GETXATTR                = 385
+	SYS_LGETXATTR               = 386
+	SYS_FGETXATTR               = 387
+	SYS_LISTXATTR               = 388
+	SYS_LLISTXATTR              = 389
+	SYS_FLISTXATTR              = 390
+	SYS_REMOVEXATTR             = 391
+	SYS_LREMOVEXATTR            = 392
+	SYS_FREMOVEXATTR            = 393
+	SYS_FUTEX                   = 394
+	SYS_SCHED_SETAFFINITY       = 395
+	SYS_SCHED_GETAFFINITY       = 396
+	SYS_TUXCALL                 = 397
+	SYS_IO_SETUP                = 398
+	SYS_IO_DESTROY              = 399
+	SYS_IO_GETEVENTS            = 400
+	SYS_IO_SUBMIT               = 401
+	SYS_IO_CANCEL               = 402
+	SYS_IO_PGETEVENTS           = 403
+	SYS_RSEQ                    = 404
+	SYS_EXIT_GROUP              = 405
+	SYS_LOOKUP_DCOOKIE          = 406
+	SYS_EPOLL_CREATE            = 407
+	SYS_EPOLL_CTL               = 408
+	SYS_EPOLL_WAIT              = 409
+	SYS_REMAP_FILE_PAGES        = 410
+	SYS_SET_TID_ADDRESS         = 411
+	SYS_RESTART_SYSCALL         = 412
+	SYS_FADVISE64               = 413
+	SYS_TIMER_CREATE            = 414
+	SYS_TIMER_SETTIME           = 415
+	SYS_TIMER_GETTIME           = 416
+	SYS_TIMER_GETOVERRUN        = 417
+	SYS_TIMER_DELETE            = 418
+	SYS_CLOCK_SETTIME           = 419
+	SYS_CLOCK_GETTIME           = 420
+	SYS_CLOCK_GETRES            = 421
+	SYS_CLOCK_NANOSLEEP         = 422
+	SYS_SEMTIMEDOP              = 423
+	SYS_TGKILL                  = 424
+	SYS_STAT64                  = 425
+	SYS_LSTAT64                 = 426
+	SYS_FSTAT64                 = 427
+	SYS_VSERVER                 = 428
+	SYS_MBIND                   = 429
+	SYS_GET_MEMPOLICY           = 430
+	SYS_SET_MEMPOLICY           = 431
+	SYS_MQ_OPEN                 = 432
+	SYS_MQ_UNLINK               = 433
+	SYS_MQ_TIMEDSEND            = 434
+	SYS_MQ_TIMEDRECEIVE         = 435
+	SYS_MQ_NOTIFY               = 436
+	SYS_MQ_GETSETATTR           = 437
+	SYS_WAITID                  = 438
+	SYS_ADD_KEY                 = 439
+	SYS_REQUEST_KEY             = 440
+	SYS_KEYCTL                  = 441
+	SYS_IOPRIO_SET              = 442
+	SYS_IOPRIO_GET              = 443
+	SYS_INOTIFY_INIT            = 444
+	SYS_INOTIFY_ADD_WATCH       = 445
+	SYS_INOTIFY_RM_WATCH        = 446
+	SYS_FDATASYNC               = 447
+	SYS_KEXEC_LOAD              = 448
+	SYS_MIGRATE_PAGES           = 449
+	SYS_OPENAT                  = 450
+	SYS_MKDIRAT                 = 451
+	SYS_MKNODAT                 = 452
+	SYS_FCHOWNAT                = 453
+	SYS_FUTIMESAT               = 454
+	SYS_FSTATAT64               = 455
+	SYS_UNLINKAT                = 456
+	SYS_RENAMEAT                = 457
+	SYS_LINKAT                  = 458
+	SYS_SYMLINKAT               = 459
+	SYS_READLINKAT              = 460
+	SYS_FCHMODAT                = 461
+	SYS_FACCESSAT               = 462
+	SYS_PSELECT6                = 463
+	SYS_PPOLL                   = 464
+	SYS_UNSHARE                 = 465
+	SYS_SET_ROBUST_LIST         = 466
+	SYS_GET_ROBUST_LIST         = 467
+	SYS_SPLICE                  = 468
+	SYS_SYNC_FILE_RANGE         = 469
+	SYS_TEE                     = 470
+	SYS_VMSPLICE                = 471
+	SYS_MOVE_PAGES              = 472
+	SYS_GETCPU                  = 473
+	SYS_EPOLL_PWAIT             = 474
+	SYS_UTIMENSAT               = 475
+	SYS_SIGNALFD                = 476
+	SYS_TIMERFD                 = 477
+	SYS_EVENTFD                 = 478
+	SYS_RECVMMSG                = 479
+	SYS_FALLOCATE               = 480
+	SYS_TIMERFD_CREATE          = 481
+	SYS_TIMERFD_SETTIME         = 482
+	SYS_TIMERFD_GETTIME         = 483
+	SYS_SIGNALFD4               = 484
+	SYS_EVENTFD2                = 485
+	SYS_EPOLL_CREATE1           = 486
+	SYS_DUP3                    = 487
+	SYS_PIPE2                   = 488
+	SYS_INOTIFY_INIT1           = 489
+	SYS_PREADV                  = 490
+	SYS_PWRITEV                 = 491
+	SYS_RT_TGSIGQUEUEINFO       = 492
+	SYS_PERF_EVENT_OPEN         = 493
+	SYS_FANOTIFY_INIT           = 494
+	SYS_FANOTIFY_MARK           = 495
+	SYS_PRLIMIT64               = 496
+	SYS_NAME_TO_HANDLE_AT       = 497
+	SYS_OPEN_BY_HANDLE_AT       = 498
+	SYS_CLOCK_ADJTIME           = 499
+	SYS_SYNCFS                  = 500
+	SYS_SETNS                   = 501
+	SYS_ACCEPT4                 = 502
+	SYS_SENDMMSG                = 503
+	SYS_PROCESS_VM_READV        = 504
+	SYS_PROCESS_VM_WRITEV       = 505
+	SYS_KCMP                    = 506
+	SYS_FINIT_MODULE            = 507
+	SYS_SCHED_SETATTR           = 508
+	SYS_SCHED_GETATTR           = 509
+	SYS_RENAMEAT2               = 510
+	SYS_GETRANDOM               = 511
+	SYS_MEMFD_CREATE            = 512
+	SYS_EXECVEAT                = 513
+	SYS_SECCOMP                 = 514
+	SYS_COPY_FILE_RANGE         = 515
+	SYS_PREADV2                 = 516
+	SYS_PWRITEV2                = 517
+	SYS_STATX                   = 518
+)
diff --git a/src/cmd/vendor/golang.org/x/sys/unix/ztypes_linux.go b/src/cmd/vendor/golang.org/x/sys/unix/ztypes_linux.go
index bbf8399f..9ef4569d 100644
--- a/src/cmd/vendor/golang.org/x/sys/unix/ztypes_linux.go
+++ b/src/cmd/vendor/golang.org/x/sys/unix/ztypes_linux.go
@@ -1,6 +1,6 @@
 // Code generated by mkmerge; DO NOT EDIT.
 
-//go:build linux
+//go:build linux && !sw64
 
 package unix
 
diff --git a/src/cmd/vendor/golang.org/x/sys/unix/ztypes_linux_sw64.go b/src/cmd/vendor/golang.org/x/sys/unix/ztypes_linux_sw64.go
new file mode 100644
index 00000000..0fea65bc
--- /dev/null
+++ b/src/cmd/vendor/golang.org/x/sys/unix/ztypes_linux_sw64.go
@@ -0,0 +1,6496 @@
+// cgo -godefs -objdir=/tmp/sw64/cgo -- -Wall -Werror -static -I/tmp/sw64/include /home/zhangjh/git-source/go/sys/unix/linux/types.go | go run mkpost.go
+// Code generated by the command above; see README.md. DO NOT EDIT.
+
+//go:build sw64 && linux
+
+package unix
+
+const (
+	SizeofPtr      = 0x8
+	SizeofShort    = 0x2
+	SizeofInt      = 0x4
+	SizeofLong     = 0x8
+	SizeofLongLong = 0x8
+	PathMax        = 0x1000
+)
+
+type (
+	_C_short     int16
+	_C_int       int32
+	_C_long      int64
+	_C_long_long int64
+)
+
+type Timespec struct {
+	Sec  int64
+	Nsec int64
+}
+
+type Timeval struct {
+	Sec  int64
+	Usec int64
+}
+
+type Timex struct {
+	Modes     uint32
+	Offset    int64
+	Freq      int64
+	Maxerror  int64
+	Esterror  int64
+	Status    int32
+	Constant  int64
+	Precision int64
+	Tolerance int64
+	Time      Timeval
+	Tick      int64
+	Ppsfreq   int64
+	Jitter    int64
+	Shift     int32
+	Stabil    int64
+	Jitcnt    int64
+	Calcnt    int64
+	Errcnt    int64
+	Stbcnt    int64
+	Tai       int32
+	_         [44]byte
+}
+
+type ItimerSpec struct {
+	Interval Timespec
+	Value    Timespec
+}
+
+type Itimerval struct {
+	Interval Timeval
+	Value    Timeval
+}
+
+const (
+	ADJ_OFFSET            = 0x1
+	ADJ_FREQUENCY         = 0x2
+	ADJ_MAXERROR          = 0x4
+	ADJ_ESTERROR          = 0x8
+	ADJ_STATUS            = 0x10
+	ADJ_TIMECONST         = 0x20
+	ADJ_TAI               = 0x80
+	ADJ_SETOFFSET         = 0x100
+	ADJ_MICRO             = 0x1000
+	ADJ_NANO              = 0x2000
+	ADJ_TICK              = 0x4000
+	ADJ_OFFSET_SINGLESHOT = 0x8001
+	ADJ_OFFSET_SS_READ    = 0xa001
+)
+
+const (
+	STA_PLL       = 0x1
+	STA_PPSFREQ   = 0x2
+	STA_PPSTIME   = 0x4
+	STA_FLL       = 0x8
+	STA_INS       = 0x10
+	STA_DEL       = 0x20
+	STA_UNSYNC    = 0x40
+	STA_FREQHOLD  = 0x80
+	STA_PPSSIGNAL = 0x100
+	STA_PPSJITTER = 0x200
+	STA_PPSWANDER = 0x400
+	STA_PPSERROR  = 0x800
+	STA_CLOCKERR  = 0x1000
+	STA_NANO      = 0x2000
+	STA_MODE      = 0x4000
+	STA_CLK       = 0x8000
+)
+
+const (
+	TIME_OK    = 0x0
+	TIME_INS   = 0x1
+	TIME_DEL   = 0x2
+	TIME_OOP   = 0x3
+	TIME_WAIT  = 0x4
+	TIME_ERROR = 0x5
+	TIME_BAD   = 0x5
+)
+
+type Time_t int64
+
+type Tms struct {
+	Utime  int64
+	Stime  int64
+	Cutime int64
+	Cstime int64
+}
+
+type Utimbuf struct {
+	Actime  int64
+	Modtime int64
+}
+
+type Rusage struct {
+	Utime    Timeval
+	Stime    Timeval
+	Maxrss   int64
+	Ixrss    int64
+	Idrss    int64
+	Isrss    int64
+	Minflt   int64
+	Majflt   int64
+	Nswap    int64
+	Inblock  int64
+	Oublock  int64
+	Msgsnd   int64
+	Msgrcv   int64
+	Nsignals int64
+	Nvcsw    int64
+	Nivcsw   int64
+}
+
+type Rlimit struct {
+	Cur uint64
+	Max uint64
+}
+
+type _Gid_t uint32
+
+type Stat_t struct {
+	Dev     uint64
+	Ino     uint64
+	Rdev    uint64
+	Size    int64
+	Blocks  uint64
+	Mode    uint32
+	Uid     uint32
+	Gid     uint32
+	Blksize uint32
+	Nlink   uint32
+	_       int32
+	Atim    Timespec
+	Mtim    Timespec
+	Ctim    Timespec
+	_       [3]int64
+}
+
+type StatxTimestamp struct {
+	Sec  int64
+	Nsec uint32
+	_    int32
+}
+
+type Statx_t struct {
+	Mask             uint32
+	Blksize          uint32
+	Attributes       uint64
+	Nlink            uint32
+	Uid              uint32
+	Gid              uint32
+	Mode             uint16
+	_                [1]uint16
+	Ino              uint64
+	Size             uint64
+	Blocks           uint64
+	Attributes_mask  uint64
+	Atime            StatxTimestamp
+	Btime            StatxTimestamp
+	Ctime            StatxTimestamp
+	Mtime            StatxTimestamp
+	Rdev_major       uint32
+	Rdev_minor       uint32
+	Dev_major        uint32
+	Dev_minor        uint32
+	Mnt_id           uint64
+	Dio_mem_align    uint32
+	Dio_offset_align uint32
+	_                [12]uint64
+}
+
+type Dirent struct {
+	Ino    uint64
+	Off    int64
+	Reclen uint16
+	Type   uint8
+	Name   [256]int8
+	_      [5]byte
+}
+
+type Fsid struct {
+	Val [2]int32
+}
+
+type Flock_t struct {
+	Type   int16
+	Whence int16
+	Start  int64
+	Len    int64
+	Pid    int32
+	_      [4]byte
+}
+
+type FileCloneRange struct {
+	Src_fd      int64
+	Src_offset  uint64
+	Src_length  uint64
+	Dest_offset uint64
+}
+
+type RawFileDedupeRange struct {
+	Src_offset uint64
+	Src_length uint64
+	Dest_count uint16
+	Reserved1  uint16
+	Reserved2  uint32
+}
+
+type RawFileDedupeRangeInfo struct {
+	Dest_fd       int64
+	Dest_offset   uint64
+	Bytes_deduped uint64
+	Status        int32
+	Reserved      uint32
+}
+
+const (
+	SizeofRawFileDedupeRange     = 0x18
+	SizeofRawFileDedupeRangeInfo = 0x20
+	FILE_DEDUPE_RANGE_SAME       = 0x0
+	FILE_DEDUPE_RANGE_DIFFERS    = 0x1
+)
+
+type FscryptPolicy struct {
+	Version                   uint8
+	Contents_encryption_mode  uint8
+	Filenames_encryption_mode uint8
+	Flags                     uint8
+	Master_key_descriptor     [8]uint8
+}
+
+type FscryptKey struct {
+	Mode uint32
+	Raw  [64]uint8
+	Size uint32
+}
+
+type FscryptPolicyV1 struct {
+	Version                   uint8
+	Contents_encryption_mode  uint8
+	Filenames_encryption_mode uint8
+	Flags                     uint8
+	Master_key_descriptor     [8]uint8
+}
+
+type FscryptPolicyV2 struct {
+	Version                   uint8
+	Contents_encryption_mode  uint8
+	Filenames_encryption_mode uint8
+	Flags                     uint8
+	_                         [4]uint8
+	Master_key_identifier     [16]uint8
+}
+
+type FscryptGetPolicyExArg struct {
+	Size   uint64
+	Policy [24]byte
+}
+
+type FscryptKeySpecifier struct {
+	Type uint32
+	_    uint32
+	U    [32]byte
+}
+
+type FscryptAddKeyArg struct {
+	Key_spec FscryptKeySpecifier
+	Raw_size uint32
+	Key_id   uint32
+	_        [8]uint32
+}
+
+type FscryptRemoveKeyArg struct {
+	Key_spec             FscryptKeySpecifier
+	Removal_status_flags uint32
+	_                    [5]uint32
+}
+
+type FscryptGetKeyStatusArg struct {
+	Key_spec     FscryptKeySpecifier
+	_            [6]uint32
+	Status       uint32
+	Status_flags uint32
+	User_count   uint32
+	_            [13]uint32
+}
+
+type DmIoctl struct {
+	Version      [3]uint32
+	Data_size    uint32
+	Data_start   uint32
+	Target_count uint32
+	Open_count   int32
+	Flags        uint32
+	Event_nr     uint32
+	_            uint32
+	Dev          uint64
+	Name         [128]byte
+	Uuid         [129]byte
+	Data         [7]byte
+}
+
+type DmTargetSpec struct {
+	Sector_start uint64
+	Length       uint64
+	Status       int32
+	Next         uint32
+	Target_type  [16]byte
+}
+
+type DmTargetDeps struct {
+	Count uint32
+	_     uint32
+}
+
+type DmNameList struct {
+	Dev  uint64
+	Next uint32
+	Name [0]byte
+	_    [4]byte
+}
+
+type DmTargetVersions struct {
+	Next    uint32
+	Version [3]uint32
+}
+
+type DmTargetMsg struct {
+	Sector uint64
+}
+
+const (
+	SizeofDmIoctl      = 0x138
+	SizeofDmTargetSpec = 0x28
+)
+
+type KeyctlDHParams struct {
+	Private int32
+	Prime   int32
+	Base    int32
+}
+
+const (
+	FADV_NORMAL     = 0x0
+	FADV_RANDOM     = 0x1
+	FADV_SEQUENTIAL = 0x2
+	FADV_WILLNEED   = 0x3
+	FADV_DONTNEED   = 0x4
+	FADV_NOREUSE    = 0x5
+)
+
+type RawSockaddrInet4 struct {
+	Family uint16
+	Port   uint16
+	Addr   [4]byte /* in_addr */
+	Zero   [8]uint8
+}
+
+type RawSockaddrInet6 struct {
+	Family   uint16
+	Port     uint16
+	Flowinfo uint32
+	Addr     [16]byte /* in6_addr */
+	Scope_id uint32
+}
+
+type RawSockaddrUnix struct {
+	Family uint16
+	Path   [108]int8
+}
+
+type RawSockaddrLinklayer struct {
+	Family   uint16
+	Protocol uint16
+	Ifindex  int32
+	Hatype   uint16
+	Pkttype  uint8
+	Halen    uint8
+	Addr     [8]uint8
+}
+
+type RawSockaddrNetlink struct {
+	Family uint16
+	Pad    uint16
+	Pid    uint32
+	Groups uint32
+}
+
+type RawSockaddrHCI struct {
+	Family  uint16
+	Dev     uint16
+	Channel uint16
+}
+
+type RawSockaddrL2 struct {
+	Family      uint16
+	Psm         uint16
+	Bdaddr      [6]uint8
+	Cid         uint16
+	Bdaddr_type uint8
+	_           [1]byte
+}
+
+type RawSockaddrRFCOMM struct {
+	Family  uint16
+	Bdaddr  [6]uint8
+	Channel uint8
+	_       [1]byte
+}
+
+type RawSockaddrCAN struct {
+	Family  uint16
+	Ifindex int32
+	Addr    [16]byte
+}
+
+type RawSockaddrALG struct {
+	Family uint16
+	Type   [14]uint8
+	Feat   uint32
+	Mask   uint32
+	Name   [64]uint8
+}
+
+type RawSockaddrVM struct {
+	Family    uint16
+	Reserved1 uint16
+	Port      uint32
+	Cid       uint32
+	Flags     uint8
+	Zero      [3]uint8
+}
+
+type RawSockaddrXDP struct {
+	Family         uint16
+	Flags          uint16
+	Ifindex        uint32
+	Queue_id       uint32
+	Shared_umem_fd uint32
+}
+
+type RawSockaddrPPPoX [0x1e]byte
+
+type RawSockaddrTIPC struct {
+	Family   uint16
+	Addrtype uint8
+	Scope    int8
+	Addr     [12]byte
+}
+
+type RawSockaddrL2TPIP struct {
+	Family  uint16
+	Unused  uint16
+	Addr    [4]byte /* in_addr */
+	Conn_id uint32
+	_       [4]uint8
+}
+
+type RawSockaddrL2TPIP6 struct {
+	Family   uint16
+	Unused   uint16
+	Flowinfo uint32
+	Addr     [16]byte /* in6_addr */
+	Scope_id uint32
+	Conn_id  uint32
+}
+
+type RawSockaddrIUCV struct {
+	Family  uint16
+	Port    uint16
+	Addr    uint32
+	Nodeid  [8]int8
+	User_id [8]int8
+	Name    [8]int8
+}
+
+type RawSockaddrNFC struct {
+	Sa_family    uint16
+	Dev_idx      uint32
+	Target_idx   uint32
+	Nfc_protocol uint32
+}
+
+type RawSockaddrNFCLLCP struct {
+	Sa_family        uint16
+	Dev_idx          uint32
+	Target_idx       uint32
+	Nfc_protocol     uint32
+	Dsap             uint8
+	Ssap             uint8
+	Service_name     [63]uint8
+	Service_name_len uint64
+}
+
+type RawSockaddr struct {
+	Family uint16
+	Data   [14]int8
+}
+
+type RawSockaddrAny struct {
+	Addr RawSockaddr
+	Pad  [96]int8
+}
+
+type _Socklen uint32
+
+type Linger struct {
+	Onoff  int32
+	Linger int32
+}
+
+type Iovec struct {
+	Base *byte
+	Len  uint64
+}
+
+type IPMreq struct {
+	Multiaddr [4]byte /* in_addr */
+	Interface [4]byte /* in_addr */
+}
+
+type IPMreqn struct {
+	Multiaddr [4]byte /* in_addr */
+	Address   [4]byte /* in_addr */
+	Ifindex   int32
+}
+
+type IPv6Mreq struct {
+	Multiaddr [16]byte /* in6_addr */
+	Interface uint32
+}
+
+type PacketMreq struct {
+	Ifindex int32
+	Type    uint16
+	Alen    uint16
+	Address [8]uint8
+}
+
+type Msghdr struct {
+	Name       *byte
+	Namelen    uint32
+	Iov        *Iovec
+	Iovlen     uint64
+	Control    *byte
+	Controllen uint64
+	Flags      int32
+	_          [4]byte
+}
+
+type Cmsghdr struct {
+	Len   uint64
+	Level int32
+	Type  int32
+}
+
+type Inet4Pktinfo struct {
+	Ifindex  int32
+	Spec_dst [4]byte /* in_addr */
+	Addr     [4]byte /* in_addr */
+}
+
+type Inet6Pktinfo struct {
+	Addr    [16]byte /* in6_addr */
+	Ifindex uint32
+}
+
+type IPv6MTUInfo struct {
+	Addr RawSockaddrInet6
+	Mtu  uint32
+}
+
+type ICMPv6Filter struct {
+	Data [8]uint32
+}
+
+type Ucred struct {
+	Pid int32
+	Uid uint32
+	Gid uint32
+}
+
+type TCPInfo struct {
+	State           uint8
+	Ca_state        uint8
+	Retransmits     uint8
+	Probes          uint8
+	Backoff         uint8
+	Options         uint8
+	Rto             uint32
+	Ato             uint32
+	Snd_mss         uint32
+	Rcv_mss         uint32
+	Unacked         uint32
+	Sacked          uint32
+	Lost            uint32
+	Retrans         uint32
+	Fackets         uint32
+	Last_data_sent  uint32
+	Last_ack_sent   uint32
+	Last_data_recv  uint32
+	Last_ack_recv   uint32
+	Pmtu            uint32
+	Rcv_ssthresh    uint32
+	Rtt             uint32
+	Rttvar          uint32
+	Snd_ssthresh    uint32
+	Snd_cwnd        uint32
+	Advmss          uint32
+	Reordering      uint32
+	Rcv_rtt         uint32
+	Rcv_space       uint32
+	Total_retrans   uint32
+	Pacing_rate     uint64
+	Max_pacing_rate uint64
+	Bytes_acked     uint64
+	Bytes_received  uint64
+	Segs_out        uint32
+	Segs_in         uint32
+	Notsent_bytes   uint32
+	Min_rtt         uint32
+	Data_segs_in    uint32
+	Data_segs_out   uint32
+	Delivery_rate   uint64
+	Busy_time       uint64
+	Rwnd_limited    uint64
+	Sndbuf_limited  uint64
+	Delivered       uint32
+	Delivered_ce    uint32
+	Bytes_sent      uint64
+	Bytes_retrans   uint64
+	Dsack_dups      uint32
+	Reord_seen      uint32
+	Rcv_ooopack     uint32
+	Snd_wnd         uint32
+	Rcv_wnd         uint32
+	Rehash          uint32
+}
+
+type CanFilter struct {
+	Id   uint32
+	Mask uint32
+}
+
+type ifreq struct {
+	Ifrn [16]byte
+	Ifru [24]byte
+}
+
+type TCPRepairOpt struct {
+	Code uint32
+	Val  uint32
+}
+
+const (
+	SizeofSockaddrInet4     = 0x10
+	SizeofSockaddrInet6     = 0x1c
+	SizeofSockaddrAny       = 0x70
+	SizeofSockaddrUnix      = 0x6e
+	SizeofSockaddrLinklayer = 0x14
+	SizeofSockaddrNetlink   = 0xc
+	SizeofSockaddrHCI       = 0x6
+	SizeofSockaddrL2        = 0xe
+	SizeofSockaddrRFCOMM    = 0xa
+	SizeofSockaddrCAN       = 0x18
+	SizeofSockaddrALG       = 0x58
+	SizeofSockaddrVM        = 0x10
+	SizeofSockaddrXDP       = 0x10
+	SizeofSockaddrPPPoX     = 0x1e
+	SizeofSockaddrTIPC      = 0x10
+	SizeofSockaddrL2TPIP    = 0x10
+	SizeofSockaddrL2TPIP6   = 0x20
+	SizeofSockaddrIUCV      = 0x20
+	SizeofSockaddrNFC       = 0x10
+	SizeofSockaddrNFCLLCP   = 0x60
+	SizeofLinger            = 0x8
+	SizeofIovec             = 0x10
+	SizeofIPMreq            = 0x8
+	SizeofIPMreqn           = 0xc
+	SizeofIPv6Mreq          = 0x14
+	SizeofPacketMreq        = 0x10
+	SizeofMsghdr            = 0x38
+	SizeofCmsghdr           = 0x10
+	SizeofInet4Pktinfo      = 0xc
+	SizeofInet6Pktinfo      = 0x14
+	SizeofIPv6MTUInfo       = 0x20
+	SizeofICMPv6Filter      = 0x20
+	SizeofUcred             = 0xc
+	SizeofTCPInfo           = 0xf0
+	SizeofCanFilter         = 0x8
+	SizeofTCPRepairOpt      = 0x8
+)
+
+const (
+	NDA_UNSPEC         = 0x0
+	NDA_DST            = 0x1
+	NDA_LLADDR         = 0x2
+	NDA_CACHEINFO      = 0x3
+	NDA_PROBES         = 0x4
+	NDA_VLAN           = 0x5
+	NDA_PORT           = 0x6
+	NDA_VNI            = 0x7
+	NDA_IFINDEX        = 0x8
+	NDA_MASTER         = 0x9
+	NDA_LINK_NETNSID   = 0xa
+	NDA_SRC_VNI        = 0xb
+	NTF_USE            = 0x1
+	NTF_SELF           = 0x2
+	NTF_MASTER         = 0x4
+	NTF_PROXY          = 0x8
+	NTF_EXT_LEARNED    = 0x10
+	NTF_OFFLOADED      = 0x20
+	NTF_ROUTER         = 0x80
+	NUD_INCOMPLETE     = 0x1
+	NUD_REACHABLE      = 0x2
+	NUD_STALE          = 0x4
+	NUD_DELAY          = 0x8
+	NUD_PROBE          = 0x10
+	NUD_FAILED         = 0x20
+	NUD_NOARP          = 0x40
+	NUD_PERMANENT      = 0x80
+	NUD_NONE           = 0x0
+	IFA_UNSPEC         = 0x0
+	IFA_ADDRESS        = 0x1
+	IFA_LOCAL          = 0x2
+	IFA_LABEL          = 0x3
+	IFA_BROADCAST      = 0x4
+	IFA_ANYCAST        = 0x5
+	IFA_CACHEINFO      = 0x6
+	IFA_MULTICAST      = 0x7
+	IFA_FLAGS          = 0x8
+	IFA_RT_PRIORITY    = 0x9
+	IFA_TARGET_NETNSID = 0xa
+	RT_SCOPE_UNIVERSE  = 0x0
+	RT_SCOPE_SITE      = 0xc8
+	RT_SCOPE_LINK      = 0xfd
+	RT_SCOPE_HOST      = 0xfe
+	RT_SCOPE_NOWHERE   = 0xff
+	RT_TABLE_UNSPEC    = 0x0
+	RT_TABLE_COMPAT    = 0xfc
+	RT_TABLE_DEFAULT   = 0xfd
+	RT_TABLE_MAIN      = 0xfe
+	RT_TABLE_LOCAL     = 0xff
+	RT_TABLE_MAX       = 0xffffffff
+	RTA_UNSPEC         = 0x0
+	RTA_DST            = 0x1
+	RTA_SRC            = 0x2
+	RTA_IIF            = 0x3
+	RTA_OIF            = 0x4
+	RTA_GATEWAY        = 0x5
+	RTA_PRIORITY       = 0x6
+	RTA_PREFSRC        = 0x7
+	RTA_METRICS        = 0x8
+	RTA_MULTIPATH      = 0x9
+	RTA_FLOW           = 0xb
+	RTA_CACHEINFO      = 0xc
+	RTA_TABLE          = 0xf
+	RTA_MARK           = 0x10
+	RTA_MFC_STATS      = 0x11
+	RTA_VIA            = 0x12
+	RTA_NEWDST         = 0x13
+	RTA_PREF           = 0x14
+	RTA_ENCAP_TYPE     = 0x15
+	RTA_ENCAP          = 0x16
+	RTA_EXPIRES        = 0x17
+	RTA_PAD            = 0x18
+	RTA_UID            = 0x19
+	RTA_TTL_PROPAGATE  = 0x1a
+	RTA_IP_PROTO       = 0x1b
+	RTA_SPORT          = 0x1c
+	RTA_DPORT          = 0x1d
+	RTN_UNSPEC         = 0x0
+	RTN_UNICAST        = 0x1
+	RTN_LOCAL          = 0x2
+	RTN_BROADCAST      = 0x3
+	RTN_ANYCAST        = 0x4
+	RTN_MULTICAST      = 0x5
+	RTN_BLACKHOLE      = 0x6
+	RTN_UNREACHABLE    = 0x7
+	RTN_PROHIBIT       = 0x8
+	RTN_THROW          = 0x9
+	RTN_NAT            = 0xa
+	RTN_XRESOLVE       = 0xb
+	SizeofNlMsghdr     = 0x10
+	SizeofNlMsgerr     = 0x14
+	SizeofRtGenmsg     = 0x1
+	SizeofNlAttr       = 0x4
+	SizeofRtAttr       = 0x4
+	SizeofIfInfomsg    = 0x10
+	SizeofIfAddrmsg    = 0x8
+	SizeofIfaCacheinfo = 0x10
+	SizeofRtMsg        = 0xc
+	SizeofRtNexthop    = 0x8
+	SizeofNdUseroptmsg = 0x10
+	SizeofNdMsg        = 0xc
+)
+
+type NlMsghdr struct {
+	Len   uint32
+	Type  uint16
+	Flags uint16
+	Seq   uint32
+	Pid   uint32
+}
+
+type NlMsgerr struct {
+	Error int32
+	Msg   NlMsghdr
+}
+
+type RtGenmsg struct {
+	Family uint8
+}
+
+type NlAttr struct {
+	Len  uint16
+	Type uint16
+}
+
+type RtAttr struct {
+	Len  uint16
+	Type uint16
+}
+
+type IfInfomsg struct {
+	Family uint8
+	_      uint8
+	Type   uint16
+	Index  int32
+	Flags  uint32
+	Change uint32
+}
+
+type IfAddrmsg struct {
+	Family    uint8
+	Prefixlen uint8
+	Flags     uint8
+	Scope     uint8
+	Index     uint32
+}
+
+type IfaCacheinfo struct {
+	Prefered uint32
+	Valid    uint32
+	Cstamp   uint32
+	Tstamp   uint32
+}
+
+type RtMsg struct {
+	Family   uint8
+	Dst_len  uint8
+	Src_len  uint8
+	Tos      uint8
+	Table    uint8
+	Protocol uint8
+	Scope    uint8
+	Type     uint8
+	Flags    uint32
+}
+
+type RtNexthop struct {
+	Len     uint16
+	Flags   uint8
+	Hops    uint8
+	Ifindex int32
+}
+
+type NdUseroptmsg struct {
+	Family    uint8
+	Pad1      uint8
+	Opts_len  uint16
+	Ifindex   int32
+	Icmp_type uint8
+	Icmp_code uint8
+	Pad2      uint16
+	Pad3      uint32
+}
+
+type NdMsg struct {
+	Family  uint8
+	Pad1    uint8
+	Pad2    uint16
+	Ifindex int32
+	State   uint16
+	Flags   uint8
+	Type    uint8
+}
+
+const (
+	ICMP_FILTER = 0x1
+
+	ICMPV6_FILTER             = 0x1
+	ICMPV6_FILTER_BLOCK       = 0x1
+	ICMPV6_FILTER_BLOCKOTHERS = 0x3
+	ICMPV6_FILTER_PASS        = 0x2
+	ICMPV6_FILTER_PASSONLY    = 0x4
+)
+
+const (
+	SizeofSockFilter = 0x8
+	SizeofSockFprog  = 0x10
+)
+
+type SockFilter struct {
+	Code uint16
+	Jt   uint8
+	Jf   uint8
+	K    uint32
+}
+
+type SockFprog struct {
+	Len    uint16
+	Filter *SockFilter
+}
+
+type InotifyEvent struct {
+	Wd     int32
+	Mask   uint32
+	Cookie uint32
+	Len    uint32
+}
+
+const SizeofInotifyEvent = 0x10
+
+type PtraceRegs struct{}
+
+type FdSet struct {
+	Bits [16]int64
+}
+
+type Sysinfo_t struct {
+	Uptime    int64
+	Loads     [3]uint64
+	Totalram  uint64
+	Freeram   uint64
+	Sharedram uint64
+	Bufferram uint64
+	Totalswap uint64
+	Freeswap  uint64
+	Procs     uint16
+	Pad       uint16
+	Totalhigh uint64
+	Freehigh  uint64
+	Unit      uint32
+	_         [0]int8
+	_         [4]byte
+}
+
+const SI_LOAD_SHIFT = 0x10
+
+type Utsname struct {
+	Sysname    [65]byte
+	Nodename   [65]byte
+	Release    [65]byte
+	Version    [65]byte
+	Machine    [65]byte
+	Domainname [65]byte
+}
+
+type Ustat_t struct {
+	Tfree  int32
+	Tinode uint64
+	Fname  [6]int8
+	Fpack  [6]int8
+	_      [4]byte
+}
+
+type EpollEvent struct {
+	Events uint32
+	_      int32
+	Fd     int32
+	Pad    int32
+}
+
+const (
+	AT_EMPTY_PATH   = 0x1000
+	AT_FDCWD        = -0x64
+	AT_NO_AUTOMOUNT = 0x800
+	AT_REMOVEDIR    = 0x200
+
+	AT_STATX_SYNC_AS_STAT = 0x0
+	AT_STATX_FORCE_SYNC   = 0x2000
+	AT_STATX_DONT_SYNC    = 0x4000
+
+	AT_RECURSIVE = 0x8000
+
+	AT_SYMLINK_FOLLOW   = 0x400
+	AT_SYMLINK_NOFOLLOW = 0x100
+
+	AT_EACCESS = 0x200
+
+	OPEN_TREE_CLONE   = 0x1
+	OPEN_TREE_CLOEXEC = 0x200000
+
+	MOVE_MOUNT_F_SYMLINKS   = 0x1
+	MOVE_MOUNT_F_AUTOMOUNTS = 0x2
+	MOVE_MOUNT_F_EMPTY_PATH = 0x4
+	MOVE_MOUNT_T_SYMLINKS   = 0x10
+	MOVE_MOUNT_T_AUTOMOUNTS = 0x20
+	MOVE_MOUNT_T_EMPTY_PATH = 0x40
+
+	FSOPEN_CLOEXEC = 0x1
+
+	FSPICK_CLOEXEC          = 0x1
+	FSPICK_SYMLINK_NOFOLLOW = 0x2
+	FSPICK_NO_AUTOMOUNT     = 0x4
+	FSPICK_EMPTY_PATH       = 0x8
+
+	FSMOUNT_CLOEXEC = 0x1
+)
+
+type OpenHow struct {
+	Flags   uint64
+	Mode    uint64
+	Resolve uint64
+}
+
+const SizeofOpenHow = 0x18
+
+const (
+	RESOLVE_BENEATH       = 0x8
+	RESOLVE_IN_ROOT       = 0x10
+	RESOLVE_NO_MAGICLINKS = 0x2
+	RESOLVE_NO_SYMLINKS   = 0x4
+	RESOLVE_NO_XDEV       = 0x1
+)
+
+type PollFd struct {
+	Fd      int32
+	Events  int16
+	Revents int16
+}
+
+const (
+	POLLIN    = 0x1
+	POLLPRI   = 0x2
+	POLLOUT   = 0x4
+	POLLRDHUP = 0x2000
+	POLLERR   = 0x8
+	POLLHUP   = 0x10
+	POLLNVAL  = 0x20
+)
+
+type Sigset_t struct {
+	Val [16]uint64
+}
+type sigset_argpack struct {
+	ss    *Sigset_t
+	ssLen uintptr
+}
+
+const _C__NSIG = 0x41
+
+const (
+	SIG_BLOCK   = 0x1
+	SIG_UNBLOCK = 0x2
+	SIG_SETMASK = 0x3
+)
+
+type SignalfdSiginfo struct {
+	Signo     uint32
+	Errno     int32
+	Code      int32
+	Pid       uint32
+	Uid       uint32
+	Fd        int32
+	Tid       uint32
+	Band      uint32
+	Overrun   uint32
+	Trapno    uint32
+	Status    int32
+	Int       int32
+	Ptr       uint64
+	Utime     uint64
+	Stime     uint64
+	Addr      uint64
+	Addr_lsb  uint16
+	_         uint16
+	Syscall   int32
+	Call_addr uint64
+	Arch      uint32
+	_         [28]uint8
+}
+
+type Siginfo struct {
+	Signo int32
+	Errno int32
+	Code  int32
+	_     int32
+	_     [112]byte
+}
+
+type Termios struct {
+	Iflag  uint32
+	Oflag  uint32
+	Cflag  uint32
+	Lflag  uint32
+	Cc     [19]uint8
+	Line   uint8
+	Ispeed uint32
+	Ospeed uint32
+}
+
+type Winsize struct {
+	Row    uint16
+	Col    uint16
+	Xpixel uint16
+	Ypixel uint16
+}
+
+type Taskstats struct {
+	Version                   uint16
+	Ac_exitcode               uint32
+	Ac_flag                   uint8
+	Ac_nice                   uint8
+	Cpu_count                 uint64
+	Cpu_delay_total           uint64
+	Blkio_count               uint64
+	Blkio_delay_total         uint64
+	Swapin_count              uint64
+	Swapin_delay_total        uint64
+	Cpu_run_real_total        uint64
+	Cpu_run_virtual_total     uint64
+	Ac_comm                   [32]int8
+	Ac_sched                  uint8
+	Ac_pad                    [3]uint8
+	_                         [4]byte
+	Ac_uid                    uint32
+	Ac_gid                    uint32
+	Ac_pid                    uint32
+	Ac_ppid                   uint32
+	Ac_btime                  uint32
+	Ac_etime                  uint64
+	Ac_utime                  uint64
+	Ac_stime                  uint64
+	Ac_minflt                 uint64
+	Ac_majflt                 uint64
+	Coremem                   uint64
+	Virtmem                   uint64
+	Hiwater_rss               uint64
+	Hiwater_vm                uint64
+	Read_char                 uint64
+	Write_char                uint64
+	Read_syscalls             uint64
+	Write_syscalls            uint64
+	Read_bytes                uint64
+	Write_bytes               uint64
+	Cancelled_write_bytes     uint64
+	Nvcsw                     uint64
+	Nivcsw                    uint64
+	Ac_utimescaled            uint64
+	Ac_stimescaled            uint64
+	Cpu_scaled_run_real_total uint64
+	Freepages_count           uint64
+	Freepages_delay_total     uint64
+	Thrashing_count           uint64
+	Thrashing_delay_total     uint64
+	Ac_btime64                uint64
+	Compact_count             uint64
+	Compact_delay_total       uint64
+	Ac_tgid                   uint32
+	Ac_tgetime                uint64
+	Ac_exe_dev                uint64
+	Ac_exe_inode              uint64
+	Wpcopy_count              uint64
+	Wpcopy_delay_total        uint64
+	Irq_count                 uint64
+	Irq_delay_total           uint64
+}
+
+const (
+	TASKSTATS_CMD_UNSPEC                  = 0x0
+	TASKSTATS_CMD_GET                     = 0x1
+	TASKSTATS_CMD_NEW                     = 0x2
+	TASKSTATS_TYPE_UNSPEC                 = 0x0
+	TASKSTATS_TYPE_PID                    = 0x1
+	TASKSTATS_TYPE_TGID                   = 0x2
+	TASKSTATS_TYPE_STATS                  = 0x3
+	TASKSTATS_TYPE_AGGR_PID               = 0x4
+	TASKSTATS_TYPE_AGGR_TGID              = 0x5
+	TASKSTATS_TYPE_NULL                   = 0x6
+	TASKSTATS_CMD_ATTR_UNSPEC             = 0x0
+	TASKSTATS_CMD_ATTR_PID                = 0x1
+	TASKSTATS_CMD_ATTR_TGID               = 0x2
+	TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3
+	TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4
+)
+
+type CGroupStats struct {
+	Sleeping        uint64
+	Running         uint64
+	Stopped         uint64
+	Uninterruptible uint64
+	Io_wait         uint64
+}
+
+const (
+	CGROUPSTATS_CMD_UNSPEC        = 0x3
+	CGROUPSTATS_CMD_GET           = 0x4
+	CGROUPSTATS_CMD_NEW           = 0x5
+	CGROUPSTATS_TYPE_UNSPEC       = 0x0
+	CGROUPSTATS_TYPE_CGROUP_STATS = 0x1
+	CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0
+	CGROUPSTATS_CMD_ATTR_FD       = 0x1
+)
+
+type Genlmsghdr struct {
+	Cmd      uint8
+	Version  uint8
+	Reserved uint16
+}
+
+const (
+	CTRL_CMD_UNSPEC            = 0x0
+	CTRL_CMD_NEWFAMILY         = 0x1
+	CTRL_CMD_DELFAMILY         = 0x2
+	CTRL_CMD_GETFAMILY         = 0x3
+	CTRL_CMD_NEWOPS            = 0x4
+	CTRL_CMD_DELOPS            = 0x5
+	CTRL_CMD_GETOPS            = 0x6
+	CTRL_CMD_NEWMCAST_GRP      = 0x7
+	CTRL_CMD_DELMCAST_GRP      = 0x8
+	CTRL_CMD_GETMCAST_GRP      = 0x9
+	CTRL_CMD_GETPOLICY         = 0xa
+	CTRL_ATTR_UNSPEC           = 0x0
+	CTRL_ATTR_FAMILY_ID        = 0x1
+	CTRL_ATTR_FAMILY_NAME      = 0x2
+	CTRL_ATTR_VERSION          = 0x3
+	CTRL_ATTR_HDRSIZE          = 0x4
+	CTRL_ATTR_MAXATTR          = 0x5
+	CTRL_ATTR_OPS              = 0x6
+	CTRL_ATTR_MCAST_GROUPS     = 0x7
+	CTRL_ATTR_POLICY           = 0x8
+	CTRL_ATTR_OP_POLICY        = 0x9
+	CTRL_ATTR_OP               = 0xa
+	CTRL_ATTR_OP_UNSPEC        = 0x0
+	CTRL_ATTR_OP_ID            = 0x1
+	CTRL_ATTR_OP_FLAGS         = 0x2
+	CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0
+	CTRL_ATTR_MCAST_GRP_NAME   = 0x1
+	CTRL_ATTR_MCAST_GRP_ID     = 0x2
+	CTRL_ATTR_POLICY_UNSPEC    = 0x0
+	CTRL_ATTR_POLICY_DO        = 0x1
+	CTRL_ATTR_POLICY_DUMP      = 0x2
+	CTRL_ATTR_POLICY_DUMP_MAX  = 0x2
+)
+
+type cpuMask uint64
+
+const (
+	_CPU_SETSIZE = 0x400
+	_NCPUBITS    = 0x40
+)
+
+const (
+	BDADDR_BREDR     = 0x0
+	BDADDR_LE_PUBLIC = 0x1
+	BDADDR_LE_RANDOM = 0x2
+)
+
+type PerfEventAttr struct {
+	Type               uint32
+	Size               uint32
+	Config             uint64
+	Sample             uint64
+	Sample_type        uint64
+	Read_format        uint64
+	Bits               uint64
+	Wakeup             uint32
+	Bp_type            uint32
+	Ext1               uint64
+	Ext2               uint64
+	Branch_sample_type uint64
+	Sample_regs_user   uint64
+	Sample_stack_user  uint32
+	Clockid            int32
+	Sample_regs_intr   uint64
+	Aux_watermark      uint32
+	Sample_max_stack   uint16
+	_                  uint16
+	Aux_sample_size    uint32
+	_                  uint32
+	Sig_data           uint64
+}
+
+type PerfEventMmapPage struct {
+	Version        uint32
+	Compat_version uint32
+	Lock           uint32
+	Index          uint32
+	Offset         int64
+	Time_enabled   uint64
+	Time_running   uint64
+	Capabilities   uint64
+	Pmc_width      uint16
+	Time_shift     uint16
+	Time_mult      uint32
+	Time_offset    uint64
+	Time_zero      uint64
+	Size           uint32
+	_              uint32
+	Time_cycles    uint64
+	Time_mask      uint64
+	_              [928]uint8
+	Data_head      uint64
+	Data_tail      uint64
+	Data_offset    uint64
+	Data_size      uint64
+	Aux_head       uint64
+	Aux_tail       uint64
+	Aux_offset     uint64
+	Aux_size       uint64
+}
+
+const (
+	PerfBitDisabled               uint64 = CBitFieldMaskBit0
+	PerfBitInherit                       = CBitFieldMaskBit1
+	PerfBitPinned                        = CBitFieldMaskBit2
+	PerfBitExclusive                     = CBitFieldMaskBit3
+	PerfBitExcludeUser                   = CBitFieldMaskBit4
+	PerfBitExcludeKernel                 = CBitFieldMaskBit5
+	PerfBitExcludeHv                     = CBitFieldMaskBit6
+	PerfBitExcludeIdle                   = CBitFieldMaskBit7
+	PerfBitMmap                          = CBitFieldMaskBit8
+	PerfBitComm                          = CBitFieldMaskBit9
+	PerfBitFreq                          = CBitFieldMaskBit10
+	PerfBitInheritStat                   = CBitFieldMaskBit11
+	PerfBitEnableOnExec                  = CBitFieldMaskBit12
+	PerfBitTask                          = CBitFieldMaskBit13
+	PerfBitWatermark                     = CBitFieldMaskBit14
+	PerfBitPreciseIPBit1                 = CBitFieldMaskBit15
+	PerfBitPreciseIPBit2                 = CBitFieldMaskBit16
+	PerfBitMmapData                      = CBitFieldMaskBit17
+	PerfBitSampleIDAll                   = CBitFieldMaskBit18
+	PerfBitExcludeHost                   = CBitFieldMaskBit19
+	PerfBitExcludeGuest                  = CBitFieldMaskBit20
+	PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21
+	PerfBitExcludeCallchainUser          = CBitFieldMaskBit22
+	PerfBitMmap2                         = CBitFieldMaskBit23
+	PerfBitCommExec                      = CBitFieldMaskBit24
+	PerfBitUseClockID                    = CBitFieldMaskBit25
+	PerfBitContextSwitch                 = CBitFieldMaskBit26
+	PerfBitWriteBackward                 = CBitFieldMaskBit27
+)
+
+const (
+	PERF_TYPE_HARDWARE                    = 0x0
+	PERF_TYPE_SOFTWARE                    = 0x1
+	PERF_TYPE_TRACEPOINT                  = 0x2
+	PERF_TYPE_HW_CACHE                    = 0x3
+	PERF_TYPE_RAW                         = 0x4
+	PERF_TYPE_BREAKPOINT                  = 0x5
+	PERF_TYPE_MAX                         = 0x6
+	PERF_COUNT_HW_CPU_CYCLES              = 0x0
+	PERF_COUNT_HW_INSTRUCTIONS            = 0x1
+	PERF_COUNT_HW_CACHE_REFERENCES        = 0x2
+	PERF_COUNT_HW_CACHE_MISSES            = 0x3
+	PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4
+	PERF_COUNT_HW_BRANCH_MISSES           = 0x5
+	PERF_COUNT_HW_BUS_CYCLES              = 0x6
+	PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7
+	PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8
+	PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9
+	PERF_COUNT_HW_MAX                     = 0xa
+	PERF_COUNT_HW_CACHE_L1D               = 0x0
+	PERF_COUNT_HW_CACHE_L1I               = 0x1
+	PERF_COUNT_HW_CACHE_LL                = 0x2
+	PERF_COUNT_HW_CACHE_DTLB              = 0x3
+	PERF_COUNT_HW_CACHE_ITLB              = 0x4
+	PERF_COUNT_HW_CACHE_BPU               = 0x5
+	PERF_COUNT_HW_CACHE_NODE              = 0x6
+	PERF_COUNT_HW_CACHE_MAX               = 0x7
+	PERF_COUNT_HW_CACHE_OP_READ           = 0x0
+	PERF_COUNT_HW_CACHE_OP_WRITE          = 0x1
+	PERF_COUNT_HW_CACHE_OP_PREFETCH       = 0x2
+	PERF_COUNT_HW_CACHE_OP_MAX            = 0x3
+	PERF_COUNT_HW_CACHE_RESULT_ACCESS     = 0x0
+	PERF_COUNT_HW_CACHE_RESULT_MISS       = 0x1
+	PERF_COUNT_HW_CACHE_RESULT_MAX        = 0x2
+	PERF_COUNT_SW_CPU_CLOCK               = 0x0
+	PERF_COUNT_SW_TASK_CLOCK              = 0x1
+	PERF_COUNT_SW_PAGE_FAULTS             = 0x2
+	PERF_COUNT_SW_CONTEXT_SWITCHES        = 0x3
+	PERF_COUNT_SW_CPU_MIGRATIONS          = 0x4
+	PERF_COUNT_SW_PAGE_FAULTS_MIN         = 0x5
+	PERF_COUNT_SW_PAGE_FAULTS_MAJ         = 0x6
+	PERF_COUNT_SW_ALIGNMENT_FAULTS        = 0x7
+	PERF_COUNT_SW_EMULATION_FAULTS        = 0x8
+	PERF_COUNT_SW_DUMMY                   = 0x9
+	PERF_COUNT_SW_BPF_OUTPUT              = 0xa
+	PERF_COUNT_SW_MAX                     = 0xc
+	PERF_SAMPLE_IP                        = 0x1
+	PERF_SAMPLE_TID                       = 0x2
+	PERF_SAMPLE_TIME                      = 0x4
+	PERF_SAMPLE_ADDR                      = 0x8
+	PERF_SAMPLE_READ                      = 0x10
+	PERF_SAMPLE_CALLCHAIN                 = 0x20
+	PERF_SAMPLE_ID                        = 0x40
+	PERF_SAMPLE_CPU                       = 0x80
+	PERF_SAMPLE_PERIOD                    = 0x100
+	PERF_SAMPLE_STREAM_ID                 = 0x200
+	PERF_SAMPLE_RAW                       = 0x400
+	PERF_SAMPLE_BRANCH_STACK              = 0x800
+	PERF_SAMPLE_REGS_USER                 = 0x1000
+	PERF_SAMPLE_STACK_USER                = 0x2000
+	PERF_SAMPLE_WEIGHT                    = 0x4000
+	PERF_SAMPLE_DATA_SRC                  = 0x8000
+	PERF_SAMPLE_IDENTIFIER                = 0x10000
+	PERF_SAMPLE_TRANSACTION               = 0x20000
+	PERF_SAMPLE_REGS_INTR                 = 0x40000
+	PERF_SAMPLE_PHYS_ADDR                 = 0x80000
+	PERF_SAMPLE_AUX                       = 0x100000
+	PERF_SAMPLE_CGROUP                    = 0x200000
+
+	PERF_SAMPLE_MAX                     = 0x2000000
+	PERF_SAMPLE_BRANCH_USER_SHIFT       = 0x0
+	PERF_SAMPLE_BRANCH_KERNEL_SHIFT     = 0x1
+	PERF_SAMPLE_BRANCH_HV_SHIFT         = 0x2
+	PERF_SAMPLE_BRANCH_ANY_SHIFT        = 0x3
+	PERF_SAMPLE_BRANCH_ANY_CALL_SHIFT   = 0x4
+	PERF_SAMPLE_BRANCH_ANY_RETURN_SHIFT = 0x5
+	PERF_SAMPLE_BRANCH_IND_CALL_SHIFT   = 0x6
+	PERF_SAMPLE_BRANCH_ABORT_TX_SHIFT   = 0x7
+	PERF_SAMPLE_BRANCH_IN_TX_SHIFT      = 0x8
+	PERF_SAMPLE_BRANCH_NO_TX_SHIFT      = 0x9
+	PERF_SAMPLE_BRANCH_COND_SHIFT       = 0xa
+	PERF_SAMPLE_BRANCH_CALL_STACK_SHIFT = 0xb
+	PERF_SAMPLE_BRANCH_IND_JUMP_SHIFT   = 0xc
+	PERF_SAMPLE_BRANCH_CALL_SHIFT       = 0xd
+	PERF_SAMPLE_BRANCH_NO_FLAGS_SHIFT   = 0xe
+	PERF_SAMPLE_BRANCH_NO_CYCLES_SHIFT  = 0xf
+	PERF_SAMPLE_BRANCH_TYPE_SAVE_SHIFT  = 0x10
+	PERF_SAMPLE_BRANCH_HW_INDEX_SHIFT   = 0x11
+	PERF_SAMPLE_BRANCH_PRIV_SAVE_SHIFT  = 0x12
+	PERF_SAMPLE_BRANCH_MAX_SHIFT        = 0x13
+	PERF_SAMPLE_BRANCH_USER             = 0x1
+	PERF_SAMPLE_BRANCH_KERNEL           = 0x2
+	PERF_SAMPLE_BRANCH_HV               = 0x4
+	PERF_SAMPLE_BRANCH_ANY              = 0x8
+	PERF_SAMPLE_BRANCH_ANY_CALL         = 0x10
+	PERF_SAMPLE_BRANCH_ANY_RETURN       = 0x20
+	PERF_SAMPLE_BRANCH_IND_CALL         = 0x40
+	PERF_SAMPLE_BRANCH_ABORT_TX         = 0x80
+	PERF_SAMPLE_BRANCH_IN_TX            = 0x100
+	PERF_SAMPLE_BRANCH_NO_TX            = 0x200
+	PERF_SAMPLE_BRANCH_COND             = 0x400
+	PERF_SAMPLE_BRANCH_CALL_STACK       = 0x800
+	PERF_SAMPLE_BRANCH_IND_JUMP         = 0x1000
+	PERF_SAMPLE_BRANCH_CALL             = 0x2000
+	PERF_SAMPLE_BRANCH_NO_FLAGS         = 0x4000
+	PERF_SAMPLE_BRANCH_NO_CYCLES        = 0x8000
+	PERF_SAMPLE_BRANCH_TYPE_SAVE        = 0x10000
+	PERF_SAMPLE_BRANCH_HW_INDEX         = 0x20000
+	PERF_SAMPLE_BRANCH_PRIV_SAVE        = 0x40000
+	PERF_SAMPLE_BRANCH_MAX              = 0x80000
+	PERF_BR_UNKNOWN                     = 0x0
+	PERF_BR_COND                        = 0x1
+	PERF_BR_UNCOND                      = 0x2
+	PERF_BR_IND                         = 0x3
+	PERF_BR_CALL                        = 0x4
+	PERF_BR_IND_CALL                    = 0x5
+	PERF_BR_RET                         = 0x6
+	PERF_BR_SYSCALL                     = 0x7
+	PERF_BR_SYSRET                      = 0x8
+	PERF_BR_COND_CALL                   = 0x9
+	PERF_BR_COND_RET                    = 0xa
+
+	PERF_BR_SERROR                 = 0xd
+	PERF_BR_NO_TX                  = 0xe
+	PERF_BR_EXTEND_ABI             = 0xf
+	PERF_BR_MAX                    = 0x10
+	PERF_SAMPLE_REGS_ABI_NONE      = 0x0
+	PERF_SAMPLE_REGS_ABI_32        = 0x1
+	PERF_SAMPLE_REGS_ABI_64        = 0x2
+	PERF_TXN_ELISION               = 0x1
+	PERF_TXN_TRANSACTION           = 0x2
+	PERF_TXN_SYNC                  = 0x4
+	PERF_TXN_ASYNC                 = 0x8
+	PERF_TXN_RETRY                 = 0x10
+	PERF_TXN_CONFLICT              = 0x20
+	PERF_TXN_CAPACITY_WRITE        = 0x40
+	PERF_TXN_CAPACITY_READ         = 0x80
+	PERF_TXN_MAX                   = 0x100
+	PERF_TXN_ABORT_MASK            = -0x100000000
+	PERF_TXN_ABORT_SHIFT           = 0x20
+	PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1
+	PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2
+	PERF_FORMAT_ID                 = 0x4
+	PERF_FORMAT_GROUP              = 0x8
+	PERF_FORMAT_LOST               = 0x10
+	PERF_FORMAT_MAX                = 0x20
+	PERF_IOC_FLAG_GROUP            = 0x1
+	PERF_RECORD_MMAP               = 0x1
+	PERF_RECORD_LOST               = 0x2
+	PERF_RECORD_COMM               = 0x3
+	PERF_RECORD_EXIT               = 0x4
+	PERF_RECORD_THROTTLE           = 0x5
+	PERF_RECORD_UNTHROTTLE         = 0x6
+	PERF_RECORD_FORK               = 0x7
+	PERF_RECORD_READ               = 0x8
+	PERF_RECORD_SAMPLE             = 0x9
+	PERF_RECORD_MMAP2              = 0xa
+	PERF_RECORD_AUX                = 0xb
+	PERF_RECORD_ITRACE_START       = 0xc
+	PERF_RECORD_LOST_SAMPLES       = 0xd
+	PERF_RECORD_SWITCH             = 0xe
+	PERF_RECORD_SWITCH_CPU_WIDE    = 0xf
+	PERF_RECORD_NAMESPACES         = 0x10
+	PERF_RECORD_KSYMBOL            = 0x11
+	PERF_RECORD_BPF_EVENT          = 0x12
+	PERF_RECORD_CGROUP             = 0x13
+	PERF_RECORD_TEXT_POKE          = 0x14
+
+	PERF_RECORD_MAX                  = 0x16
+	PERF_RECORD_KSYMBOL_TYPE_UNKNOWN = 0x0
+	PERF_RECORD_KSYMBOL_TYPE_BPF     = 0x1
+	PERF_RECORD_KSYMBOL_TYPE_OOL     = 0x2
+	PERF_RECORD_KSYMBOL_TYPE_MAX     = 0x3
+	PERF_BPF_EVENT_UNKNOWN           = 0x0
+	PERF_BPF_EVENT_PROG_LOAD         = 0x1
+	PERF_BPF_EVENT_PROG_UNLOAD       = 0x2
+	PERF_BPF_EVENT_MAX               = 0x3
+	PERF_CONTEXT_HV                  = -0x20
+	PERF_CONTEXT_KERNEL              = -0x80
+	PERF_CONTEXT_USER                = -0x200
+	PERF_CONTEXT_GUEST               = -0x800
+	PERF_CONTEXT_GUEST_KERNEL        = -0x880
+	PERF_CONTEXT_GUEST_USER          = -0xa00
+	PERF_CONTEXT_MAX                 = -0xfff
+)
+
+const (
+	CBitFieldMaskBit0  = 0x1
+	CBitFieldMaskBit1  = 0x2
+	CBitFieldMaskBit2  = 0x4
+	CBitFieldMaskBit3  = 0x8
+	CBitFieldMaskBit4  = 0x10
+	CBitFieldMaskBit5  = 0x20
+	CBitFieldMaskBit6  = 0x40
+	CBitFieldMaskBit7  = 0x80
+	CBitFieldMaskBit8  = 0x100
+	CBitFieldMaskBit9  = 0x200
+	CBitFieldMaskBit10 = 0x400
+	CBitFieldMaskBit11 = 0x800
+	CBitFieldMaskBit12 = 0x1000
+	CBitFieldMaskBit13 = 0x2000
+	CBitFieldMaskBit14 = 0x4000
+	CBitFieldMaskBit15 = 0x8000
+	CBitFieldMaskBit16 = 0x10000
+	CBitFieldMaskBit17 = 0x20000
+	CBitFieldMaskBit18 = 0x40000
+	CBitFieldMaskBit19 = 0x80000
+	CBitFieldMaskBit20 = 0x100000
+	CBitFieldMaskBit21 = 0x200000
+	CBitFieldMaskBit22 = 0x400000
+	CBitFieldMaskBit23 = 0x800000
+	CBitFieldMaskBit24 = 0x1000000
+	CBitFieldMaskBit25 = 0x2000000
+	CBitFieldMaskBit26 = 0x4000000
+	CBitFieldMaskBit27 = 0x8000000
+	CBitFieldMaskBit28 = 0x10000000
+	CBitFieldMaskBit29 = 0x20000000
+	CBitFieldMaskBit30 = 0x40000000
+	CBitFieldMaskBit31 = 0x80000000
+	CBitFieldMaskBit32 = 0x100000000
+	CBitFieldMaskBit33 = 0x200000000
+	CBitFieldMaskBit34 = 0x400000000
+	CBitFieldMaskBit35 = 0x800000000
+	CBitFieldMaskBit36 = 0x1000000000
+	CBitFieldMaskBit37 = 0x2000000000
+	CBitFieldMaskBit38 = 0x4000000000
+	CBitFieldMaskBit39 = 0x8000000000
+	CBitFieldMaskBit40 = 0x10000000000
+	CBitFieldMaskBit41 = 0x20000000000
+	CBitFieldMaskBit42 = 0x40000000000
+	CBitFieldMaskBit43 = 0x80000000000
+	CBitFieldMaskBit44 = 0x100000000000
+	CBitFieldMaskBit45 = 0x200000000000
+	CBitFieldMaskBit46 = 0x400000000000
+	CBitFieldMaskBit47 = 0x800000000000
+	CBitFieldMaskBit48 = 0x1000000000000
+	CBitFieldMaskBit49 = 0x2000000000000
+	CBitFieldMaskBit50 = 0x4000000000000
+	CBitFieldMaskBit51 = 0x8000000000000
+	CBitFieldMaskBit52 = 0x10000000000000
+	CBitFieldMaskBit53 = 0x20000000000000
+	CBitFieldMaskBit54 = 0x40000000000000
+	CBitFieldMaskBit55 = 0x80000000000000
+	CBitFieldMaskBit56 = 0x100000000000000
+	CBitFieldMaskBit57 = 0x200000000000000
+	CBitFieldMaskBit58 = 0x400000000000000
+	CBitFieldMaskBit59 = 0x800000000000000
+	CBitFieldMaskBit60 = 0x1000000000000000
+	CBitFieldMaskBit61 = 0x2000000000000000
+	CBitFieldMaskBit62 = 0x4000000000000000
+	CBitFieldMaskBit63 = 0x8000000000000000
+)
+
+type SockaddrStorage struct {
+	Family uint16
+	Data   [118]byte
+	_      uint64
+}
+
+type TCPMD5Sig struct {
+	Addr      SockaddrStorage
+	Flags     uint8
+	Prefixlen uint8
+	Keylen    uint16
+	Ifindex   int32
+	Key       [80]uint8
+}
+
+type HDDriveCmdHdr struct {
+	Command uint8
+	Number  uint8
+	Feature uint8
+	Count   uint8
+}
+
+type HDGeometry struct {
+	Heads     uint8
+	Sectors   uint8
+	Cylinders uint16
+	Start     uint64
+}
+
+type HDDriveID struct {
+	Config         uint16
+	Cyls           uint16
+	Reserved2      uint16
+	Heads          uint16
+	Track_bytes    uint16
+	Sector_bytes   uint16
+	Sectors        uint16
+	Vendor0        uint16
+	Vendor1        uint16
+	Vendor2        uint16
+	Serial_no      [20]uint8
+	Buf_type       uint16
+	Buf_size       uint16
+	Ecc_bytes      uint16
+	Fw_rev         [8]uint8
+	Model          [40]uint8
+	Max_multsect   uint8
+	Vendor3        uint8
+	Dword_io       uint16
+	Vendor4        uint8
+	Capability     uint8
+	Reserved50     uint16
+	Vendor5        uint8
+	TPIO           uint8
+	Vendor6        uint8
+	TDMA           uint8
+	Field_valid    uint16
+	Cur_cyls       uint16
+	Cur_heads      uint16
+	Cur_sectors    uint16
+	Cur_capacity0  uint16
+	Cur_capacity1  uint16
+	Multsect       uint8
+	Multsect_valid uint8
+	Lba_capacity   uint32
+	Dma_1word      uint16
+	Dma_mword      uint16
+	Eide_pio_modes uint16
+	Eide_dma_min   uint16
+	Eide_dma_time  uint16
+	Eide_pio       uint16
+	Eide_pio_iordy uint16
+	Words69_70     [2]uint16
+	Words71_74     [4]uint16
+	Queue_depth    uint16
+	Words76_79     [4]uint16
+	Major_rev_num  uint16
+	Minor_rev_num  uint16
+	Command_set_1  uint16
+	Command_set_2  uint16
+	Cfsse          uint16
+	Cfs_enable_1   uint16
+	Cfs_enable_2   uint16
+	Csf_default    uint16
+	Dma_ultra      uint16
+	Trseuc         uint16
+	TrsEuc         uint16
+	CurAPMvalues   uint16
+	Mprc           uint16
+	Hw_config      uint16
+	Acoustic       uint16
+	Msrqs          uint16
+	Sxfert         uint16
+	Sal            uint16
+	Spg            uint32
+	Lba_capacity_2 uint64
+	Words104_125   [22]uint16
+	Last_lun       uint16
+	Word127        uint16
+	Dlf            uint16
+	Csfo           uint16
+	Words130_155   [26]uint16
+	Word156        uint16
+	Words157_159   [3]uint16
+	Cfa_power      uint16
+	Words161_175   [15]uint16
+	Words176_205   [30]uint16
+	Words206_254   [49]uint16
+	Integrity_word uint16
+}
+
+type Statfs_t struct {
+	Type    int64
+	Bsize   int64
+	Blocks  uint64
+	Bfree   uint64
+	Bavail  uint64
+	Files   uint64
+	Ffree   uint64
+	Fsid    Fsid
+	Namelen int64
+	Frsize  int64
+	Flags   int64
+	Spare   [4]int64
+}
+
+const (
+	ST_MANDLOCK    = 0x40
+	ST_NOATIME     = 0x400
+	ST_NODEV       = 0x4
+	ST_NODIRATIME  = 0x800
+	ST_NOEXEC      = 0x8
+	ST_NOSUID      = 0x2
+	ST_RDONLY      = 0x1
+	ST_RELATIME    = 0x1000
+	ST_SYNCHRONOUS = 0x10
+)
+
+type TpacketHdr struct {
+	Status  uint64
+	Len     uint32
+	Snaplen uint32
+	Mac     uint16
+	Net     uint16
+	Sec     uint32
+	Usec    uint32
+	_       [4]byte
+}
+
+type Tpacket2Hdr struct {
+	Status    uint32
+	Len       uint32
+	Snaplen   uint32
+	Mac       uint16
+	Net       uint16
+	Sec       uint32
+	Nsec      uint32
+	Vlan_tci  uint16
+	Vlan_tpid uint16
+	_         [4]uint8
+}
+
+type Tpacket3Hdr struct {
+	Next_offset uint32
+	Sec         uint32
+	Nsec        uint32
+	Snaplen     uint32
+	Len         uint32
+	Status      uint32
+	Mac         uint16
+	Net         uint16
+	Hv1         TpacketHdrVariant1
+	_           [8]uint8
+}
+
+type TpacketHdrVariant1 struct {
+	Rxhash    uint32
+	Vlan_tci  uint32
+	Vlan_tpid uint16
+	_         uint16
+}
+
+type TpacketBlockDesc struct {
+	Version uint32
+	To_priv uint32
+	Hdr     [40]byte
+}
+
+type TpacketBDTS struct {
+	Sec  uint32
+	Usec uint32
+}
+
+type TpacketHdrV1 struct {
+	Block_status        uint32
+	Num_pkts            uint32
+	Offset_to_first_pkt uint32
+	Blk_len             uint32
+	Seq_num             uint64
+	Ts_first_pkt        TpacketBDTS
+	Ts_last_pkt         TpacketBDTS
+}
+
+type TpacketReq struct {
+	Block_size uint32
+	Block_nr   uint32
+	Frame_size uint32
+	Frame_nr   uint32
+}
+
+type TpacketReq3 struct {
+	Block_size       uint32
+	Block_nr         uint32
+	Frame_size       uint32
+	Frame_nr         uint32
+	Retire_blk_tov   uint32
+	Sizeof_priv      uint32
+	Feature_req_word uint32
+}
+
+type TpacketStats struct {
+	Packets uint32
+	Drops   uint32
+}
+
+type TpacketStatsV3 struct {
+	Packets      uint32
+	Drops        uint32
+	Freeze_q_cnt uint32
+}
+
+type TpacketAuxdata struct {
+	Status    uint32
+	Len       uint32
+	Snaplen   uint32
+	Mac       uint16
+	Net       uint16
+	Vlan_tci  uint16
+	Vlan_tpid uint16
+}
+
+const (
+	TPACKET_V1 = 0x0
+	TPACKET_V2 = 0x1
+	TPACKET_V3 = 0x2
+)
+
+const (
+	SizeofTpacketHdr  = 0x20
+	SizeofTpacket2Hdr = 0x20
+	SizeofTpacket3Hdr = 0x30
+
+	SizeofTpacketStats   = 0x8
+	SizeofTpacketStatsV3 = 0xc
+)
+
+const (
+	IFLA_UNSPEC             = 0x0
+	IFLA_ADDRESS            = 0x1
+	IFLA_BROADCAST          = 0x2
+	IFLA_IFNAME             = 0x3
+	IFLA_MTU                = 0x4
+	IFLA_LINK               = 0x5
+	IFLA_QDISC              = 0x6
+	IFLA_STATS              = 0x7
+	IFLA_COST               = 0x8
+	IFLA_PRIORITY           = 0x9
+	IFLA_MASTER             = 0xa
+	IFLA_WIRELESS           = 0xb
+	IFLA_PROTINFO           = 0xc
+	IFLA_TXQLEN             = 0xd
+	IFLA_MAP                = 0xe
+	IFLA_WEIGHT             = 0xf
+	IFLA_OPERSTATE          = 0x10
+	IFLA_LINKMODE           = 0x11
+	IFLA_LINKINFO           = 0x12
+	IFLA_NET_NS_PID         = 0x13
+	IFLA_IFALIAS            = 0x14
+	IFLA_NUM_VF             = 0x15
+	IFLA_VFINFO_LIST        = 0x16
+	IFLA_STATS64            = 0x17
+	IFLA_VF_PORTS           = 0x18
+	IFLA_PORT_SELF          = 0x19
+	IFLA_AF_SPEC            = 0x1a
+	IFLA_GROUP              = 0x1b
+	IFLA_NET_NS_FD          = 0x1c
+	IFLA_EXT_MASK           = 0x1d
+	IFLA_PROMISCUITY        = 0x1e
+	IFLA_NUM_TX_QUEUES      = 0x1f
+	IFLA_NUM_RX_QUEUES      = 0x20
+	IFLA_CARRIER            = 0x21
+	IFLA_PHYS_PORT_ID       = 0x22
+	IFLA_CARRIER_CHANGES    = 0x23
+	IFLA_PHYS_SWITCH_ID     = 0x24
+	IFLA_LINK_NETNSID       = 0x25
+	IFLA_PHYS_PORT_NAME     = 0x26
+	IFLA_PROTO_DOWN         = 0x27
+	IFLA_GSO_MAX_SEGS       = 0x28
+	IFLA_GSO_MAX_SIZE       = 0x29
+	IFLA_PAD                = 0x2a
+	IFLA_XDP                = 0x2b
+	IFLA_EVENT              = 0x2c
+	IFLA_NEW_NETNSID        = 0x2d
+	IFLA_IF_NETNSID         = 0x2e
+	IFLA_TARGET_NETNSID     = 0x2e
+	IFLA_CARRIER_UP_COUNT   = 0x2f
+	IFLA_CARRIER_DOWN_COUNT = 0x30
+	IFLA_NEW_IFINDEX        = 0x31
+	IFLA_MIN_MTU            = 0x32
+	IFLA_MAX_MTU            = 0x33
+	IFLA_PROP_LIST          = 0x34
+	IFLA_ALT_IFNAME         = 0x35
+	IFLA_PERM_ADDRESS       = 0x36
+	IFLA_PROTO_DOWN_REASON  = 0x37
+
+	IFLA_ALLMULTI                              = 0x3d
+	IFLA_DEVLINK_PORT                          = 0x3e
+	IFLA_GSO_IPV4_MAX_SIZE                     = 0x3f
+	IFLA_GRO_IPV4_MAX_SIZE                     = 0x40
+	IFLA_PROTO_DOWN_REASON_UNSPEC              = 0x0
+	IFLA_PROTO_DOWN_REASON_MASK                = 0x1
+	IFLA_PROTO_DOWN_REASON_VALUE               = 0x2
+	IFLA_PROTO_DOWN_REASON_MAX                 = 0x2
+	IFLA_INET_UNSPEC                           = 0x0
+	IFLA_INET_CONF                             = 0x1
+	IFLA_INET6_UNSPEC                          = 0x0
+	IFLA_INET6_FLAGS                           = 0x1
+	IFLA_INET6_CONF                            = 0x2
+	IFLA_INET6_STATS                           = 0x3
+	IFLA_INET6_MCAST                           = 0x4
+	IFLA_INET6_CACHEINFO                       = 0x5
+	IFLA_INET6_ICMP6STATS                      = 0x6
+	IFLA_INET6_TOKEN                           = 0x7
+	IFLA_INET6_ADDR_GEN_MODE                   = 0x8
+	IFLA_BR_UNSPEC                             = 0x0
+	IFLA_BR_FORWARD_DELAY                      = 0x1
+	IFLA_BR_HELLO_TIME                         = 0x2
+	IFLA_BR_MAX_AGE                            = 0x3
+	IFLA_BR_AGEING_TIME                        = 0x4
+	IFLA_BR_STP_STATE                          = 0x5
+	IFLA_BR_PRIORITY                           = 0x6
+	IFLA_BR_VLAN_FILTERING                     = 0x7
+	IFLA_BR_VLAN_PROTOCOL                      = 0x8
+	IFLA_BR_GROUP_FWD_MASK                     = 0x9
+	IFLA_BR_ROOT_ID                            = 0xa
+	IFLA_BR_BRIDGE_ID                          = 0xb
+	IFLA_BR_ROOT_PORT                          = 0xc
+	IFLA_BR_ROOT_PATH_COST                     = 0xd
+	IFLA_BR_TOPOLOGY_CHANGE                    = 0xe
+	IFLA_BR_TOPOLOGY_CHANGE_DETECTED           = 0xf
+	IFLA_BR_HELLO_TIMER                        = 0x10
+	IFLA_BR_TCN_TIMER                          = 0x11
+	IFLA_BR_TOPOLOGY_CHANGE_TIMER              = 0x12
+	IFLA_BR_GC_TIMER                           = 0x13
+	IFLA_BR_GROUP_ADDR                         = 0x14
+	IFLA_BR_FDB_FLUSH                          = 0x15
+	IFLA_BR_MCAST_ROUTER                       = 0x16
+	IFLA_BR_MCAST_SNOOPING                     = 0x17
+	IFLA_BR_MCAST_QUERY_USE_IFADDR             = 0x18
+	IFLA_BR_MCAST_QUERIER                      = 0x19
+	IFLA_BR_MCAST_HASH_ELASTICITY              = 0x1a
+	IFLA_BR_MCAST_HASH_MAX                     = 0x1b
+	IFLA_BR_MCAST_LAST_MEMBER_CNT              = 0x1c
+	IFLA_BR_MCAST_STARTUP_QUERY_CNT            = 0x1d
+	IFLA_BR_MCAST_LAST_MEMBER_INTVL            = 0x1e
+	IFLA_BR_MCAST_MEMBERSHIP_INTVL             = 0x1f
+	IFLA_BR_MCAST_QUERIER_INTVL                = 0x20
+	IFLA_BR_MCAST_QUERY_INTVL                  = 0x21
+	IFLA_BR_MCAST_QUERY_RESPONSE_INTVL         = 0x22
+	IFLA_BR_MCAST_STARTUP_QUERY_INTVL          = 0x23
+	IFLA_BR_NF_CALL_IPTABLES                   = 0x24
+	IFLA_BR_NF_CALL_IP6TABLES                  = 0x25
+	IFLA_BR_NF_CALL_ARPTABLES                  = 0x26
+	IFLA_BR_VLAN_DEFAULT_PVID                  = 0x27
+	IFLA_BR_PAD                                = 0x28
+	IFLA_BR_VLAN_STATS_ENABLED                 = 0x29
+	IFLA_BR_MCAST_STATS_ENABLED                = 0x2a
+	IFLA_BR_MCAST_IGMP_VERSION                 = 0x2b
+	IFLA_BR_MCAST_MLD_VERSION                  = 0x2c
+	IFLA_BR_VLAN_STATS_PER_PORT                = 0x2d
+	IFLA_BR_MULTI_BOOLOPT                      = 0x2e
+	IFLA_BRPORT_UNSPEC                         = 0x0
+	IFLA_BRPORT_STATE                          = 0x1
+	IFLA_BRPORT_PRIORITY                       = 0x2
+	IFLA_BRPORT_COST                           = 0x3
+	IFLA_BRPORT_MODE                           = 0x4
+	IFLA_BRPORT_GUARD                          = 0x5
+	IFLA_BRPORT_PROTECT                        = 0x6
+	IFLA_BRPORT_FAST_LEAVE                     = 0x7
+	IFLA_BRPORT_LEARNING                       = 0x8
+	IFLA_BRPORT_UNICAST_FLOOD                  = 0x9
+	IFLA_BRPORT_PROXYARP                       = 0xa
+	IFLA_BRPORT_LEARNING_SYNC                  = 0xb
+	IFLA_BRPORT_PROXYARP_WIFI                  = 0xc
+	IFLA_BRPORT_ROOT_ID                        = 0xd
+	IFLA_BRPORT_BRIDGE_ID                      = 0xe
+	IFLA_BRPORT_DESIGNATED_PORT                = 0xf
+	IFLA_BRPORT_DESIGNATED_COST                = 0x10
+	IFLA_BRPORT_ID                             = 0x11
+	IFLA_BRPORT_NO                             = 0x12
+	IFLA_BRPORT_TOPOLOGY_CHANGE_ACK            = 0x13
+	IFLA_BRPORT_CONFIG_PENDING                 = 0x14
+	IFLA_BRPORT_MESSAGE_AGE_TIMER              = 0x15
+	IFLA_BRPORT_FORWARD_DELAY_TIMER            = 0x16
+	IFLA_BRPORT_HOLD_TIMER                     = 0x17
+	IFLA_BRPORT_FLUSH                          = 0x18
+	IFLA_BRPORT_MULTICAST_ROUTER               = 0x19
+	IFLA_BRPORT_PAD                            = 0x1a
+	IFLA_BRPORT_MCAST_FLOOD                    = 0x1b
+	IFLA_BRPORT_MCAST_TO_UCAST                 = 0x1c
+	IFLA_BRPORT_VLAN_TUNNEL                    = 0x1d
+	IFLA_BRPORT_BCAST_FLOOD                    = 0x1e
+	IFLA_BRPORT_GROUP_FWD_MASK                 = 0x1f
+	IFLA_BRPORT_NEIGH_SUPPRESS                 = 0x20
+	IFLA_BRPORT_ISOLATED                       = 0x21
+	IFLA_BRPORT_BACKUP_PORT                    = 0x22
+	IFLA_BRPORT_MRP_RING_OPEN                  = 0x23
+	IFLA_BRPORT_MRP_IN_OPEN                    = 0x24
+	IFLA_INFO_UNSPEC                           = 0x0
+	IFLA_INFO_KIND                             = 0x1
+	IFLA_INFO_DATA                             = 0x2
+	IFLA_INFO_XSTATS                           = 0x3
+	IFLA_INFO_SLAVE_KIND                       = 0x4
+	IFLA_INFO_SLAVE_DATA                       = 0x5
+	IFLA_VLAN_UNSPEC                           = 0x0
+	IFLA_VLAN_ID                               = 0x1
+	IFLA_VLAN_FLAGS                            = 0x2
+	IFLA_VLAN_EGRESS_QOS                       = 0x3
+	IFLA_VLAN_INGRESS_QOS                      = 0x4
+	IFLA_VLAN_PROTOCOL                         = 0x5
+	IFLA_VLAN_QOS_UNSPEC                       = 0x0
+	IFLA_VLAN_QOS_MAPPING                      = 0x1
+	IFLA_MACVLAN_UNSPEC                        = 0x0
+	IFLA_MACVLAN_MODE                          = 0x1
+	IFLA_MACVLAN_FLAGS                         = 0x2
+	IFLA_MACVLAN_MACADDR_MODE                  = 0x3
+	IFLA_MACVLAN_MACADDR                       = 0x4
+	IFLA_MACVLAN_MACADDR_DATA                  = 0x5
+	IFLA_MACVLAN_MACADDR_COUNT                 = 0x6
+	IFLA_VRF_UNSPEC                            = 0x0
+	IFLA_VRF_TABLE                             = 0x1
+	IFLA_VRF_PORT_UNSPEC                       = 0x0
+	IFLA_VRF_PORT_TABLE                        = 0x1
+	IFLA_MACSEC_UNSPEC                         = 0x0
+	IFLA_MACSEC_SCI                            = 0x1
+	IFLA_MACSEC_PORT                           = 0x2
+	IFLA_MACSEC_ICV_LEN                        = 0x3
+	IFLA_MACSEC_CIPHER_SUITE                   = 0x4
+	IFLA_MACSEC_WINDOW                         = 0x5
+	IFLA_MACSEC_ENCODING_SA                    = 0x6
+	IFLA_MACSEC_ENCRYPT                        = 0x7
+	IFLA_MACSEC_PROTECT                        = 0x8
+	IFLA_MACSEC_INC_SCI                        = 0x9
+	IFLA_MACSEC_ES                             = 0xa
+	IFLA_MACSEC_SCB                            = 0xb
+	IFLA_MACSEC_REPLAY_PROTECT                 = 0xc
+	IFLA_MACSEC_VALIDATION                     = 0xd
+	IFLA_MACSEC_PAD                            = 0xe
+	IFLA_MACSEC_OFFLOAD                        = 0xf
+	IFLA_XFRM_UNSPEC                           = 0x0
+	IFLA_XFRM_LINK                             = 0x1
+	IFLA_XFRM_IF_ID                            = 0x2
+	IFLA_IPVLAN_UNSPEC                         = 0x0
+	IFLA_IPVLAN_MODE                           = 0x1
+	IFLA_IPVLAN_FLAGS                          = 0x2
+	IFLA_VXLAN_UNSPEC                          = 0x0
+	IFLA_VXLAN_ID                              = 0x1
+	IFLA_VXLAN_GROUP                           = 0x2
+	IFLA_VXLAN_LINK                            = 0x3
+	IFLA_VXLAN_LOCAL                           = 0x4
+	IFLA_VXLAN_TTL                             = 0x5
+	IFLA_VXLAN_TOS                             = 0x6
+	IFLA_VXLAN_LEARNING                        = 0x7
+	IFLA_VXLAN_AGEING                          = 0x8
+	IFLA_VXLAN_LIMIT                           = 0x9
+	IFLA_VXLAN_PORT_RANGE                      = 0xa
+	IFLA_VXLAN_PROXY                           = 0xb
+	IFLA_VXLAN_RSC                             = 0xc
+	IFLA_VXLAN_L2MISS                          = 0xd
+	IFLA_VXLAN_L3MISS                          = 0xe
+	IFLA_VXLAN_PORT                            = 0xf
+	IFLA_VXLAN_GROUP6                          = 0x10
+	IFLA_VXLAN_LOCAL6                          = 0x11
+	IFLA_VXLAN_UDP_CSUM                        = 0x12
+	IFLA_VXLAN_UDP_ZERO_CSUM6_TX               = 0x13
+	IFLA_VXLAN_UDP_ZERO_CSUM6_RX               = 0x14
+	IFLA_VXLAN_REMCSUM_TX                      = 0x15
+	IFLA_VXLAN_REMCSUM_RX                      = 0x16
+	IFLA_VXLAN_GBP                             = 0x17
+	IFLA_VXLAN_REMCSUM_NOPARTIAL               = 0x18
+	IFLA_VXLAN_COLLECT_METADATA                = 0x19
+	IFLA_VXLAN_LABEL                           = 0x1a
+	IFLA_VXLAN_GPE                             = 0x1b
+	IFLA_VXLAN_TTL_INHERIT                     = 0x1c
+	IFLA_VXLAN_DF                              = 0x1d
+	IFLA_GENEVE_UNSPEC                         = 0x0
+	IFLA_GENEVE_ID                             = 0x1
+	IFLA_GENEVE_REMOTE                         = 0x2
+	IFLA_GENEVE_TTL                            = 0x3
+	IFLA_GENEVE_TOS                            = 0x4
+	IFLA_GENEVE_PORT                           = 0x5
+	IFLA_GENEVE_COLLECT_METADATA               = 0x6
+	IFLA_GENEVE_REMOTE6                        = 0x7
+	IFLA_GENEVE_UDP_CSUM                       = 0x8
+	IFLA_GENEVE_UDP_ZERO_CSUM6_TX              = 0x9
+	IFLA_GENEVE_UDP_ZERO_CSUM6_RX              = 0xa
+	IFLA_GENEVE_LABEL                          = 0xb
+	IFLA_GENEVE_TTL_INHERIT                    = 0xc
+	IFLA_GENEVE_DF                             = 0xd
+	IFLA_BAREUDP_UNSPEC                        = 0x0
+	IFLA_BAREUDP_PORT                          = 0x1
+	IFLA_BAREUDP_ETHERTYPE                     = 0x2
+	IFLA_BAREUDP_SRCPORT_MIN                   = 0x3
+	IFLA_BAREUDP_MULTIPROTO_MODE               = 0x4
+	IFLA_PPP_UNSPEC                            = 0x0
+	IFLA_PPP_DEV_FD                            = 0x1
+	IFLA_GTP_UNSPEC                            = 0x0
+	IFLA_GTP_FD0                               = 0x1
+	IFLA_GTP_FD1                               = 0x2
+	IFLA_GTP_PDP_HASHSIZE                      = 0x3
+	IFLA_GTP_ROLE                              = 0x4
+	IFLA_BOND_UNSPEC                           = 0x0
+	IFLA_BOND_MODE                             = 0x1
+	IFLA_BOND_ACTIVE_SLAVE                     = 0x2
+	IFLA_BOND_MIIMON                           = 0x3
+	IFLA_BOND_UPDELAY                          = 0x4
+	IFLA_BOND_DOWNDELAY                        = 0x5
+	IFLA_BOND_USE_CARRIER                      = 0x6
+	IFLA_BOND_ARP_INTERVAL                     = 0x7
+	IFLA_BOND_ARP_IP_TARGET                    = 0x8
+	IFLA_BOND_ARP_VALIDATE                     = 0x9
+	IFLA_BOND_ARP_ALL_TARGETS                  = 0xa
+	IFLA_BOND_PRIMARY                          = 0xb
+	IFLA_BOND_PRIMARY_RESELECT                 = 0xc
+	IFLA_BOND_FAIL_OVER_MAC                    = 0xd
+	IFLA_BOND_XMIT_HASH_POLICY                 = 0xe
+	IFLA_BOND_RESEND_IGMP                      = 0xf
+	IFLA_BOND_NUM_PEER_NOTIF                   = 0x10
+	IFLA_BOND_ALL_SLAVES_ACTIVE                = 0x11
+	IFLA_BOND_MIN_LINKS                        = 0x12
+	IFLA_BOND_LP_INTERVAL                      = 0x13
+	IFLA_BOND_PACKETS_PER_SLAVE                = 0x14
+	IFLA_BOND_AD_LACP_RATE                     = 0x15
+	IFLA_BOND_AD_SELECT                        = 0x16
+	IFLA_BOND_AD_INFO                          = 0x17
+	IFLA_BOND_AD_ACTOR_SYS_PRIO                = 0x18
+	IFLA_BOND_AD_USER_PORT_KEY                 = 0x19
+	IFLA_BOND_AD_ACTOR_SYSTEM                  = 0x1a
+	IFLA_BOND_TLB_DYNAMIC_LB                   = 0x1b
+	IFLA_BOND_PEER_NOTIF_DELAY                 = 0x1c
+	IFLA_BOND_AD_INFO_UNSPEC                   = 0x0
+	IFLA_BOND_AD_INFO_AGGREGATOR               = 0x1
+	IFLA_BOND_AD_INFO_NUM_PORTS                = 0x2
+	IFLA_BOND_AD_INFO_ACTOR_KEY                = 0x3
+	IFLA_BOND_AD_INFO_PARTNER_KEY              = 0x4
+	IFLA_BOND_AD_INFO_PARTNER_MAC              = 0x5
+	IFLA_BOND_SLAVE_UNSPEC                     = 0x0
+	IFLA_BOND_SLAVE_STATE                      = 0x1
+	IFLA_BOND_SLAVE_MII_STATUS                 = 0x2
+	IFLA_BOND_SLAVE_LINK_FAILURE_COUNT         = 0x3
+	IFLA_BOND_SLAVE_PERM_HWADDR                = 0x4
+	IFLA_BOND_SLAVE_QUEUE_ID                   = 0x5
+	IFLA_BOND_SLAVE_AD_AGGREGATOR_ID           = 0x6
+	IFLA_BOND_SLAVE_AD_ACTOR_OPER_PORT_STATE   = 0x7
+	IFLA_BOND_SLAVE_AD_PARTNER_OPER_PORT_STATE = 0x8
+	IFLA_VF_INFO_UNSPEC                        = 0x0
+	IFLA_VF_INFO                               = 0x1
+	IFLA_VF_UNSPEC                             = 0x0
+	IFLA_VF_MAC                                = 0x1
+	IFLA_VF_VLAN                               = 0x2
+	IFLA_VF_TX_RATE                            = 0x3
+	IFLA_VF_SPOOFCHK                           = 0x4
+	IFLA_VF_LINK_STATE                         = 0x5
+	IFLA_VF_RATE                               = 0x6
+	IFLA_VF_RSS_QUERY_EN                       = 0x7
+	IFLA_VF_STATS                              = 0x8
+	IFLA_VF_TRUST                              = 0x9
+	IFLA_VF_IB_NODE_GUID                       = 0xa
+	IFLA_VF_IB_PORT_GUID                       = 0xb
+	IFLA_VF_VLAN_LIST                          = 0xc
+	IFLA_VF_BROADCAST                          = 0xd
+	IFLA_VF_VLAN_INFO_UNSPEC                   = 0x0
+	IFLA_VF_VLAN_INFO                          = 0x1
+	IFLA_VF_LINK_STATE_AUTO                    = 0x0
+	IFLA_VF_LINK_STATE_ENABLE                  = 0x1
+	IFLA_VF_LINK_STATE_DISABLE                 = 0x2
+	IFLA_VF_STATS_RX_PACKETS                   = 0x0
+	IFLA_VF_STATS_TX_PACKETS                   = 0x1
+	IFLA_VF_STATS_RX_BYTES                     = 0x2
+	IFLA_VF_STATS_TX_BYTES                     = 0x3
+	IFLA_VF_STATS_BROADCAST                    = 0x4
+	IFLA_VF_STATS_MULTICAST                    = 0x5
+	IFLA_VF_STATS_PAD                          = 0x6
+	IFLA_VF_STATS_RX_DROPPED                   = 0x7
+	IFLA_VF_STATS_TX_DROPPED                   = 0x8
+	IFLA_VF_PORT_UNSPEC                        = 0x0
+	IFLA_VF_PORT                               = 0x1
+	IFLA_PORT_UNSPEC                           = 0x0
+	IFLA_PORT_VF                               = 0x1
+	IFLA_PORT_PROFILE                          = 0x2
+	IFLA_PORT_VSI_TYPE                         = 0x3
+	IFLA_PORT_INSTANCE_UUID                    = 0x4
+	IFLA_PORT_HOST_UUID                        = 0x5
+	IFLA_PORT_REQUEST                          = 0x6
+	IFLA_PORT_RESPONSE                         = 0x7
+	IFLA_IPOIB_UNSPEC                          = 0x0
+	IFLA_IPOIB_PKEY                            = 0x1
+	IFLA_IPOIB_MODE                            = 0x2
+	IFLA_IPOIB_UMCAST                          = 0x3
+	IFLA_HSR_UNSPEC                            = 0x0
+	IFLA_HSR_SLAVE1                            = 0x1
+	IFLA_HSR_SLAVE2                            = 0x2
+	IFLA_HSR_MULTICAST_SPEC                    = 0x3
+	IFLA_HSR_SUPERVISION_ADDR                  = 0x4
+	IFLA_HSR_SEQ_NR                            = 0x5
+	IFLA_HSR_VERSION                           = 0x6
+	IFLA_HSR_PROTOCOL                          = 0x7
+	IFLA_STATS_UNSPEC                          = 0x0
+	IFLA_STATS_LINK_64                         = 0x1
+	IFLA_STATS_LINK_XSTATS                     = 0x2
+	IFLA_STATS_LINK_XSTATS_SLAVE               = 0x3
+	IFLA_STATS_LINK_OFFLOAD_XSTATS             = 0x4
+	IFLA_STATS_AF_SPEC                         = 0x5
+	IFLA_OFFLOAD_XSTATS_UNSPEC                 = 0x0
+	IFLA_OFFLOAD_XSTATS_CPU_HIT                = 0x1
+	IFLA_XDP_UNSPEC                            = 0x0
+	IFLA_XDP_FD                                = 0x1
+	IFLA_XDP_ATTACHED                          = 0x2
+	IFLA_XDP_FLAGS                             = 0x3
+	IFLA_XDP_PROG_ID                           = 0x4
+	IFLA_XDP_DRV_PROG_ID                       = 0x5
+	IFLA_XDP_SKB_PROG_ID                       = 0x6
+	IFLA_XDP_HW_PROG_ID                        = 0x7
+	IFLA_XDP_EXPECTED_FD                       = 0x8
+	IFLA_EVENT_NONE                            = 0x0
+	IFLA_EVENT_REBOOT                          = 0x1
+	IFLA_EVENT_FEATURES                        = 0x2
+	IFLA_EVENT_BONDING_FAILOVER                = 0x3
+	IFLA_EVENT_NOTIFY_PEERS                    = 0x4
+	IFLA_EVENT_IGMP_RESEND                     = 0x5
+	IFLA_EVENT_BONDING_OPTIONS                 = 0x6
+	IFLA_TUN_UNSPEC                            = 0x0
+	IFLA_TUN_OWNER                             = 0x1
+	IFLA_TUN_GROUP                             = 0x2
+	IFLA_TUN_TYPE                              = 0x3
+	IFLA_TUN_PI                                = 0x4
+	IFLA_TUN_VNET_HDR                          = 0x5
+	IFLA_TUN_PERSIST                           = 0x6
+	IFLA_TUN_MULTI_QUEUE                       = 0x7
+	IFLA_TUN_NUM_QUEUES                        = 0x8
+	IFLA_TUN_NUM_DISABLED_QUEUES               = 0x9
+	IFLA_RMNET_UNSPEC                          = 0x0
+	IFLA_RMNET_MUX_ID                          = 0x1
+	IFLA_RMNET_FLAGS                           = 0x2
+)
+
+const (
+	NF_INET_PRE_ROUTING  = 0x0
+	NF_INET_LOCAL_IN     = 0x1
+	NF_INET_FORWARD      = 0x2
+	NF_INET_LOCAL_OUT    = 0x3
+	NF_INET_POST_ROUTING = 0x4
+	NF_INET_NUMHOOKS     = 0x5
+)
+
+const (
+	NF_NETDEV_INGRESS = 0x0
+
+	NF_NETDEV_NUMHOOKS = 0x2
+)
+
+const (
+	NFPROTO_UNSPEC   = 0x0
+	NFPROTO_INET     = 0x1
+	NFPROTO_IPV4     = 0x2
+	NFPROTO_ARP      = 0x3
+	NFPROTO_NETDEV   = 0x5
+	NFPROTO_BRIDGE   = 0x7
+	NFPROTO_IPV6     = 0xa
+	NFPROTO_DECNET   = 0xc
+	NFPROTO_NUMPROTO = 0xd
+)
+
+const SO_ORIGINAL_DST = 0x50
+
+type Nfgenmsg struct {
+	Nfgen_family uint8
+	Version      uint8
+	Res_id       uint16
+}
+
+const (
+	NFNL_BATCH_UNSPEC = 0x0
+	NFNL_BATCH_GENID  = 0x1
+)
+
+const (
+	NFT_REG_VERDICT                   = 0x0
+	NFT_REG_1                         = 0x1
+	NFT_REG_2                         = 0x2
+	NFT_REG_3                         = 0x3
+	NFT_REG_4                         = 0x4
+	NFT_REG32_00                      = 0x8
+	NFT_REG32_01                      = 0x9
+	NFT_REG32_02                      = 0xa
+	NFT_REG32_03                      = 0xb
+	NFT_REG32_04                      = 0xc
+	NFT_REG32_05                      = 0xd
+	NFT_REG32_06                      = 0xe
+	NFT_REG32_07                      = 0xf
+	NFT_REG32_08                      = 0x10
+	NFT_REG32_09                      = 0x11
+	NFT_REG32_10                      = 0x12
+	NFT_REG32_11                      = 0x13
+	NFT_REG32_12                      = 0x14
+	NFT_REG32_13                      = 0x15
+	NFT_REG32_14                      = 0x16
+	NFT_REG32_15                      = 0x17
+	NFT_CONTINUE                      = -0x1
+	NFT_BREAK                         = -0x2
+	NFT_JUMP                          = -0x3
+	NFT_GOTO                          = -0x4
+	NFT_RETURN                        = -0x5
+	NFT_MSG_NEWTABLE                  = 0x0
+	NFT_MSG_GETTABLE                  = 0x1
+	NFT_MSG_DELTABLE                  = 0x2
+	NFT_MSG_NEWCHAIN                  = 0x3
+	NFT_MSG_GETCHAIN                  = 0x4
+	NFT_MSG_DELCHAIN                  = 0x5
+	NFT_MSG_NEWRULE                   = 0x6
+	NFT_MSG_GETRULE                   = 0x7
+	NFT_MSG_DELRULE                   = 0x8
+	NFT_MSG_NEWSET                    = 0x9
+	NFT_MSG_GETSET                    = 0xa
+	NFT_MSG_DELSET                    = 0xb
+	NFT_MSG_NEWSETELEM                = 0xc
+	NFT_MSG_GETSETELEM                = 0xd
+	NFT_MSG_DELSETELEM                = 0xe
+	NFT_MSG_NEWGEN                    = 0xf
+	NFT_MSG_GETGEN                    = 0x10
+	NFT_MSG_TRACE                     = 0x11
+	NFT_MSG_NEWOBJ                    = 0x12
+	NFT_MSG_GETOBJ                    = 0x13
+	NFT_MSG_DELOBJ                    = 0x14
+	NFT_MSG_GETOBJ_RESET              = 0x15
+	NFT_MSG_NEWFLOWTABLE              = 0x16
+	NFT_MSG_GETFLOWTABLE              = 0x17
+	NFT_MSG_DELFLOWTABLE              = 0x18
+	NFT_MSG_GETRULE_RESET             = 0x19
+	NFT_MSG_MAX                       = 0x22
+	NFTA_LIST_UNSPEC                  = 0x0
+	NFTA_LIST_ELEM                    = 0x1
+	NFTA_HOOK_UNSPEC                  = 0x0
+	NFTA_HOOK_HOOKNUM                 = 0x1
+	NFTA_HOOK_PRIORITY                = 0x2
+	NFTA_HOOK_DEV                     = 0x3
+	NFT_TABLE_F_DORMANT               = 0x1
+	NFTA_TABLE_UNSPEC                 = 0x0
+	NFTA_TABLE_NAME                   = 0x1
+	NFTA_TABLE_FLAGS                  = 0x2
+	NFTA_TABLE_USE                    = 0x3
+	NFTA_CHAIN_UNSPEC                 = 0x0
+	NFTA_CHAIN_TABLE                  = 0x1
+	NFTA_CHAIN_HANDLE                 = 0x2
+	NFTA_CHAIN_NAME                   = 0x3
+	NFTA_CHAIN_HOOK                   = 0x4
+	NFTA_CHAIN_POLICY                 = 0x5
+	NFTA_CHAIN_USE                    = 0x6
+	NFTA_CHAIN_TYPE                   = 0x7
+	NFTA_CHAIN_COUNTERS               = 0x8
+	NFTA_CHAIN_PAD                    = 0x9
+	NFTA_RULE_UNSPEC                  = 0x0
+	NFTA_RULE_TABLE                   = 0x1
+	NFTA_RULE_CHAIN                   = 0x2
+	NFTA_RULE_HANDLE                  = 0x3
+	NFTA_RULE_EXPRESSIONS             = 0x4
+	NFTA_RULE_COMPAT                  = 0x5
+	NFTA_RULE_POSITION                = 0x6
+	NFTA_RULE_USERDATA                = 0x7
+	NFTA_RULE_PAD                     = 0x8
+	NFTA_RULE_ID                      = 0x9
+	NFT_RULE_COMPAT_F_INV             = 0x2
+	NFT_RULE_COMPAT_F_MASK            = 0x2
+	NFTA_RULE_COMPAT_UNSPEC           = 0x0
+	NFTA_RULE_COMPAT_PROTO            = 0x1
+	NFTA_RULE_COMPAT_FLAGS            = 0x2
+	NFT_SET_ANONYMOUS                 = 0x1
+	NFT_SET_CONSTANT                  = 0x2
+	NFT_SET_INTERVAL                  = 0x4
+	NFT_SET_MAP                       = 0x8
+	NFT_SET_TIMEOUT                   = 0x10
+	NFT_SET_EVAL                      = 0x20
+	NFT_SET_OBJECT                    = 0x40
+	NFT_SET_POL_PERFORMANCE           = 0x0
+	NFT_SET_POL_MEMORY                = 0x1
+	NFTA_SET_DESC_UNSPEC              = 0x0
+	NFTA_SET_DESC_SIZE                = 0x1
+	NFTA_SET_UNSPEC                   = 0x0
+	NFTA_SET_TABLE                    = 0x1
+	NFTA_SET_NAME                     = 0x2
+	NFTA_SET_FLAGS                    = 0x3
+	NFTA_SET_KEY_TYPE                 = 0x4
+	NFTA_SET_KEY_LEN                  = 0x5
+	NFTA_SET_DATA_TYPE                = 0x6
+	NFTA_SET_DATA_LEN                 = 0x7
+	NFTA_SET_POLICY                   = 0x8
+	NFTA_SET_DESC                     = 0x9
+	NFTA_SET_ID                       = 0xa
+	NFTA_SET_TIMEOUT                  = 0xb
+	NFTA_SET_GC_INTERVAL              = 0xc
+	NFTA_SET_USERDATA                 = 0xd
+	NFTA_SET_PAD                      = 0xe
+	NFTA_SET_OBJ_TYPE                 = 0xf
+	NFT_SET_ELEM_INTERVAL_END         = 0x1
+	NFTA_SET_ELEM_UNSPEC              = 0x0
+	NFTA_SET_ELEM_KEY                 = 0x1
+	NFTA_SET_ELEM_DATA                = 0x2
+	NFTA_SET_ELEM_FLAGS               = 0x3
+	NFTA_SET_ELEM_TIMEOUT             = 0x4
+	NFTA_SET_ELEM_EXPIRATION          = 0x5
+	NFTA_SET_ELEM_USERDATA            = 0x6
+	NFTA_SET_ELEM_EXPR                = 0x7
+	NFTA_SET_ELEM_PAD                 = 0x8
+	NFTA_SET_ELEM_OBJREF              = 0x9
+	NFTA_SET_ELEM_LIST_UNSPEC         = 0x0
+	NFTA_SET_ELEM_LIST_TABLE          = 0x1
+	NFTA_SET_ELEM_LIST_SET            = 0x2
+	NFTA_SET_ELEM_LIST_ELEMENTS       = 0x3
+	NFTA_SET_ELEM_LIST_SET_ID         = 0x4
+	NFT_DATA_VALUE                    = 0x0
+	NFT_DATA_VERDICT                  = 0xffffff00
+	NFTA_DATA_UNSPEC                  = 0x0
+	NFTA_DATA_VALUE                   = 0x1
+	NFTA_DATA_VERDICT                 = 0x2
+	NFTA_VERDICT_UNSPEC               = 0x0
+	NFTA_VERDICT_CODE                 = 0x1
+	NFTA_VERDICT_CHAIN                = 0x2
+	NFTA_EXPR_UNSPEC                  = 0x0
+	NFTA_EXPR_NAME                    = 0x1
+	NFTA_EXPR_DATA                    = 0x2
+	NFTA_IMMEDIATE_UNSPEC             = 0x0
+	NFTA_IMMEDIATE_DREG               = 0x1
+	NFTA_IMMEDIATE_DATA               = 0x2
+	NFTA_BITWISE_UNSPEC               = 0x0
+	NFTA_BITWISE_SREG                 = 0x1
+	NFTA_BITWISE_DREG                 = 0x2
+	NFTA_BITWISE_LEN                  = 0x3
+	NFTA_BITWISE_MASK                 = 0x4
+	NFTA_BITWISE_XOR                  = 0x5
+	NFT_BYTEORDER_NTOH                = 0x0
+	NFT_BYTEORDER_HTON                = 0x1
+	NFTA_BYTEORDER_UNSPEC             = 0x0
+	NFTA_BYTEORDER_SREG               = 0x1
+	NFTA_BYTEORDER_DREG               = 0x2
+	NFTA_BYTEORDER_OP                 = 0x3
+	NFTA_BYTEORDER_LEN                = 0x4
+	NFTA_BYTEORDER_SIZE               = 0x5
+	NFT_CMP_EQ                        = 0x0
+	NFT_CMP_NEQ                       = 0x1
+	NFT_CMP_LT                        = 0x2
+	NFT_CMP_LTE                       = 0x3
+	NFT_CMP_GT                        = 0x4
+	NFT_CMP_GTE                       = 0x5
+	NFTA_CMP_UNSPEC                   = 0x0
+	NFTA_CMP_SREG                     = 0x1
+	NFTA_CMP_OP                       = 0x2
+	NFTA_CMP_DATA                     = 0x3
+	NFT_RANGE_EQ                      = 0x0
+	NFT_RANGE_NEQ                     = 0x1
+	NFTA_RANGE_UNSPEC                 = 0x0
+	NFTA_RANGE_SREG                   = 0x1
+	NFTA_RANGE_OP                     = 0x2
+	NFTA_RANGE_FROM_DATA              = 0x3
+	NFTA_RANGE_TO_DATA                = 0x4
+	NFT_LOOKUP_F_INV                  = 0x1
+	NFTA_LOOKUP_UNSPEC                = 0x0
+	NFTA_LOOKUP_SET                   = 0x1
+	NFTA_LOOKUP_SREG                  = 0x2
+	NFTA_LOOKUP_DREG                  = 0x3
+	NFTA_LOOKUP_SET_ID                = 0x4
+	NFTA_LOOKUP_FLAGS                 = 0x5
+	NFT_DYNSET_OP_ADD                 = 0x0
+	NFT_DYNSET_OP_UPDATE              = 0x1
+	NFT_DYNSET_F_INV                  = 0x1
+	NFTA_DYNSET_UNSPEC                = 0x0
+	NFTA_DYNSET_SET_NAME              = 0x1
+	NFTA_DYNSET_SET_ID                = 0x2
+	NFTA_DYNSET_OP                    = 0x3
+	NFTA_DYNSET_SREG_KEY              = 0x4
+	NFTA_DYNSET_SREG_DATA             = 0x5
+	NFTA_DYNSET_TIMEOUT               = 0x6
+	NFTA_DYNSET_EXPR                  = 0x7
+	NFTA_DYNSET_PAD                   = 0x8
+	NFTA_DYNSET_FLAGS                 = 0x9
+	NFT_PAYLOAD_LL_HEADER             = 0x0
+	NFT_PAYLOAD_NETWORK_HEADER        = 0x1
+	NFT_PAYLOAD_TRANSPORT_HEADER      = 0x2
+	NFT_PAYLOAD_CSUM_NONE             = 0x0
+	NFT_PAYLOAD_CSUM_INET             = 0x1
+	NFT_PAYLOAD_L4CSUM_PSEUDOHDR      = 0x1
+	NFTA_PAYLOAD_UNSPEC               = 0x0
+	NFTA_PAYLOAD_DREG                 = 0x1
+	NFTA_PAYLOAD_BASE                 = 0x2
+	NFTA_PAYLOAD_OFFSET               = 0x3
+	NFTA_PAYLOAD_LEN                  = 0x4
+	NFTA_PAYLOAD_SREG                 = 0x5
+	NFTA_PAYLOAD_CSUM_TYPE            = 0x6
+	NFTA_PAYLOAD_CSUM_OFFSET          = 0x7
+	NFTA_PAYLOAD_CSUM_FLAGS           = 0x8
+	NFT_EXTHDR_F_PRESENT              = 0x1
+	NFT_EXTHDR_OP_IPV6                = 0x0
+	NFT_EXTHDR_OP_TCPOPT              = 0x1
+	NFTA_EXTHDR_UNSPEC                = 0x0
+	NFTA_EXTHDR_DREG                  = 0x1
+	NFTA_EXTHDR_TYPE                  = 0x2
+	NFTA_EXTHDR_OFFSET                = 0x3
+	NFTA_EXTHDR_LEN                   = 0x4
+	NFTA_EXTHDR_FLAGS                 = 0x5
+	NFTA_EXTHDR_OP                    = 0x6
+	NFTA_EXTHDR_SREG                  = 0x7
+	NFT_META_LEN                      = 0x0
+	NFT_META_PROTOCOL                 = 0x1
+	NFT_META_PRIORITY                 = 0x2
+	NFT_META_MARK                     = 0x3
+	NFT_META_IIF                      = 0x4
+	NFT_META_OIF                      = 0x5
+	NFT_META_IIFNAME                  = 0x6
+	NFT_META_OIFNAME                  = 0x7
+	NFT_META_IIFTYPE                  = 0x8
+	NFT_META_OIFTYPE                  = 0x9
+	NFT_META_SKUID                    = 0xa
+	NFT_META_SKGID                    = 0xb
+	NFT_META_NFTRACE                  = 0xc
+	NFT_META_RTCLASSID                = 0xd
+	NFT_META_SECMARK                  = 0xe
+	NFT_META_NFPROTO                  = 0xf
+	NFT_META_L4PROTO                  = 0x10
+	NFT_META_BRI_IIFNAME              = 0x11
+	NFT_META_BRI_OIFNAME              = 0x12
+	NFT_META_PKTTYPE                  = 0x13
+	NFT_META_CPU                      = 0x14
+	NFT_META_IIFGROUP                 = 0x15
+	NFT_META_OIFGROUP                 = 0x16
+	NFT_META_CGROUP                   = 0x17
+	NFT_META_PRANDOM                  = 0x18
+	NFT_RT_CLASSID                    = 0x0
+	NFT_RT_NEXTHOP4                   = 0x1
+	NFT_RT_NEXTHOP6                   = 0x2
+	NFT_RT_TCPMSS                     = 0x3
+	NFT_HASH_JENKINS                  = 0x0
+	NFT_HASH_SYM                      = 0x1
+	NFTA_HASH_UNSPEC                  = 0x0
+	NFTA_HASH_SREG                    = 0x1
+	NFTA_HASH_DREG                    = 0x2
+	NFTA_HASH_LEN                     = 0x3
+	NFTA_HASH_MODULUS                 = 0x4
+	NFTA_HASH_SEED                    = 0x5
+	NFTA_HASH_OFFSET                  = 0x6
+	NFTA_HASH_TYPE                    = 0x7
+	NFTA_META_UNSPEC                  = 0x0
+	NFTA_META_DREG                    = 0x1
+	NFTA_META_KEY                     = 0x2
+	NFTA_META_SREG                    = 0x3
+	NFTA_RT_UNSPEC                    = 0x0
+	NFTA_RT_DREG                      = 0x1
+	NFTA_RT_KEY                       = 0x2
+	NFT_CT_STATE                      = 0x0
+	NFT_CT_DIRECTION                  = 0x1
+	NFT_CT_STATUS                     = 0x2
+	NFT_CT_MARK                       = 0x3
+	NFT_CT_SECMARK                    = 0x4
+	NFT_CT_EXPIRATION                 = 0x5
+	NFT_CT_HELPER                     = 0x6
+	NFT_CT_L3PROTOCOL                 = 0x7
+	NFT_CT_SRC                        = 0x8
+	NFT_CT_DST                        = 0x9
+	NFT_CT_PROTOCOL                   = 0xa
+	NFT_CT_PROTO_SRC                  = 0xb
+	NFT_CT_PROTO_DST                  = 0xc
+	NFT_CT_LABELS                     = 0xd
+	NFT_CT_PKTS                       = 0xe
+	NFT_CT_BYTES                      = 0xf
+	NFT_CT_AVGPKT                     = 0x10
+	NFT_CT_ZONE                       = 0x11
+	NFT_CT_EVENTMASK                  = 0x12
+	NFTA_CT_UNSPEC                    = 0x0
+	NFTA_CT_DREG                      = 0x1
+	NFTA_CT_KEY                       = 0x2
+	NFTA_CT_DIRECTION                 = 0x3
+	NFTA_CT_SREG                      = 0x4
+	NFT_LIMIT_PKTS                    = 0x0
+	NFT_LIMIT_PKT_BYTES               = 0x1
+	NFT_LIMIT_F_INV                   = 0x1
+	NFTA_LIMIT_UNSPEC                 = 0x0
+	NFTA_LIMIT_RATE                   = 0x1
+	NFTA_LIMIT_UNIT                   = 0x2
+	NFTA_LIMIT_BURST                  = 0x3
+	NFTA_LIMIT_TYPE                   = 0x4
+	NFTA_LIMIT_FLAGS                  = 0x5
+	NFTA_LIMIT_PAD                    = 0x6
+	NFTA_COUNTER_UNSPEC               = 0x0
+	NFTA_COUNTER_BYTES                = 0x1
+	NFTA_COUNTER_PACKETS              = 0x2
+	NFTA_COUNTER_PAD                  = 0x3
+	NFTA_LOG_UNSPEC                   = 0x0
+	NFTA_LOG_GROUP                    = 0x1
+	NFTA_LOG_PREFIX                   = 0x2
+	NFTA_LOG_SNAPLEN                  = 0x3
+	NFTA_LOG_QTHRESHOLD               = 0x4
+	NFTA_LOG_LEVEL                    = 0x5
+	NFTA_LOG_FLAGS                    = 0x6
+	NFTA_QUEUE_UNSPEC                 = 0x0
+	NFTA_QUEUE_NUM                    = 0x1
+	NFTA_QUEUE_TOTAL                  = 0x2
+	NFTA_QUEUE_FLAGS                  = 0x3
+	NFTA_QUEUE_SREG_QNUM              = 0x4
+	NFT_QUOTA_F_INV                   = 0x1
+	NFT_QUOTA_F_DEPLETED              = 0x2
+	NFTA_QUOTA_UNSPEC                 = 0x0
+	NFTA_QUOTA_BYTES                  = 0x1
+	NFTA_QUOTA_FLAGS                  = 0x2
+	NFTA_QUOTA_PAD                    = 0x3
+	NFTA_QUOTA_CONSUMED               = 0x4
+	NFT_REJECT_ICMP_UNREACH           = 0x0
+	NFT_REJECT_TCP_RST                = 0x1
+	NFT_REJECT_ICMPX_UNREACH          = 0x2
+	NFT_REJECT_ICMPX_NO_ROUTE         = 0x0
+	NFT_REJECT_ICMPX_PORT_UNREACH     = 0x1
+	NFT_REJECT_ICMPX_HOST_UNREACH     = 0x2
+	NFT_REJECT_ICMPX_ADMIN_PROHIBITED = 0x3
+	NFTA_REJECT_UNSPEC                = 0x0
+	NFTA_REJECT_TYPE                  = 0x1
+	NFTA_REJECT_ICMP_CODE             = 0x2
+	NFT_NAT_SNAT                      = 0x0
+	NFT_NAT_DNAT                      = 0x1
+	NFTA_NAT_UNSPEC                   = 0x0
+	NFTA_NAT_TYPE                     = 0x1
+	NFTA_NAT_FAMILY                   = 0x2
+	NFTA_NAT_REG_ADDR_MIN             = 0x3
+	NFTA_NAT_REG_ADDR_MAX             = 0x4
+	NFTA_NAT_REG_PROTO_MIN            = 0x5
+	NFTA_NAT_REG_PROTO_MAX            = 0x6
+	NFTA_NAT_FLAGS                    = 0x7
+	NFTA_MASQ_UNSPEC                  = 0x0
+	NFTA_MASQ_FLAGS                   = 0x1
+	NFTA_MASQ_REG_PROTO_MIN           = 0x2
+	NFTA_MASQ_REG_PROTO_MAX           = 0x3
+	NFTA_REDIR_UNSPEC                 = 0x0
+	NFTA_REDIR_REG_PROTO_MIN          = 0x1
+	NFTA_REDIR_REG_PROTO_MAX          = 0x2
+	NFTA_REDIR_FLAGS                  = 0x3
+	NFTA_DUP_UNSPEC                   = 0x0
+	NFTA_DUP_SREG_ADDR                = 0x1
+	NFTA_DUP_SREG_DEV                 = 0x2
+	NFTA_FWD_UNSPEC                   = 0x0
+	NFTA_FWD_SREG_DEV                 = 0x1
+	NFTA_OBJREF_UNSPEC                = 0x0
+	NFTA_OBJREF_IMM_TYPE              = 0x1
+	NFTA_OBJREF_IMM_NAME              = 0x2
+	NFTA_OBJREF_SET_SREG              = 0x3
+	NFTA_OBJREF_SET_NAME              = 0x4
+	NFTA_OBJREF_SET_ID                = 0x5
+	NFTA_GEN_UNSPEC                   = 0x0
+	NFTA_GEN_ID                       = 0x1
+	NFTA_GEN_PROC_PID                 = 0x2
+	NFTA_GEN_PROC_NAME                = 0x3
+	NFTA_FIB_UNSPEC                   = 0x0
+	NFTA_FIB_DREG                     = 0x1
+	NFTA_FIB_RESULT                   = 0x2
+	NFTA_FIB_FLAGS                    = 0x3
+	NFT_FIB_RESULT_UNSPEC             = 0x0
+	NFT_FIB_RESULT_OIF                = 0x1
+	NFT_FIB_RESULT_OIFNAME            = 0x2
+	NFT_FIB_RESULT_ADDRTYPE           = 0x3
+	NFTA_FIB_F_SADDR                  = 0x1
+	NFTA_FIB_F_DADDR                  = 0x2
+	NFTA_FIB_F_MARK                   = 0x4
+	NFTA_FIB_F_IIF                    = 0x8
+	NFTA_FIB_F_OIF                    = 0x10
+	NFTA_FIB_F_PRESENT                = 0x20
+	NFTA_CT_HELPER_UNSPEC             = 0x0
+	NFTA_CT_HELPER_NAME               = 0x1
+	NFTA_CT_HELPER_L3PROTO            = 0x2
+	NFTA_CT_HELPER_L4PROTO            = 0x3
+	NFTA_OBJ_UNSPEC                   = 0x0
+	NFTA_OBJ_TABLE                    = 0x1
+	NFTA_OBJ_NAME                     = 0x2
+	NFTA_OBJ_TYPE                     = 0x3
+	NFTA_OBJ_DATA                     = 0x4
+	NFTA_OBJ_USE                      = 0x5
+	NFTA_TRACE_UNSPEC                 = 0x0
+	NFTA_TRACE_TABLE                  = 0x1
+	NFTA_TRACE_CHAIN                  = 0x2
+	NFTA_TRACE_RULE_HANDLE            = 0x3
+	NFTA_TRACE_TYPE                   = 0x4
+	NFTA_TRACE_VERDICT                = 0x5
+	NFTA_TRACE_ID                     = 0x6
+	NFTA_TRACE_LL_HEADER              = 0x7
+	NFTA_TRACE_NETWORK_HEADER         = 0x8
+	NFTA_TRACE_TRANSPORT_HEADER       = 0x9
+	NFTA_TRACE_IIF                    = 0xa
+	NFTA_TRACE_IIFTYPE                = 0xb
+	NFTA_TRACE_OIF                    = 0xc
+	NFTA_TRACE_OIFTYPE                = 0xd
+	NFTA_TRACE_MARK                   = 0xe
+	NFTA_TRACE_NFPROTO                = 0xf
+	NFTA_TRACE_POLICY                 = 0x10
+	NFTA_TRACE_PAD                    = 0x11
+	NFT_TRACETYPE_UNSPEC              = 0x0
+	NFT_TRACETYPE_POLICY              = 0x1
+	NFT_TRACETYPE_RETURN              = 0x2
+	NFT_TRACETYPE_RULE                = 0x3
+	NFTA_NG_UNSPEC                    = 0x0
+	NFTA_NG_DREG                      = 0x1
+	NFTA_NG_MODULUS                   = 0x2
+	NFTA_NG_TYPE                      = 0x3
+	NFTA_NG_OFFSET                    = 0x4
+	NFT_NG_INCREMENTAL                = 0x0
+	NFT_NG_RANDOM                     = 0x1
+)
+
+const (
+	NFTA_TARGET_UNSPEC = 0x0
+	NFTA_TARGET_NAME   = 0x1
+	NFTA_TARGET_REV    = 0x2
+	NFTA_TARGET_INFO   = 0x3
+	NFTA_MATCH_UNSPEC  = 0x0
+	NFTA_MATCH_NAME    = 0x1
+	NFTA_MATCH_REV     = 0x2
+	NFTA_MATCH_INFO    = 0x3
+	NFTA_COMPAT_UNSPEC = 0x0
+	NFTA_COMPAT_NAME   = 0x1
+	NFTA_COMPAT_REV    = 0x2
+	NFTA_COMPAT_TYPE   = 0x3
+)
+
+type RTCTime struct {
+	Sec   int32
+	Min   int32
+	Hour  int32
+	Mday  int32
+	Mon   int32
+	Year  int32
+	Wday  int32
+	Yday  int32
+	Isdst int32
+}
+
+type RTCWkAlrm struct {
+	Enabled uint8
+	Pending uint8
+	Time    RTCTime
+}
+
+type RTCPLLInfo struct {
+	Ctrl    int32
+	Value   int32
+	Max     int32
+	Min     int32
+	Posmult int32
+	Negmult int32
+	Clock   int64
+}
+
+type BlkpgIoctlArg struct {
+	Op      int32
+	Flags   int32
+	Datalen int32
+	Data    *byte
+}
+
+type BlkpgPartition struct {
+	Start   int64
+	Length  int64
+	Pno     int32
+	Devname [64]uint8
+	Volname [64]uint8
+	_       [4]byte
+}
+
+const (
+	BLKPG                  = 0x20001269
+	BLKPG_ADD_PARTITION    = 0x1
+	BLKPG_DEL_PARTITION    = 0x2
+	BLKPG_RESIZE_PARTITION = 0x3
+)
+
+const (
+	NETNSA_NONE         = 0x0
+	NETNSA_NSID         = 0x1
+	NETNSA_PID          = 0x2
+	NETNSA_FD           = 0x3
+	NETNSA_TARGET_NSID  = 0x4
+	NETNSA_CURRENT_NSID = 0x5
+)
+
+type XDPRingOffset struct {
+	Producer uint64
+	Consumer uint64
+	Desc     uint64
+	Flags    uint64
+}
+
+type XDPMmapOffsets struct {
+	Rx XDPRingOffset
+	Tx XDPRingOffset
+	Fr XDPRingOffset
+	Cr XDPRingOffset
+}
+
+type XDPUmemReg struct {
+	Addr     uint64
+	Len      uint64
+	Size     uint32
+	Headroom uint32
+	Flags    uint32
+	_        [4]byte
+}
+
+type XDPStatistics struct {
+	Rx_dropped               uint64
+	Rx_invalid_descs         uint64
+	Tx_invalid_descs         uint64
+	Rx_ring_full             uint64
+	Rx_fill_ring_empty_descs uint64
+	Tx_ring_empty_descs      uint64
+}
+
+type XDPDesc struct {
+	Addr    uint64
+	Len     uint32
+	Options uint32
+}
+
+const (
+	NCSI_CMD_UNSPEC                 = 0x0
+	NCSI_CMD_PKG_INFO               = 0x1
+	NCSI_CMD_SET_INTERFACE          = 0x2
+	NCSI_CMD_CLEAR_INTERFACE        = 0x3
+	NCSI_ATTR_UNSPEC                = 0x0
+	NCSI_ATTR_IFINDEX               = 0x1
+	NCSI_ATTR_PACKAGE_LIST          = 0x2
+	NCSI_ATTR_PACKAGE_ID            = 0x3
+	NCSI_ATTR_CHANNEL_ID            = 0x4
+	NCSI_PKG_ATTR_UNSPEC            = 0x0
+	NCSI_PKG_ATTR                   = 0x1
+	NCSI_PKG_ATTR_ID                = 0x2
+	NCSI_PKG_ATTR_FORCED            = 0x3
+	NCSI_PKG_ATTR_CHANNEL_LIST      = 0x4
+	NCSI_CHANNEL_ATTR_UNSPEC        = 0x0
+	NCSI_CHANNEL_ATTR               = 0x1
+	NCSI_CHANNEL_ATTR_ID            = 0x2
+	NCSI_CHANNEL_ATTR_VERSION_MAJOR = 0x3
+	NCSI_CHANNEL_ATTR_VERSION_MINOR = 0x4
+	NCSI_CHANNEL_ATTR_VERSION_STR   = 0x5
+	NCSI_CHANNEL_ATTR_LINK_STATE    = 0x6
+	NCSI_CHANNEL_ATTR_ACTIVE        = 0x7
+	NCSI_CHANNEL_ATTR_FORCED        = 0x8
+	NCSI_CHANNEL_ATTR_VLAN_LIST     = 0x9
+	NCSI_CHANNEL_ATTR_VLAN_ID       = 0xa
+)
+
+type ScmTimestamping struct {
+	Ts [3]Timespec
+}
+
+const (
+	SOF_TIMESTAMPING_TX_HARDWARE  = 0x1
+	SOF_TIMESTAMPING_TX_SOFTWARE  = 0x2
+	SOF_TIMESTAMPING_RX_HARDWARE  = 0x4
+	SOF_TIMESTAMPING_RX_SOFTWARE  = 0x8
+	SOF_TIMESTAMPING_SOFTWARE     = 0x10
+	SOF_TIMESTAMPING_SYS_HARDWARE = 0x20
+	SOF_TIMESTAMPING_RAW_HARDWARE = 0x40
+	SOF_TIMESTAMPING_OPT_ID       = 0x80
+	SOF_TIMESTAMPING_TX_SCHED     = 0x100
+	SOF_TIMESTAMPING_TX_ACK       = 0x200
+	SOF_TIMESTAMPING_OPT_CMSG     = 0x400
+	SOF_TIMESTAMPING_OPT_TSONLY   = 0x800
+	SOF_TIMESTAMPING_OPT_STATS    = 0x1000
+	SOF_TIMESTAMPING_OPT_PKTINFO  = 0x2000
+	SOF_TIMESTAMPING_OPT_TX_SWHW  = 0x4000
+	SOF_TIMESTAMPING_BIND_PHC     = 0x8000
+	SOF_TIMESTAMPING_OPT_ID_TCP   = 0x10000
+
+	SOF_TIMESTAMPING_LAST = 0x10000
+	SOF_TIMESTAMPING_MASK = 0x1ffff
+
+	SCM_TSTAMP_SND   = 0x0
+	SCM_TSTAMP_SCHED = 0x1
+	SCM_TSTAMP_ACK   = 0x2
+)
+
+type SockExtendedErr struct {
+	Errno  uint32
+	Origin uint8
+	Type   uint8
+	Code   uint8
+	Pad    uint8
+	Info   uint32
+	Data   uint32
+}
+
+type FanotifyEventMetadata struct {
+	Event_len    uint32
+	Vers         uint8
+	Reserved     uint8
+	Metadata_len uint16
+	Mask         uint64
+	Fd           int32
+	Pid          int32
+}
+
+type FanotifyResponse struct {
+	Fd       int32
+	Response uint32
+}
+
+const (
+	CRYPTO_MSG_BASE      = 0x10
+	CRYPTO_MSG_NEWALG    = 0x10
+	CRYPTO_MSG_DELALG    = 0x11
+	CRYPTO_MSG_UPDATEALG = 0x12
+	CRYPTO_MSG_GETALG    = 0x13
+	CRYPTO_MSG_DELRNG    = 0x14
+	CRYPTO_MSG_GETSTAT   = 0x15
+)
+
+const (
+	CRYPTOCFGA_UNSPEC           = 0x0
+	CRYPTOCFGA_PRIORITY_VAL     = 0x1
+	CRYPTOCFGA_REPORT_LARVAL    = 0x2
+	CRYPTOCFGA_REPORT_HASH      = 0x3
+	CRYPTOCFGA_REPORT_BLKCIPHER = 0x4
+	CRYPTOCFGA_REPORT_AEAD      = 0x5
+	CRYPTOCFGA_REPORT_COMPRESS  = 0x6
+	CRYPTOCFGA_REPORT_RNG       = 0x7
+	CRYPTOCFGA_REPORT_CIPHER    = 0x8
+	CRYPTOCFGA_REPORT_AKCIPHER  = 0x9
+	CRYPTOCFGA_REPORT_KPP       = 0xa
+	CRYPTOCFGA_REPORT_ACOMP     = 0xb
+	CRYPTOCFGA_STAT_LARVAL      = 0xc
+	CRYPTOCFGA_STAT_HASH        = 0xd
+	CRYPTOCFGA_STAT_BLKCIPHER   = 0xe
+	CRYPTOCFGA_STAT_AEAD        = 0xf
+	CRYPTOCFGA_STAT_COMPRESS    = 0x10
+	CRYPTOCFGA_STAT_RNG         = 0x11
+	CRYPTOCFGA_STAT_CIPHER      = 0x12
+	CRYPTOCFGA_STAT_AKCIPHER    = 0x13
+	CRYPTOCFGA_STAT_KPP         = 0x14
+	CRYPTOCFGA_STAT_ACOMP       = 0x15
+)
+
+type CryptoUserAlg struct {
+	Name        [64]int8
+	Driver_name [64]int8
+	Module_name [64]int8
+	Type        uint32
+	Mask        uint32
+	Refcnt      uint32
+	Flags       uint32
+}
+
+type CryptoStatAEAD struct {
+	Type         [64]int8
+	Encrypt_cnt  uint64
+	Encrypt_tlen uint64
+	Decrypt_cnt  uint64
+	Decrypt_tlen uint64
+	Err_cnt      uint64
+}
+
+type CryptoStatAKCipher struct {
+	Type         [64]int8
+	Encrypt_cnt  uint64
+	Encrypt_tlen uint64
+	Decrypt_cnt  uint64
+	Decrypt_tlen uint64
+	Verify_cnt   uint64
+	Sign_cnt     uint64
+	Err_cnt      uint64
+}
+
+type CryptoStatCipher struct {
+	Type         [64]int8
+	Encrypt_cnt  uint64
+	Encrypt_tlen uint64
+	Decrypt_cnt  uint64
+	Decrypt_tlen uint64
+	Err_cnt      uint64
+}
+
+type CryptoStatCompress struct {
+	Type            [64]int8
+	Compress_cnt    uint64
+	Compress_tlen   uint64
+	Decompress_cnt  uint64
+	Decompress_tlen uint64
+	Err_cnt         uint64
+}
+
+type CryptoStatHash struct {
+	Type      [64]int8
+	Hash_cnt  uint64
+	Hash_tlen uint64
+	Err_cnt   uint64
+}
+
+type CryptoStatKPP struct {
+	Type                      [64]int8
+	Setsecret_cnt             uint64
+	Generate_public_key_cnt   uint64
+	Compute_shared_secret_cnt uint64
+	Err_cnt                   uint64
+}
+
+type CryptoStatRNG struct {
+	Type          [64]int8
+	Generate_cnt  uint64
+	Generate_tlen uint64
+	Seed_cnt      uint64
+	Err_cnt       uint64
+}
+
+type CryptoStatLarval struct {
+	Type [64]int8
+}
+
+type CryptoReportLarval struct {
+	Type [64]int8
+}
+
+type CryptoReportHash struct {
+	Type       [64]int8
+	Blocksize  uint32
+	Digestsize uint32
+}
+
+type CryptoReportCipher struct {
+	Type        [64]int8
+	Blocksize   uint32
+	Min_keysize uint32
+	Max_keysize uint32
+}
+
+type CryptoReportBlkCipher struct {
+	Type        [64]int8
+	Geniv       [64]int8
+	Blocksize   uint32
+	Min_keysize uint32
+	Max_keysize uint32
+	Ivsize      uint32
+}
+
+type CryptoReportAEAD struct {
+	Type        [64]int8
+	Geniv       [64]int8
+	Blocksize   uint32
+	Maxauthsize uint32
+	Ivsize      uint32
+}
+
+type CryptoReportComp struct {
+	Type [64]int8
+}
+
+type CryptoReportRNG struct {
+	Type     [64]int8
+	Seedsize uint32
+}
+
+type CryptoReportAKCipher struct {
+	Type [64]int8
+}
+
+type CryptoReportKPP struct {
+	Type [64]int8
+}
+
+type CryptoReportAcomp struct {
+	Type [64]int8
+}
+
+const (
+	BPF_REG_0                                  = 0x0
+	BPF_REG_1                                  = 0x1
+	BPF_REG_2                                  = 0x2
+	BPF_REG_3                                  = 0x3
+	BPF_REG_4                                  = 0x4
+	BPF_REG_5                                  = 0x5
+	BPF_REG_6                                  = 0x6
+	BPF_REG_7                                  = 0x7
+	BPF_REG_8                                  = 0x8
+	BPF_REG_9                                  = 0x9
+	BPF_REG_10                                 = 0xa
+	BPF_CGROUP_ITER_ORDER_UNSPEC               = 0x0
+	BPF_CGROUP_ITER_SELF_ONLY                  = 0x1
+	BPF_CGROUP_ITER_DESCENDANTS_PRE            = 0x2
+	BPF_CGROUP_ITER_DESCENDANTS_POST           = 0x3
+	BPF_CGROUP_ITER_ANCESTORS_UP               = 0x4
+	BPF_MAP_CREATE                             = 0x0
+	BPF_MAP_LOOKUP_ELEM                        = 0x1
+	BPF_MAP_UPDATE_ELEM                        = 0x2
+	BPF_MAP_DELETE_ELEM                        = 0x3
+	BPF_MAP_GET_NEXT_KEY                       = 0x4
+	BPF_PROG_LOAD                              = 0x5
+	BPF_OBJ_PIN                                = 0x6
+	BPF_OBJ_GET                                = 0x7
+	BPF_PROG_ATTACH                            = 0x8
+	BPF_PROG_DETACH                            = 0x9
+	BPF_PROG_TEST_RUN                          = 0xa
+	BPF_PROG_RUN                               = 0xa
+	BPF_PROG_GET_NEXT_ID                       = 0xb
+	BPF_MAP_GET_NEXT_ID                        = 0xc
+	BPF_PROG_GET_FD_BY_ID                      = 0xd
+	BPF_MAP_GET_FD_BY_ID                       = 0xe
+	BPF_OBJ_GET_INFO_BY_FD                     = 0xf
+	BPF_PROG_QUERY                             = 0x10
+	BPF_RAW_TRACEPOINT_OPEN                    = 0x11
+	BPF_BTF_LOAD                               = 0x12
+	BPF_BTF_GET_FD_BY_ID                       = 0x13
+	BPF_TASK_FD_QUERY                          = 0x14
+	BPF_MAP_LOOKUP_AND_DELETE_ELEM             = 0x15
+	BPF_MAP_FREEZE                             = 0x16
+	BPF_BTF_GET_NEXT_ID                        = 0x17
+	BPF_MAP_LOOKUP_BATCH                       = 0x18
+	BPF_MAP_LOOKUP_AND_DELETE_BATCH            = 0x19
+	BPF_MAP_UPDATE_BATCH                       = 0x1a
+	BPF_MAP_DELETE_BATCH                       = 0x1b
+	BPF_LINK_CREATE                            = 0x1c
+	BPF_LINK_UPDATE                            = 0x1d
+	BPF_LINK_GET_FD_BY_ID                      = 0x1e
+	BPF_LINK_GET_NEXT_ID                       = 0x1f
+	BPF_ENABLE_STATS                           = 0x20
+	BPF_ITER_CREATE                            = 0x21
+	BPF_LINK_DETACH                            = 0x22
+	BPF_PROG_BIND_MAP                          = 0x23
+	BPF_MAP_TYPE_UNSPEC                        = 0x0
+	BPF_MAP_TYPE_HASH                          = 0x1
+	BPF_MAP_TYPE_ARRAY                         = 0x2
+	BPF_MAP_TYPE_PROG_ARRAY                    = 0x3
+	BPF_MAP_TYPE_PERF_EVENT_ARRAY              = 0x4
+	BPF_MAP_TYPE_PERCPU_HASH                   = 0x5
+	BPF_MAP_TYPE_PERCPU_ARRAY                  = 0x6
+	BPF_MAP_TYPE_STACK_TRACE                   = 0x7
+	BPF_MAP_TYPE_CGROUP_ARRAY                  = 0x8
+	BPF_MAP_TYPE_LRU_HASH                      = 0x9
+	BPF_MAP_TYPE_LRU_PERCPU_HASH               = 0xa
+	BPF_MAP_TYPE_LPM_TRIE                      = 0xb
+	BPF_MAP_TYPE_ARRAY_OF_MAPS                 = 0xc
+	BPF_MAP_TYPE_HASH_OF_MAPS                  = 0xd
+	BPF_MAP_TYPE_DEVMAP                        = 0xe
+	BPF_MAP_TYPE_SOCKMAP                       = 0xf
+	BPF_MAP_TYPE_CPUMAP                        = 0x10
+	BPF_MAP_TYPE_XSKMAP                        = 0x11
+	BPF_MAP_TYPE_SOCKHASH                      = 0x12
+	BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED     = 0x13
+	BPF_MAP_TYPE_CGROUP_STORAGE                = 0x13
+	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY           = 0x14
+	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE         = 0x15
+	BPF_MAP_TYPE_QUEUE                         = 0x16
+	BPF_MAP_TYPE_STACK                         = 0x17
+	BPF_MAP_TYPE_SK_STORAGE                    = 0x18
+	BPF_MAP_TYPE_DEVMAP_HASH                   = 0x19
+	BPF_MAP_TYPE_STRUCT_OPS                    = 0x1a
+	BPF_MAP_TYPE_RINGBUF                       = 0x1b
+	BPF_MAP_TYPE_INODE_STORAGE                 = 0x1c
+	BPF_MAP_TYPE_TASK_STORAGE                  = 0x1d
+	BPF_MAP_TYPE_BLOOM_FILTER                  = 0x1e
+	BPF_MAP_TYPE_USER_RINGBUF                  = 0x1f
+	BPF_MAP_TYPE_CGRP_STORAGE                  = 0x20
+	BPF_PROG_TYPE_UNSPEC                       = 0x0
+	BPF_PROG_TYPE_SOCKET_FILTER                = 0x1
+	BPF_PROG_TYPE_KPROBE                       = 0x2
+	BPF_PROG_TYPE_SCHED_CLS                    = 0x3
+	BPF_PROG_TYPE_SCHED_ACT                    = 0x4
+	BPF_PROG_TYPE_TRACEPOINT                   = 0x5
+	BPF_PROG_TYPE_XDP                          = 0x6
+	BPF_PROG_TYPE_PERF_EVENT                   = 0x7
+	BPF_PROG_TYPE_CGROUP_SKB                   = 0x8
+	BPF_PROG_TYPE_CGROUP_SOCK                  = 0x9
+	BPF_PROG_TYPE_LWT_IN                       = 0xa
+	BPF_PROG_TYPE_LWT_OUT                      = 0xb
+	BPF_PROG_TYPE_LWT_XMIT                     = 0xc
+	BPF_PROG_TYPE_SOCK_OPS                     = 0xd
+	BPF_PROG_TYPE_SK_SKB                       = 0xe
+	BPF_PROG_TYPE_CGROUP_DEVICE                = 0xf
+	BPF_PROG_TYPE_SK_MSG                       = 0x10
+	BPF_PROG_TYPE_RAW_TRACEPOINT               = 0x11
+	BPF_PROG_TYPE_CGROUP_SOCK_ADDR             = 0x12
+	BPF_PROG_TYPE_LWT_SEG6LOCAL                = 0x13
+	BPF_PROG_TYPE_LIRC_MODE2                   = 0x14
+	BPF_PROG_TYPE_SK_REUSEPORT                 = 0x15
+	BPF_PROG_TYPE_FLOW_DISSECTOR               = 0x16
+	BPF_PROG_TYPE_CGROUP_SYSCTL                = 0x17
+	BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE      = 0x18
+	BPF_PROG_TYPE_CGROUP_SOCKOPT               = 0x19
+	BPF_PROG_TYPE_TRACING                      = 0x1a
+	BPF_PROG_TYPE_STRUCT_OPS                   = 0x1b
+	BPF_PROG_TYPE_EXT                          = 0x1c
+	BPF_PROG_TYPE_LSM                          = 0x1d
+	BPF_PROG_TYPE_SK_LOOKUP                    = 0x1e
+	BPF_PROG_TYPE_SYSCALL                      = 0x1f
+	BPF_CGROUP_INET_INGRESS                    = 0x0
+	BPF_CGROUP_INET_EGRESS                     = 0x1
+	BPF_CGROUP_INET_SOCK_CREATE                = 0x2
+	BPF_CGROUP_SOCK_OPS                        = 0x3
+	BPF_SK_SKB_STREAM_PARSER                   = 0x4
+	BPF_SK_SKB_STREAM_VERDICT                  = 0x5
+	BPF_CGROUP_DEVICE                          = 0x6
+	BPF_SK_MSG_VERDICT                         = 0x7
+	BPF_CGROUP_INET4_BIND                      = 0x8
+	BPF_CGROUP_INET6_BIND                      = 0x9
+	BPF_CGROUP_INET4_CONNECT                   = 0xa
+	BPF_CGROUP_INET6_CONNECT                   = 0xb
+	BPF_CGROUP_INET4_POST_BIND                 = 0xc
+	BPF_CGROUP_INET6_POST_BIND                 = 0xd
+	BPF_CGROUP_UDP4_SENDMSG                    = 0xe
+	BPF_CGROUP_UDP6_SENDMSG                    = 0xf
+	BPF_LIRC_MODE2                             = 0x10
+	BPF_FLOW_DISSECTOR                         = 0x11
+	BPF_CGROUP_SYSCTL                          = 0x12
+	BPF_CGROUP_UDP4_RECVMSG                    = 0x13
+	BPF_CGROUP_UDP6_RECVMSG                    = 0x14
+	BPF_CGROUP_GETSOCKOPT                      = 0x15
+	BPF_CGROUP_SETSOCKOPT                      = 0x16
+	BPF_TRACE_RAW_TP                           = 0x17
+	BPF_TRACE_FENTRY                           = 0x18
+	BPF_TRACE_FEXIT                            = 0x19
+	BPF_MODIFY_RETURN                          = 0x1a
+	BPF_LSM_MAC                                = 0x1b
+	BPF_TRACE_ITER                             = 0x1c
+	BPF_CGROUP_INET4_GETPEERNAME               = 0x1d
+	BPF_CGROUP_INET6_GETPEERNAME               = 0x1e
+	BPF_CGROUP_INET4_GETSOCKNAME               = 0x1f
+	BPF_CGROUP_INET6_GETSOCKNAME               = 0x20
+	BPF_XDP_DEVMAP                             = 0x21
+	BPF_CGROUP_INET_SOCK_RELEASE               = 0x22
+	BPF_XDP_CPUMAP                             = 0x23
+	BPF_SK_LOOKUP                              = 0x24
+	BPF_XDP                                    = 0x25
+	BPF_SK_SKB_VERDICT                         = 0x26
+	BPF_SK_REUSEPORT_SELECT                    = 0x27
+	BPF_SK_REUSEPORT_SELECT_OR_MIGRATE         = 0x28
+	BPF_PERF_EVENT                             = 0x29
+	BPF_TRACE_KPROBE_MULTI                     = 0x2a
+	BPF_LSM_CGROUP                             = 0x2b
+	BPF_LINK_TYPE_UNSPEC                       = 0x0
+	BPF_LINK_TYPE_RAW_TRACEPOINT               = 0x1
+	BPF_LINK_TYPE_TRACING                      = 0x2
+	BPF_LINK_TYPE_CGROUP                       = 0x3
+	BPF_LINK_TYPE_ITER                         = 0x4
+	BPF_LINK_TYPE_NETNS                        = 0x5
+	BPF_LINK_TYPE_XDP                          = 0x6
+	BPF_LINK_TYPE_PERF_EVENT                   = 0x7
+	BPF_LINK_TYPE_KPROBE_MULTI                 = 0x8
+	BPF_LINK_TYPE_STRUCT_OPS                   = 0x9
+	BPF_ANY                                    = 0x0
+	BPF_NOEXIST                                = 0x1
+	BPF_EXIST                                  = 0x2
+	BPF_F_LOCK                                 = 0x4
+	BPF_F_NO_PREALLOC                          = 0x1
+	BPF_F_NO_COMMON_LRU                        = 0x2
+	BPF_F_NUMA_NODE                            = 0x4
+	BPF_F_RDONLY                               = 0x8
+	BPF_F_WRONLY                               = 0x10
+	BPF_F_STACK_BUILD_ID                       = 0x20
+	BPF_F_ZERO_SEED                            = 0x40
+	BPF_F_RDONLY_PROG                          = 0x80
+	BPF_F_WRONLY_PROG                          = 0x100
+	BPF_F_CLONE                                = 0x200
+	BPF_F_MMAPABLE                             = 0x400
+	BPF_F_PRESERVE_ELEMS                       = 0x800
+	BPF_F_INNER_MAP                            = 0x1000
+	BPF_STATS_RUN_TIME                         = 0x0
+	BPF_STACK_BUILD_ID_EMPTY                   = 0x0
+	BPF_STACK_BUILD_ID_VALID                   = 0x1
+	BPF_STACK_BUILD_ID_IP                      = 0x2
+	BPF_F_RECOMPUTE_CSUM                       = 0x1
+	BPF_F_INVALIDATE_HASH                      = 0x2
+	BPF_F_HDR_FIELD_MASK                       = 0xf
+	BPF_F_PSEUDO_HDR                           = 0x10
+	BPF_F_MARK_MANGLED_0                       = 0x20
+	BPF_F_MARK_ENFORCE                         = 0x40
+	BPF_F_INGRESS                              = 0x1
+	BPF_F_TUNINFO_IPV6                         = 0x1
+	BPF_F_SKIP_FIELD_MASK                      = 0xff
+	BPF_F_USER_STACK                           = 0x100
+	BPF_F_FAST_STACK_CMP                       = 0x200
+	BPF_F_REUSE_STACKID                        = 0x400
+	BPF_F_USER_BUILD_ID                        = 0x800
+	BPF_F_ZERO_CSUM_TX                         = 0x2
+	BPF_F_DONT_FRAGMENT                        = 0x4
+	BPF_F_SEQ_NUMBER                           = 0x8
+	BPF_F_TUNINFO_FLAGS                        = 0x10
+	BPF_F_INDEX_MASK                           = 0xffffffff
+	BPF_F_CURRENT_CPU                          = 0xffffffff
+	BPF_F_CTXLEN_MASK                          = 0xfffff00000000
+	BPF_F_CURRENT_NETNS                        = -0x1
+	BPF_CSUM_LEVEL_QUERY                       = 0x0
+	BPF_CSUM_LEVEL_INC                         = 0x1
+	BPF_CSUM_LEVEL_DEC                         = 0x2
+	BPF_CSUM_LEVEL_RESET                       = 0x3
+	BPF_F_ADJ_ROOM_FIXED_GSO                   = 0x1
+	BPF_F_ADJ_ROOM_ENCAP_L3_IPV4               = 0x2
+	BPF_F_ADJ_ROOM_ENCAP_L3_IPV6               = 0x4
+	BPF_F_ADJ_ROOM_ENCAP_L4_GRE                = 0x8
+	BPF_F_ADJ_ROOM_ENCAP_L4_UDP                = 0x10
+	BPF_F_ADJ_ROOM_NO_CSUM_RESET               = 0x20
+	BPF_F_ADJ_ROOM_ENCAP_L2_ETH                = 0x40
+	BPF_ADJ_ROOM_ENCAP_L2_MASK                 = 0xff
+	BPF_ADJ_ROOM_ENCAP_L2_SHIFT                = 0x38
+	BPF_F_SYSCTL_BASE_NAME                     = 0x1
+	BPF_LOCAL_STORAGE_GET_F_CREATE             = 0x1
+	BPF_SK_STORAGE_GET_F_CREATE                = 0x1
+	BPF_F_GET_BRANCH_RECORDS_SIZE              = 0x1
+	BPF_RB_NO_WAKEUP                           = 0x1
+	BPF_RB_FORCE_WAKEUP                        = 0x2
+	BPF_RB_AVAIL_DATA                          = 0x0
+	BPF_RB_RING_SIZE                           = 0x1
+	BPF_RB_CONS_POS                            = 0x2
+	BPF_RB_PROD_POS                            = 0x3
+	BPF_RINGBUF_BUSY_BIT                       = 0x80000000
+	BPF_RINGBUF_DISCARD_BIT                    = 0x40000000
+	BPF_RINGBUF_HDR_SZ                         = 0x8
+	BPF_SK_LOOKUP_F_REPLACE                    = 0x1
+	BPF_SK_LOOKUP_F_NO_REUSEPORT               = 0x2
+	BPF_ADJ_ROOM_NET                           = 0x0
+	BPF_ADJ_ROOM_MAC                           = 0x1
+	BPF_HDR_START_MAC                          = 0x0
+	BPF_HDR_START_NET                          = 0x1
+	BPF_LWT_ENCAP_SEG6                         = 0x0
+	BPF_LWT_ENCAP_SEG6_INLINE                  = 0x1
+	BPF_LWT_ENCAP_IP                           = 0x2
+	BPF_F_BPRM_SECUREEXEC                      = 0x1
+	BPF_F_BROADCAST                            = 0x8
+	BPF_F_EXCLUDE_INGRESS                      = 0x10
+	BPF_SKB_TSTAMP_UNSPEC                      = 0x0
+	BPF_SKB_TSTAMP_DELIVERY_MONO               = 0x1
+	BPF_OK                                     = 0x0
+	BPF_DROP                                   = 0x2
+	BPF_REDIRECT                               = 0x7
+	BPF_LWT_REROUTE                            = 0x80
+	BPF_FLOW_DISSECTOR_CONTINUE                = 0x81
+	BPF_SOCK_OPS_RTO_CB_FLAG                   = 0x1
+	BPF_SOCK_OPS_RETRANS_CB_FLAG               = 0x2
+	BPF_SOCK_OPS_STATE_CB_FLAG                 = 0x4
+	BPF_SOCK_OPS_RTT_CB_FLAG                   = 0x8
+	BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG     = 0x10
+	BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG = 0x20
+	BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG         = 0x40
+	BPF_SOCK_OPS_ALL_CB_FLAGS                  = 0x7f
+	BPF_SOCK_OPS_VOID                          = 0x0
+	BPF_SOCK_OPS_TIMEOUT_INIT                  = 0x1
+	BPF_SOCK_OPS_RWND_INIT                     = 0x2
+	BPF_SOCK_OPS_TCP_CONNECT_CB                = 0x3
+	BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB         = 0x4
+	BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB        = 0x5
+	BPF_SOCK_OPS_NEEDS_ECN                     = 0x6
+	BPF_SOCK_OPS_BASE_RTT                      = 0x7
+	BPF_SOCK_OPS_RTO_CB                        = 0x8
+	BPF_SOCK_OPS_RETRANS_CB                    = 0x9
+	BPF_SOCK_OPS_STATE_CB                      = 0xa
+	BPF_SOCK_OPS_TCP_LISTEN_CB                 = 0xb
+	BPF_SOCK_OPS_RTT_CB                        = 0xc
+	BPF_SOCK_OPS_PARSE_HDR_OPT_CB              = 0xd
+	BPF_SOCK_OPS_HDR_OPT_LEN_CB                = 0xe
+	BPF_SOCK_OPS_WRITE_HDR_OPT_CB              = 0xf
+	BPF_TCP_ESTABLISHED                        = 0x1
+	BPF_TCP_SYN_SENT                           = 0x2
+	BPF_TCP_SYN_RECV                           = 0x3
+	BPF_TCP_FIN_WAIT1                          = 0x4
+	BPF_TCP_FIN_WAIT2                          = 0x5
+	BPF_TCP_TIME_WAIT                          = 0x6
+	BPF_TCP_CLOSE                              = 0x7
+	BPF_TCP_CLOSE_WAIT                         = 0x8
+	BPF_TCP_LAST_ACK                           = 0x9
+	BPF_TCP_LISTEN                             = 0xa
+	BPF_TCP_CLOSING                            = 0xb
+	BPF_TCP_NEW_SYN_RECV                       = 0xc
+	BPF_TCP_MAX_STATES                         = 0xd
+	TCP_BPF_IW                                 = 0x3e9
+	TCP_BPF_SNDCWND_CLAMP                      = 0x3ea
+	TCP_BPF_DELACK_MAX                         = 0x3eb
+	TCP_BPF_RTO_MIN                            = 0x3ec
+	TCP_BPF_SYN                                = 0x3ed
+	TCP_BPF_SYN_IP                             = 0x3ee
+	TCP_BPF_SYN_MAC                            = 0x3ef
+	BPF_LOAD_HDR_OPT_TCP_SYN                   = 0x1
+	BPF_WRITE_HDR_TCP_CURRENT_MSS              = 0x1
+	BPF_WRITE_HDR_TCP_SYNACK_COOKIE            = 0x2
+	BPF_DEVCG_ACC_MKNOD                        = 0x1
+	BPF_DEVCG_ACC_READ                         = 0x2
+	BPF_DEVCG_ACC_WRITE                        = 0x4
+	BPF_DEVCG_DEV_BLOCK                        = 0x1
+	BPF_DEVCG_DEV_CHAR                         = 0x2
+	BPF_FIB_LOOKUP_DIRECT                      = 0x1
+	BPF_FIB_LOOKUP_OUTPUT                      = 0x2
+	BPF_FIB_LKUP_RET_SUCCESS                   = 0x0
+	BPF_FIB_LKUP_RET_BLACKHOLE                 = 0x1
+	BPF_FIB_LKUP_RET_UNREACHABLE               = 0x2
+	BPF_FIB_LKUP_RET_PROHIBIT                  = 0x3
+	BPF_FIB_LKUP_RET_NOT_FWDED                 = 0x4
+	BPF_FIB_LKUP_RET_FWD_DISABLED              = 0x5
+	BPF_FIB_LKUP_RET_UNSUPP_LWT                = 0x6
+	BPF_FIB_LKUP_RET_NO_NEIGH                  = 0x7
+	BPF_FIB_LKUP_RET_FRAG_NEEDED               = 0x8
+	BPF_MTU_CHK_SEGS                           = 0x1
+	BPF_MTU_CHK_RET_SUCCESS                    = 0x0
+	BPF_MTU_CHK_RET_FRAG_NEEDED                = 0x1
+	BPF_MTU_CHK_RET_SEGS_TOOBIG                = 0x2
+	BPF_FD_TYPE_RAW_TRACEPOINT                 = 0x0
+	BPF_FD_TYPE_TRACEPOINT                     = 0x1
+	BPF_FD_TYPE_KPROBE                         = 0x2
+	BPF_FD_TYPE_KRETPROBE                      = 0x3
+	BPF_FD_TYPE_UPROBE                         = 0x4
+	BPF_FD_TYPE_URETPROBE                      = 0x5
+	BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG        = 0x1
+	BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL    = 0x2
+	BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP         = 0x4
+	BPF_CORE_FIELD_BYTE_OFFSET                 = 0x0
+	BPF_CORE_FIELD_BYTE_SIZE                   = 0x1
+	BPF_CORE_FIELD_EXISTS                      = 0x2
+	BPF_CORE_FIELD_SIGNED                      = 0x3
+	BPF_CORE_FIELD_LSHIFT_U64                  = 0x4
+	BPF_CORE_FIELD_RSHIFT_U64                  = 0x5
+	BPF_CORE_TYPE_ID_LOCAL                     = 0x6
+	BPF_CORE_TYPE_ID_TARGET                    = 0x7
+	BPF_CORE_TYPE_EXISTS                       = 0x8
+	BPF_CORE_TYPE_SIZE                         = 0x9
+	BPF_CORE_ENUMVAL_EXISTS                    = 0xa
+	BPF_CORE_ENUMVAL_VALUE                     = 0xb
+	BPF_CORE_TYPE_MATCHES                      = 0xc
+)
+
+const (
+	RTNLGRP_NONE          = 0x0
+	RTNLGRP_LINK          = 0x1
+	RTNLGRP_NOTIFY        = 0x2
+	RTNLGRP_NEIGH         = 0x3
+	RTNLGRP_TC            = 0x4
+	RTNLGRP_IPV4_IFADDR   = 0x5
+	RTNLGRP_IPV4_MROUTE   = 0x6
+	RTNLGRP_IPV4_ROUTE    = 0x7
+	RTNLGRP_IPV4_RULE     = 0x8
+	RTNLGRP_IPV6_IFADDR   = 0x9
+	RTNLGRP_IPV6_MROUTE   = 0xa
+	RTNLGRP_IPV6_ROUTE    = 0xb
+	RTNLGRP_IPV6_IFINFO   = 0xc
+	RTNLGRP_DECnet_IFADDR = 0xd
+	RTNLGRP_NOP2          = 0xe
+	RTNLGRP_DECnet_ROUTE  = 0xf
+	RTNLGRP_DECnet_RULE   = 0x10
+	RTNLGRP_NOP4          = 0x11
+	RTNLGRP_IPV6_PREFIX   = 0x12
+	RTNLGRP_IPV6_RULE     = 0x13
+	RTNLGRP_ND_USEROPT    = 0x14
+	RTNLGRP_PHONET_IFADDR = 0x15
+	RTNLGRP_PHONET_ROUTE  = 0x16
+	RTNLGRP_DCB           = 0x17
+	RTNLGRP_IPV4_NETCONF  = 0x18
+	RTNLGRP_IPV6_NETCONF  = 0x19
+	RTNLGRP_MDB           = 0x1a
+	RTNLGRP_MPLS_ROUTE    = 0x1b
+	RTNLGRP_NSID          = 0x1c
+	RTNLGRP_MPLS_NETCONF  = 0x1d
+	RTNLGRP_IPV4_MROUTE_R = 0x1e
+	RTNLGRP_IPV6_MROUTE_R = 0x1f
+	RTNLGRP_NEXTHOP       = 0x20
+	RTNLGRP_BRVLAN        = 0x21
+)
+
+type CapUserHeader struct {
+	Version uint32
+	Pid     int32
+}
+
+type CapUserData struct {
+	Effective   uint32
+	Permitted   uint32
+	Inheritable uint32
+}
+
+const (
+	LINUX_CAPABILITY_VERSION_1 = 0x19980330
+	LINUX_CAPABILITY_VERSION_2 = 0x20071026
+	LINUX_CAPABILITY_VERSION_3 = 0x20080522
+)
+
+const (
+	LO_FLAGS_READ_ONLY = 0x1
+	LO_FLAGS_AUTOCLEAR = 0x4
+	LO_FLAGS_PARTSCAN  = 0x8
+	LO_FLAGS_DIRECT_IO = 0x10
+)
+
+type LoopInfo struct {
+	Number           int32
+	Device           uint32
+	Inode            uint64
+	Rdevice          uint32
+	Offset           int32
+	Encrypt_type     int32
+	Encrypt_key_size int32
+	Flags            int32
+	Name             [64]int8
+	Encrypt_key      [32]uint8
+	Init             [2]uint64
+	Reserved         [4]int8
+	_                [4]byte
+}
+type LoopInfo64 struct {
+	Device           uint64
+	Inode            uint64
+	Rdevice          uint64
+	Offset           uint64
+	Sizelimit        uint64
+	Number           uint32
+	Encrypt_type     uint32
+	Encrypt_key_size uint32
+	Flags            uint32
+	File_name        [64]uint8
+	Crypt_name       [64]uint8
+	Encrypt_key      [32]uint8
+	Init             [2]uint64
+}
+
+type LoopConfig struct {
+	Fd   uint32
+	Size uint32
+	Info LoopInfo64
+	_    [8]uint64
+}
+
+type TIPCSocketAddr struct {
+	Ref  uint32
+	Node uint32
+}
+
+type TIPCServiceRange struct {
+	Type  uint32
+	Lower uint32
+	Upper uint32
+}
+
+type TIPCServiceName struct {
+	Type     uint32
+	Instance uint32
+	Domain   uint32
+}
+
+type TIPCSubscr struct {
+	Seq     TIPCServiceRange
+	Timeout uint32
+	Filter  uint32
+	Handle  [8]int8
+}
+
+type TIPCEvent struct {
+	Event uint32
+	Lower uint32
+	Upper uint32
+	Port  TIPCSocketAddr
+	S     TIPCSubscr
+}
+
+type TIPCGroupReq struct {
+	Type     uint32
+	Instance uint32
+	Scope    uint32
+	Flags    uint32
+}
+
+type TIPCSIOCLNReq struct {
+	Peer     uint32
+	Id       uint32
+	Linkname [68]int8
+}
+
+type TIPCSIOCNodeIDReq struct {
+	Peer uint32
+	Id   [16]int8
+}
+
+const (
+	TIPC_CLUSTER_SCOPE = 0x2
+	TIPC_NODE_SCOPE    = 0x3
+)
+
+const (
+	SYSLOG_ACTION_CLOSE         = 0
+	SYSLOG_ACTION_OPEN          = 1
+	SYSLOG_ACTION_READ          = 2
+	SYSLOG_ACTION_READ_ALL      = 3
+	SYSLOG_ACTION_READ_CLEAR    = 4
+	SYSLOG_ACTION_CLEAR         = 5
+	SYSLOG_ACTION_CONSOLE_OFF   = 6
+	SYSLOG_ACTION_CONSOLE_ON    = 7
+	SYSLOG_ACTION_CONSOLE_LEVEL = 8
+	SYSLOG_ACTION_SIZE_UNREAD   = 9
+	SYSLOG_ACTION_SIZE_BUFFER   = 10
+)
+
+const (
+	DEVLINK_CMD_UNSPEC                                 = 0x0
+	DEVLINK_CMD_GET                                    = 0x1
+	DEVLINK_CMD_SET                                    = 0x2
+	DEVLINK_CMD_NEW                                    = 0x3
+	DEVLINK_CMD_DEL                                    = 0x4
+	DEVLINK_CMD_PORT_GET                               = 0x5
+	DEVLINK_CMD_PORT_SET                               = 0x6
+	DEVLINK_CMD_PORT_NEW                               = 0x7
+	DEVLINK_CMD_PORT_DEL                               = 0x8
+	DEVLINK_CMD_PORT_SPLIT                             = 0x9
+	DEVLINK_CMD_PORT_UNSPLIT                           = 0xa
+	DEVLINK_CMD_SB_GET                                 = 0xb
+	DEVLINK_CMD_SB_SET                                 = 0xc
+	DEVLINK_CMD_SB_NEW                                 = 0xd
+	DEVLINK_CMD_SB_DEL                                 = 0xe
+	DEVLINK_CMD_SB_POOL_GET                            = 0xf
+	DEVLINK_CMD_SB_POOL_SET                            = 0x10
+	DEVLINK_CMD_SB_POOL_NEW                            = 0x11
+	DEVLINK_CMD_SB_POOL_DEL                            = 0x12
+	DEVLINK_CMD_SB_PORT_POOL_GET                       = 0x13
+	DEVLINK_CMD_SB_PORT_POOL_SET                       = 0x14
+	DEVLINK_CMD_SB_PORT_POOL_NEW                       = 0x15
+	DEVLINK_CMD_SB_PORT_POOL_DEL                       = 0x16
+	DEVLINK_CMD_SB_TC_POOL_BIND_GET                    = 0x17
+	DEVLINK_CMD_SB_TC_POOL_BIND_SET                    = 0x18
+	DEVLINK_CMD_SB_TC_POOL_BIND_NEW                    = 0x19
+	DEVLINK_CMD_SB_TC_POOL_BIND_DEL                    = 0x1a
+	DEVLINK_CMD_SB_OCC_SNAPSHOT                        = 0x1b
+	DEVLINK_CMD_SB_OCC_MAX_CLEAR                       = 0x1c
+	DEVLINK_CMD_ESWITCH_GET                            = 0x1d
+	DEVLINK_CMD_ESWITCH_SET                            = 0x1e
+	DEVLINK_CMD_DPIPE_TABLE_GET                        = 0x1f
+	DEVLINK_CMD_DPIPE_ENTRIES_GET                      = 0x20
+	DEVLINK_CMD_DPIPE_HEADERS_GET                      = 0x21
+	DEVLINK_CMD_DPIPE_TABLE_COUNTERS_SET               = 0x22
+	DEVLINK_CMD_RESOURCE_SET                           = 0x23
+	DEVLINK_CMD_RESOURCE_DUMP                          = 0x24
+	DEVLINK_CMD_RELOAD                                 = 0x25
+	DEVLINK_CMD_PARAM_GET                              = 0x26
+	DEVLINK_CMD_PARAM_SET                              = 0x27
+	DEVLINK_CMD_PARAM_NEW                              = 0x28
+	DEVLINK_CMD_PARAM_DEL                              = 0x29
+	DEVLINK_CMD_REGION_GET                             = 0x2a
+	DEVLINK_CMD_REGION_SET                             = 0x2b
+	DEVLINK_CMD_REGION_NEW                             = 0x2c
+	DEVLINK_CMD_REGION_DEL                             = 0x2d
+	DEVLINK_CMD_REGION_READ                            = 0x2e
+	DEVLINK_CMD_PORT_PARAM_GET                         = 0x2f
+	DEVLINK_CMD_PORT_PARAM_SET                         = 0x30
+	DEVLINK_CMD_PORT_PARAM_NEW                         = 0x31
+	DEVLINK_CMD_PORT_PARAM_DEL                         = 0x32
+	DEVLINK_CMD_INFO_GET                               = 0x33
+	DEVLINK_CMD_HEALTH_REPORTER_GET                    = 0x34
+	DEVLINK_CMD_HEALTH_REPORTER_SET                    = 0x35
+	DEVLINK_CMD_HEALTH_REPORTER_RECOVER                = 0x36
+	DEVLINK_CMD_HEALTH_REPORTER_DIAGNOSE               = 0x37
+	DEVLINK_CMD_HEALTH_REPORTER_DUMP_GET               = 0x38
+	DEVLINK_CMD_HEALTH_REPORTER_DUMP_CLEAR             = 0x39
+	DEVLINK_CMD_FLASH_UPDATE                           = 0x3a
+	DEVLINK_CMD_FLASH_UPDATE_END                       = 0x3b
+	DEVLINK_CMD_FLASH_UPDATE_STATUS                    = 0x3c
+	DEVLINK_CMD_TRAP_GET                               = 0x3d
+	DEVLINK_CMD_TRAP_SET                               = 0x3e
+	DEVLINK_CMD_TRAP_NEW                               = 0x3f
+	DEVLINK_CMD_TRAP_DEL                               = 0x40
+	DEVLINK_CMD_TRAP_GROUP_GET                         = 0x41
+	DEVLINK_CMD_TRAP_GROUP_SET                         = 0x42
+	DEVLINK_CMD_TRAP_GROUP_NEW                         = 0x43
+	DEVLINK_CMD_TRAP_GROUP_DEL                         = 0x44
+	DEVLINK_CMD_TRAP_POLICER_GET                       = 0x45
+	DEVLINK_CMD_TRAP_POLICER_SET                       = 0x46
+	DEVLINK_CMD_TRAP_POLICER_NEW                       = 0x47
+	DEVLINK_CMD_TRAP_POLICER_DEL                       = 0x48
+	DEVLINK_CMD_HEALTH_REPORTER_TEST                   = 0x49
+	DEVLINK_CMD_RATE_GET                               = 0x4a
+	DEVLINK_CMD_RATE_SET                               = 0x4b
+	DEVLINK_CMD_RATE_NEW                               = 0x4c
+	DEVLINK_CMD_RATE_DEL                               = 0x4d
+	DEVLINK_CMD_LINECARD_GET                           = 0x4e
+	DEVLINK_CMD_LINECARD_SET                           = 0x4f
+	DEVLINK_CMD_LINECARD_NEW                           = 0x50
+	DEVLINK_CMD_LINECARD_DEL                           = 0x51
+	DEVLINK_CMD_SELFTESTS_GET                          = 0x52
+	DEVLINK_CMD_MAX                                    = 0x53
+	DEVLINK_PORT_TYPE_NOTSET                           = 0x0
+	DEVLINK_PORT_TYPE_AUTO                             = 0x1
+	DEVLINK_PORT_TYPE_ETH                              = 0x2
+	DEVLINK_PORT_TYPE_IB                               = 0x3
+	DEVLINK_SB_POOL_TYPE_INGRESS                       = 0x0
+	DEVLINK_SB_POOL_TYPE_EGRESS                        = 0x1
+	DEVLINK_SB_THRESHOLD_TYPE_STATIC                   = 0x0
+	DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC                  = 0x1
+	DEVLINK_ESWITCH_MODE_LEGACY                        = 0x0
+	DEVLINK_ESWITCH_MODE_SWITCHDEV                     = 0x1
+	DEVLINK_ESWITCH_INLINE_MODE_NONE                   = 0x0
+	DEVLINK_ESWITCH_INLINE_MODE_LINK                   = 0x1
+	DEVLINK_ESWITCH_INLINE_MODE_NETWORK                = 0x2
+	DEVLINK_ESWITCH_INLINE_MODE_TRANSPORT              = 0x3
+	DEVLINK_ESWITCH_ENCAP_MODE_NONE                    = 0x0
+	DEVLINK_ESWITCH_ENCAP_MODE_BASIC                   = 0x1
+	DEVLINK_PORT_FLAVOUR_PHYSICAL                      = 0x0
+	DEVLINK_PORT_FLAVOUR_CPU                           = 0x1
+	DEVLINK_PORT_FLAVOUR_DSA                           = 0x2
+	DEVLINK_PORT_FLAVOUR_PCI_PF                        = 0x3
+	DEVLINK_PORT_FLAVOUR_PCI_VF                        = 0x4
+	DEVLINK_PORT_FLAVOUR_VIRTUAL                       = 0x5
+	DEVLINK_PORT_FLAVOUR_UNUSED                        = 0x6
+	DEVLINK_PARAM_CMODE_RUNTIME                        = 0x0
+	DEVLINK_PARAM_CMODE_DRIVERINIT                     = 0x1
+	DEVLINK_PARAM_CMODE_PERMANENT                      = 0x2
+	DEVLINK_PARAM_CMODE_MAX                            = 0x2
+	DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_DRIVER          = 0x0
+	DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_FLASH           = 0x1
+	DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_DISK            = 0x2
+	DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_UNKNOWN         = 0x3
+	DEVLINK_PARAM_RESET_DEV_ON_DRV_PROBE_VALUE_UNKNOWN = 0x0
+	DEVLINK_PARAM_RESET_DEV_ON_DRV_PROBE_VALUE_ALWAYS  = 0x1
+	DEVLINK_PARAM_RESET_DEV_ON_DRV_PROBE_VALUE_NEVER   = 0x2
+	DEVLINK_PARAM_RESET_DEV_ON_DRV_PROBE_VALUE_DISK    = 0x3
+	DEVLINK_ATTR_STATS_RX_PACKETS                      = 0x0
+	DEVLINK_ATTR_STATS_RX_BYTES                        = 0x1
+	DEVLINK_ATTR_STATS_RX_DROPPED                      = 0x2
+	DEVLINK_ATTR_STATS_MAX                             = 0x2
+	DEVLINK_FLASH_OVERWRITE_SETTINGS_BIT               = 0x0
+	DEVLINK_FLASH_OVERWRITE_IDENTIFIERS_BIT            = 0x1
+	DEVLINK_FLASH_OVERWRITE_MAX_BIT                    = 0x1
+	DEVLINK_TRAP_ACTION_DROP                           = 0x0
+	DEVLINK_TRAP_ACTION_TRAP                           = 0x1
+	DEVLINK_TRAP_ACTION_MIRROR                         = 0x2
+	DEVLINK_TRAP_TYPE_DROP                             = 0x0
+	DEVLINK_TRAP_TYPE_EXCEPTION                        = 0x1
+	DEVLINK_TRAP_TYPE_CONTROL                          = 0x2
+	DEVLINK_ATTR_TRAP_METADATA_TYPE_IN_PORT            = 0x0
+	DEVLINK_ATTR_TRAP_METADATA_TYPE_FA_COOKIE          = 0x1
+	DEVLINK_RELOAD_ACTION_UNSPEC                       = 0x0
+	DEVLINK_RELOAD_ACTION_DRIVER_REINIT                = 0x1
+	DEVLINK_RELOAD_ACTION_FW_ACTIVATE                  = 0x2
+	DEVLINK_RELOAD_ACTION_MAX                          = 0x2
+	DEVLINK_RELOAD_LIMIT_UNSPEC                        = 0x0
+	DEVLINK_RELOAD_LIMIT_NO_RESET                      = 0x1
+	DEVLINK_RELOAD_LIMIT_MAX                           = 0x1
+	DEVLINK_ATTR_UNSPEC                                = 0x0
+	DEVLINK_ATTR_BUS_NAME                              = 0x1
+	DEVLINK_ATTR_DEV_NAME                              = 0x2
+	DEVLINK_ATTR_PORT_INDEX                            = 0x3
+	DEVLINK_ATTR_PORT_TYPE                             = 0x4
+	DEVLINK_ATTR_PORT_DESIRED_TYPE                     = 0x5
+	DEVLINK_ATTR_PORT_NETDEV_IFINDEX                   = 0x6
+	DEVLINK_ATTR_PORT_NETDEV_NAME                      = 0x7
+	DEVLINK_ATTR_PORT_IBDEV_NAME                       = 0x8
+	DEVLINK_ATTR_PORT_SPLIT_COUNT                      = 0x9
+	DEVLINK_ATTR_PORT_SPLIT_GROUP                      = 0xa
+	DEVLINK_ATTR_SB_INDEX                              = 0xb
+	DEVLINK_ATTR_SB_SIZE                               = 0xc
+	DEVLINK_ATTR_SB_INGRESS_POOL_COUNT                 = 0xd
+	DEVLINK_ATTR_SB_EGRESS_POOL_COUNT                  = 0xe
+	DEVLINK_ATTR_SB_INGRESS_TC_COUNT                   = 0xf
+	DEVLINK_ATTR_SB_EGRESS_TC_COUNT                    = 0x10
+	DEVLINK_ATTR_SB_POOL_INDEX                         = 0x11
+	DEVLINK_ATTR_SB_POOL_TYPE                          = 0x12
+	DEVLINK_ATTR_SB_POOL_SIZE                          = 0x13
+	DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE                = 0x14
+	DEVLINK_ATTR_SB_THRESHOLD                          = 0x15
+	DEVLINK_ATTR_SB_TC_INDEX                           = 0x16
+	DEVLINK_ATTR_SB_OCC_CUR                            = 0x17
+	DEVLINK_ATTR_SB_OCC_MAX                            = 0x18
+	DEVLINK_ATTR_ESWITCH_MODE                          = 0x19
+	DEVLINK_ATTR_ESWITCH_INLINE_MODE                   = 0x1a
+	DEVLINK_ATTR_DPIPE_TABLES                          = 0x1b
+	DEVLINK_ATTR_DPIPE_TABLE                           = 0x1c
+	DEVLINK_ATTR_DPIPE_TABLE_NAME                      = 0x1d
+	DEVLINK_ATTR_DPIPE_TABLE_SIZE                      = 0x1e
+	DEVLINK_ATTR_DPIPE_TABLE_MATCHES                   = 0x1f
+	DEVLINK_ATTR_DPIPE_TABLE_ACTIONS                   = 0x20
+	DEVLINK_ATTR_DPIPE_TABLE_COUNTERS_ENABLED          = 0x21
+	DEVLINK_ATTR_DPIPE_ENTRIES                         = 0x22
+	DEVLINK_ATTR_DPIPE_ENTRY                           = 0x23
+	DEVLINK_ATTR_DPIPE_ENTRY_INDEX                     = 0x24
+	DEVLINK_ATTR_DPIPE_ENTRY_MATCH_VALUES              = 0x25
+	DEVLINK_ATTR_DPIPE_ENTRY_ACTION_VALUES             = 0x26
+	DEVLINK_ATTR_DPIPE_ENTRY_COUNTER                   = 0x27
+	DEVLINK_ATTR_DPIPE_MATCH                           = 0x28
+	DEVLINK_ATTR_DPIPE_MATCH_VALUE                     = 0x29
+	DEVLINK_ATTR_DPIPE_MATCH_TYPE                      = 0x2a
+	DEVLINK_ATTR_DPIPE_ACTION                          = 0x2b
+	DEVLINK_ATTR_DPIPE_ACTION_VALUE                    = 0x2c
+	DEVLINK_ATTR_DPIPE_ACTION_TYPE                     = 0x2d
+	DEVLINK_ATTR_DPIPE_VALUE                           = 0x2e
+	DEVLINK_ATTR_DPIPE_VALUE_MASK                      = 0x2f
+	DEVLINK_ATTR_DPIPE_VALUE_MAPPING                   = 0x30
+	DEVLINK_ATTR_DPIPE_HEADERS                         = 0x31
+	DEVLINK_ATTR_DPIPE_HEADER                          = 0x32
+	DEVLINK_ATTR_DPIPE_HEADER_NAME                     = 0x33
+	DEVLINK_ATTR_DPIPE_HEADER_ID                       = 0x34
+	DEVLINK_ATTR_DPIPE_HEADER_FIELDS                   = 0x35
+	DEVLINK_ATTR_DPIPE_HEADER_GLOBAL                   = 0x36
+	DEVLINK_ATTR_DPIPE_HEADER_INDEX                    = 0x37
+	DEVLINK_ATTR_DPIPE_FIELD                           = 0x38
+	DEVLINK_ATTR_DPIPE_FIELD_NAME                      = 0x39
+	DEVLINK_ATTR_DPIPE_FIELD_ID                        = 0x3a
+	DEVLINK_ATTR_DPIPE_FIELD_BITWIDTH                  = 0x3b
+	DEVLINK_ATTR_DPIPE_FIELD_MAPPING_TYPE              = 0x3c
+	DEVLINK_ATTR_PAD                                   = 0x3d
+	DEVLINK_ATTR_ESWITCH_ENCAP_MODE                    = 0x3e
+	DEVLINK_ATTR_RESOURCE_LIST                         = 0x3f
+	DEVLINK_ATTR_RESOURCE                              = 0x40
+	DEVLINK_ATTR_RESOURCE_NAME                         = 0x41
+	DEVLINK_ATTR_RESOURCE_ID                           = 0x42
+	DEVLINK_ATTR_RESOURCE_SIZE                         = 0x43
+	DEVLINK_ATTR_RESOURCE_SIZE_NEW                     = 0x44
+	DEVLINK_ATTR_RESOURCE_SIZE_VALID                   = 0x45
+	DEVLINK_ATTR_RESOURCE_SIZE_MIN                     = 0x46
+	DEVLINK_ATTR_RESOURCE_SIZE_MAX                     = 0x47
+	DEVLINK_ATTR_RESOURCE_SIZE_GRAN                    = 0x48
+	DEVLINK_ATTR_RESOURCE_UNIT                         = 0x49
+	DEVLINK_ATTR_RESOURCE_OCC                          = 0x4a
+	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_ID               = 0x4b
+	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_UNITS            = 0x4c
+	DEVLINK_ATTR_PORT_FLAVOUR                          = 0x4d
+	DEVLINK_ATTR_PORT_NUMBER                           = 0x4e
+	DEVLINK_ATTR_PORT_SPLIT_SUBPORT_NUMBER             = 0x4f
+	DEVLINK_ATTR_PARAM                                 = 0x50
+	DEVLINK_ATTR_PARAM_NAME                            = 0x51
+	DEVLINK_ATTR_PARAM_GENERIC                         = 0x52
+	DEVLINK_ATTR_PARAM_TYPE                            = 0x53
+	DEVLINK_ATTR_PARAM_VALUES_LIST                     = 0x54
+	DEVLINK_ATTR_PARAM_VALUE                           = 0x55
+	DEVLINK_ATTR_PARAM_VALUE_DATA                      = 0x56
+	DEVLINK_ATTR_PARAM_VALUE_CMODE                     = 0x57
+	DEVLINK_ATTR_REGION_NAME                           = 0x58
+	DEVLINK_ATTR_REGION_SIZE                           = 0x59
+	DEVLINK_ATTR_REGION_SNAPSHOTS                      = 0x5a
+	DEVLINK_ATTR_REGION_SNAPSHOT                       = 0x5b
+	DEVLINK_ATTR_REGION_SNAPSHOT_ID                    = 0x5c
+	DEVLINK_ATTR_REGION_CHUNKS                         = 0x5d
+	DEVLINK_ATTR_REGION_CHUNK                          = 0x5e
+	DEVLINK_ATTR_REGION_CHUNK_DATA                     = 0x5f
+	DEVLINK_ATTR_REGION_CHUNK_ADDR                     = 0x60
+	DEVLINK_ATTR_REGION_CHUNK_LEN                      = 0x61
+	DEVLINK_ATTR_INFO_DRIVER_NAME                      = 0x62
+	DEVLINK_ATTR_INFO_SERIAL_NUMBER                    = 0x63
+	DEVLINK_ATTR_INFO_VERSION_FIXED                    = 0x64
+	DEVLINK_ATTR_INFO_VERSION_RUNNING                  = 0x65
+	DEVLINK_ATTR_INFO_VERSION_STORED                   = 0x66
+	DEVLINK_ATTR_INFO_VERSION_NAME                     = 0x67
+	DEVLINK_ATTR_INFO_VERSION_VALUE                    = 0x68
+	DEVLINK_ATTR_SB_POOL_CELL_SIZE                     = 0x69
+	DEVLINK_ATTR_FMSG                                  = 0x6a
+	DEVLINK_ATTR_FMSG_OBJ_NEST_START                   = 0x6b
+	DEVLINK_ATTR_FMSG_PAIR_NEST_START                  = 0x6c
+	DEVLINK_ATTR_FMSG_ARR_NEST_START                   = 0x6d
+	DEVLINK_ATTR_FMSG_NEST_END                         = 0x6e
+	DEVLINK_ATTR_FMSG_OBJ_NAME                         = 0x6f
+	DEVLINK_ATTR_FMSG_OBJ_VALUE_TYPE                   = 0x70
+	DEVLINK_ATTR_FMSG_OBJ_VALUE_DATA                   = 0x71
+	DEVLINK_ATTR_HEALTH_REPORTER                       = 0x72
+	DEVLINK_ATTR_HEALTH_REPORTER_NAME                  = 0x73
+	DEVLINK_ATTR_HEALTH_REPORTER_STATE                 = 0x74
+	DEVLINK_ATTR_HEALTH_REPORTER_ERR_COUNT             = 0x75
+	DEVLINK_ATTR_HEALTH_REPORTER_RECOVER_COUNT         = 0x76
+	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS               = 0x77
+	DEVLINK_ATTR_HEALTH_REPORTER_GRACEFUL_PERIOD       = 0x78
+	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_RECOVER          = 0x79
+	DEVLINK_ATTR_FLASH_UPDATE_FILE_NAME                = 0x7a
+	DEVLINK_ATTR_FLASH_UPDATE_COMPONENT                = 0x7b
+	DEVLINK_ATTR_FLASH_UPDATE_STATUS_MSG               = 0x7c
+	DEVLINK_ATTR_FLASH_UPDATE_STATUS_DONE              = 0x7d
+	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TOTAL             = 0x7e
+	DEVLINK_ATTR_PORT_PCI_PF_NUMBER                    = 0x7f
+	DEVLINK_ATTR_PORT_PCI_VF_NUMBER                    = 0x80
+	DEVLINK_ATTR_STATS                                 = 0x81
+	DEVLINK_ATTR_TRAP_NAME                             = 0x82
+	DEVLINK_ATTR_TRAP_ACTION                           = 0x83
+	DEVLINK_ATTR_TRAP_TYPE                             = 0x84
+	DEVLINK_ATTR_TRAP_GENERIC                          = 0x85
+	DEVLINK_ATTR_TRAP_METADATA                         = 0x86
+	DEVLINK_ATTR_TRAP_GROUP_NAME                       = 0x87
+	DEVLINK_ATTR_RELOAD_FAILED                         = 0x88
+	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS_NS            = 0x89
+	DEVLINK_ATTR_NETNS_FD                              = 0x8a
+	DEVLINK_ATTR_NETNS_PID                             = 0x8b
+	DEVLINK_ATTR_NETNS_ID                              = 0x8c
+	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_DUMP             = 0x8d
+	DEVLINK_ATTR_TRAP_POLICER_ID                       = 0x8e
+	DEVLINK_ATTR_TRAP_POLICER_RATE                     = 0x8f
+	DEVLINK_ATTR_TRAP_POLICER_BURST                    = 0x90
+	DEVLINK_ATTR_PORT_FUNCTION                         = 0x91
+	DEVLINK_ATTR_INFO_BOARD_SERIAL_NUMBER              = 0x92
+	DEVLINK_ATTR_PORT_LANES                            = 0x93
+	DEVLINK_ATTR_PORT_SPLITTABLE                       = 0x94
+	DEVLINK_ATTR_PORT_EXTERNAL                         = 0x95
+	DEVLINK_ATTR_PORT_CONTROLLER_NUMBER                = 0x96
+	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TIMEOUT           = 0x97
+	DEVLINK_ATTR_FLASH_UPDATE_OVERWRITE_MASK           = 0x98
+	DEVLINK_ATTR_RELOAD_ACTION                         = 0x99
+	DEVLINK_ATTR_RELOAD_ACTIONS_PERFORMED              = 0x9a
+	DEVLINK_ATTR_RELOAD_LIMITS                         = 0x9b
+	DEVLINK_ATTR_DEV_STATS                             = 0x9c
+	DEVLINK_ATTR_RELOAD_STATS                          = 0x9d
+	DEVLINK_ATTR_RELOAD_STATS_ENTRY                    = 0x9e
+	DEVLINK_ATTR_RELOAD_STATS_LIMIT                    = 0x9f
+	DEVLINK_ATTR_RELOAD_STATS_VALUE                    = 0xa0
+	DEVLINK_ATTR_REMOTE_RELOAD_STATS                   = 0xa1
+	DEVLINK_ATTR_RELOAD_ACTION_INFO                    = 0xa2
+	DEVLINK_ATTR_RELOAD_ACTION_STATS                   = 0xa3
+
+	DEVLINK_ATTR_LINECARD_INDEX              = 0xab
+	DEVLINK_ATTR_LINECARD_STATE              = 0xac
+	DEVLINK_ATTR_LINECARD_TYPE               = 0xad
+	DEVLINK_ATTR_LINECARD_SUPPORTED_TYPES    = 0xae
+	DEVLINK_ATTR_NESTED_DEVLINK              = 0xaf
+	DEVLINK_ATTR_SELFTESTS                   = 0xb0
+	DEVLINK_ATTR_MAX                         = 0xb3
+	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_NONE    = 0x0
+	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX = 0x1
+	DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT     = 0x0
+	DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY   = 0x0
+	DEVLINK_DPIPE_FIELD_ETHERNET_DST_MAC     = 0x0
+	DEVLINK_DPIPE_FIELD_IPV4_DST_IP          = 0x0
+	DEVLINK_DPIPE_FIELD_IPV6_DST_IP          = 0x0
+	DEVLINK_DPIPE_HEADER_ETHERNET            = 0x0
+	DEVLINK_DPIPE_HEADER_IPV4                = 0x1
+	DEVLINK_DPIPE_HEADER_IPV6                = 0x2
+	DEVLINK_RESOURCE_UNIT_ENTRY              = 0x0
+	DEVLINK_PORT_FUNCTION_ATTR_UNSPEC        = 0x0
+	DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR       = 0x1
+
+	DEVLINK_PORT_FN_ATTR_CAPS      = 0x4
+	DEVLINK_PORT_FUNCTION_ATTR_MAX = 0x4
+)
+
+type FsverityDigest struct {
+	Algorithm uint16
+	Size      uint16
+}
+
+type FsverityEnableArg struct {
+	Version        uint32
+	Hash_algorithm uint32
+	Block_size     uint32
+	Salt_size      uint32
+	Salt_ptr       uint64
+	Sig_size       uint32
+	_              uint32
+	Sig_ptr        uint64
+	_              [11]uint64
+}
+
+type Nhmsg struct {
+	Family   uint8
+	Scope    uint8
+	Protocol uint8
+	Resvd    uint8
+	Flags    uint32
+}
+
+type NexthopGrp struct {
+	Id     uint32
+	Weight uint8
+	Resvd1 uint8
+	Resvd2 uint16
+}
+
+const (
+	NHA_UNSPEC     = 0x0
+	NHA_ID         = 0x1
+	NHA_GROUP      = 0x2
+	NHA_GROUP_TYPE = 0x3
+	NHA_BLACKHOLE  = 0x4
+	NHA_OIF        = 0x5
+	NHA_GATEWAY    = 0x6
+	NHA_ENCAP_TYPE = 0x7
+	NHA_ENCAP      = 0x8
+	NHA_GROUPS     = 0x9
+	NHA_MASTER     = 0xa
+)
+
+const (
+	CAN_RAW_FILTER        = 0x1
+	CAN_RAW_ERR_FILTER    = 0x2
+	CAN_RAW_LOOPBACK      = 0x3
+	CAN_RAW_RECV_OWN_MSGS = 0x4
+	CAN_RAW_FD_FRAMES     = 0x5
+	CAN_RAW_JOIN_FILTERS  = 0x6
+)
+
+type WatchdogInfo struct {
+	Options  uint32
+	Version  uint32
+	Identity [32]uint8
+}
+
+type PPSFData struct {
+	Info    PPSKInfo
+	Timeout PPSKTime
+}
+
+type PPSKParams struct {
+	Api_version   int32
+	Mode          int32
+	Assert_off_tu PPSKTime
+	Clear_off_tu  PPSKTime
+}
+
+type PPSKInfo struct {
+	Assert_sequence uint32
+	Clear_sequence  uint32
+	Assert_tu       PPSKTime
+	Clear_tu        PPSKTime
+	Current_mode    int32
+	_               [4]byte
+}
+
+type PPSKTime struct {
+	Sec   int64
+	Nsec  int32
+	Flags uint32
+}
+
+const (
+	PPS_GETPARAMS = 0x400870a1
+	PPS_SETPARAMS = 0x800870a2
+	PPS_GETCAP    = 0x400870a3
+	PPS_FETCH     = 0xc00870a4
+)
+
+const (
+	LWTUNNEL_ENCAP_NONE       = 0x0
+	LWTUNNEL_ENCAP_MPLS       = 0x1
+	LWTUNNEL_ENCAP_IP         = 0x2
+	LWTUNNEL_ENCAP_ILA        = 0x3
+	LWTUNNEL_ENCAP_IP6        = 0x4
+	LWTUNNEL_ENCAP_SEG6       = 0x5
+	LWTUNNEL_ENCAP_BPF        = 0x6
+	LWTUNNEL_ENCAP_SEG6_LOCAL = 0x7
+	LWTUNNEL_ENCAP_RPL        = 0x8
+
+	LWTUNNEL_ENCAP_XFRM = 0xa
+	LWTUNNEL_ENCAP_MAX  = 0xa
+
+	MPLS_IPTUNNEL_UNSPEC = 0x0
+	MPLS_IPTUNNEL_DST    = 0x1
+	MPLS_IPTUNNEL_TTL    = 0x2
+	MPLS_IPTUNNEL_MAX    = 0x2
+)
+
+const (
+	ETHTOOL_ID_UNSPEC                                                       = 0x0
+	ETHTOOL_RX_COPYBREAK                                                    = 0x1
+	ETHTOOL_TX_COPYBREAK                                                    = 0x2
+	ETHTOOL_PFC_PREVENTION_TOUT                                             = 0x3
+	ETHTOOL_TUNABLE_UNSPEC                                                  = 0x0
+	ETHTOOL_TUNABLE_U8                                                      = 0x1
+	ETHTOOL_TUNABLE_U16                                                     = 0x2
+	ETHTOOL_TUNABLE_U32                                                     = 0x3
+	ETHTOOL_TUNABLE_U64                                                     = 0x4
+	ETHTOOL_TUNABLE_STRING                                                  = 0x5
+	ETHTOOL_TUNABLE_S8                                                      = 0x6
+	ETHTOOL_TUNABLE_S16                                                     = 0x7
+	ETHTOOL_TUNABLE_S32                                                     = 0x8
+	ETHTOOL_TUNABLE_S64                                                     = 0x9
+	ETHTOOL_PHY_ID_UNSPEC                                                   = 0x0
+	ETHTOOL_PHY_DOWNSHIFT                                                   = 0x1
+	ETHTOOL_PHY_FAST_LINK_DOWN                                              = 0x2
+	ETHTOOL_PHY_EDPD                                                        = 0x3
+	ETHTOOL_LINK_EXT_STATE_AUTONEG                                          = 0x0
+	ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE                            = 0x1
+	ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH                            = 0x2
+	ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY                             = 0x3
+	ETHTOOL_LINK_EXT_STATE_NO_CABLE                                         = 0x4
+	ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE                                      = 0x5
+	ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE                                     = 0x6
+	ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE                              = 0x7
+	ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED                            = 0x8
+	ETHTOOL_LINK_EXT_STATE_OVERHEAT                                         = 0x9
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED                        = 0x1
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED                           = 0x2
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED                  = 0x3
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE             = 0x4
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE               = 0x5
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD                                     = 0x6
+	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED                 = 0x1
+	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT                    = 0x2
+	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY = 0x3
+	ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT                               = 0x4
+	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK            = 0x1
+	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK               = 0x2
+	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS              = 0x3
+	ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED                      = 0x4
+	ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED                      = 0x5
+	ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS           = 0x1
+	ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE                          = 0x2
+	ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE                          = 0x1
+	ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE                         = 0x2
+	ETHTOOL_FLASH_ALL_REGIONS                                               = 0x0
+	ETHTOOL_F_UNSUPPORTED__BIT                                              = 0x0
+	ETHTOOL_F_WISH__BIT                                                     = 0x1
+	ETHTOOL_F_COMPAT__BIT                                                   = 0x2
+	ETHTOOL_FEC_NONE_BIT                                                    = 0x0
+	ETHTOOL_FEC_AUTO_BIT                                                    = 0x1
+	ETHTOOL_FEC_OFF_BIT                                                     = 0x2
+	ETHTOOL_FEC_RS_BIT                                                      = 0x3
+	ETHTOOL_FEC_BASER_BIT                                                   = 0x4
+	ETHTOOL_FEC_LLRS_BIT                                                    = 0x5
+	ETHTOOL_LINK_MODE_10baseT_Half_BIT                                      = 0x0
+	ETHTOOL_LINK_MODE_10baseT_Full_BIT                                      = 0x1
+	ETHTOOL_LINK_MODE_100baseT_Half_BIT                                     = 0x2
+	ETHTOOL_LINK_MODE_100baseT_Full_BIT                                     = 0x3
+	ETHTOOL_LINK_MODE_1000baseT_Half_BIT                                    = 0x4
+	ETHTOOL_LINK_MODE_1000baseT_Full_BIT                                    = 0x5
+	ETHTOOL_LINK_MODE_Autoneg_BIT                                           = 0x6
+	ETHTOOL_LINK_MODE_TP_BIT                                                = 0x7
+	ETHTOOL_LINK_MODE_AUI_BIT                                               = 0x8
+	ETHTOOL_LINK_MODE_MII_BIT                                               = 0x9
+	ETHTOOL_LINK_MODE_FIBRE_BIT                                             = 0xa
+	ETHTOOL_LINK_MODE_BNC_BIT                                               = 0xb
+	ETHTOOL_LINK_MODE_10000baseT_Full_BIT                                   = 0xc
+	ETHTOOL_LINK_MODE_Pause_BIT                                             = 0xd
+	ETHTOOL_LINK_MODE_Asym_Pause_BIT                                        = 0xe
+	ETHTOOL_LINK_MODE_2500baseX_Full_BIT                                    = 0xf
+	ETHTOOL_LINK_MODE_Backplane_BIT                                         = 0x10
+	ETHTOOL_LINK_MODE_1000baseKX_Full_BIT                                   = 0x11
+	ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT                                 = 0x12
+	ETHTOOL_LINK_MODE_10000baseKR_Full_BIT                                  = 0x13
+	ETHTOOL_LINK_MODE_10000baseR_FEC_BIT                                    = 0x14
+	ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT                                = 0x15
+	ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT                                 = 0x16
+	ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT                                 = 0x17
+	ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT                                 = 0x18
+	ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT                                 = 0x19
+	ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT                                 = 0x1a
+	ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT                                 = 0x1b
+	ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT                                 = 0x1c
+	ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT                                 = 0x1d
+	ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT                                 = 0x1e
+	ETHTOOL_LINK_MODE_25000baseCR_Full_BIT                                  = 0x1f
+	ETHTOOL_LINK_MODE_25000baseKR_Full_BIT                                  = 0x20
+	ETHTOOL_LINK_MODE_25000baseSR_Full_BIT                                  = 0x21
+	ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT                                 = 0x22
+	ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT                                 = 0x23
+	ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT                                = 0x24
+	ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT                                = 0x25
+	ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT                                = 0x26
+	ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT                            = 0x27
+	ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT                                 = 0x28
+	ETHTOOL_LINK_MODE_1000baseX_Full_BIT                                    = 0x29
+	ETHTOOL_LINK_MODE_10000baseCR_Full_BIT                                  = 0x2a
+	ETHTOOL_LINK_MODE_10000baseSR_Full_BIT                                  = 0x2b
+	ETHTOOL_LINK_MODE_10000baseLR_Full_BIT                                  = 0x2c
+	ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT                                 = 0x2d
+	ETHTOOL_LINK_MODE_10000baseER_Full_BIT                                  = 0x2e
+	ETHTOOL_LINK_MODE_2500baseT_Full_BIT                                    = 0x2f
+	ETHTOOL_LINK_MODE_5000baseT_Full_BIT                                    = 0x30
+	ETHTOOL_LINK_MODE_FEC_NONE_BIT                                          = 0x31
+	ETHTOOL_LINK_MODE_FEC_RS_BIT                                            = 0x32
+	ETHTOOL_LINK_MODE_FEC_BASER_BIT                                         = 0x33
+	ETHTOOL_LINK_MODE_50000baseKR_Full_BIT                                  = 0x34
+	ETHTOOL_LINK_MODE_50000baseSR_Full_BIT                                  = 0x35
+	ETHTOOL_LINK_MODE_50000baseCR_Full_BIT                                  = 0x36
+	ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT                            = 0x37
+	ETHTOOL_LINK_MODE_50000baseDR_Full_BIT                                  = 0x38
+	ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT                                = 0x39
+	ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT                                = 0x3a
+	ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT                                = 0x3b
+	ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT                        = 0x3c
+	ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT                                = 0x3d
+	ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT                                = 0x3e
+	ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT                                = 0x3f
+	ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT                        = 0x40
+	ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT                                = 0x41
+	ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT                                = 0x42
+	ETHTOOL_LINK_MODE_100baseT1_Full_BIT                                    = 0x43
+	ETHTOOL_LINK_MODE_1000baseT1_Full_BIT                                   = 0x44
+	ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT                                = 0x45
+	ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT                                = 0x46
+	ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT                        = 0x47
+	ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT                                = 0x48
+	ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT                                = 0x49
+	ETHTOOL_LINK_MODE_FEC_LLRS_BIT                                          = 0x4a
+	ETHTOOL_LINK_MODE_100000baseKR_Full_BIT                                 = 0x4b
+	ETHTOOL_LINK_MODE_100000baseSR_Full_BIT                                 = 0x4c
+	ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT                           = 0x4d
+	ETHTOOL_LINK_MODE_100000baseCR_Full_BIT                                 = 0x4e
+	ETHTOOL_LINK_MODE_100000baseDR_Full_BIT                                 = 0x4f
+	ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT                                = 0x50
+	ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT                                = 0x51
+	ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT                        = 0x52
+	ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT                                = 0x53
+	ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT                                = 0x54
+	ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT                                = 0x55
+	ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT                                = 0x56
+	ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT                        = 0x57
+	ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT                                = 0x58
+	ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT                                = 0x59
+	ETHTOOL_LINK_MODE_100baseFX_Half_BIT                                    = 0x5a
+	ETHTOOL_LINK_MODE_100baseFX_Full_BIT                                    = 0x5b
+
+	ETHTOOL_MSG_USER_NONE          = 0x0
+	ETHTOOL_MSG_STRSET_GET         = 0x1
+	ETHTOOL_MSG_LINKINFO_GET       = 0x2
+	ETHTOOL_MSG_LINKINFO_SET       = 0x3
+	ETHTOOL_MSG_LINKMODES_GET      = 0x4
+	ETHTOOL_MSG_LINKMODES_SET      = 0x5
+	ETHTOOL_MSG_LINKSTATE_GET      = 0x6
+	ETHTOOL_MSG_DEBUG_GET          = 0x7
+	ETHTOOL_MSG_DEBUG_SET          = 0x8
+	ETHTOOL_MSG_WOL_GET            = 0x9
+	ETHTOOL_MSG_WOL_SET            = 0xa
+	ETHTOOL_MSG_FEATURES_GET       = 0xb
+	ETHTOOL_MSG_FEATURES_SET       = 0xc
+	ETHTOOL_MSG_PRIVFLAGS_GET      = 0xd
+	ETHTOOL_MSG_PRIVFLAGS_SET      = 0xe
+	ETHTOOL_MSG_RINGS_GET          = 0xf
+	ETHTOOL_MSG_RINGS_SET          = 0x10
+	ETHTOOL_MSG_CHANNELS_GET       = 0x11
+	ETHTOOL_MSG_CHANNELS_SET       = 0x12
+	ETHTOOL_MSG_COALESCE_GET       = 0x13
+	ETHTOOL_MSG_COALESCE_SET       = 0x14
+	ETHTOOL_MSG_PAUSE_GET          = 0x15
+	ETHTOOL_MSG_PAUSE_SET          = 0x16
+	ETHTOOL_MSG_EEE_GET            = 0x17
+	ETHTOOL_MSG_EEE_SET            = 0x18
+	ETHTOOL_MSG_TSINFO_GET         = 0x19
+	ETHTOOL_MSG_CABLE_TEST_ACT     = 0x1a
+	ETHTOOL_MSG_CABLE_TEST_TDR_ACT = 0x1b
+	ETHTOOL_MSG_TUNNEL_INFO_GET    = 0x1c
+
+	ETHTOOL_MSG_PSE_GET               = 0x24
+	ETHTOOL_MSG_PSE_SET               = 0x25
+	ETHTOOL_MSG_RSS_GET               = 0x26
+	ETHTOOL_MSG_USER_MAX              = 0x2b
+	ETHTOOL_MSG_KERNEL_NONE           = 0x0
+	ETHTOOL_MSG_STRSET_GET_REPLY      = 0x1
+	ETHTOOL_MSG_LINKINFO_GET_REPLY    = 0x2
+	ETHTOOL_MSG_LINKINFO_NTF          = 0x3
+	ETHTOOL_MSG_LINKMODES_GET_REPLY   = 0x4
+	ETHTOOL_MSG_LINKMODES_NTF         = 0x5
+	ETHTOOL_MSG_LINKSTATE_GET_REPLY   = 0x6
+	ETHTOOL_MSG_DEBUG_GET_REPLY       = 0x7
+	ETHTOOL_MSG_DEBUG_NTF             = 0x8
+	ETHTOOL_MSG_WOL_GET_REPLY         = 0x9
+	ETHTOOL_MSG_WOL_NTF               = 0xa
+	ETHTOOL_MSG_FEATURES_GET_REPLY    = 0xb
+	ETHTOOL_MSG_FEATURES_SET_REPLY    = 0xc
+	ETHTOOL_MSG_FEATURES_NTF          = 0xd
+	ETHTOOL_MSG_PRIVFLAGS_GET_REPLY   = 0xe
+	ETHTOOL_MSG_PRIVFLAGS_NTF         = 0xf
+	ETHTOOL_MSG_RINGS_GET_REPLY       = 0x10
+	ETHTOOL_MSG_RINGS_NTF             = 0x11
+	ETHTOOL_MSG_CHANNELS_GET_REPLY    = 0x12
+	ETHTOOL_MSG_CHANNELS_NTF          = 0x13
+	ETHTOOL_MSG_COALESCE_GET_REPLY    = 0x14
+	ETHTOOL_MSG_COALESCE_NTF          = 0x15
+	ETHTOOL_MSG_PAUSE_GET_REPLY       = 0x16
+	ETHTOOL_MSG_PAUSE_NTF             = 0x17
+	ETHTOOL_MSG_EEE_GET_REPLY         = 0x18
+	ETHTOOL_MSG_EEE_NTF               = 0x19
+	ETHTOOL_MSG_TSINFO_GET_REPLY      = 0x1a
+	ETHTOOL_MSG_CABLE_TEST_NTF        = 0x1b
+	ETHTOOL_MSG_CABLE_TEST_TDR_NTF    = 0x1c
+	ETHTOOL_MSG_TUNNEL_INFO_GET_REPLY = 0x1d
+
+	ETHTOOL_MSG_PSE_GET_REPLY              = 0x25
+	ETHTOOL_MSG_RSS_GET_REPLY              = 0x26
+	ETHTOOL_MSG_KERNEL_MAX                 = 0x2b
+	ETHTOOL_A_HEADER_UNSPEC                = 0x0
+	ETHTOOL_A_HEADER_DEV_INDEX             = 0x1
+	ETHTOOL_A_HEADER_DEV_NAME              = 0x2
+	ETHTOOL_A_HEADER_FLAGS                 = 0x3
+	ETHTOOL_A_HEADER_MAX                   = 0x3
+	ETHTOOL_A_BITSET_BIT_UNSPEC            = 0x0
+	ETHTOOL_A_BITSET_BIT_INDEX             = 0x1
+	ETHTOOL_A_BITSET_BIT_NAME              = 0x2
+	ETHTOOL_A_BITSET_BIT_VALUE             = 0x3
+	ETHTOOL_A_BITSET_BIT_MAX               = 0x3
+	ETHTOOL_A_BITSET_BITS_UNSPEC           = 0x0
+	ETHTOOL_A_BITSET_BITS_BIT              = 0x1
+	ETHTOOL_A_BITSET_BITS_MAX              = 0x1
+	ETHTOOL_A_BITSET_UNSPEC                = 0x0
+	ETHTOOL_A_BITSET_NOMASK                = 0x1
+	ETHTOOL_A_BITSET_SIZE                  = 0x2
+	ETHTOOL_A_BITSET_BITS                  = 0x3
+	ETHTOOL_A_BITSET_VALUE                 = 0x4
+	ETHTOOL_A_BITSET_MASK                  = 0x5
+	ETHTOOL_A_BITSET_MAX                   = 0x5
+	ETHTOOL_A_STRING_UNSPEC                = 0x0
+	ETHTOOL_A_STRING_INDEX                 = 0x1
+	ETHTOOL_A_STRING_VALUE                 = 0x2
+	ETHTOOL_A_STRING_MAX                   = 0x2
+	ETHTOOL_A_STRINGS_UNSPEC               = 0x0
+	ETHTOOL_A_STRINGS_STRING               = 0x1
+	ETHTOOL_A_STRINGS_MAX                  = 0x1
+	ETHTOOL_A_STRINGSET_UNSPEC             = 0x0
+	ETHTOOL_A_STRINGSET_ID                 = 0x1
+	ETHTOOL_A_STRINGSET_COUNT              = 0x2
+	ETHTOOL_A_STRINGSET_STRINGS            = 0x3
+	ETHTOOL_A_STRINGSET_MAX                = 0x3
+	ETHTOOL_A_STRINGSETS_UNSPEC            = 0x0
+	ETHTOOL_A_STRINGSETS_STRINGSET         = 0x1
+	ETHTOOL_A_STRINGSETS_MAX               = 0x1
+	ETHTOOL_A_STRSET_UNSPEC                = 0x0
+	ETHTOOL_A_STRSET_HEADER                = 0x1
+	ETHTOOL_A_STRSET_STRINGSETS            = 0x2
+	ETHTOOL_A_STRSET_COUNTS_ONLY           = 0x3
+	ETHTOOL_A_STRSET_MAX                   = 0x3
+	ETHTOOL_A_LINKINFO_UNSPEC              = 0x0
+	ETHTOOL_A_LINKINFO_HEADER              = 0x1
+	ETHTOOL_A_LINKINFO_PORT                = 0x2
+	ETHTOOL_A_LINKINFO_PHYADDR             = 0x3
+	ETHTOOL_A_LINKINFO_TP_MDIX             = 0x4
+	ETHTOOL_A_LINKINFO_TP_MDIX_CTRL        = 0x5
+	ETHTOOL_A_LINKINFO_TRANSCEIVER         = 0x6
+	ETHTOOL_A_LINKINFO_MAX                 = 0x6
+	ETHTOOL_A_LINKMODES_UNSPEC             = 0x0
+	ETHTOOL_A_LINKMODES_HEADER             = 0x1
+	ETHTOOL_A_LINKMODES_AUTONEG            = 0x2
+	ETHTOOL_A_LINKMODES_OURS               = 0x3
+	ETHTOOL_A_LINKMODES_PEER               = 0x4
+	ETHTOOL_A_LINKMODES_SPEED              = 0x5
+	ETHTOOL_A_LINKMODES_DUPLEX             = 0x6
+	ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG   = 0x7
+	ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE = 0x8
+
+	ETHTOOL_A_LINKMODES_RATE_MATCHING = 0xa
+	ETHTOOL_A_LINKMODES_MAX           = 0xa
+	ETHTOOL_A_LINKSTATE_UNSPEC        = 0x0
+	ETHTOOL_A_LINKSTATE_HEADER        = 0x1
+	ETHTOOL_A_LINKSTATE_LINK          = 0x2
+	ETHTOOL_A_LINKSTATE_SQI           = 0x3
+	ETHTOOL_A_LINKSTATE_SQI_MAX       = 0x4
+	ETHTOOL_A_LINKSTATE_EXT_STATE     = 0x5
+	ETHTOOL_A_LINKSTATE_EXT_SUBSTATE  = 0x6
+	ETHTOOL_A_LINKSTATE_EXT_DOWN_CNT  = 0x7
+	ETHTOOL_A_LINKSTATE_MAX           = 0x7
+	ETHTOOL_A_DEBUG_UNSPEC            = 0x0
+	ETHTOOL_A_DEBUG_HEADER            = 0x1
+	ETHTOOL_A_DEBUG_MSGMASK           = 0x2
+	ETHTOOL_A_DEBUG_MAX               = 0x2
+	ETHTOOL_A_WOL_UNSPEC              = 0x0
+	ETHTOOL_A_WOL_HEADER              = 0x1
+	ETHTOOL_A_WOL_MODES               = 0x2
+	ETHTOOL_A_WOL_SOPASS              = 0x3
+	ETHTOOL_A_WOL_MAX                 = 0x3
+	ETHTOOL_A_FEATURES_UNSPEC         = 0x0
+	ETHTOOL_A_FEATURES_HEADER         = 0x1
+	ETHTOOL_A_FEATURES_HW             = 0x2
+	ETHTOOL_A_FEATURES_WANTED         = 0x3
+	ETHTOOL_A_FEATURES_ACTIVE         = 0x4
+	ETHTOOL_A_FEATURES_NOCHANGE       = 0x5
+	ETHTOOL_A_FEATURES_MAX            = 0x5
+	ETHTOOL_A_PRIVFLAGS_UNSPEC        = 0x0
+	ETHTOOL_A_PRIVFLAGS_HEADER        = 0x1
+	ETHTOOL_A_PRIVFLAGS_FLAGS         = 0x2
+	ETHTOOL_A_PRIVFLAGS_MAX           = 0x2
+	ETHTOOL_A_RINGS_UNSPEC            = 0x0
+	ETHTOOL_A_RINGS_HEADER            = 0x1
+	ETHTOOL_A_RINGS_RX_MAX            = 0x2
+	ETHTOOL_A_RINGS_RX_MINI_MAX       = 0x3
+	ETHTOOL_A_RINGS_RX_JUMBO_MAX      = 0x4
+	ETHTOOL_A_RINGS_TX_MAX            = 0x5
+	ETHTOOL_A_RINGS_RX                = 0x6
+	ETHTOOL_A_RINGS_RX_MINI           = 0x7
+	ETHTOOL_A_RINGS_RX_JUMBO          = 0x8
+	ETHTOOL_A_RINGS_TX                = 0x9
+
+	ETHTOOL_A_RINGS_MAX                     = 0x10
+	ETHTOOL_A_CHANNELS_UNSPEC               = 0x0
+	ETHTOOL_A_CHANNELS_HEADER               = 0x1
+	ETHTOOL_A_CHANNELS_RX_MAX               = 0x2
+	ETHTOOL_A_CHANNELS_TX_MAX               = 0x3
+	ETHTOOL_A_CHANNELS_OTHER_MAX            = 0x4
+	ETHTOOL_A_CHANNELS_COMBINED_MAX         = 0x5
+	ETHTOOL_A_CHANNELS_RX_COUNT             = 0x6
+	ETHTOOL_A_CHANNELS_TX_COUNT             = 0x7
+	ETHTOOL_A_CHANNELS_OTHER_COUNT          = 0x8
+	ETHTOOL_A_CHANNELS_COMBINED_COUNT       = 0x9
+	ETHTOOL_A_CHANNELS_MAX                  = 0x9
+	ETHTOOL_A_COALESCE_UNSPEC               = 0x0
+	ETHTOOL_A_COALESCE_HEADER               = 0x1
+	ETHTOOL_A_COALESCE_RX_USECS             = 0x2
+	ETHTOOL_A_COALESCE_RX_MAX_FRAMES        = 0x3
+	ETHTOOL_A_COALESCE_RX_USECS_IRQ         = 0x4
+	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_IRQ    = 0x5
+	ETHTOOL_A_COALESCE_TX_USECS             = 0x6
+	ETHTOOL_A_COALESCE_TX_MAX_FRAMES        = 0x7
+	ETHTOOL_A_COALESCE_TX_USECS_IRQ         = 0x8
+	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_IRQ    = 0x9
+	ETHTOOL_A_COALESCE_STATS_BLOCK_USECS    = 0xa
+	ETHTOOL_A_COALESCE_USE_ADAPTIVE_RX      = 0xb
+	ETHTOOL_A_COALESCE_USE_ADAPTIVE_TX      = 0xc
+	ETHTOOL_A_COALESCE_PKT_RATE_LOW         = 0xd
+	ETHTOOL_A_COALESCE_RX_USECS_LOW         = 0xe
+	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_LOW    = 0xf
+	ETHTOOL_A_COALESCE_TX_USECS_LOW         = 0x10
+	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_LOW    = 0x11
+	ETHTOOL_A_COALESCE_PKT_RATE_HIGH        = 0x12
+	ETHTOOL_A_COALESCE_RX_USECS_HIGH        = 0x13
+	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_HIGH   = 0x14
+	ETHTOOL_A_COALESCE_TX_USECS_HIGH        = 0x15
+	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_HIGH   = 0x16
+	ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL = 0x17
+
+	ETHTOOL_A_COALESCE_MAX                    = 0x1c
+	ETHTOOL_A_PAUSE_UNSPEC                    = 0x0
+	ETHTOOL_A_PAUSE_HEADER                    = 0x1
+	ETHTOOL_A_PAUSE_AUTONEG                   = 0x2
+	ETHTOOL_A_PAUSE_RX                        = 0x3
+	ETHTOOL_A_PAUSE_TX                        = 0x4
+	ETHTOOL_A_PAUSE_STATS                     = 0x5
+	ETHTOOL_A_PAUSE_MAX                       = 0x6
+	ETHTOOL_A_PAUSE_STAT_UNSPEC               = 0x0
+	ETHTOOL_A_PAUSE_STAT_PAD                  = 0x1
+	ETHTOOL_A_PAUSE_STAT_TX_FRAMES            = 0x2
+	ETHTOOL_A_PAUSE_STAT_RX_FRAMES            = 0x3
+	ETHTOOL_A_PAUSE_STAT_MAX                  = 0x3
+	ETHTOOL_A_EEE_UNSPEC                      = 0x0
+	ETHTOOL_A_EEE_HEADER                      = 0x1
+	ETHTOOL_A_EEE_MODES_OURS                  = 0x2
+	ETHTOOL_A_EEE_MODES_PEER                  = 0x3
+	ETHTOOL_A_EEE_ACTIVE                      = 0x4
+	ETHTOOL_A_EEE_ENABLED                     = 0x5
+	ETHTOOL_A_EEE_TX_LPI_ENABLED              = 0x6
+	ETHTOOL_A_EEE_TX_LPI_TIMER                = 0x7
+	ETHTOOL_A_EEE_MAX                         = 0x7
+	ETHTOOL_A_TSINFO_UNSPEC                   = 0x0
+	ETHTOOL_A_TSINFO_HEADER                   = 0x1
+	ETHTOOL_A_TSINFO_TIMESTAMPING             = 0x2
+	ETHTOOL_A_TSINFO_TX_TYPES                 = 0x3
+	ETHTOOL_A_TSINFO_RX_FILTERS               = 0x4
+	ETHTOOL_A_TSINFO_PHC_INDEX                = 0x5
+	ETHTOOL_A_TSINFO_MAX                      = 0x5
+	ETHTOOL_A_CABLE_TEST_UNSPEC               = 0x0
+	ETHTOOL_A_CABLE_TEST_HEADER               = 0x1
+	ETHTOOL_A_CABLE_TEST_MAX                  = 0x1
+	ETHTOOL_A_CABLE_RESULT_CODE_UNSPEC        = 0x0
+	ETHTOOL_A_CABLE_RESULT_CODE_OK            = 0x1
+	ETHTOOL_A_CABLE_RESULT_CODE_OPEN          = 0x2
+	ETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT    = 0x3
+	ETHTOOL_A_CABLE_RESULT_CODE_CROSS_SHORT   = 0x4
+	ETHTOOL_A_CABLE_PAIR_A                    = 0x0
+	ETHTOOL_A_CABLE_PAIR_B                    = 0x1
+	ETHTOOL_A_CABLE_PAIR_C                    = 0x2
+	ETHTOOL_A_CABLE_PAIR_D                    = 0x3
+	ETHTOOL_A_CABLE_RESULT_UNSPEC             = 0x0
+	ETHTOOL_A_CABLE_RESULT_PAIR               = 0x1
+	ETHTOOL_A_CABLE_RESULT_CODE               = 0x2
+	ETHTOOL_A_CABLE_RESULT_MAX                = 0x2
+	ETHTOOL_A_CABLE_FAULT_LENGTH_UNSPEC       = 0x0
+	ETHTOOL_A_CABLE_FAULT_LENGTH_PAIR         = 0x1
+	ETHTOOL_A_CABLE_FAULT_LENGTH_CM           = 0x2
+	ETHTOOL_A_CABLE_FAULT_LENGTH_MAX          = 0x2
+	ETHTOOL_A_CABLE_TEST_NTF_STATUS_UNSPEC    = 0x0
+	ETHTOOL_A_CABLE_TEST_NTF_STATUS_STARTED   = 0x1
+	ETHTOOL_A_CABLE_TEST_NTF_STATUS_COMPLETED = 0x2
+	ETHTOOL_A_CABLE_NEST_UNSPEC               = 0x0
+	ETHTOOL_A_CABLE_NEST_RESULT               = 0x1
+	ETHTOOL_A_CABLE_NEST_FAULT_LENGTH         = 0x2
+	ETHTOOL_A_CABLE_NEST_MAX                  = 0x2
+	ETHTOOL_A_CABLE_TEST_NTF_UNSPEC           = 0x0
+	ETHTOOL_A_CABLE_TEST_NTF_HEADER           = 0x1
+	ETHTOOL_A_CABLE_TEST_NTF_STATUS           = 0x2
+	ETHTOOL_A_CABLE_TEST_NTF_NEST             = 0x3
+	ETHTOOL_A_CABLE_TEST_NTF_MAX              = 0x3
+	ETHTOOL_A_CABLE_TEST_TDR_CFG_UNSPEC       = 0x0
+	ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST        = 0x1
+	ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST         = 0x2
+	ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP         = 0x3
+	ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR         = 0x4
+	ETHTOOL_A_CABLE_TEST_TDR_CFG_MAX          = 0x4
+	ETHTOOL_A_CABLE_TEST_TDR_UNSPEC           = 0x0
+	ETHTOOL_A_CABLE_TEST_TDR_HEADER           = 0x1
+	ETHTOOL_A_CABLE_TEST_TDR_CFG              = 0x2
+	ETHTOOL_A_CABLE_TEST_TDR_MAX              = 0x2
+	ETHTOOL_A_CABLE_AMPLITUDE_UNSPEC          = 0x0
+	ETHTOOL_A_CABLE_AMPLITUDE_PAIR            = 0x1
+	ETHTOOL_A_CABLE_AMPLITUDE_mV              = 0x2
+	ETHTOOL_A_CABLE_AMPLITUDE_MAX             = 0x2
+	ETHTOOL_A_CABLE_PULSE_UNSPEC              = 0x0
+	ETHTOOL_A_CABLE_PULSE_mV                  = 0x1
+	ETHTOOL_A_CABLE_PULSE_MAX                 = 0x1
+	ETHTOOL_A_CABLE_STEP_UNSPEC               = 0x0
+	ETHTOOL_A_CABLE_STEP_FIRST_DISTANCE       = 0x1
+	ETHTOOL_A_CABLE_STEP_LAST_DISTANCE        = 0x2
+	ETHTOOL_A_CABLE_STEP_STEP_DISTANCE        = 0x3
+	ETHTOOL_A_CABLE_STEP_MAX                  = 0x3
+	ETHTOOL_A_CABLE_TDR_NEST_UNSPEC           = 0x0
+	ETHTOOL_A_CABLE_TDR_NEST_STEP             = 0x1
+	ETHTOOL_A_CABLE_TDR_NEST_AMPLITUDE        = 0x2
+	ETHTOOL_A_CABLE_TDR_NEST_PULSE            = 0x3
+	ETHTOOL_A_CABLE_TDR_NEST_MAX              = 0x3
+	ETHTOOL_A_CABLE_TEST_TDR_NTF_UNSPEC       = 0x0
+	ETHTOOL_A_CABLE_TEST_TDR_NTF_HEADER       = 0x1
+	ETHTOOL_A_CABLE_TEST_TDR_NTF_STATUS       = 0x2
+	ETHTOOL_A_CABLE_TEST_TDR_NTF_NEST         = 0x3
+	ETHTOOL_A_CABLE_TEST_TDR_NTF_MAX          = 0x3
+	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN             = 0x0
+	ETHTOOL_UDP_TUNNEL_TYPE_GENEVE            = 0x1
+	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN_GPE         = 0x2
+	ETHTOOL_A_TUNNEL_UDP_ENTRY_UNSPEC         = 0x0
+	ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT           = 0x1
+	ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE           = 0x2
+	ETHTOOL_A_TUNNEL_UDP_ENTRY_MAX            = 0x2
+	ETHTOOL_A_TUNNEL_UDP_TABLE_UNSPEC         = 0x0
+	ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE           = 0x1
+	ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES          = 0x2
+	ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY          = 0x3
+	ETHTOOL_A_TUNNEL_UDP_TABLE_MAX            = 0x3
+	ETHTOOL_A_TUNNEL_UDP_UNSPEC               = 0x0
+	ETHTOOL_A_TUNNEL_UDP_TABLE                = 0x1
+	ETHTOOL_A_TUNNEL_UDP_MAX                  = 0x1
+	ETHTOOL_A_TUNNEL_INFO_UNSPEC              = 0x0
+	ETHTOOL_A_TUNNEL_INFO_HEADER              = 0x1
+	ETHTOOL_A_TUNNEL_INFO_UDP_PORTS           = 0x2
+	ETHTOOL_A_TUNNEL_INFO_MAX                 = 0x2
+)
+
+const SPEED_UNKNOWN = -0x1
+
+type EthtoolDrvinfo struct {
+	Cmd          uint32
+	Driver       [32]byte
+	Version      [32]byte
+	Fw_version   [32]byte
+	Bus_info     [32]byte
+	Erom_version [32]byte
+	Reserved2    [12]byte
+	N_priv_flags uint32
+	N_stats      uint32
+	Testinfo_len uint32
+	Eedump_len   uint32
+	Regdump_len  uint32
+}
+
+type (
+	HIDRawReportDescriptor struct {
+		Size  uint32
+		Value [4096]uint8
+	}
+	HIDRawDevInfo struct {
+		Bustype uint32
+		Vendor  int16
+		Product int16
+	}
+)
+
+const (
+	CLOSE_RANGE_UNSHARE = 0x2
+	CLOSE_RANGE_CLOEXEC = 0x4
+)
+
+const (
+	NLMSGERR_ATTR_MSG    = 0x1
+	NLMSGERR_ATTR_OFFS   = 0x2
+	NLMSGERR_ATTR_COOKIE = 0x3
+)
+
+type (
+	EraseInfo struct {
+		Start  uint32
+		Length uint32
+	}
+	EraseInfo64 struct {
+		Start  uint64
+		Length uint64
+	}
+	MtdOobBuf struct {
+		Start  uint32
+		Length uint32
+		Ptr    *uint8
+	}
+	MtdOobBuf64 struct {
+		Start  uint64
+		Pad    uint32
+		Length uint32
+		Ptr    uint64
+	}
+	MtdWriteReq struct {
+		Start  uint64
+		Len    uint64
+		Ooblen uint64
+		Data   uint64
+		Oob    uint64
+		Mode   uint8
+		_      [7]uint8
+	}
+	MtdInfo struct {
+		Type      uint8
+		Flags     uint32
+		Size      uint32
+		Erasesize uint32
+		Writesize uint32
+		Oobsize   uint32
+		_         uint64
+	}
+	RegionInfo struct {
+		Offset      uint32
+		Erasesize   uint32
+		Numblocks   uint32
+		Regionindex uint32
+	}
+	OtpInfo struct {
+		Start  uint32
+		Length uint32
+		Locked uint32
+	}
+	NandOobinfo struct {
+		Useecc   uint32
+		Eccbytes uint32
+		Oobfree  [8][2]uint32
+		Eccpos   [32]uint32
+	}
+	NandOobfree struct {
+		Offset uint32
+		Length uint32
+	}
+	NandEcclayout struct {
+		Eccbytes uint32
+		Eccpos   [64]uint32
+		Oobavail uint32
+		Oobfree  [8]NandOobfree
+	}
+	MtdEccStats struct {
+		Corrected uint32
+		Failed    uint32
+		Badblocks uint32
+		Bbtblocks uint32
+	}
+)
+
+const (
+	MTD_OPS_PLACE_OOB = 0x0
+	MTD_OPS_AUTO_OOB  = 0x1
+	MTD_OPS_RAW       = 0x2
+)
+
+const (
+	MTD_FILE_MODE_NORMAL      = 0x0
+	MTD_FILE_MODE_OTP_FACTORY = 0x1
+	MTD_FILE_MODE_OTP_USER    = 0x2
+	MTD_FILE_MODE_RAW         = 0x3
+)
+
+const (
+	NFC_CMD_UNSPEC                    = 0x0
+	NFC_CMD_GET_DEVICE                = 0x1
+	NFC_CMD_DEV_UP                    = 0x2
+	NFC_CMD_DEV_DOWN                  = 0x3
+	NFC_CMD_DEP_LINK_UP               = 0x4
+	NFC_CMD_DEP_LINK_DOWN             = 0x5
+	NFC_CMD_START_POLL                = 0x6
+	NFC_CMD_STOP_POLL                 = 0x7
+	NFC_CMD_GET_TARGET                = 0x8
+	NFC_EVENT_TARGETS_FOUND           = 0x9
+	NFC_EVENT_DEVICE_ADDED            = 0xa
+	NFC_EVENT_DEVICE_REMOVED          = 0xb
+	NFC_EVENT_TARGET_LOST             = 0xc
+	NFC_EVENT_TM_ACTIVATED            = 0xd
+	NFC_EVENT_TM_DEACTIVATED          = 0xe
+	NFC_CMD_LLC_GET_PARAMS            = 0xf
+	NFC_CMD_LLC_SET_PARAMS            = 0x10
+	NFC_CMD_ENABLE_SE                 = 0x11
+	NFC_CMD_DISABLE_SE                = 0x12
+	NFC_CMD_LLC_SDREQ                 = 0x13
+	NFC_EVENT_LLC_SDRES               = 0x14
+	NFC_CMD_FW_DOWNLOAD               = 0x15
+	NFC_EVENT_SE_ADDED                = 0x16
+	NFC_EVENT_SE_REMOVED              = 0x17
+	NFC_EVENT_SE_CONNECTIVITY         = 0x18
+	NFC_EVENT_SE_TRANSACTION          = 0x19
+	NFC_CMD_GET_SE                    = 0x1a
+	NFC_CMD_SE_IO                     = 0x1b
+	NFC_CMD_ACTIVATE_TARGET           = 0x1c
+	NFC_CMD_VENDOR                    = 0x1d
+	NFC_CMD_DEACTIVATE_TARGET         = 0x1e
+	NFC_ATTR_UNSPEC                   = 0x0
+	NFC_ATTR_DEVICE_INDEX             = 0x1
+	NFC_ATTR_DEVICE_NAME              = 0x2
+	NFC_ATTR_PROTOCOLS                = 0x3
+	NFC_ATTR_TARGET_INDEX             = 0x4
+	NFC_ATTR_TARGET_SENS_RES          = 0x5
+	NFC_ATTR_TARGET_SEL_RES           = 0x6
+	NFC_ATTR_TARGET_NFCID1            = 0x7
+	NFC_ATTR_TARGET_SENSB_RES         = 0x8
+	NFC_ATTR_TARGET_SENSF_RES         = 0x9
+	NFC_ATTR_COMM_MODE                = 0xa
+	NFC_ATTR_RF_MODE                  = 0xb
+	NFC_ATTR_DEVICE_POWERED           = 0xc
+	NFC_ATTR_IM_PROTOCOLS             = 0xd
+	NFC_ATTR_TM_PROTOCOLS             = 0xe
+	NFC_ATTR_LLC_PARAM_LTO            = 0xf
+	NFC_ATTR_LLC_PARAM_RW             = 0x10
+	NFC_ATTR_LLC_PARAM_MIUX           = 0x11
+	NFC_ATTR_SE                       = 0x12
+	NFC_ATTR_LLC_SDP                  = 0x13
+	NFC_ATTR_FIRMWARE_NAME            = 0x14
+	NFC_ATTR_SE_INDEX                 = 0x15
+	NFC_ATTR_SE_TYPE                  = 0x16
+	NFC_ATTR_SE_AID                   = 0x17
+	NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS = 0x18
+	NFC_ATTR_SE_APDU                  = 0x19
+	NFC_ATTR_TARGET_ISO15693_DSFID    = 0x1a
+	NFC_ATTR_TARGET_ISO15693_UID      = 0x1b
+	NFC_ATTR_SE_PARAMS                = 0x1c
+	NFC_ATTR_VENDOR_ID                = 0x1d
+	NFC_ATTR_VENDOR_SUBCMD            = 0x1e
+	NFC_ATTR_VENDOR_DATA              = 0x1f
+	NFC_SDP_ATTR_UNSPEC               = 0x0
+	NFC_SDP_ATTR_URI                  = 0x1
+	NFC_SDP_ATTR_SAP                  = 0x2
+)
+
+type LandlockRulesetAttr struct{}
+
+type LandlockPathBeneathAttr struct{}
+
+const (
+	PIDFD_NONBLOCK = 0x4
+)
+
+type SysvIpcPerm struct {
+	Key  int32
+	Uid  uint32
+	Gid  uint32
+	Cuid uint32
+	Cgid uint32
+	Mode uint32
+	_    [0]uint8
+	Seq  uint16
+	_    uint16
+	_    uint64
+	_    uint64
+}
+type SysvShmDesc struct {
+	Perm   SysvIpcPerm
+	Segsz  uint64
+	Atime  int64
+	Dtime  int64
+	Ctime  int64
+	Cpid   int32
+	Lpid   int32
+	Nattch uint64
+	_      uint64
+	_      uint64
+}
+
+const (
+	IPC_CREAT   = 0x200
+	IPC_EXCL    = 0x400
+	IPC_NOWAIT  = 0x800
+	IPC_PRIVATE = 0x0
+
+	ipc_64 = 0x100
+)
+
+const (
+	IPC_RMID = 0x0
+	IPC_SET  = 0x1
+	IPC_STAT = 0x2
+)
+
+const (
+	SHM_RDONLY = 0x1000
+	SHM_RND    = 0x2000
+)
+
+type MountAttr struct {
+	Attr_set    uint64
+	Attr_clr    uint64
+	Propagation uint64
+	Userns_fd   uint64
+}
+
+const (
+	WG_CMD_GET_DEVICE                      = 0x0
+	WG_CMD_SET_DEVICE                      = 0x1
+	WGDEVICE_F_REPLACE_PEERS               = 0x1
+	WGDEVICE_A_UNSPEC                      = 0x0
+	WGDEVICE_A_IFINDEX                     = 0x1
+	WGDEVICE_A_IFNAME                      = 0x2
+	WGDEVICE_A_PRIVATE_KEY                 = 0x3
+	WGDEVICE_A_PUBLIC_KEY                  = 0x4
+	WGDEVICE_A_FLAGS                       = 0x5
+	WGDEVICE_A_LISTEN_PORT                 = 0x6
+	WGDEVICE_A_FWMARK                      = 0x7
+	WGDEVICE_A_PEERS                       = 0x8
+	WGPEER_F_REMOVE_ME                     = 0x1
+	WGPEER_F_REPLACE_ALLOWEDIPS            = 0x2
+	WGPEER_F_UPDATE_ONLY                   = 0x4
+	WGPEER_A_UNSPEC                        = 0x0
+	WGPEER_A_PUBLIC_KEY                    = 0x1
+	WGPEER_A_PRESHARED_KEY                 = 0x2
+	WGPEER_A_FLAGS                         = 0x3
+	WGPEER_A_ENDPOINT                      = 0x4
+	WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL = 0x5
+	WGPEER_A_LAST_HANDSHAKE_TIME           = 0x6
+	WGPEER_A_RX_BYTES                      = 0x7
+	WGPEER_A_TX_BYTES                      = 0x8
+	WGPEER_A_ALLOWEDIPS                    = 0x9
+	WGPEER_A_PROTOCOL_VERSION              = 0xa
+	WGALLOWEDIP_A_UNSPEC                   = 0x0
+	WGALLOWEDIP_A_FAMILY                   = 0x1
+	WGALLOWEDIP_A_IPADDR                   = 0x2
+	WGALLOWEDIP_A_CIDR_MASK                = 0x3
+)
+
+const (
+	NL_ATTR_TYPE_INVALID      = 0x0
+	NL_ATTR_TYPE_FLAG         = 0x1
+	NL_ATTR_TYPE_U8           = 0x2
+	NL_ATTR_TYPE_U16          = 0x3
+	NL_ATTR_TYPE_U32          = 0x4
+	NL_ATTR_TYPE_U64          = 0x5
+	NL_ATTR_TYPE_S8           = 0x6
+	NL_ATTR_TYPE_S16          = 0x7
+	NL_ATTR_TYPE_S32          = 0x8
+	NL_ATTR_TYPE_S64          = 0x9
+	NL_ATTR_TYPE_BINARY       = 0xa
+	NL_ATTR_TYPE_STRING       = 0xb
+	NL_ATTR_TYPE_NUL_STRING   = 0xc
+	NL_ATTR_TYPE_NESTED       = 0xd
+	NL_ATTR_TYPE_NESTED_ARRAY = 0xe
+	NL_ATTR_TYPE_BITFIELD32   = 0xf
+
+	NL_POLICY_TYPE_ATTR_UNSPEC          = 0x0
+	NL_POLICY_TYPE_ATTR_TYPE            = 0x1
+	NL_POLICY_TYPE_ATTR_MIN_VALUE_S     = 0x2
+	NL_POLICY_TYPE_ATTR_MAX_VALUE_S     = 0x3
+	NL_POLICY_TYPE_ATTR_MIN_VALUE_U     = 0x4
+	NL_POLICY_TYPE_ATTR_MAX_VALUE_U     = 0x5
+	NL_POLICY_TYPE_ATTR_MIN_LENGTH      = 0x6
+	NL_POLICY_TYPE_ATTR_MAX_LENGTH      = 0x7
+	NL_POLICY_TYPE_ATTR_POLICY_IDX      = 0x8
+	NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE  = 0x9
+	NL_POLICY_TYPE_ATTR_BITFIELD32_MASK = 0xa
+	NL_POLICY_TYPE_ATTR_PAD             = 0xb
+	NL_POLICY_TYPE_ATTR_MASK            = 0xc
+	NL_POLICY_TYPE_ATTR_MAX             = 0xc
+)
+
+type CANBitTiming struct {
+	Bitrate      uint32
+	Sample_point uint32
+	Tq           uint32
+	Prop_seg     uint32
+	Phase_seg1   uint32
+	Phase_seg2   uint32
+	Sjw          uint32
+	Brp          uint32
+}
+
+type CANBitTimingConst struct {
+	Name      [16]uint8
+	Tseg1_min uint32
+	Tseg1_max uint32
+	Tseg2_min uint32
+	Tseg2_max uint32
+	Sjw_max   uint32
+	Brp_min   uint32
+	Brp_max   uint32
+	Brp_inc   uint32
+}
+
+type CANClock struct {
+	Freq uint32
+}
+
+type CANBusErrorCounters struct {
+	Txerr uint16
+	Rxerr uint16
+}
+
+type CANCtrlMode struct {
+	Mask  uint32
+	Flags uint32
+}
+
+type CANDeviceStats struct {
+	Bus_error        uint32
+	Error_warning    uint32
+	Error_passive    uint32
+	Bus_off          uint32
+	Arbitration_lost uint32
+	Restarts         uint32
+}
+
+const (
+	CAN_STATE_ERROR_ACTIVE  = 0x0
+	CAN_STATE_ERROR_WARNING = 0x1
+	CAN_STATE_ERROR_PASSIVE = 0x2
+	CAN_STATE_BUS_OFF       = 0x3
+	CAN_STATE_STOPPED       = 0x4
+	CAN_STATE_SLEEPING      = 0x5
+	CAN_STATE_MAX           = 0x6
+)
+
+const (
+	IFLA_CAN_UNSPEC               = 0x0
+	IFLA_CAN_BITTIMING            = 0x1
+	IFLA_CAN_BITTIMING_CONST      = 0x2
+	IFLA_CAN_CLOCK                = 0x3
+	IFLA_CAN_STATE                = 0x4
+	IFLA_CAN_CTRLMODE             = 0x5
+	IFLA_CAN_RESTART_MS           = 0x6
+	IFLA_CAN_RESTART              = 0x7
+	IFLA_CAN_BERR_COUNTER         = 0x8
+	IFLA_CAN_DATA_BITTIMING       = 0x9
+	IFLA_CAN_DATA_BITTIMING_CONST = 0xa
+	IFLA_CAN_TERMINATION          = 0xb
+	IFLA_CAN_TERMINATION_CONST    = 0xc
+	IFLA_CAN_BITRATE_CONST        = 0xd
+	IFLA_CAN_DATA_BITRATE_CONST   = 0xe
+	IFLA_CAN_BITRATE_MAX          = 0xf
+)
+
+type KCMAttach struct {
+	Fd     int32
+	Bpf_fd int32
+}
+
+type KCMUnattach struct {
+	Fd int32
+}
+
+type KCMClone struct {
+	Fd int32
+}
+
+const (
+	NL80211_AC_BE                                = 0x2
+	NL80211_AC_BK                                = 0x3
+	NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED      = 0x0
+	NL80211_ACL_POLICY_DENY_UNLESS_LISTED        = 0x1
+	NL80211_AC_VI                                = 0x1
+	NL80211_AC_VO                                = 0x0
+	NL80211_AP_SETTINGS_EXTERNAL_AUTH_SUPPORT    = 0x1
+	NL80211_AP_SETTINGS_SA_QUERY_OFFLOAD_SUPPORT = 0x2
+	NL80211_AP_SME_SA_QUERY_OFFLOAD              = 0x1
+	NL80211_ATTR_4ADDR                           = 0x53
+	NL80211_ATTR_ACK                             = 0x5c
+	NL80211_ATTR_ACK_SIGNAL                      = 0x107
+	NL80211_ATTR_ACL_POLICY                      = 0xa5
+	NL80211_ATTR_ADMITTED_TIME                   = 0xd4
+	NL80211_ATTR_AIRTIME_WEIGHT                  = 0x112
+	NL80211_ATTR_AKM_SUITES                      = 0x4c
+	NL80211_ATTR_AP_ISOLATE                      = 0x60
+	NL80211_ATTR_AP_SETTINGS_FLAGS               = 0x135
+	NL80211_ATTR_AUTH_DATA                       = 0x9c
+	NL80211_ATTR_AUTH_TYPE                       = 0x35
+	NL80211_ATTR_BANDS                           = 0xef
+	NL80211_ATTR_BEACON_HEAD                     = 0xe
+	NL80211_ATTR_BEACON_INTERVAL                 = 0xc
+	NL80211_ATTR_BEACON_TAIL                     = 0xf
+	NL80211_ATTR_BG_SCAN_PERIOD                  = 0x98
+	NL80211_ATTR_BSS_BASIC_RATES                 = 0x24
+	NL80211_ATTR_BSS                             = 0x2f
+	NL80211_ATTR_BSS_CTS_PROT                    = 0x1c
+	NL80211_ATTR_BSS_HT_OPMODE                   = 0x6d
+	NL80211_ATTR_BSSID                           = 0xf5
+	NL80211_ATTR_BSS_SELECT                      = 0xe3
+	NL80211_ATTR_BSS_SHORT_PREAMBLE              = 0x1d
+	NL80211_ATTR_BSS_SHORT_SLOT_TIME             = 0x1e
+	NL80211_ATTR_CENTER_FREQ1                    = 0xa0
+	NL80211_ATTR_CENTER_FREQ1_OFFSET             = 0x123
+	NL80211_ATTR_CENTER_FREQ2                    = 0xa1
+	NL80211_ATTR_CHANNEL_WIDTH                   = 0x9f
+	NL80211_ATTR_CH_SWITCH_BLOCK_TX              = 0xb8
+	NL80211_ATTR_CH_SWITCH_COUNT                 = 0xb7
+	NL80211_ATTR_CIPHER_SUITE_GROUP              = 0x4a
+	NL80211_ATTR_CIPHER_SUITES                   = 0x39
+	NL80211_ATTR_CIPHER_SUITES_PAIRWISE          = 0x49
+	NL80211_ATTR_CNTDWN_OFFS_BEACON              = 0xba
+	NL80211_ATTR_CNTDWN_OFFS_PRESP               = 0xbb
+	NL80211_ATTR_COALESCE_RULE                   = 0xb6
+	NL80211_ATTR_COALESCE_RULE_CONDITION         = 0x2
+	NL80211_ATTR_COALESCE_RULE_DELAY             = 0x1
+	NL80211_ATTR_COALESCE_RULE_MAX               = 0x3
+	NL80211_ATTR_COALESCE_RULE_PKT_PATTERN       = 0x3
+	NL80211_ATTR_COLOR_CHANGE_COLOR              = 0x130
+	NL80211_ATTR_COLOR_CHANGE_COUNT              = 0x12f
+	NL80211_ATTR_COLOR_CHANGE_ELEMS              = 0x131
+	NL80211_ATTR_CONN_FAILED_REASON              = 0x9b
+	NL80211_ATTR_CONTROL_PORT                    = 0x44
+	NL80211_ATTR_CONTROL_PORT_ETHERTYPE          = 0x66
+	NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT         = 0x67
+	NL80211_ATTR_CONTROL_PORT_NO_PREAUTH         = 0x11e
+	NL80211_ATTR_CONTROL_PORT_OVER_NL80211       = 0x108
+	NL80211_ATTR_COOKIE                          = 0x58
+	NL80211_ATTR_CQM_BEACON_LOSS_EVENT           = 0x8
+	NL80211_ATTR_CQM                             = 0x5e
+	NL80211_ATTR_CQM_MAX                         = 0x9
+	NL80211_ATTR_CQM_PKT_LOSS_EVENT              = 0x4
+	NL80211_ATTR_CQM_RSSI_HYST                   = 0x2
+	NL80211_ATTR_CQM_RSSI_LEVEL                  = 0x9
+	NL80211_ATTR_CQM_RSSI_THOLD                  = 0x1
+	NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT        = 0x3
+	NL80211_ATTR_CQM_TXE_INTVL                   = 0x7
+	NL80211_ATTR_CQM_TXE_PKTS                    = 0x6
+	NL80211_ATTR_CQM_TXE_RATE                    = 0x5
+	NL80211_ATTR_CRIT_PROT_ID                    = 0xb3
+	NL80211_ATTR_CSA_C_OFF_BEACON                = 0xba
+	NL80211_ATTR_CSA_C_OFF_PRESP                 = 0xbb
+	NL80211_ATTR_CSA_C_OFFSETS_TX                = 0xcd
+	NL80211_ATTR_CSA_IES                         = 0xb9
+	NL80211_ATTR_DEVICE_AP_SME                   = 0x8d
+	NL80211_ATTR_DFS_CAC_TIME                    = 0x7
+	NL80211_ATTR_DFS_REGION                      = 0x92
+	NL80211_ATTR_DISABLE_EHT                     = 0x137
+
+	NL80211_ATTR_DISABLE_HT                     = 0x93
+	NL80211_ATTR_DISABLE_VHT                    = 0xaf
+	NL80211_ATTR_DISCONNECTED_BY_AP             = 0x47
+	NL80211_ATTR_DONT_WAIT_FOR_ACK              = 0x8e
+	NL80211_ATTR_DTIM_PERIOD                    = 0xd
+	NL80211_ATTR_DURATION                       = 0x57
+	NL80211_ATTR_EHT_CAPABILITY                 = 0x136
+	NL80211_ATTR_EML_CAPABILITY                 = 0x13d
+	NL80211_ATTR_EXT_CAPA                       = 0xa9
+	NL80211_ATTR_EXT_CAPA_MASK                  = 0xaa
+	NL80211_ATTR_EXTERNAL_AUTH_ACTION           = 0x104
+	NL80211_ATTR_EXTERNAL_AUTH_SUPPORT          = 0x105
+	NL80211_ATTR_EXT_FEATURES                   = 0xd9
+	NL80211_ATTR_FEATURE_FLAGS                  = 0x8f
+	NL80211_ATTR_FILS_CACHE_ID                  = 0xfd
+	NL80211_ATTR_FILS_DISCOVERY                 = 0x126
+	NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM          = 0xfb
+	NL80211_ATTR_FILS_ERP_REALM                 = 0xfa
+	NL80211_ATTR_FILS_ERP_RRK                   = 0xfc
+	NL80211_ATTR_FILS_ERP_USERNAME              = 0xf9
+	NL80211_ATTR_FILS_KEK                       = 0xf2
+	NL80211_ATTR_FILS_NONCES                    = 0xf3
+	NL80211_ATTR_FRAME                          = 0x33
+	NL80211_ATTR_FRAME_MATCH                    = 0x5b
+	NL80211_ATTR_FRAME_TYPE                     = 0x65
+	NL80211_ATTR_FREQ_AFTER                     = 0x3b
+	NL80211_ATTR_FREQ_BEFORE                    = 0x3a
+	NL80211_ATTR_FREQ_FIXED                     = 0x3c
+	NL80211_ATTR_FREQ_RANGE_END                 = 0x3
+	NL80211_ATTR_FREQ_RANGE_MAX_BW              = 0x4
+	NL80211_ATTR_FREQ_RANGE_START               = 0x2
+	NL80211_ATTR_FTM_RESPONDER                  = 0x10e
+	NL80211_ATTR_FTM_RESPONDER_STATS            = 0x10f
+	NL80211_ATTR_GENERATION                     = 0x2e
+	NL80211_ATTR_HANDLE_DFS                     = 0xbf
+	NL80211_ATTR_HE_6GHZ_CAPABILITY             = 0x125
+	NL80211_ATTR_HE_BSS_COLOR                   = 0x11b
+	NL80211_ATTR_HE_CAPABILITY                  = 0x10d
+	NL80211_ATTR_HE_OBSS_PD                     = 0x117
+	NL80211_ATTR_HIDDEN_SSID                    = 0x7e
+	NL80211_ATTR_HT_CAPABILITY                  = 0x1f
+	NL80211_ATTR_HT_CAPABILITY_MASK             = 0x94
+	NL80211_ATTR_IE_ASSOC_RESP                  = 0x80
+	NL80211_ATTR_IE                             = 0x2a
+	NL80211_ATTR_IE_PROBE_RESP                  = 0x7f
+	NL80211_ATTR_IE_RIC                         = 0xb2
+	NL80211_ATTR_IFACE_SOCKET_OWNER             = 0xcc
+	NL80211_ATTR_IFINDEX                        = 0x3
+	NL80211_ATTR_IFNAME                         = 0x4
+	NL80211_ATTR_IFTYPE_AKM_SUITES              = 0x11c
+	NL80211_ATTR_IFTYPE                         = 0x5
+	NL80211_ATTR_IFTYPE_EXT_CAPA                = 0xe6
+	NL80211_ATTR_INACTIVITY_TIMEOUT             = 0x96
+	NL80211_ATTR_INTERFACE_COMBINATIONS         = 0x78
+	NL80211_ATTR_KEY_CIPHER                     = 0x9
+	NL80211_ATTR_KEY                            = 0x50
+	NL80211_ATTR_KEY_DATA                       = 0x7
+	NL80211_ATTR_KEY_DEFAULT                    = 0xb
+	NL80211_ATTR_KEY_DEFAULT_MGMT               = 0x28
+	NL80211_ATTR_KEY_DEFAULT_TYPES              = 0x6e
+	NL80211_ATTR_KEY_IDX                        = 0x8
+	NL80211_ATTR_KEYS                           = 0x51
+	NL80211_ATTR_KEY_SEQ                        = 0xa
+	NL80211_ATTR_KEY_TYPE                       = 0x37
+	NL80211_ATTR_LOCAL_MESH_POWER_MODE          = 0xa4
+	NL80211_ATTR_LOCAL_STATE_CHANGE             = 0x5f
+	NL80211_ATTR_MAC_ACL_MAX                    = 0xa7
+	NL80211_ATTR_MAC_ADDRS                      = 0xa6
+	NL80211_ATTR_MAC                            = 0x6
+	NL80211_ATTR_MAC_HINT                       = 0xc8
+	NL80211_ATTR_MAC_MASK                       = 0xd7
+	NL80211_ATTR_MAX_AP_ASSOC_STA               = 0xca
+	NL80211_ATTR_MAX                            = 0x146
+	NL80211_ATTR_MAX_CRIT_PROT_DURATION         = 0xb4
+	NL80211_ATTR_MAX_CSA_COUNTERS               = 0xce
+	NL80211_ATTR_MAX_MATCH_SETS                 = 0x85
+	NL80211_ATTR_MAX_NUM_AKM_SUITES             = 0x13c
+	NL80211_ATTR_MAX_NUM_PMKIDS                 = 0x56
+	NL80211_ATTR_MAX_NUM_SCAN_SSIDS             = 0x2b
+	NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS       = 0xde
+	NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS       = 0x7b
+	NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION = 0x6f
+	NL80211_ATTR_MAX_SCAN_IE_LEN                = 0x38
+	NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL         = 0xdf
+	NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS       = 0xe0
+	NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN          = 0x7c
+	NL80211_ATTR_MBSSID_CONFIG                  = 0x132
+	NL80211_ATTR_MBSSID_ELEMS                   = 0x133
+	NL80211_ATTR_MCAST_RATE                     = 0x6b
+	NL80211_ATTR_MDID                           = 0xb1
+	NL80211_ATTR_MEASUREMENT_DURATION           = 0xeb
+	NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY = 0xec
+	NL80211_ATTR_MESH_CONFIG                    = 0x23
+	NL80211_ATTR_MESH_ID                        = 0x18
+	NL80211_ATTR_MESH_PEER_AID                  = 0xed
+	NL80211_ATTR_MESH_SETUP                     = 0x70
+	NL80211_ATTR_MGMT_SUBTYPE                   = 0x29
+	NL80211_ATTR_MLD_ADDR                       = 0x13a
+	NL80211_ATTR_MLD_CAPA_AND_OPS               = 0x13e
+	NL80211_ATTR_MLO_LINK_ID                    = 0x139
+	NL80211_ATTR_MLO_LINKS                      = 0x138
+	NL80211_ATTR_MLO_SUPPORT                    = 0x13b
+	NL80211_ATTR_MNTR_FLAGS                     = 0x17
+	NL80211_ATTR_MPATH_INFO                     = 0x1b
+	NL80211_ATTR_MPATH_NEXT_HOP                 = 0x1a
+	NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED   = 0xf4
+	NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR        = 0xe8
+	NL80211_ATTR_MU_MIMO_GROUP_DATA             = 0xe7
+	NL80211_ATTR_NAN_FUNC                       = 0xf0
+	NL80211_ATTR_NAN_MASTER_PREF                = 0xee
+	NL80211_ATTR_NAN_MATCH                      = 0xf1
+	NL80211_ATTR_NETNS_FD                       = 0xdb
+	NL80211_ATTR_NOACK_MAP                      = 0x95
+	NL80211_ATTR_NSS                            = 0x106
+	NL80211_ATTR_OBSS_COLOR_BITMAP              = 0x12e
+	NL80211_ATTR_OFFCHANNEL_TX_OK               = 0x6c
+	NL80211_ATTR_OPER_CLASS                     = 0xd6
+	NL80211_ATTR_OPMODE_NOTIF                   = 0xc2
+	NL80211_ATTR_P2P_CTWINDOW                   = 0xa2
+	NL80211_ATTR_P2P_OPPPS                      = 0xa3
+	NL80211_ATTR_PAD                            = 0xe5
+	NL80211_ATTR_PBSS                           = 0xe2
+	NL80211_ATTR_PEER_AID                       = 0xb5
+	NL80211_ATTR_PEER_MEASUREMENTS              = 0x111
+	NL80211_ATTR_PID                            = 0x52
+	NL80211_ATTR_PMK                            = 0xfe
+	NL80211_ATTR_PMKID                          = 0x55
+	NL80211_ATTR_PMK_LIFETIME                   = 0x11f
+	NL80211_ATTR_PMKR0_NAME                     = 0x102
+	NL80211_ATTR_PMK_REAUTH_THRESHOLD           = 0x120
+	NL80211_ATTR_PMKSA_CANDIDATE                = 0x86
+	NL80211_ATTR_PORT_AUTHORIZED                = 0x103
+	NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN        = 0x5
+	NL80211_ATTR_POWER_RULE_MAX_EIRP            = 0x6
+	NL80211_ATTR_PREV_BSSID                     = 0x4f
+	NL80211_ATTR_PRIVACY                        = 0x46
+	NL80211_ATTR_PROBE_RESP                     = 0x91
+	NL80211_ATTR_PROBE_RESP_OFFLOAD             = 0x90
+	NL80211_ATTR_PROTOCOL_FEATURES              = 0xad
+	NL80211_ATTR_PS_STATE                       = 0x5d
+	NL80211_ATTR_QOS_MAP                        = 0xc7
+	NL80211_ATTR_RADAR_BACKGROUND               = 0x134
+	NL80211_ATTR_RADAR_EVENT                    = 0xa8
+	NL80211_ATTR_REASON_CODE                    = 0x36
+	NL80211_ATTR_RECEIVE_MULTICAST              = 0x121
+
+	NL80211_ATTR_REG_ALPHA2          = 0x21
+	NL80211_ATTR_REG_INDOOR          = 0xdd
+	NL80211_ATTR_REG_INITIATOR       = 0x30
+	NL80211_ATTR_REG_RULE_FLAGS      = 0x1
+	NL80211_ATTR_REG_RULES           = 0x22
+	NL80211_ATTR_REG_TYPE            = 0x31
+	NL80211_ATTR_REKEY_DATA          = 0x7a
+	NL80211_ATTR_REQ_IE              = 0x4d
+	NL80211_ATTR_RESP_IE             = 0x4e
+	NL80211_ATTR_ROAM_SUPPORT        = 0x83
+	NL80211_ATTR_RX_FRAME_TYPES      = 0x64
+	NL80211_ATTR_RX_HW_TIMESTAMP     = 0x140
+	NL80211_ATTR_RXMGMT_FLAGS        = 0xbc
+	NL80211_ATTR_RX_SIGNAL_DBM       = 0x97
+	NL80211_ATTR_S1G_CAPABILITY      = 0x128
+	NL80211_ATTR_S1G_CAPABILITY_MASK = 0x129
+	NL80211_ATTR_SAE_DATA            = 0x9c
+	NL80211_ATTR_SAE_PASSWORD        = 0x115
+
+	NL80211_ATTR_SCAN_FLAGS                  = 0x9e
+	NL80211_ATTR_SCAN_FREQ_KHZ               = 0x124
+	NL80211_ATTR_SCAN_FREQUENCIES            = 0x2c
+	NL80211_ATTR_SCAN_GENERATION             = 0x2e
+	NL80211_ATTR_SCAN_SSIDS                  = 0x2d
+	NL80211_ATTR_SCAN_START_TIME_TSF_BSSID   = 0xea
+	NL80211_ATTR_SCAN_START_TIME_TSF         = 0xe9
+	NL80211_ATTR_SCAN_SUPP_RATES             = 0x7d
+	NL80211_ATTR_SCHED_SCAN_DELAY            = 0xdc
+	NL80211_ATTR_SCHED_SCAN_INTERVAL         = 0x77
+	NL80211_ATTR_SCHED_SCAN_MATCH            = 0x84
+	NL80211_ATTR_SCHED_SCAN_MATCH_SSID       = 0x1
+	NL80211_ATTR_SCHED_SCAN_MAX_REQS         = 0x100
+	NL80211_ATTR_SCHED_SCAN_MULTI            = 0xff
+	NL80211_ATTR_SCHED_SCAN_PLANS            = 0xe1
+	NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI    = 0xf6
+	NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST      = 0xf7
+	NL80211_ATTR_SMPS_MODE                   = 0xd5
+	NL80211_ATTR_SOCKET_OWNER                = 0xcc
+	NL80211_ATTR_SOFTWARE_IFTYPES            = 0x79
+	NL80211_ATTR_SPLIT_WIPHY_DUMP            = 0xae
+	NL80211_ATTR_SSID                        = 0x34
+	NL80211_ATTR_STA_AID                     = 0x10
+	NL80211_ATTR_STA_CAPABILITY              = 0xab
+	NL80211_ATTR_STA_EXT_CAPABILITY          = 0xac
+	NL80211_ATTR_STA_FLAGS2                  = 0x43
+	NL80211_ATTR_STA_FLAGS                   = 0x11
+	NL80211_ATTR_STA_INFO                    = 0x15
+	NL80211_ATTR_STA_LISTEN_INTERVAL         = 0x12
+	NL80211_ATTR_STA_PLINK_ACTION            = 0x19
+	NL80211_ATTR_STA_PLINK_STATE             = 0x74
+	NL80211_ATTR_STA_SUPPORTED_CHANNELS      = 0xbd
+	NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES  = 0xbe
+	NL80211_ATTR_STA_SUPPORTED_RATES         = 0x13
+	NL80211_ATTR_STA_SUPPORT_P2P_PS          = 0xe4
+	NL80211_ATTR_STATUS_CODE                 = 0x48
+	NL80211_ATTR_STA_TX_POWER                = 0x114
+	NL80211_ATTR_STA_TX_POWER_SETTING        = 0x113
+	NL80211_ATTR_STA_VLAN                    = 0x14
+	NL80211_ATTR_STA_WME                     = 0x81
+	NL80211_ATTR_SUPPORT_10_MHZ              = 0xc1
+	NL80211_ATTR_SUPPORT_5_MHZ               = 0xc0
+	NL80211_ATTR_SUPPORT_AP_UAPSD            = 0x82
+	NL80211_ATTR_SUPPORTED_COMMANDS          = 0x32
+	NL80211_ATTR_SUPPORTED_IFTYPES           = 0x20
+	NL80211_ATTR_SUPPORT_IBSS_RSN            = 0x68
+	NL80211_ATTR_SUPPORT_MESH_AUTH           = 0x73
+	NL80211_ATTR_SURVEY_INFO                 = 0x54
+	NL80211_ATTR_SURVEY_RADIO_STATS          = 0xda
+	NL80211_ATTR_TD_BITMAP                   = 0x141
+	NL80211_ATTR_TDLS_ACTION                 = 0x88
+	NL80211_ATTR_TDLS_DIALOG_TOKEN           = 0x89
+	NL80211_ATTR_TDLS_EXTERNAL_SETUP         = 0x8c
+	NL80211_ATTR_TDLS_INITIATOR              = 0xcf
+	NL80211_ATTR_TDLS_OPERATION              = 0x8a
+	NL80211_ATTR_TDLS_PEER_CAPABILITY        = 0xcb
+	NL80211_ATTR_TDLS_SUPPORT                = 0x8b
+	NL80211_ATTR_TESTDATA                    = 0x45
+	NL80211_ATTR_TID_CONFIG                  = 0x11d
+	NL80211_ATTR_TIMED_OUT                   = 0x41
+	NL80211_ATTR_TIMEOUT                     = 0x110
+	NL80211_ATTR_TIMEOUT_REASON              = 0xf8
+	NL80211_ATTR_TSID                        = 0xd2
+	NL80211_ATTR_TWT_RESPONDER               = 0x116
+	NL80211_ATTR_TX_FRAME_TYPES              = 0x63
+	NL80211_ATTR_TX_HW_TIMESTAMP             = 0x13f
+	NL80211_ATTR_TX_NO_CCK_RATE              = 0x87
+	NL80211_ATTR_TXQ_LIMIT                   = 0x10a
+	NL80211_ATTR_TXQ_MEMORY_LIMIT            = 0x10b
+	NL80211_ATTR_TXQ_QUANTUM                 = 0x10c
+	NL80211_ATTR_TXQ_STATS                   = 0x109
+	NL80211_ATTR_TX_RATES                    = 0x5a
+	NL80211_ATTR_UNSOL_BCAST_PROBE_RESP      = 0x127
+	NL80211_ATTR_UNSPEC                      = 0x0
+	NL80211_ATTR_USE_MFP                     = 0x42
+	NL80211_ATTR_USER_PRIO                   = 0xd3
+	NL80211_ATTR_USER_REG_HINT_TYPE          = 0x9a
+	NL80211_ATTR_USE_RRM                     = 0xd0
+	NL80211_ATTR_VENDOR_DATA                 = 0xc5
+	NL80211_ATTR_VENDOR_EVENTS               = 0xc6
+	NL80211_ATTR_VENDOR_ID                   = 0xc3
+	NL80211_ATTR_VENDOR_SUBCMD               = 0xc4
+	NL80211_ATTR_VHT_CAPABILITY              = 0x9d
+	NL80211_ATTR_VHT_CAPABILITY_MASK         = 0xb0
+	NL80211_ATTR_VLAN_ID                     = 0x11a
+	NL80211_ATTR_WANT_1X_4WAY_HS             = 0x101
+	NL80211_ATTR_WDEV                        = 0x99
+	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX      = 0x72
+	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX      = 0x71
+	NL80211_ATTR_WIPHY_ANTENNA_RX            = 0x6a
+	NL80211_ATTR_WIPHY_ANTENNA_TX            = 0x69
+	NL80211_ATTR_WIPHY_BANDS                 = 0x16
+	NL80211_ATTR_WIPHY_CHANNEL_TYPE          = 0x27
+	NL80211_ATTR_WIPHY                       = 0x1
+	NL80211_ATTR_WIPHY_COVERAGE_CLASS        = 0x59
+	NL80211_ATTR_WIPHY_DYN_ACK               = 0xd1
+	NL80211_ATTR_WIPHY_EDMG_BW_CONFIG        = 0x119
+	NL80211_ATTR_WIPHY_EDMG_CHANNELS         = 0x118
+	NL80211_ATTR_WIPHY_FRAG_THRESHOLD        = 0x3f
+	NL80211_ATTR_WIPHY_FREQ                  = 0x26
+	NL80211_ATTR_WIPHY_FREQ_HINT             = 0xc9
+	NL80211_ATTR_WIPHY_FREQ_OFFSET           = 0x122
+	NL80211_ATTR_WIPHY_NAME                  = 0x2
+	NL80211_ATTR_WIPHY_RETRY_LONG            = 0x3e
+	NL80211_ATTR_WIPHY_RETRY_SHORT           = 0x3d
+	NL80211_ATTR_WIPHY_RTS_THRESHOLD         = 0x40
+	NL80211_ATTR_WIPHY_SELF_MANAGED_REG      = 0xd8
+	NL80211_ATTR_WIPHY_TX_POWER_LEVEL        = 0x62
+	NL80211_ATTR_WIPHY_TX_POWER_SETTING      = 0x61
+	NL80211_ATTR_WIPHY_TXQ_PARAMS            = 0x25
+	NL80211_ATTR_WOWLAN_TRIGGERS             = 0x75
+	NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED   = 0x76
+	NL80211_ATTR_WPA_VERSIONS                = 0x4b
+	NL80211_AUTHTYPE_AUTOMATIC               = 0x8
+	NL80211_AUTHTYPE_FILS_PK                 = 0x7
+	NL80211_AUTHTYPE_FILS_SK                 = 0x5
+	NL80211_AUTHTYPE_FILS_SK_PFS             = 0x6
+	NL80211_AUTHTYPE_FT                      = 0x2
+	NL80211_AUTHTYPE_MAX                     = 0x7
+	NL80211_AUTHTYPE_NETWORK_EAP             = 0x3
+	NL80211_AUTHTYPE_OPEN_SYSTEM             = 0x0
+	NL80211_AUTHTYPE_SAE                     = 0x4
+	NL80211_AUTHTYPE_SHARED_KEY              = 0x1
+	NL80211_BAND_2GHZ                        = 0x0
+	NL80211_BAND_5GHZ                        = 0x1
+	NL80211_BAND_60GHZ                       = 0x2
+	NL80211_BAND_6GHZ                        = 0x3
+	NL80211_BAND_ATTR_EDMG_BW_CONFIG         = 0xb
+	NL80211_BAND_ATTR_EDMG_CHANNELS          = 0xa
+	NL80211_BAND_ATTR_FREQS                  = 0x1
+	NL80211_BAND_ATTR_HT_AMPDU_DENSITY       = 0x6
+	NL80211_BAND_ATTR_HT_AMPDU_FACTOR        = 0x5
+	NL80211_BAND_ATTR_HT_CAPA                = 0x4
+	NL80211_BAND_ATTR_HT_MCS_SET             = 0x3
+	NL80211_BAND_ATTR_IFTYPE_DATA            = 0x9
+	NL80211_BAND_ATTR_MAX                    = 0xd
+	NL80211_BAND_ATTR_RATES                  = 0x2
+	NL80211_BAND_ATTR_VHT_CAPA               = 0x8
+	NL80211_BAND_ATTR_VHT_MCS_SET            = 0x7
+	NL80211_BAND_IFTYPE_ATTR_EHT_CAP_MAC     = 0x8
+	NL80211_BAND_IFTYPE_ATTR_EHT_CAP_MCS_SET = 0xa
+	NL80211_BAND_IFTYPE_ATTR_EHT_CAP_PHY     = 0x9
+	NL80211_BAND_IFTYPE_ATTR_EHT_CAP_PPE     = 0xb
+	NL80211_BAND_IFTYPE_ATTR_HE_6GHZ_CAPA    = 0x6
+	NL80211_BAND_IFTYPE_ATTR_HE_CAP_MAC      = 0x2
+	NL80211_BAND_IFTYPE_ATTR_HE_CAP_MCS_SET  = 0x4
+	NL80211_BAND_IFTYPE_ATTR_HE_CAP_PHY      = 0x3
+	NL80211_BAND_IFTYPE_ATTR_HE_CAP_PPE      = 0x5
+	NL80211_BAND_IFTYPE_ATTR_IFTYPES         = 0x1
+	NL80211_BAND_IFTYPE_ATTR_MAX             = 0xb
+	NL80211_BAND_IFTYPE_ATTR_VENDOR_ELEMS    = 0x7
+	NL80211_BAND_LC                          = 0x5
+	NL80211_BAND_S1GHZ                       = 0x4
+	NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE  = 0x2
+	NL80211_BITRATE_ATTR_MAX                 = 0x2
+	NL80211_BITRATE_ATTR_RATE                = 0x1
+	NL80211_BSS_BEACON_IES                   = 0xb
+	NL80211_BSS_BEACON_INTERVAL              = 0x4
+	NL80211_BSS_BEACON_TSF                   = 0xd
+	NL80211_BSS_BSSID                        = 0x1
+	NL80211_BSS_CAPABILITY                   = 0x5
+	NL80211_BSS_CHAIN_SIGNAL                 = 0x13
+	NL80211_BSS_CHAN_WIDTH_10                = 0x1
+	NL80211_BSS_CHAN_WIDTH_1                 = 0x3
+	NL80211_BSS_CHAN_WIDTH_20                = 0x0
+	NL80211_BSS_CHAN_WIDTH_2                 = 0x4
+	NL80211_BSS_CHAN_WIDTH_5                 = 0x2
+	NL80211_BSS_CHAN_WIDTH                   = 0xc
+	NL80211_BSS_FREQUENCY                    = 0x2
+	NL80211_BSS_FREQUENCY_OFFSET             = 0x14
+	NL80211_BSS_INFORMATION_ELEMENTS         = 0x6
+	NL80211_BSS_LAST_SEEN_BOOTTIME           = 0xf
+	NL80211_BSS_MAX                          = 0x16
+	NL80211_BSS_MLD_ADDR                     = 0x16
+	NL80211_BSS_MLO_LINK_ID                  = 0x15
+	NL80211_BSS_PAD                          = 0x10
+	NL80211_BSS_PARENT_BSSID                 = 0x12
+	NL80211_BSS_PARENT_TSF                   = 0x11
+	NL80211_BSS_PRESP_DATA                   = 0xe
+	NL80211_BSS_SEEN_MS_AGO                  = 0xa
+	NL80211_BSS_SELECT_ATTR_BAND_PREF        = 0x2
+	NL80211_BSS_SELECT_ATTR_MAX              = 0x3
+	NL80211_BSS_SELECT_ATTR_RSSI_ADJUST      = 0x3
+	NL80211_BSS_SELECT_ATTR_RSSI             = 0x1
+	NL80211_BSS_SIGNAL_MBM                   = 0x7
+	NL80211_BSS_SIGNAL_UNSPEC                = 0x8
+	NL80211_BSS_STATUS_ASSOCIATED            = 0x1
+	NL80211_BSS_STATUS_AUTHENTICATED         = 0x0
+	NL80211_BSS_STATUS                       = 0x9
+	NL80211_BSS_STATUS_IBSS_JOINED           = 0x2
+	NL80211_BSS_TSF                          = 0x3
+	NL80211_CHAN_HT20                        = 0x1
+	NL80211_CHAN_HT40MINUS                   = 0x2
+	NL80211_CHAN_HT40PLUS                    = 0x3
+	NL80211_CHAN_NO_HT                       = 0x0
+	NL80211_CHAN_WIDTH_10                    = 0x7
+	NL80211_CHAN_WIDTH_160                   = 0x5
+	NL80211_CHAN_WIDTH_16                    = 0xc
+	NL80211_CHAN_WIDTH_1                     = 0x8
+	NL80211_CHAN_WIDTH_20                    = 0x1
+	NL80211_CHAN_WIDTH_20_NOHT               = 0x0
+	NL80211_CHAN_WIDTH_2                     = 0x9
+	NL80211_CHAN_WIDTH_320                   = 0xd
+	NL80211_CHAN_WIDTH_40                    = 0x2
+	NL80211_CHAN_WIDTH_4                     = 0xa
+	NL80211_CHAN_WIDTH_5                     = 0x6
+	NL80211_CHAN_WIDTH_80                    = 0x3
+	NL80211_CHAN_WIDTH_80P80                 = 0x4
+	NL80211_CHAN_WIDTH_8                     = 0xb
+	NL80211_CMD_ABORT_SCAN                   = 0x72
+	NL80211_CMD_ACTION                       = 0x3b
+	NL80211_CMD_ACTION_TX_STATUS             = 0x3c
+	NL80211_CMD_ADD_LINK                     = 0x94
+	NL80211_CMD_ADD_LINK_STA                 = 0x96
+	NL80211_CMD_ADD_NAN_FUNCTION             = 0x75
+	NL80211_CMD_ADD_TX_TS                    = 0x69
+	NL80211_CMD_ASSOC_COMEBACK               = 0x93
+	NL80211_CMD_ASSOCIATE                    = 0x26
+	NL80211_CMD_AUTHENTICATE                 = 0x25
+	NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL     = 0x38
+	NL80211_CMD_CHANGE_NAN_CONFIG            = 0x77
+	NL80211_CMD_CHANNEL_SWITCH               = 0x66
+	NL80211_CMD_CH_SWITCH_NOTIFY             = 0x58
+	NL80211_CMD_CH_SWITCH_STARTED_NOTIFY     = 0x6e
+	NL80211_CMD_COLOR_CHANGE_ABORTED         = 0x90
+	NL80211_CMD_COLOR_CHANGE_COMPLETED       = 0x91
+	NL80211_CMD_COLOR_CHANGE_REQUEST         = 0x8e
+	NL80211_CMD_COLOR_CHANGE_STARTED         = 0x8f
+	NL80211_CMD_CONNECT                      = 0x2e
+	NL80211_CMD_CONN_FAILED                  = 0x5b
+	NL80211_CMD_CONTROL_PORT_FRAME           = 0x81
+	NL80211_CMD_CONTROL_PORT_FRAME_TX_STATUS = 0x8b
+	NL80211_CMD_CRIT_PROTOCOL_START          = 0x62
+	NL80211_CMD_CRIT_PROTOCOL_STOP           = 0x63
+	NL80211_CMD_DEAUTHENTICATE               = 0x27
+	NL80211_CMD_DEL_BEACON                   = 0x10
+	NL80211_CMD_DEL_INTERFACE                = 0x8
+	NL80211_CMD_DEL_KEY                      = 0xc
+	NL80211_CMD_DEL_MPATH                    = 0x18
+	NL80211_CMD_DEL_NAN_FUNCTION             = 0x76
+	NL80211_CMD_DEL_PMK                      = 0x7c
+	NL80211_CMD_DEL_PMKSA                    = 0x35
+	NL80211_CMD_DEL_STATION                  = 0x14
+	NL80211_CMD_DEL_TX_TS                    = 0x6a
+	NL80211_CMD_DEL_WIPHY                    = 0x4
+	NL80211_CMD_DISASSOCIATE                 = 0x28
+	NL80211_CMD_DISCONNECT                   = 0x30
+	NL80211_CMD_EXTERNAL_AUTH                = 0x7f
+	NL80211_CMD_FLUSH_PMKSA                  = 0x36
+	NL80211_CMD_FRAME                        = 0x3b
+	NL80211_CMD_FRAME_TX_STATUS              = 0x3c
+	NL80211_CMD_FRAME_WAIT_CANCEL            = 0x43
+	NL80211_CMD_FT_EVENT                     = 0x61
+	NL80211_CMD_GET_BEACON                   = 0xd
+	NL80211_CMD_GET_COALESCE                 = 0x64
+	NL80211_CMD_GET_FTM_RESPONDER_STATS      = 0x82
+	NL80211_CMD_GET_INTERFACE                = 0x5
+	NL80211_CMD_GET_KEY                      = 0x9
+	NL80211_CMD_GET_MESH_CONFIG              = 0x1c
+	NL80211_CMD_GET_MESH_PARAMS              = 0x1c
+	NL80211_CMD_GET_MPATH                    = 0x15
+	NL80211_CMD_GET_MPP                      = 0x6b
+	NL80211_CMD_GET_POWER_SAVE               = 0x3e
+	NL80211_CMD_GET_PROTOCOL_FEATURES        = 0x5f
+	NL80211_CMD_GET_REG                      = 0x1f
+	NL80211_CMD_GET_SCAN                     = 0x20
+	NL80211_CMD_GET_STATION                  = 0x11
+	NL80211_CMD_GET_SURVEY                   = 0x32
+	NL80211_CMD_GET_WIPHY                    = 0x1
+	NL80211_CMD_GET_WOWLAN                   = 0x49
+	NL80211_CMD_JOIN_IBSS                    = 0x2b
+	NL80211_CMD_JOIN_MESH                    = 0x44
+	NL80211_CMD_JOIN_OCB                     = 0x6c
+	NL80211_CMD_LEAVE_IBSS                   = 0x2c
+	NL80211_CMD_LEAVE_MESH                   = 0x45
+	NL80211_CMD_LEAVE_OCB                    = 0x6d
+	NL80211_CMD_MAX                          = 0x9a
+	NL80211_CMD_MICHAEL_MIC_FAILURE          = 0x29
+	NL80211_CMD_MODIFY_LINK_STA              = 0x97
+	NL80211_CMD_NAN_MATCH                    = 0x78
+	NL80211_CMD_NEW_BEACON                   = 0xf
+	NL80211_CMD_NEW_INTERFACE                = 0x7
+	NL80211_CMD_NEW_KEY                      = 0xb
+	NL80211_CMD_NEW_MPATH                    = 0x17
+	NL80211_CMD_NEW_PEER_CANDIDATE           = 0x48
+	NL80211_CMD_NEW_SCAN_RESULTS             = 0x22
+	NL80211_CMD_NEW_STATION                  = 0x13
+	NL80211_CMD_NEW_SURVEY_RESULTS           = 0x33
+	NL80211_CMD_NEW_WIPHY                    = 0x3
+	NL80211_CMD_NOTIFY_CQM                   = 0x40
+	NL80211_CMD_NOTIFY_RADAR                 = 0x86
+	NL80211_CMD_OBSS_COLOR_COLLISION         = 0x8d
+	NL80211_CMD_PEER_MEASUREMENT_COMPLETE    = 0x85
+	NL80211_CMD_PEER_MEASUREMENT_RESULT      = 0x84
+	NL80211_CMD_PEER_MEASUREMENT_START       = 0x83
+	NL80211_CMD_PMKSA_CANDIDATE              = 0x50
+	NL80211_CMD_PORT_AUTHORIZED              = 0x7d
+	NL80211_CMD_PROBE_CLIENT                 = 0x54
+	NL80211_CMD_PROBE_MESH_LINK              = 0x88
+	NL80211_CMD_RADAR_DETECT                 = 0x5e
+	NL80211_CMD_REG_BEACON_HINT              = 0x2a
+	NL80211_CMD_REG_CHANGE                   = 0x24
+	NL80211_CMD_REGISTER_ACTION              = 0x3a
+	NL80211_CMD_REGISTER_BEACONS             = 0x55
+	NL80211_CMD_REGISTER_FRAME               = 0x3a
+	NL80211_CMD_RELOAD_REGDB                 = 0x7e
+	NL80211_CMD_REMAIN_ON_CHANNEL            = 0x37
+	NL80211_CMD_REMOVE_LINK                  = 0x95
+	NL80211_CMD_REMOVE_LINK_STA              = 0x98
+	NL80211_CMD_REQ_SET_REG                  = 0x1b
+	NL80211_CMD_ROAM                         = 0x2f
+	NL80211_CMD_SCAN_ABORTED                 = 0x23
+	NL80211_CMD_SCHED_SCAN_RESULTS           = 0x4d
+	NL80211_CMD_SCHED_SCAN_STOPPED           = 0x4e
+	NL80211_CMD_SET_BEACON                   = 0xe
+	NL80211_CMD_SET_BSS                      = 0x19
+	NL80211_CMD_SET_CHANNEL                  = 0x41
+	NL80211_CMD_SET_COALESCE                 = 0x65
+	NL80211_CMD_SET_CQM                      = 0x3f
+	NL80211_CMD_SET_FILS_AAD                 = 0x92
+	NL80211_CMD_SET_INTERFACE                = 0x6
+	NL80211_CMD_SET_KEY                      = 0xa
+	NL80211_CMD_SET_MAC_ACL                  = 0x5d
+	NL80211_CMD_SET_MCAST_RATE               = 0x5c
+	NL80211_CMD_SET_MESH_CONFIG              = 0x1d
+	NL80211_CMD_SET_MESH_PARAMS              = 0x1d
+	NL80211_CMD_SET_MGMT_EXTRA_IE            = 0x1e
+	NL80211_CMD_SET_MPATH                    = 0x16
+	NL80211_CMD_SET_MULTICAST_TO_UNICAST     = 0x79
+	NL80211_CMD_SET_NOACK_MAP                = 0x57
+	NL80211_CMD_SET_PMK                      = 0x7b
+	NL80211_CMD_SET_PMKSA                    = 0x34
+	NL80211_CMD_SET_POWER_SAVE               = 0x3d
+	NL80211_CMD_SET_QOS_MAP                  = 0x68
+	NL80211_CMD_SET_REG                      = 0x1a
+	NL80211_CMD_SET_REKEY_OFFLOAD            = 0x4f
+
+	NL80211_CMD_SET_STATION                      = 0x12
+	NL80211_CMD_SET_TID_CONFIG                   = 0x89
+	NL80211_CMD_SET_TX_BITRATE_MASK              = 0x39
+	NL80211_CMD_SET_WDS_PEER                     = 0x42
+	NL80211_CMD_SET_WIPHY                        = 0x2
+	NL80211_CMD_SET_WIPHY_NETNS                  = 0x31
+	NL80211_CMD_SET_WOWLAN                       = 0x4a
+	NL80211_CMD_STA_OPMODE_CHANGED               = 0x80
+	NL80211_CMD_START_AP                         = 0xf
+	NL80211_CMD_START_NAN                        = 0x73
+	NL80211_CMD_START_P2P_DEVICE                 = 0x59
+	NL80211_CMD_START_SCHED_SCAN                 = 0x4b
+	NL80211_CMD_STOP_AP                          = 0x10
+	NL80211_CMD_STOP_NAN                         = 0x74
+	NL80211_CMD_STOP_P2P_DEVICE                  = 0x5a
+	NL80211_CMD_STOP_SCHED_SCAN                  = 0x4c
+	NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH       = 0x70
+	NL80211_CMD_TDLS_CHANNEL_SWITCH              = 0x6f
+	NL80211_CMD_TDLS_MGMT                        = 0x52
+	NL80211_CMD_TDLS_OPER                        = 0x51
+	NL80211_CMD_TESTMODE                         = 0x2d
+	NL80211_CMD_TRIGGER_SCAN                     = 0x21
+	NL80211_CMD_UNEXPECTED_4ADDR_FRAME           = 0x56
+	NL80211_CMD_UNEXPECTED_FRAME                 = 0x53
+	NL80211_CMD_UNPROT_BEACON                    = 0x8a
+	NL80211_CMD_UNPROT_DEAUTHENTICATE            = 0x46
+	NL80211_CMD_UNPROT_DISASSOCIATE              = 0x47
+	NL80211_CMD_UNSPEC                           = 0x0
+	NL80211_CMD_UPDATE_CONNECT_PARAMS            = 0x7a
+	NL80211_CMD_UPDATE_FT_IES                    = 0x60
+	NL80211_CMD_UPDATE_OWE_INFO                  = 0x87
+	NL80211_CMD_VENDOR                           = 0x67
+	NL80211_CMD_WIPHY_REG_CHANGE                 = 0x71
+	NL80211_COALESCE_CONDITION_MATCH             = 0x0
+	NL80211_COALESCE_CONDITION_NO_MATCH          = 0x1
+	NL80211_CONN_FAIL_BLOCKED_CLIENT             = 0x1
+	NL80211_CONN_FAIL_MAX_CLIENTS                = 0x0
+	NL80211_CQM_RSSI_BEACON_LOSS_EVENT           = 0x2
+	NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH        = 0x1
+	NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW         = 0x0
+	NL80211_CQM_TXE_MAX_INTVL                    = 0x708
+	NL80211_CRIT_PROTO_APIPA                     = 0x3
+	NL80211_CRIT_PROTO_DHCP                      = 0x1
+	NL80211_CRIT_PROTO_EAPOL                     = 0x2
+	NL80211_CRIT_PROTO_MAX_DURATION              = 0x1388
+	NL80211_CRIT_PROTO_UNSPEC                    = 0x0
+	NL80211_DFS_AVAILABLE                        = 0x2
+	NL80211_DFS_ETSI                             = 0x2
+	NL80211_DFS_FCC                              = 0x1
+	NL80211_DFS_JP                               = 0x3
+	NL80211_DFS_UNAVAILABLE                      = 0x1
+	NL80211_DFS_UNSET                            = 0x0
+	NL80211_DFS_USABLE                           = 0x0
+	NL80211_EDMG_BW_CONFIG_MAX                   = 0xf
+	NL80211_EDMG_BW_CONFIG_MIN                   = 0x4
+	NL80211_EDMG_CHANNELS_MAX                    = 0x3c
+	NL80211_EDMG_CHANNELS_MIN                    = 0x1
+	NL80211_EHT_MAX_CAPABILITY_LEN               = 0x33
+	NL80211_EHT_MIN_CAPABILITY_LEN               = 0xd
+	NL80211_EXTERNAL_AUTH_ABORT                  = 0x1
+	NL80211_EXTERNAL_AUTH_START                  = 0x0
+	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK    = 0x32
+	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X    = 0x10
+	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK   = 0xf
+	NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP  = 0x12
+	NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT       = 0x1b
+	NL80211_EXT_FEATURE_AIRTIME_FAIRNESS         = 0x21
+	NL80211_EXT_FEATURE_AP_PMKSA_CACHING         = 0x22
+	NL80211_EXT_FEATURE_AQL                      = 0x28
+	NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT = 0x2e
+	NL80211_EXT_FEATURE_BEACON_PROTECTION        = 0x29
+
+	NL80211_EXT_FEATURE_BEACON_RATE_HT                      = 0x7
+	NL80211_EXT_FEATURE_BEACON_RATE_LEGACY                  = 0x6
+	NL80211_EXT_FEATURE_BEACON_RATE_VHT                     = 0x8
+	NL80211_EXT_FEATURE_BSS_COLOR                           = 0x3a
+	NL80211_EXT_FEATURE_BSS_PARENT_TSF                      = 0x4
+	NL80211_EXT_FEATURE_CAN_REPLACE_PTK0                    = 0x1f
+	NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH             = 0x2a
+	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211           = 0x1a
+	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211_TX_STATUS = 0x30
+	NL80211_EXT_FEATURE_CQM_RSSI_LIST                       = 0xd
+	NL80211_EXT_FEATURE_DATA_ACK_SIGNAL_SUPPORT             = 0x1b
+	NL80211_EXT_FEATURE_DEL_IBSS_STA                        = 0x2c
+	NL80211_EXT_FEATURE_DFS_OFFLOAD                         = 0x19
+	NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER                = 0x20
+	NL80211_EXT_FEATURE_EXT_KEY_ID                          = 0x24
+	NL80211_EXT_FEATURE_FILS_CRYPTO_OFFLOAD                 = 0x3b
+	NL80211_EXT_FEATURE_FILS_DISCOVERY                      = 0x34
+	NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME               = 0x11
+	NL80211_EXT_FEATURE_FILS_SK_OFFLOAD                     = 0xe
+	NL80211_EXT_FEATURE_FILS_STA                            = 0x9
+	NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN                  = 0x18
+	NL80211_EXT_FEATURE_LOW_POWER_SCAN                      = 0x17
+	NL80211_EXT_FEATURE_LOW_SPAN_SCAN                       = 0x16
+	NL80211_EXT_FEATURE_MFP_OPTIONAL                        = 0x15
+	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA                   = 0xa
+	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA_CONNECTED         = 0xb
+	NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS             = 0x2d
+	NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER                 = 0x2
+	NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION  = 0x14
+	NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE          = 0x13
+	NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION        = 0x31
+	NL80211_EXT_FEATURE_POWERED_ADDR_CHANGE                 = 0x3d
+	NL80211_EXT_FEATURE_PROTECTED_TWT                       = 0x2b
+
+	NL80211_EXT_FEATURE_RADAR_BACKGROUND                    = 0x3c
+	NL80211_EXT_FEATURE_RRM                                 = 0x1
+	NL80211_EXT_FEATURE_SAE_OFFLOAD_AP                      = 0x33
+	NL80211_EXT_FEATURE_SAE_OFFLOAD                         = 0x26
+	NL80211_EXT_FEATURE_SCAN_FREQ_KHZ                       = 0x2f
+	NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT               = 0x1e
+	NL80211_EXT_FEATURE_SCAN_RANDOM_SN                      = 0x1d
+	NL80211_EXT_FEATURE_SCAN_START_TIME                     = 0x3
+	NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD = 0x23
+	NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI            = 0xc
+
+	NL80211_EXT_FEATURE_SET_SCAN_DWELL                     = 0x5
+	NL80211_EXT_FEATURE_STA_TX_PWR                         = 0x25
+	NL80211_EXT_FEATURE_TXQS                               = 0x1c
+	NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP             = 0x35
+	NL80211_EXT_FEATURE_VHT_IBSS                           = 0x0
+	NL80211_EXT_FEATURE_VLAN_OFFLOAD                       = 0x27
+	NL80211_FEATURE_ACKTO_ESTIMATION                       = 0x800000
+	NL80211_FEATURE_ACTIVE_MONITOR                         = 0x20000
+	NL80211_FEATURE_ADVERTISE_CHAN_LIMITS                  = 0x4000
+	NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE              = 0x40000
+	NL80211_FEATURE_AP_SCAN                                = 0x100
+	NL80211_FEATURE_CELL_BASE_REG_HINTS                    = 0x8
+	NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES              = 0x80000
+	NL80211_FEATURE_DYNAMIC_SMPS                           = 0x2000000
+	NL80211_FEATURE_FULL_AP_CLIENT_STATE                   = 0x8000
+	NL80211_FEATURE_HT_IBSS                                = 0x2
+	NL80211_FEATURE_INACTIVITY_TIMER                       = 0x4
+	NL80211_FEATURE_LOW_PRIORITY_SCAN                      = 0x40
+	NL80211_FEATURE_MAC_ON_CREATE                          = 0x8000000
+	NL80211_FEATURE_ND_RANDOM_MAC_ADDR                     = 0x80000000
+	NL80211_FEATURE_NEED_OBSS_SCAN                         = 0x400
+	NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL               = 0x10
+	NL80211_FEATURE_P2P_GO_CTWIN                           = 0x800
+	NL80211_FEATURE_P2P_GO_OPPPS                           = 0x1000
+	NL80211_FEATURE_QUIET                                  = 0x200000
+	NL80211_FEATURE_SAE                                    = 0x20
+	NL80211_FEATURE_SCAN_FLUSH                             = 0x80
+	NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR                   = 0x20000000
+	NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR             = 0x40000000
+	NL80211_FEATURE_SK_TX_STATUS                           = 0x1
+	NL80211_FEATURE_STATIC_SMPS                            = 0x1000000
+	NL80211_FEATURE_SUPPORTS_WMM_ADMISSION                 = 0x4000000
+	NL80211_FEATURE_TDLS_CHANNEL_SWITCH                    = 0x10000000
+	NL80211_FEATURE_TX_POWER_INSERTION                     = 0x400000
+	NL80211_FEATURE_USERSPACE_MPM                          = 0x10000
+	NL80211_FEATURE_VIF_TXPOWER                            = 0x200
+	NL80211_FEATURE_WFA_TPC_IE_IN_PROBES                   = 0x100000
+	NL80211_FILS_DISCOVERY_ATTR_INT_MAX                    = 0x2
+	NL80211_FILS_DISCOVERY_ATTR_INT_MIN                    = 0x1
+	NL80211_FILS_DISCOVERY_ATTR_MAX                        = 0x3
+	NL80211_FILS_DISCOVERY_ATTR_TMPL                       = 0x3
+	NL80211_FILS_DISCOVERY_TMPL_MIN_LEN                    = 0x2a
+	NL80211_FREQUENCY_ATTR_16MHZ                           = 0x19
+	NL80211_FREQUENCY_ATTR_1MHZ                            = 0x15
+	NL80211_FREQUENCY_ATTR_2MHZ                            = 0x16
+	NL80211_FREQUENCY_ATTR_4MHZ                            = 0x17
+	NL80211_FREQUENCY_ATTR_8MHZ                            = 0x18
+	NL80211_FREQUENCY_ATTR_DFS_CAC_TIME                    = 0xd
+	NL80211_FREQUENCY_ATTR_DFS_STATE                       = 0x7
+	NL80211_FREQUENCY_ATTR_DFS_TIME                        = 0x8
+	NL80211_FREQUENCY_ATTR_DISABLED                        = 0x2
+	NL80211_FREQUENCY_ATTR_FREQ                            = 0x1
+	NL80211_FREQUENCY_ATTR_GO_CONCURRENT                   = 0xf
+	NL80211_FREQUENCY_ATTR_INDOOR_ONLY                     = 0xe
+	NL80211_FREQUENCY_ATTR_IR_CONCURRENT                   = 0xf
+	NL80211_FREQUENCY_ATTR_MAX                             = 0x1b
+	NL80211_FREQUENCY_ATTR_MAX_TX_POWER                    = 0x6
+	NL80211_FREQUENCY_ATTR_NO_10MHZ                        = 0x11
+	NL80211_FREQUENCY_ATTR_NO_160MHZ                       = 0xc
+	NL80211_FREQUENCY_ATTR_NO_20MHZ                        = 0x10
+	NL80211_FREQUENCY_ATTR_NO_320MHZ                       = 0x1a
+	NL80211_FREQUENCY_ATTR_NO_80MHZ                        = 0xb
+	NL80211_FREQUENCY_ATTR_NO_EHT                          = 0x1b
+	NL80211_FREQUENCY_ATTR_NO_HE                           = 0x13
+	NL80211_FREQUENCY_ATTR_NO_HT40_MINUS                   = 0x9
+	NL80211_FREQUENCY_ATTR_NO_HT40_PLUS                    = 0xa
+	NL80211_FREQUENCY_ATTR_NO_IBSS                         = 0x3
+	NL80211_FREQUENCY_ATTR_NO_IR                           = 0x3
+	NL80211_FREQUENCY_ATTR_OFFSET                          = 0x14
+	NL80211_FREQUENCY_ATTR_PASSIVE_SCAN                    = 0x3
+	NL80211_FREQUENCY_ATTR_RADAR                           = 0x5
+	NL80211_FREQUENCY_ATTR_WMM                             = 0x12
+	NL80211_FTM_RESP_ATTR_CIVICLOC                         = 0x3
+	NL80211_FTM_RESP_ATTR_ENABLED                          = 0x1
+	NL80211_FTM_RESP_ATTR_LCI                              = 0x2
+	NL80211_FTM_RESP_ATTR_MAX                              = 0x3
+	NL80211_FTM_STATS_ASAP_NUM                             = 0x4
+	NL80211_FTM_STATS_FAILED_NUM                           = 0x3
+	NL80211_FTM_STATS_MAX                                  = 0xa
+	NL80211_FTM_STATS_NON_ASAP_NUM                         = 0x5
+	NL80211_FTM_STATS_OUT_OF_WINDOW_TRIGGERS_NUM           = 0x9
+	NL80211_FTM_STATS_PAD                                  = 0xa
+	NL80211_FTM_STATS_PARTIAL_NUM                          = 0x2
+	NL80211_FTM_STATS_RESCHEDULE_REQUESTS_NUM              = 0x8
+	NL80211_FTM_STATS_SUCCESS_NUM                          = 0x1
+	NL80211_FTM_STATS_TOTAL_DURATION_MSEC                  = 0x6
+	NL80211_FTM_STATS_UNKNOWN_TRIGGERS_NUM                 = 0x7
+	NL80211_GENL_NAME                                      = "nl80211"
+	NL80211_HE_BSS_COLOR_ATTR_COLOR                        = 0x1
+	NL80211_HE_BSS_COLOR_ATTR_DISABLED                     = 0x2
+	NL80211_HE_BSS_COLOR_ATTR_MAX                          = 0x3
+	NL80211_HE_BSS_COLOR_ATTR_PARTIAL                      = 0x3
+	NL80211_HE_MAX_CAPABILITY_LEN                          = 0x36
+	NL80211_HE_MIN_CAPABILITY_LEN                          = 0x10
+	NL80211_HE_NSS_MAX                                     = 0x8
+	NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP               = 0x4
+	NL80211_HE_OBSS_PD_ATTR_MAX                            = 0x6
+	NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET                     = 0x2
+	NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET                     = 0x1
+	NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET             = 0x3
+	NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP           = 0x5
+	NL80211_HE_OBSS_PD_ATTR_SR_CTRL                        = 0x6
+	NL80211_HIDDEN_SSID_NOT_IN_USE                         = 0x0
+	NL80211_HIDDEN_SSID_ZERO_CONTENTS                      = 0x2
+	NL80211_HIDDEN_SSID_ZERO_LEN                           = 0x1
+	NL80211_HT_CAPABILITY_LEN                              = 0x1a
+	NL80211_IFACE_COMB_BI_MIN_GCD                          = 0x7
+	NL80211_IFACE_COMB_LIMITS                              = 0x1
+	NL80211_IFACE_COMB_MAXNUM                              = 0x2
+	NL80211_IFACE_COMB_NUM_CHANNELS                        = 0x4
+	NL80211_IFACE_COMB_RADAR_DETECT_REGIONS                = 0x6
+	NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS                 = 0x5
+	NL80211_IFACE_COMB_STA_AP_BI_MATCH                     = 0x3
+	NL80211_IFACE_COMB_UNSPEC                              = 0x0
+	NL80211_IFACE_LIMIT_MAX                                = 0x1
+	NL80211_IFACE_LIMIT_TYPES                              = 0x2
+	NL80211_IFACE_LIMIT_UNSPEC                             = 0x0
+	NL80211_IFTYPE_ADHOC                                   = 0x1
+	NL80211_IFTYPE_AKM_ATTR_IFTYPES                        = 0x1
+	NL80211_IFTYPE_AKM_ATTR_MAX                            = 0x2
+	NL80211_IFTYPE_AKM_ATTR_SUITES                         = 0x2
+	NL80211_IFTYPE_AP                                      = 0x3
+	NL80211_IFTYPE_AP_VLAN                                 = 0x4
+	NL80211_IFTYPE_MAX                                     = 0xc
+	NL80211_IFTYPE_MESH_POINT                              = 0x7
+	NL80211_IFTYPE_MONITOR                                 = 0x6
+	NL80211_IFTYPE_NAN                                     = 0xc
+	NL80211_IFTYPE_OCB                                     = 0xb
+	NL80211_IFTYPE_P2P_CLIENT                              = 0x8
+	NL80211_IFTYPE_P2P_DEVICE                              = 0xa
+	NL80211_IFTYPE_P2P_GO                                  = 0x9
+	NL80211_IFTYPE_STATION                                 = 0x2
+	NL80211_IFTYPE_UNSPECIFIED                             = 0x0
+	NL80211_IFTYPE_WDS                                     = 0x5
+	NL80211_KCK_EXT_LEN                                    = 0x18
+	NL80211_KCK_LEN                                        = 0x10
+	NL80211_KEK_EXT_LEN                                    = 0x20
+	NL80211_KEK_LEN                                        = 0x10
+	NL80211_KEY_CIPHER                                     = 0x3
+	NL80211_KEY_DATA                                       = 0x1
+	NL80211_KEY_DEFAULT_BEACON                             = 0xa
+	NL80211_KEY_DEFAULT                                    = 0x5
+	NL80211_KEY_DEFAULT_MGMT                               = 0x6
+	NL80211_KEY_DEFAULT_TYPE_MULTICAST                     = 0x2
+	NL80211_KEY_DEFAULT_TYPES                              = 0x8
+	NL80211_KEY_DEFAULT_TYPE_UNICAST                       = 0x1
+	NL80211_KEY_IDX                                        = 0x2
+	NL80211_KEY_MAX                                        = 0xa
+	NL80211_KEY_MODE                                       = 0x9
+	NL80211_KEY_NO_TX                                      = 0x1
+	NL80211_KEY_RX_TX                                      = 0x0
+	NL80211_KEY_SEQ                                        = 0x4
+	NL80211_KEY_SET_TX                                     = 0x2
+	NL80211_KEY_TYPE                                       = 0x7
+	NL80211_KEYTYPE_GROUP                                  = 0x0
+	NL80211_KEYTYPE_PAIRWISE                               = 0x1
+	NL80211_KEYTYPE_PEERKEY                                = 0x2
+	NL80211_MAX_NR_AKM_SUITES                              = 0x2
+	NL80211_MAX_NR_CIPHER_SUITES                           = 0x5
+	NL80211_MAX_SUPP_HT_RATES                              = 0x4d
+	NL80211_MAX_SUPP_RATES                                 = 0x20
+	NL80211_MAX_SUPP_REG_RULES                             = 0x80
+	NL80211_MBSSID_CONFIG_ATTR_EMA                         = 0x5
+	NL80211_MBSSID_CONFIG_ATTR_INDEX                       = 0x3
+	NL80211_MBSSID_CONFIG_ATTR_MAX                         = 0x5
+	NL80211_MBSSID_CONFIG_ATTR_MAX_EMA_PROFILE_PERIODICITY = 0x2
+	NL80211_MBSSID_CONFIG_ATTR_MAX_INTERFACES              = 0x1
+	NL80211_MBSSID_CONFIG_ATTR_TX_IFINDEX                  = 0x4
+	NL80211_MESHCONF_ATTR_MAX                              = 0x1f
+	NL80211_MESHCONF_AUTO_OPEN_PLINKS                      = 0x7
+	NL80211_MESHCONF_AWAKE_WINDOW                          = 0x1b
+	NL80211_MESHCONF_CONFIRM_TIMEOUT                       = 0x2
+	NL80211_MESHCONF_CONNECTED_TO_AS                       = 0x1f
+	NL80211_MESHCONF_CONNECTED_TO_GATE                     = 0x1d
+	NL80211_MESHCONF_ELEMENT_TTL                           = 0xf
+	NL80211_MESHCONF_FORWARDING                            = 0x13
+	NL80211_MESHCONF_GATE_ANNOUNCEMENTS                    = 0x11
+	NL80211_MESHCONF_HOLDING_TIMEOUT                       = 0x3
+	NL80211_MESHCONF_HT_OPMODE                             = 0x16
+	NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT              = 0xb
+	NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL            = 0x19
+	NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES                 = 0x8
+	NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME               = 0xd
+	NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT             = 0x17
+	NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL                = 0x12
+	NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL                = 0xc
+	NL80211_MESHCONF_HWMP_RANN_INTERVAL                    = 0x10
+	NL80211_MESHCONF_HWMP_ROOT_INTERVAL                    = 0x18
+	NL80211_MESHCONF_HWMP_ROOTMODE                         = 0xe
+	NL80211_MESHCONF_MAX_PEER_LINKS                        = 0x4
+	NL80211_MESHCONF_MAX_RETRIES                           = 0x5
+	NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT                 = 0xa
+	NL80211_MESHCONF_NOLEARN                               = 0x1e
+	NL80211_MESHCONF_PATH_REFRESH_TIME                     = 0x9
+	NL80211_MESHCONF_PLINK_TIMEOUT                         = 0x1c
+	NL80211_MESHCONF_POWER_MODE                            = 0x1a
+	NL80211_MESHCONF_RETRY_TIMEOUT                         = 0x1
+	NL80211_MESHCONF_RSSI_THRESHOLD                        = 0x14
+	NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR              = 0x15
+	NL80211_MESHCONF_TTL                                   = 0x6
+	NL80211_MESH_POWER_ACTIVE                              = 0x1
+	NL80211_MESH_POWER_DEEP_SLEEP                          = 0x3
+	NL80211_MESH_POWER_LIGHT_SLEEP                         = 0x2
+	NL80211_MESH_POWER_MAX                                 = 0x3
+	NL80211_MESH_POWER_UNKNOWN                             = 0x0
+	NL80211_MESH_SETUP_ATTR_MAX                            = 0x8
+	NL80211_MESH_SETUP_AUTH_PROTOCOL                       = 0x8
+	NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC                = 0x2
+	NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL              = 0x1
+	NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC                  = 0x6
+	NL80211_MESH_SETUP_IE                                  = 0x3
+	NL80211_MESH_SETUP_USERSPACE_AMPE                      = 0x5
+	NL80211_MESH_SETUP_USERSPACE_AUTH                      = 0x4
+	NL80211_MESH_SETUP_USERSPACE_MPM                       = 0x7
+	NL80211_MESH_SETUP_VENDOR_PATH_SEL_IE                  = 0x3
+	NL80211_MFP_NO                                         = 0x0
+	NL80211_MFP_OPTIONAL                                   = 0x2
+	NL80211_MFP_REQUIRED                                   = 0x1
+	NL80211_MIN_REMAIN_ON_CHANNEL_TIME                     = 0xa
+	NL80211_MNTR_FLAG_ACTIVE                               = 0x6
+	NL80211_MNTR_FLAG_CONTROL                              = 0x3
+	NL80211_MNTR_FLAG_COOK_FRAMES                          = 0x5
+	NL80211_MNTR_FLAG_FCSFAIL                              = 0x1
+	NL80211_MNTR_FLAG_MAX                                  = 0x6
+	NL80211_MNTR_FLAG_OTHER_BSS                            = 0x4
+	NL80211_MNTR_FLAG_PLCPFAIL                             = 0x2
+	NL80211_MPATH_FLAG_ACTIVE                              = 0x1
+	NL80211_MPATH_FLAG_FIXED                               = 0x8
+	NL80211_MPATH_FLAG_RESOLVED                            = 0x10
+	NL80211_MPATH_FLAG_RESOLVING                           = 0x2
+	NL80211_MPATH_FLAG_SN_VALID                            = 0x4
+	NL80211_MPATH_INFO_DISCOVERY_RETRIES                   = 0x7
+	NL80211_MPATH_INFO_DISCOVERY_TIMEOUT                   = 0x6
+	NL80211_MPATH_INFO_EXPTIME                             = 0x4
+	NL80211_MPATH_INFO_FLAGS                               = 0x5
+	NL80211_MPATH_INFO_FRAME_QLEN                          = 0x1
+	NL80211_MPATH_INFO_HOP_COUNT                           = 0x8
+	NL80211_MPATH_INFO_MAX                                 = 0x9
+	NL80211_MPATH_INFO_METRIC                              = 0x3
+	NL80211_MPATH_INFO_PATH_CHANGE                         = 0x9
+	NL80211_MPATH_INFO_SN                                  = 0x2
+	NL80211_MULTICAST_GROUP_CONFIG                         = "config"
+	NL80211_MULTICAST_GROUP_MLME                           = "mlme"
+	NL80211_MULTICAST_GROUP_NAN                            = "nan"
+	NL80211_MULTICAST_GROUP_REG                            = "regulatory"
+	NL80211_MULTICAST_GROUP_SCAN                           = "scan"
+	NL80211_MULTICAST_GROUP_TESTMODE                       = "testmode"
+	NL80211_MULTICAST_GROUP_VENDOR                         = "vendor"
+	NL80211_NAN_FUNC_ATTR_MAX                              = 0x10
+	NL80211_NAN_FUNC_CLOSE_RANGE                           = 0x9
+	NL80211_NAN_FUNC_FOLLOW_UP                             = 0x2
+	NL80211_NAN_FUNC_FOLLOW_UP_DEST                        = 0x8
+	NL80211_NAN_FUNC_FOLLOW_UP_ID                          = 0x6
+	NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID                      = 0x7
+	NL80211_NAN_FUNC_INSTANCE_ID                           = 0xf
+	NL80211_NAN_FUNC_MAX_TYPE                              = 0x2
+	NL80211_NAN_FUNC_PUBLISH_BCAST                         = 0x4
+	NL80211_NAN_FUNC_PUBLISH                               = 0x0
+	NL80211_NAN_FUNC_PUBLISH_TYPE                          = 0x3
+	NL80211_NAN_FUNC_RX_MATCH_FILTER                       = 0xd
+	NL80211_NAN_FUNC_SERVICE_ID                            = 0x2
+	NL80211_NAN_FUNC_SERVICE_ID_LEN                        = 0x6
+	NL80211_NAN_FUNC_SERVICE_INFO                          = 0xb
+	NL80211_NAN_FUNC_SERVICE_SPEC_INFO_MAX_LEN             = 0xff
+	NL80211_NAN_FUNC_SRF                                   = 0xc
+	NL80211_NAN_FUNC_SRF_MAX_LEN                           = 0xff
+	NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE                      = 0x5
+	NL80211_NAN_FUNC_SUBSCRIBE                             = 0x1
+	NL80211_NAN_FUNC_TERM_REASON                           = 0x10
+	NL80211_NAN_FUNC_TERM_REASON_ERROR                     = 0x2
+	NL80211_NAN_FUNC_TERM_REASON_TTL_EXPIRED               = 0x1
+	NL80211_NAN_FUNC_TERM_REASON_USER_REQUEST              = 0x0
+	NL80211_NAN_FUNC_TTL                                   = 0xa
+	NL80211_NAN_FUNC_TX_MATCH_FILTER                       = 0xe
+	NL80211_NAN_FUNC_TYPE                                  = 0x1
+	NL80211_NAN_MATCH_ATTR_MAX                             = 0x2
+	NL80211_NAN_MATCH_FUNC_LOCAL                           = 0x1
+	NL80211_NAN_MATCH_FUNC_PEER                            = 0x2
+	NL80211_NAN_SOLICITED_PUBLISH                          = 0x1
+	NL80211_NAN_SRF_ATTR_MAX                               = 0x4
+	NL80211_NAN_SRF_BF                                     = 0x2
+	NL80211_NAN_SRF_BF_IDX                                 = 0x3
+	NL80211_NAN_SRF_INCLUDE                                = 0x1
+	NL80211_NAN_SRF_MAC_ADDRS                              = 0x4
+	NL80211_NAN_UNSOLICITED_PUBLISH                        = 0x2
+	NL80211_NUM_ACS                                        = 0x4
+	NL80211_P2P_PS_SUPPORTED                               = 0x1
+	NL80211_P2P_PS_UNSUPPORTED                             = 0x0
+	NL80211_PKTPAT_MASK                                    = 0x1
+	NL80211_PKTPAT_OFFSET                                  = 0x3
+	NL80211_PKTPAT_PATTERN                                 = 0x2
+	NL80211_PLINK_ACTION_BLOCK                             = 0x2
+	NL80211_PLINK_ACTION_NO_ACTION                         = 0x0
+	NL80211_PLINK_ACTION_OPEN                              = 0x1
+	NL80211_PLINK_BLOCKED                                  = 0x6
+	NL80211_PLINK_CNF_RCVD                                 = 0x3
+	NL80211_PLINK_ESTAB                                    = 0x4
+	NL80211_PLINK_HOLDING                                  = 0x5
+	NL80211_PLINK_LISTEN                                   = 0x0
+	NL80211_PLINK_OPN_RCVD                                 = 0x2
+	NL80211_PLINK_OPN_SNT                                  = 0x1
+	NL80211_PMKSA_CANDIDATE_BSSID                          = 0x2
+	NL80211_PMKSA_CANDIDATE_INDEX                          = 0x1
+	NL80211_PMKSA_CANDIDATE_PREAUTH                        = 0x3
+	NL80211_PMSR_ATTR_MAX                                  = 0x5
+	NL80211_PMSR_ATTR_MAX_PEERS                            = 0x1
+	NL80211_PMSR_ATTR_PEERS                                = 0x5
+	NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR                   = 0x3
+	NL80211_PMSR_ATTR_REPORT_AP_TSF                        = 0x2
+	NL80211_PMSR_ATTR_TYPE_CAPA                            = 0x4
+	NL80211_PMSR_FTM_CAPA_ATTR_ASAP                        = 0x1
+	NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS                  = 0x6
+	NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT         = 0x7
+	NL80211_PMSR_FTM_CAPA_ATTR_MAX                         = 0xa
+	NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST          = 0x8
+	NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP                    = 0x2
+	NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED           = 0xa
+	NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES                   = 0x5
+	NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC                = 0x4
+	NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI                     = 0x3
+	NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED               = 0x9
+	NL80211_PMSR_FTM_FAILURE_BAD_CHANGED_PARAMS            = 0x7
+	NL80211_PMSR_FTM_FAILURE_INVALID_TIMESTAMP             = 0x5
+	NL80211_PMSR_FTM_FAILURE_NO_RESPONSE                   = 0x1
+	NL80211_PMSR_FTM_FAILURE_PEER_BUSY                     = 0x6
+	NL80211_PMSR_FTM_FAILURE_PEER_NOT_CAPABLE              = 0x4
+	NL80211_PMSR_FTM_FAILURE_REJECTED                      = 0x2
+	NL80211_PMSR_FTM_FAILURE_UNSPECIFIED                   = 0x0
+	NL80211_PMSR_FTM_FAILURE_WRONG_CHANNEL                 = 0x3
+	NL80211_PMSR_FTM_REQ_ATTR_ASAP                         = 0x1
+	NL80211_PMSR_FTM_REQ_ATTR_BSS_COLOR                    = 0xd
+	NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION               = 0x5
+	NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD                 = 0x4
+	NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST               = 0x6
+
+	NL80211_PMSR_FTM_REQ_ATTR_MAX                 = 0xd
+	NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED   = 0xb
+	NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP      = 0x3
+	NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES    = 0x7
+	NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE            = 0x2
+	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC    = 0x9
+	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI         = 0x8
+	NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED       = 0xa
+	NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION     = 0x7
+	NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX        = 0x2
+	NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME    = 0x5
+	NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC           = 0x14
+	NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG           = 0x10
+	NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD        = 0x12
+	NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE      = 0x11
+	NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON        = 0x1
+	NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST     = 0x8
+	NL80211_PMSR_FTM_RESP_ATTR_LCI                = 0x13
+	NL80211_PMSR_FTM_RESP_ATTR_MAX                = 0x15
+	NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP     = 0x6
+	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS  = 0x3
+	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES = 0x4
+	NL80211_PMSR_FTM_RESP_ATTR_PAD                = 0x15
+	NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG           = 0x9
+	NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD        = 0xa
+	NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG            = 0xd
+	NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD         = 0xf
+	NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE       = 0xe
+	NL80211_PMSR_FTM_RESP_ATTR_RX_RATE            = 0xc
+	NL80211_PMSR_FTM_RESP_ATTR_TX_RATE            = 0xb
+	NL80211_PMSR_PEER_ATTR_ADDR                   = 0x1
+	NL80211_PMSR_PEER_ATTR_CHAN                   = 0x2
+	NL80211_PMSR_PEER_ATTR_MAX                    = 0x4
+	NL80211_PMSR_PEER_ATTR_REQ                    = 0x3
+	NL80211_PMSR_PEER_ATTR_RESP                   = 0x4
+	NL80211_PMSR_REQ_ATTR_DATA                    = 0x1
+	NL80211_PMSR_REQ_ATTR_GET_AP_TSF              = 0x2
+	NL80211_PMSR_REQ_ATTR_MAX                     = 0x2
+	NL80211_PMSR_RESP_ATTR_AP_TSF                 = 0x4
+	NL80211_PMSR_RESP_ATTR_DATA                   = 0x1
+	NL80211_PMSR_RESP_ATTR_FINAL                  = 0x5
+	NL80211_PMSR_RESP_ATTR_HOST_TIME              = 0x3
+	NL80211_PMSR_RESP_ATTR_MAX                    = 0x6
+	NL80211_PMSR_RESP_ATTR_PAD                    = 0x6
+	NL80211_PMSR_RESP_ATTR_STATUS                 = 0x2
+	NL80211_PMSR_STATUS_FAILURE                   = 0x3
+	NL80211_PMSR_STATUS_REFUSED                   = 0x1
+	NL80211_PMSR_STATUS_SUCCESS                   = 0x0
+	NL80211_PMSR_STATUS_TIMEOUT                   = 0x2
+	NL80211_PMSR_TYPE_FTM                         = 0x1
+	NL80211_PMSR_TYPE_INVALID                     = 0x0
+	NL80211_PMSR_TYPE_MAX                         = 0x1
+	NL80211_PREAMBLE_DMG                          = 0x3
+	NL80211_PREAMBLE_HE                           = 0x4
+	NL80211_PREAMBLE_HT                           = 0x1
+	NL80211_PREAMBLE_LEGACY                       = 0x0
+	NL80211_PREAMBLE_VHT                          = 0x2
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_80211U     = 0x8
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P        = 0x4
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2       = 0x2
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS        = 0x1
+	NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP     = 0x1
+	NL80211_PS_DISABLED                           = 0x0
+	NL80211_PS_ENABLED                            = 0x1
+	NL80211_RADAR_CAC_ABORTED                     = 0x2
+	NL80211_RADAR_CAC_FINISHED                    = 0x1
+	NL80211_RADAR_CAC_STARTED                     = 0x5
+	NL80211_RADAR_DETECTED                        = 0x0
+	NL80211_RADAR_NOP_FINISHED                    = 0x3
+	NL80211_RADAR_PRE_CAC_EXPIRED                 = 0x4
+	NL80211_RATE_INFO_10_MHZ_WIDTH                = 0xb
+	NL80211_RATE_INFO_160_MHZ_WIDTH               = 0xa
+	NL80211_RATE_INFO_320_MHZ_WIDTH               = 0x12
+	NL80211_RATE_INFO_40_MHZ_WIDTH                = 0x3
+	NL80211_RATE_INFO_5_MHZ_WIDTH                 = 0xc
+	NL80211_RATE_INFO_80_MHZ_WIDTH                = 0x8
+	NL80211_RATE_INFO_80P80_MHZ_WIDTH             = 0x9
+	NL80211_RATE_INFO_BITRATE32                   = 0x5
+	NL80211_RATE_INFO_BITRATE                     = 0x1
+	NL80211_RATE_INFO_EHT_GI_0_8                  = 0x0
+	NL80211_RATE_INFO_EHT_GI_1_6                  = 0x1
+	NL80211_RATE_INFO_EHT_GI_3_2                  = 0x2
+	NL80211_RATE_INFO_EHT_GI                      = 0x15
+	NL80211_RATE_INFO_EHT_MCS                     = 0x13
+	NL80211_RATE_INFO_EHT_NSS                     = 0x14
+	NL80211_RATE_INFO_EHT_RU_ALLOC_106            = 0x3
+	NL80211_RATE_INFO_EHT_RU_ALLOC_106P26         = 0x4
+	NL80211_RATE_INFO_EHT_RU_ALLOC_242            = 0x5
+	NL80211_RATE_INFO_EHT_RU_ALLOC_26             = 0x0
+	NL80211_RATE_INFO_EHT_RU_ALLOC_2x996          = 0xb
+	NL80211_RATE_INFO_EHT_RU_ALLOC_2x996P484      = 0xc
+	NL80211_RATE_INFO_EHT_RU_ALLOC_3x996          = 0xd
+	NL80211_RATE_INFO_EHT_RU_ALLOC_3x996P484      = 0xe
+	NL80211_RATE_INFO_EHT_RU_ALLOC_484            = 0x6
+	NL80211_RATE_INFO_EHT_RU_ALLOC_484P242        = 0x7
+	NL80211_RATE_INFO_EHT_RU_ALLOC_4x996          = 0xf
+	NL80211_RATE_INFO_EHT_RU_ALLOC_52             = 0x1
+	NL80211_RATE_INFO_EHT_RU_ALLOC_52P26          = 0x2
+	NL80211_RATE_INFO_EHT_RU_ALLOC_996            = 0x8
+	NL80211_RATE_INFO_EHT_RU_ALLOC_996P484        = 0x9
+	NL80211_RATE_INFO_EHT_RU_ALLOC_996P484P242    = 0xa
+	NL80211_RATE_INFO_EHT_RU_ALLOC                = 0x16
+	NL80211_RATE_INFO_HE_1XLTF                    = 0x0
+	NL80211_RATE_INFO_HE_2XLTF                    = 0x1
+	NL80211_RATE_INFO_HE_4XLTF                    = 0x2
+	NL80211_RATE_INFO_HE_DCM                      = 0x10
+	NL80211_RATE_INFO_HE_GI_0_8                   = 0x0
+	NL80211_RATE_INFO_HE_GI_1_6                   = 0x1
+	NL80211_RATE_INFO_HE_GI_3_2                   = 0x2
+	NL80211_RATE_INFO_HE_GI                       = 0xf
+	NL80211_RATE_INFO_HE_MCS                      = 0xd
+	NL80211_RATE_INFO_HE_NSS                      = 0xe
+	NL80211_RATE_INFO_HE_RU_ALLOC_106             = 0x2
+	NL80211_RATE_INFO_HE_RU_ALLOC_242             = 0x3
+	NL80211_RATE_INFO_HE_RU_ALLOC_26              = 0x0
+	NL80211_RATE_INFO_HE_RU_ALLOC_2x996           = 0x6
+	NL80211_RATE_INFO_HE_RU_ALLOC_484             = 0x4
+	NL80211_RATE_INFO_HE_RU_ALLOC_52              = 0x1
+	NL80211_RATE_INFO_HE_RU_ALLOC_996             = 0x5
+	NL80211_RATE_INFO_HE_RU_ALLOC                 = 0x11
+	NL80211_RATE_INFO_MAX                         = 0x1d
+	NL80211_RATE_INFO_MCS                         = 0x2
+	NL80211_RATE_INFO_SHORT_GI                    = 0x4
+	NL80211_RATE_INFO_VHT_MCS                     = 0x6
+	NL80211_RATE_INFO_VHT_NSS                     = 0x7
+	NL80211_REGDOM_SET_BY_CORE                    = 0x0
+	NL80211_REGDOM_SET_BY_COUNTRY_IE              = 0x3
+	NL80211_REGDOM_SET_BY_DRIVER                  = 0x2
+	NL80211_REGDOM_SET_BY_USER                    = 0x1
+	NL80211_REGDOM_TYPE_COUNTRY                   = 0x0
+	NL80211_REGDOM_TYPE_CUSTOM_WORLD              = 0x2
+	NL80211_REGDOM_TYPE_INTERSECTION              = 0x3
+	NL80211_REGDOM_TYPE_WORLD                     = 0x1
+	NL80211_REG_RULE_ATTR_MAX                     = 0x7
+	NL80211_REKEY_DATA_AKM                        = 0x4
+	NL80211_REKEY_DATA_KCK                        = 0x2
+	NL80211_REKEY_DATA_KEK                        = 0x1
+	NL80211_REKEY_DATA_REPLAY_CTR                 = 0x3
+	NL80211_REPLAY_CTR_LEN                        = 0x8
+	NL80211_RRF_AUTO_BW                           = 0x800
+	NL80211_RRF_DFS                               = 0x10
+	NL80211_RRF_GO_CONCURRENT                     = 0x1000
+	NL80211_RRF_IR_CONCURRENT                     = 0x1000
+	NL80211_RRF_NO_160MHZ                         = 0x10000
+	NL80211_RRF_NO_320MHZ                         = 0x40000
+	NL80211_RRF_NO_80MHZ                          = 0x8000
+	NL80211_RRF_NO_CCK                            = 0x2
+	NL80211_RRF_NO_HE                             = 0x20000
+	NL80211_RRF_NO_HT40                           = 0x6000
+	NL80211_RRF_NO_HT40MINUS                      = 0x2000
+	NL80211_RRF_NO_HT40PLUS                       = 0x4000
+	NL80211_RRF_NO_IBSS                           = 0x80
+	NL80211_RRF_NO_INDOOR                         = 0x4
+	NL80211_RRF_NO_IR_ALL                         = 0x180
+	NL80211_RRF_NO_IR                             = 0x80
+	NL80211_RRF_NO_OFDM                           = 0x1
+	NL80211_RRF_NO_OUTDOOR                        = 0x8
+	NL80211_RRF_PASSIVE_SCAN                      = 0x80
+	NL80211_RRF_PTMP_ONLY                         = 0x40
+	NL80211_RRF_PTP_ONLY                          = 0x20
+	NL80211_RXMGMT_FLAG_ANSWERED                  = 0x1
+	NL80211_RXMGMT_FLAG_EXTERNAL_AUTH             = 0x2
+
+	NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP            = 0x20
+	NL80211_SCAN_FLAG_AP                                 = 0x4
+	NL80211_SCAN_FLAG_COLOCATED_6GHZ                     = 0x4000
+	NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME              = 0x10
+	NL80211_SCAN_FLAG_FLUSH                              = 0x2
+	NL80211_SCAN_FLAG_FREQ_KHZ                           = 0x2000
+	NL80211_SCAN_FLAG_HIGH_ACCURACY                      = 0x400
+	NL80211_SCAN_FLAG_LOW_POWER                          = 0x200
+	NL80211_SCAN_FLAG_LOW_PRIORITY                       = 0x1
+	NL80211_SCAN_FLAG_LOW_SPAN                           = 0x100
+	NL80211_SCAN_FLAG_MIN_PREQ_CONTENT                   = 0x1000
+	NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION = 0x80
+	NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE         = 0x40
+	NL80211_SCAN_FLAG_RANDOM_ADDR                        = 0x8
+	NL80211_SCAN_FLAG_RANDOM_SN                          = 0x800
+	NL80211_SCAN_RSSI_THOLD_OFF                          = -0x12c
+	NL80211_SCHED_SCAN_MATCH_ATTR_BSSID                  = 0x5
+	NL80211_SCHED_SCAN_MATCH_ATTR_MAX                    = 0x6
+	NL80211_SCHED_SCAN_MATCH_ATTR_RELATIVE_RSSI          = 0x3
+	NL80211_SCHED_SCAN_MATCH_ATTR_RSSI_ADJUST            = 0x4
+	NL80211_SCHED_SCAN_MATCH_ATTR_RSSI                   = 0x2
+	NL80211_SCHED_SCAN_MATCH_ATTR_SSID                   = 0x1
+	NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI               = 0x6
+	NL80211_SCHED_SCAN_PLAN_INTERVAL                     = 0x1
+	NL80211_SCHED_SCAN_PLAN_ITERATIONS                   = 0x2
+	NL80211_SCHED_SCAN_PLAN_MAX                          = 0x2
+	NL80211_SMPS_DYNAMIC                                 = 0x2
+	NL80211_SMPS_MAX                                     = 0x2
+	NL80211_SMPS_OFF                                     = 0x0
+	NL80211_SMPS_STATIC                                  = 0x1
+	NL80211_STA_BSS_PARAM_BEACON_INTERVAL                = 0x5
+	NL80211_STA_BSS_PARAM_CTS_PROT                       = 0x1
+	NL80211_STA_BSS_PARAM_DTIM_PERIOD                    = 0x4
+	NL80211_STA_BSS_PARAM_MAX                            = 0x5
+	NL80211_STA_BSS_PARAM_SHORT_PREAMBLE                 = 0x2
+	NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME                = 0x3
+	NL80211_STA_FLAG_ASSOCIATED                          = 0x7
+	NL80211_STA_FLAG_AUTHENTICATED                       = 0x5
+	NL80211_STA_FLAG_AUTHORIZED                          = 0x1
+	NL80211_STA_FLAG_MAX                                 = 0x7
+	NL80211_STA_FLAG_MAX_OLD_API                         = 0x6
+	NL80211_STA_FLAG_MFP                                 = 0x4
+	NL80211_STA_FLAG_SHORT_PREAMBLE                      = 0x2
+	NL80211_STA_FLAG_TDLS_PEER                           = 0x6
+	NL80211_STA_FLAG_WME                                 = 0x3
+	NL80211_STA_INFO_ACK_SIGNAL_AVG                      = 0x23
+	NL80211_STA_INFO_ACK_SIGNAL                          = 0x22
+	NL80211_STA_INFO_AIRTIME_LINK_METRIC                 = 0x29
+	NL80211_STA_INFO_AIRTIME_WEIGHT                      = 0x28
+	NL80211_STA_INFO_ASSOC_AT_BOOTTIME                   = 0x2a
+	NL80211_STA_INFO_BEACON_LOSS                         = 0x12
+	NL80211_STA_INFO_BEACON_RX                           = 0x1d
+	NL80211_STA_INFO_BEACON_SIGNAL_AVG                   = 0x1e
+	NL80211_STA_INFO_BSS_PARAM                           = 0xf
+	NL80211_STA_INFO_CHAIN_SIGNAL_AVG                    = 0x1a
+	NL80211_STA_INFO_CHAIN_SIGNAL                        = 0x19
+	NL80211_STA_INFO_CONNECTED_TIME                      = 0x10
+	NL80211_STA_INFO_CONNECTED_TO_AS                     = 0x2b
+	NL80211_STA_INFO_CONNECTED_TO_GATE                   = 0x26
+	NL80211_STA_INFO_DATA_ACK_SIGNAL_AVG                 = 0x23
+	NL80211_STA_INFO_EXPECTED_THROUGHPUT                 = 0x1b
+	NL80211_STA_INFO_FCS_ERROR_COUNT                     = 0x25
+	NL80211_STA_INFO_INACTIVE_TIME                       = 0x1
+	NL80211_STA_INFO_LLID                                = 0x4
+	NL80211_STA_INFO_LOCAL_PM                            = 0x14
+	NL80211_STA_INFO_MAX                                 = 0x2b
+	NL80211_STA_INFO_NONPEER_PM                          = 0x16
+	NL80211_STA_INFO_PAD                                 = 0x21
+	NL80211_STA_INFO_PEER_PM                             = 0x15
+	NL80211_STA_INFO_PLID                                = 0x5
+	NL80211_STA_INFO_PLINK_STATE                         = 0x6
+	NL80211_STA_INFO_RX_BITRATE                          = 0xe
+	NL80211_STA_INFO_RX_BYTES64                          = 0x17
+	NL80211_STA_INFO_RX_BYTES                            = 0x2
+	NL80211_STA_INFO_RX_DROP_MISC                        = 0x1c
+	NL80211_STA_INFO_RX_DURATION                         = 0x20
+	NL80211_STA_INFO_RX_MPDUS                            = 0x24
+	NL80211_STA_INFO_RX_PACKETS                          = 0x9
+	NL80211_STA_INFO_SIGNAL_AVG                          = 0xd
+	NL80211_STA_INFO_SIGNAL                              = 0x7
+	NL80211_STA_INFO_STA_FLAGS                           = 0x11
+	NL80211_STA_INFO_TID_STATS                           = 0x1f
+	NL80211_STA_INFO_T_OFFSET                            = 0x13
+	NL80211_STA_INFO_TX_BITRATE                          = 0x8
+	NL80211_STA_INFO_TX_BYTES64                          = 0x18
+	NL80211_STA_INFO_TX_BYTES                            = 0x3
+	NL80211_STA_INFO_TX_DURATION                         = 0x27
+	NL80211_STA_INFO_TX_FAILED                           = 0xc
+	NL80211_STA_INFO_TX_PACKETS                          = 0xa
+	NL80211_STA_INFO_TX_RETRIES                          = 0xb
+	NL80211_STA_WME_MAX                                  = 0x2
+	NL80211_STA_WME_MAX_SP                               = 0x2
+	NL80211_STA_WME_UAPSD_QUEUES                         = 0x1
+	NL80211_SURVEY_INFO_CHANNEL_TIME_BUSY                = 0x5
+	NL80211_SURVEY_INFO_CHANNEL_TIME                     = 0x4
+	NL80211_SURVEY_INFO_CHANNEL_TIME_EXT_BUSY            = 0x6
+	NL80211_SURVEY_INFO_CHANNEL_TIME_RX                  = 0x7
+	NL80211_SURVEY_INFO_CHANNEL_TIME_TX                  = 0x8
+	NL80211_SURVEY_INFO_FREQUENCY                        = 0x1
+	NL80211_SURVEY_INFO_FREQUENCY_OFFSET                 = 0xc
+	NL80211_SURVEY_INFO_IN_USE                           = 0x3
+	NL80211_SURVEY_INFO_MAX                              = 0xc
+	NL80211_SURVEY_INFO_NOISE                            = 0x2
+	NL80211_SURVEY_INFO_PAD                              = 0xa
+	NL80211_SURVEY_INFO_TIME_BSS_RX                      = 0xb
+	NL80211_SURVEY_INFO_TIME_BUSY                        = 0x5
+	NL80211_SURVEY_INFO_TIME                             = 0x4
+	NL80211_SURVEY_INFO_TIME_EXT_BUSY                    = 0x6
+	NL80211_SURVEY_INFO_TIME_RX                          = 0x7
+	NL80211_SURVEY_INFO_TIME_SCAN                        = 0x9
+	NL80211_SURVEY_INFO_TIME_TX                          = 0x8
+	NL80211_TDLS_DISABLE_LINK                            = 0x4
+	NL80211_TDLS_DISCOVERY_REQ                           = 0x0
+	NL80211_TDLS_ENABLE_LINK                             = 0x3
+
+	NL80211_TDLS_PEER_HT                        = 0x1
+	NL80211_TDLS_PEER_VHT                       = 0x2
+	NL80211_TDLS_PEER_WMM                       = 0x4
+	NL80211_TDLS_SETUP                          = 0x1
+	NL80211_TDLS_TEARDOWN                       = 0x2
+	NL80211_TID_CONFIG_ATTR_AMPDU_CTRL          = 0x9
+	NL80211_TID_CONFIG_ATTR_AMSDU_CTRL          = 0xb
+	NL80211_TID_CONFIG_ATTR_MAX                 = 0xd
+	NL80211_TID_CONFIG_ATTR_NOACK               = 0x6
+	NL80211_TID_CONFIG_ATTR_OVERRIDE            = 0x4
+	NL80211_TID_CONFIG_ATTR_PAD                 = 0x1
+	NL80211_TID_CONFIG_ATTR_PEER_SUPP           = 0x3
+	NL80211_TID_CONFIG_ATTR_RETRY_LONG          = 0x8
+	NL80211_TID_CONFIG_ATTR_RETRY_SHORT         = 0x7
+	NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL         = 0xa
+	NL80211_TID_CONFIG_ATTR_TIDS                = 0x5
+	NL80211_TID_CONFIG_ATTR_TX_RATE             = 0xd
+	NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE        = 0xc
+	NL80211_TID_CONFIG_ATTR_VIF_SUPP            = 0x2
+	NL80211_TID_CONFIG_DISABLE                  = 0x1
+	NL80211_TID_CONFIG_ENABLE                   = 0x0
+	NL80211_TID_STATS_MAX                       = 0x6
+	NL80211_TID_STATS_PAD                       = 0x5
+	NL80211_TID_STATS_RX_MSDU                   = 0x1
+	NL80211_TID_STATS_TX_MSDU                   = 0x2
+	NL80211_TID_STATS_TX_MSDU_FAILED            = 0x4
+	NL80211_TID_STATS_TX_MSDU_RETRIES           = 0x3
+	NL80211_TID_STATS_TXQ_STATS                 = 0x6
+	NL80211_TIMEOUT_ASSOC                       = 0x3
+	NL80211_TIMEOUT_AUTH                        = 0x2
+	NL80211_TIMEOUT_SCAN                        = 0x1
+	NL80211_TIMEOUT_UNSPECIFIED                 = 0x0
+	NL80211_TKIP_DATA_OFFSET_ENCR_KEY           = 0x0
+	NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY         = 0x18
+	NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY         = 0x10
+	NL80211_TX_POWER_AUTOMATIC                  = 0x0
+	NL80211_TX_POWER_FIXED                      = 0x2
+	NL80211_TX_POWER_LIMITED                    = 0x1
+	NL80211_TXQ_ATTR_AC                         = 0x1
+	NL80211_TXQ_ATTR_AIFS                       = 0x5
+	NL80211_TXQ_ATTR_CWMAX                      = 0x4
+	NL80211_TXQ_ATTR_CWMIN                      = 0x3
+	NL80211_TXQ_ATTR_MAX                        = 0x5
+	NL80211_TXQ_ATTR_QUEUE                      = 0x1
+	NL80211_TXQ_ATTR_TXOP                       = 0x2
+	NL80211_TXQ_Q_BE                            = 0x2
+	NL80211_TXQ_Q_BK                            = 0x3
+	NL80211_TXQ_Q_VI                            = 0x1
+	NL80211_TXQ_Q_VO                            = 0x0
+	NL80211_TXQ_STATS_BACKLOG_BYTES             = 0x1
+	NL80211_TXQ_STATS_BACKLOG_PACKETS           = 0x2
+	NL80211_TXQ_STATS_COLLISIONS                = 0x8
+	NL80211_TXQ_STATS_DROPS                     = 0x4
+	NL80211_TXQ_STATS_ECN_MARKS                 = 0x5
+	NL80211_TXQ_STATS_FLOWS                     = 0x3
+	NL80211_TXQ_STATS_MAX                       = 0xb
+	NL80211_TXQ_STATS_MAX_FLOWS                 = 0xb
+	NL80211_TXQ_STATS_OVERLIMIT                 = 0x6
+	NL80211_TXQ_STATS_OVERMEMORY                = 0x7
+	NL80211_TXQ_STATS_TX_BYTES                  = 0x9
+	NL80211_TXQ_STATS_TX_PACKETS                = 0xa
+	NL80211_TX_RATE_AUTOMATIC                   = 0x0
+	NL80211_TXRATE_DEFAULT_GI                   = 0x0
+	NL80211_TX_RATE_FIXED                       = 0x2
+	NL80211_TXRATE_FORCE_LGI                    = 0x2
+	NL80211_TXRATE_FORCE_SGI                    = 0x1
+	NL80211_TXRATE_GI                           = 0x4
+	NL80211_TXRATE_HE                           = 0x5
+	NL80211_TXRATE_HE_GI                        = 0x6
+	NL80211_TXRATE_HE_LTF                       = 0x7
+	NL80211_TXRATE_HT                           = 0x2
+	NL80211_TXRATE_LEGACY                       = 0x1
+	NL80211_TX_RATE_LIMITED                     = 0x1
+	NL80211_TXRATE_MAX                          = 0x7
+	NL80211_TXRATE_MCS                          = 0x2
+	NL80211_TXRATE_VHT                          = 0x3
+	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT     = 0x1
+	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX     = 0x2
+	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL    = 0x2
+	NL80211_USER_REG_HINT_CELL_BASE             = 0x1
+	NL80211_USER_REG_HINT_INDOOR                = 0x2
+	NL80211_USER_REG_HINT_USER                  = 0x0
+	NL80211_VENDOR_ID_IS_LINUX                  = 0x80000000
+	NL80211_VHT_CAPABILITY_LEN                  = 0xc
+	NL80211_VHT_NSS_MAX                         = 0x8
+	NL80211_WIPHY_NAME_MAXLEN                   = 0x40
+	NL80211_WMMR_AIFSN                          = 0x3
+	NL80211_WMMR_CW_MAX                         = 0x2
+	NL80211_WMMR_CW_MIN                         = 0x1
+	NL80211_WMMR_MAX                            = 0x4
+	NL80211_WMMR_TXOP                           = 0x4
+	NL80211_WOWLAN_PKTPAT_MASK                  = 0x1
+	NL80211_WOWLAN_PKTPAT_OFFSET                = 0x3
+	NL80211_WOWLAN_PKTPAT_PATTERN               = 0x2
+	NL80211_WOWLAN_TCP_DATA_INTERVAL            = 0x9
+	NL80211_WOWLAN_TCP_DATA_PAYLOAD             = 0x6
+	NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ         = 0x7
+	NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN       = 0x8
+	NL80211_WOWLAN_TCP_DST_IPV4                 = 0x2
+	NL80211_WOWLAN_TCP_DST_MAC                  = 0x3
+	NL80211_WOWLAN_TCP_DST_PORT                 = 0x5
+	NL80211_WOWLAN_TCP_SRC_IPV4                 = 0x1
+	NL80211_WOWLAN_TCP_SRC_PORT                 = 0x4
+	NL80211_WOWLAN_TCP_WAKE_MASK                = 0xb
+	NL80211_WOWLAN_TCP_WAKE_PAYLOAD             = 0xa
+	NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE          = 0x8
+	NL80211_WOWLAN_TRIG_ANY                     = 0x1
+	NL80211_WOWLAN_TRIG_DISCONNECT              = 0x2
+	NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST       = 0x7
+	NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE       = 0x6
+	NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED     = 0x5
+	NL80211_WOWLAN_TRIG_MAGIC_PKT               = 0x3
+	NL80211_WOWLAN_TRIG_NET_DETECT              = 0x12
+	NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS      = 0x13
+	NL80211_WOWLAN_TRIG_PKT_PATTERN             = 0x4
+	NL80211_WOWLAN_TRIG_RFKILL_RELEASE          = 0x9
+	NL80211_WOWLAN_TRIG_TCP_CONNECTION          = 0xe
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211        = 0xa
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN    = 0xb
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023         = 0xc
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN     = 0xd
+	NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST     = 0x10
+	NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH        = 0xf
+	NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS = 0x11
+	NL80211_WPA_VERSION_1                       = 0x1
+	NL80211_WPA_VERSION_2                       = 0x2
+	NL80211_WPA_VERSION_3                       = 0x4
+)
+
+const (
+	FRA_UNSPEC             = 0x0
+	FRA_DST                = 0x1
+	FRA_SRC                = 0x2
+	FRA_IIFNAME            = 0x3
+	FRA_GOTO               = 0x4
+	FRA_UNUSED2            = 0x5
+	FRA_PRIORITY           = 0x6
+	FRA_UNUSED3            = 0x7
+	FRA_UNUSED4            = 0x8
+	FRA_UNUSED5            = 0x9
+	FRA_FWMARK             = 0xa
+	FRA_FLOW               = 0xb
+	FRA_TUN_ID             = 0xc
+	FRA_SUPPRESS_IFGROUP   = 0xd
+	FRA_SUPPRESS_PREFIXLEN = 0xe
+	FRA_TABLE              = 0xf
+	FRA_FWMASK             = 0x10
+	FRA_OIFNAME            = 0x11
+	FRA_PAD                = 0x12
+	FRA_L3MDEV             = 0x13
+	FRA_UID_RANGE          = 0x14
+	FRA_PROTOCOL           = 0x15
+	FRA_IP_PROTO           = 0x16
+	FRA_SPORT_RANGE        = 0x17
+	FRA_DPORT_RANGE        = 0x18
+	FR_ACT_UNSPEC          = 0x0
+	FR_ACT_TO_TBL          = 0x1
+	FR_ACT_GOTO            = 0x2
+	FR_ACT_NOP             = 0x3
+	FR_ACT_RES3            = 0x4
+	FR_ACT_RES4            = 0x5
+	FR_ACT_BLACKHOLE       = 0x6
+	FR_ACT_UNREACHABLE     = 0x7
+	FR_ACT_PROHIBIT        = 0x8
+)
+
+const (
+	AUDIT_NLGRP_NONE    = 0x0
+	AUDIT_NLGRP_READLOG = 0x1
+)
+
+const (
+	TUN_F_CSUM    = 0x1
+	TUN_F_TSO4    = 0x2
+	TUN_F_TSO6    = 0x4
+	TUN_F_TSO_ECN = 0x8
+	TUN_F_UFO     = 0x10
+	TUN_F_USO4    = 0x20
+	TUN_F_USO6    = 0x40
+)
+
+const (
+	VIRTIO_NET_HDR_F_NEEDS_CSUM = 0x1
+	VIRTIO_NET_HDR_F_DATA_VALID = 0x2
+	VIRTIO_NET_HDR_F_RSC_INFO   = 0x4
+)
+
+const (
+	VIRTIO_NET_HDR_GSO_NONE   = 0x0
+	VIRTIO_NET_HDR_GSO_TCPV4  = 0x1
+	VIRTIO_NET_HDR_GSO_UDP    = 0x3
+	VIRTIO_NET_HDR_GSO_TCPV6  = 0x4
+	VIRTIO_NET_HDR_GSO_UDP_L4 = 0x5
+	VIRTIO_NET_HDR_GSO_ECN    = 0x80
+)
+
+type SchedAttr struct {
+	Size     uint32
+	Policy   uint32
+	Flags    uint64
+	Nice     int32
+	Priority uint32
+	Runtime  uint64
+	Deadline uint64
+	Period   uint64
+	Util_min uint32
+	Util_max uint32
+}
+
+const SizeofSchedAttr = 0x38
+
+type Cachestat_t struct {
+	Cache            uint64
+	Dirty            uint64
+	Writeback        uint64
+	Evicted          uint64
+	Recently_evicted uint64
+}
+type CachestatRange struct {
+	Off uint64
+	Len uint64
+}
diff --git a/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/asmdecl/asmdecl.go b/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/asmdecl/asmdecl.go
index e24dac98..eb21719e 100644
--- a/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/asmdecl/asmdecl.go
+++ b/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/asmdecl/asmdecl.go
@@ -96,6 +96,7 @@ var (
 	asmArchRISCV64  = asmArch{name: "riscv64", bigEndian: false, stack: "SP", lr: true, retRegs: []string{"X10", "F10"}}
 	asmArchS390X    = asmArch{name: "s390x", bigEndian: true, stack: "R15", lr: true}
 	asmArchWasm     = asmArch{name: "wasm", bigEndian: false, stack: "SP", lr: false}
+	asmArchSW64     = asmArch{name: "sw64", bigEndian: false, stack: "R30", lr: true}
 
 	arches = []*asmArch{
 		&asmArch386,
@@ -111,6 +112,7 @@ var (
 		&asmArchRISCV64,
 		&asmArchS390X,
 		&asmArchWasm,
+		&asmArchSW64,
 	}
 )
 
@@ -744,6 +746,27 @@ func asmCheckVar(badf func(string, ...interface{}), fn *asmFunc, line, expr stri
 			case "MOVV", "MOVD":
 				src = 8
 			}
+		case "sw64":
+                        switch op {
+                        // On sw64, load/store insts's second arg
+                        // is a disp(rb) addr
+                        case "LDBU", "STB":
+                                src = 1
+                                dst = 8
+                                addr = true
+                        case "LDHU", "STH":
+                                src = 2
+                                dst = 8
+                                addr = true
+                        case "LDW", "STW", "FLDS", "FSTS":
+                                src = 4
+                                dst = 8
+                                addr = true
+                        case "LDL", "LDL_U", "STL", "STL_U", "FLDD", "FSTD":
+                                src = 8
+                                dst = 8
+                                addr = true
+                        }
 		case "s390x":
 			switch op {
 			case "MOVB", "MOVBZ":
diff --git a/src/crypto/cipher/xor_sw64_test.s b/src/crypto/cipher/xor_sw64_test.s
new file mode 100644
index 00000000..ebedff6c
--- /dev/null
+++ b/src/crypto/cipher/xor_sw64_test.s
@@ -0,0 +1,69 @@
+//go:build ignore
+// +build ignore
+
+#include "textflag.h"
+
+// func xorBytesSW64(dst, a, b *byte n int)
+TEXT ·xorBytesSW64(SB), NOSPLIT, $0
+	LDL R0, dst+0(FP)
+	LDL R1, a+8(FP)
+	LDL R2, b+16(FP)
+	LDL R3, n+24(FP)
+	CMPLT R3, $32, R4
+	BNE R4, before_loop_8
+loop_32:
+	VLDD V1, (R1)
+	VLDD V2, (R2)
+	LDI R1, 32(R1)  // addr(a) + 32
+	LDI R2, 32(R2)  // addr(b) + 32
+	VXOR V1, V2
+	VSTD V2, (R0)
+	LDI R0, 32(R0)  // addr(dst) + 32
+	LDI R3, -32(R3)  // n - 32
+	CMPLT R3, $32, R4
+	BEQ R4, loop_32
+before_loop_8:
+	CMPLT R3, $8, R4
+        BNE R4, less_than8
+loop_8:
+	LDL R11, (R1)
+  LDL R12, (R2)
+  LDI R1, 8(R1)
+  LDI R2, 8(R2)
+  XOR R11, R12, R12
+  STL R12, (R0)
+  LDI R0, 8(R0)
+  LDI R3, -8(R3)     // n - 8
+  CMPLT R3, $8, R4   // if n < 8
+  BEQ R4, loop_8
+less_than8:
+	BEQ R3, end
+	CMPLT R3, $4, R4
+	BNE R4, less_than4
+	LDW R13, (R1)
+	LDW R14, (R2)
+	LDI R1, 4(R1)
+	LDI R2, 4(R2)
+	XOR R13, R14, R14
+	STW R14, (R0)
+	LDI R0, 4(R0)
+	LDI R3, -4(R3)  // n - 4
+less_than4:
+	CMPLT R3, $2, R4
+	BNE R4, less_than2
+	LDHU R16, (R1)
+	LDHU R17, (R2)
+	LDI R1, 2(R1)
+	LDI R2, 2(R2)
+	XOR R16, R17, R17
+	STH R17, (R0)
+	LDI R0, 2(R0)
+	LDI R3, -2(R3)  // n - 2
+less_than2:
+	BEQ R3, end
+	LDBU R18, (R1)
+	LDBU R19, (R2)
+	XOR R18, R19, R19
+	STB R19, (R0)
+end:
+	RET
diff --git a/src/crypto/subtle/xor_generic.go b/src/crypto/subtle/xor_generic.go
index 7dc89e31..d8009bad 100644
--- a/src/crypto/subtle/xor_generic.go
+++ b/src/crypto/subtle/xor_generic.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build (!amd64 && !arm64 && !ppc64 && !ppc64le) || purego
+//go:build (!amd64 && !arm64 && !ppc64 && !ppc64le && !sw64) || purego
 
 package subtle
 
diff --git a/src/crypto/subtle/xor_sw64.go b/src/crypto/subtle/xor_sw64.go
new file mode 100644
index 00000000..65bab4c6
--- /dev/null
+++ b/src/crypto/subtle/xor_sw64.go
@@ -0,0 +1,10 @@
+// Copyright 2020 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !purego
+
+package subtle
+
+//go:noescape
+func xorBytes(dst, a, b *byte, n int)
diff --git a/src/crypto/subtle/xor_sw64.s b/src/crypto/subtle/xor_sw64.s
new file mode 100644
index 00000000..a1139791
--- /dev/null
+++ b/src/crypto/subtle/xor_sw64.s
@@ -0,0 +1,55 @@
+//go:build !purego
+
+#include "textflag.h"
+
+// func xorBytes(dst, a, b *byte n int)
+TEXT ·xorBytes(SB), NOSPLIT, $0
+	LDL R0, dst+0(FP)
+	LDL R1, a+8(FP)
+	LDL R2, b+16(FP)
+	LDL R3, n+24(FP)
+	CMPLT R3, $8, R4
+	BNE R4, less_than8
+loop_8:
+	LDL R11, (R1) 
+	LDL R12, (R2)
+	LDI R1, 8(R1)  // addr(a) + 8
+	LDI R2, 8(R2)  // addr(b) + 8
+	XOR R11, R12, R12
+	STL R12, (R0)
+	LDI R0, 8(R0)  // addr(dst) +8
+	LDI R3, -8(R3)  // n - 8
+	CMPLT R3, $8, R4
+	BEQ R4, loop_8
+less_than8:
+	BEQ R3, end
+	CMPLT R3, $4, R4
+	BNE R4, less_than4
+	LDW R13, (R1)
+	LDW R14, (R2)
+	LDI R1, 4(R1)
+	LDI R2, 4(R2)
+	XOR R13, R14, R14
+	STW R14, (R0)
+	LDI R0, 4(R0)
+	LDI R3, -4(R3)  // n - 4
+less_than4:
+	CMPLT R3, $2, R4
+	BNE R4, less_than2
+	LDHU R16, (R1)
+	LDHU R17, (R2)
+	LDI R1, 2(R1)
+	LDI R2, 2(R2)
+	XOR R16, R17, R17
+	STH R17, (R0)
+	LDI R0, 2(R0)
+	LDI R3, -2(R3)  // n - 2
+less_than2:
+	BEQ R3, end
+	LDBU R18, (R1)
+	LDBU R19, (R2)
+	XOR R18, R19, R19
+	STB R19, (R0)
+end:
+	RET
+	
diff --git a/src/debug/elf/elf.go b/src/debug/elf/elf.go
index e7836775..c28c1d87 100644
--- a/src/debug/elf/elf.go
+++ b/src/debug/elf/elf.go
@@ -391,6 +391,7 @@ const (
 	EM_MIPS_RS4_BE Machine = 10     /* MIPS R4000 Big-Endian */
 	EM_ALPHA_STD   Machine = 41     /* Digital Alpha (standard value). */
 	EM_ALPHA       Machine = 0x9026 /* Alpha (written in the absence of an ABI) */
+	EM_SW64        Machine = 0x9916
 )
 
 var machineStrings = []intName{
@@ -583,6 +584,7 @@ var machineStrings = []intName{
 	{10, "EM_MIPS_RS4_BE"},
 	{41, "EM_ALPHA_STD"},
 	{0x9026, "EM_ALPHA"},
+	{0x9916, "EM_SW64"},
 }
 
 func (i Machine) String() string   { return stringName(uint32(i), machineStrings, false) }
@@ -2993,6 +2995,113 @@ var rppc64Strings = []intName{
 func (i R_PPC64) String() string   { return stringName(uint32(i), rppc64Strings, false) }
 func (i R_PPC64) GoString() string { return stringName(uint32(i), rppc64Strings, true) }
 
+// Relocation types for SW64.
+type R_SW64 int
+
+const (
+	R_SW64_NONE            R_SW64 = 0  /* No reloc */
+	R_SW64_REFLONG         R_SW64 = 1  /* Direct 32 bit */
+	R_SW64_REFQUAD         R_SW64 = 2  /* Direct 64 bit */
+	R_SW64_GPREL32         R_SW64 = 3  /* GP relative 32 bit */
+	R_SW64_LITERAL         R_SW64 = 4  /* GP relative 16 bit w/optimization */
+	R_SW64_LITUSE          R_SW64 = 5  /* Optimization hint for LITERAL */
+	R_SW64_GPDISP          R_SW64 = 6  /* Add displacement to GP */
+	R_SW64_BRADDR          R_SW64 = 7  /* PC+4 relative 23 bit shifted */
+	R_SW64_HINT            R_SW64 = 8  /* PC+4 relative 16 bit shifted */
+	R_SW64_SREL16          R_SW64 = 9  /* PC relative 16 bit */
+	R_SW64_SREL32          R_SW64 = 10 /* PC relative 32 bit */
+	R_SW64_SREL64          R_SW64 = 11 /* PC relative 64 bit */
+	R_SW64_OP_PUSH         R_SW64 = 12 /* OP stack push */ /* Skip 12 - 16 on sw64; deprecated ECOFF relocs. Now copy 12 - 16 of ALPHA*/
+	R_SW64_OP_STORE        R_SW64 = 13 /* OP stack pop and store */
+	R_SW64_OP_PSUB         R_SW64 = 14 /* OP stack subtract */
+	R_SW64_OP_PRSHIFT      R_SW64 = 15 /* OP stack right shift */
+	R_SW64_GPVALUE         R_SW64 = 16
+	R_SW64_GPRELHIGH       R_SW64 = 17 /* GP relative 32 bit, high 16 bits */
+	R_SW64_GPRELLOW        R_SW64 = 18 /* GP relative 32 bit, low 16 bits */
+	R_SW64_GPREL16         R_SW64 = 19 /* GP relative 16 bit */
+	R_SW64_IMMED_GP_HI32   R_SW64 = 20 /* Skip 20 - 23 on sw64; deprecated ECOFF relocs. Now copy 20 - 23 of ALPHA*/
+	R_SW64_IMMED_SCN_HI32  R_SW64 = 21
+	R_SW64_IMMED_BR_HI32   R_SW64 = 22
+	R_SW64_IMMED_LO32      R_SW64 = 23
+	R_SW64_COPY            R_SW64 = 24 /* Copy symbol at runtime */
+	R_SW64_GLOB_DAT        R_SW64 = 25 /* Create GOT entry */
+	R_SW64_JMP_SLOT        R_SW64 = 26 /* Create PLT entry */
+	R_SW64_RELATIVE        R_SW64 = 27 /* Adjust by program base */
+	R_SW64_BRSGP           R_SW64 = 28 /* Like BRADDR, but assert that the source and target object file share the same GP value, and adjust the target address for STO_SW64_STD_GPLOAD. */
+	R_SW64_TLSGD           R_SW64 = 29 /* 29 - 41 Thread-Local Storage.  */
+	R_SW64_TLSLDM          R_SW64 = 30
+	R_SW64_DTPMOD64        R_SW64 = 31
+	R_SW64_GOTDTPREL       R_SW64 = 32
+	R_SW64_DTPREL64        R_SW64 = 33
+	R_SW64_DTPRELHI        R_SW64 = 34
+	R_SW64_DTPRELLO        R_SW64 = 35
+	R_SW64_DTPREL16        R_SW64 = 36
+	R_SW64_GOTTPREL        R_SW64 = 37
+	R_SW64_TPREL64         R_SW64 = 38
+	R_SW64_TPRELHI         R_SW64 = 39
+	R_SW64_TPRELLO         R_SW64 = 40
+	R_SW64_TPREL16         R_SW64 = 41
+	R_SW64_BR26ADDR        R_SW64 = 42
+	R_SW64_LITERAL_GOT     R_SW64 = 43
+	R_SW64_ADD_PCREL_HI_13 R_SW64 = 45
+	R_SW64_ADD_PCREL_LO_13 R_SW64 = 46
+	R_SW64_ADD_ABS_LO_16   R_SW64 = 47
+	R_SW64_CALL26          R_SW64 = 48
+)
+
+var rsw64Strings = []intName{
+	{0, "R_SW64_NONE"},
+	{1, "R_SW64_REFLONG"},
+	{2, "R_SW64_REFQUAD"},
+	{3, "R_SW64_GPREL32"},
+	{4, "R_SW64_LITERAL"},
+	{5, "R_SW64_LITUSE"},
+	{6, "R_SW64_GPDISP"},
+	{7, "R_SW64_BRADDR"},
+	{8, "R_SW64_HINT"},
+	{9, "R_SW64_SREL16"},
+	{10, "R_SW64_SREL32"},
+	{11, "R_SW64_SREL64"},
+	{12, "R_SW64_OP_PUSH"},
+	{13, "R_SW64_OP_STORE"},
+	{14, "R_SW64_OP_PSUB"},
+	{15, "R_SW64_OP_PRSHIFT"},
+	{16, "R_SW64_GPVALUE"},
+	{17, "R_SW64_GPRELHIGH"},
+	{18, "R_SW64_GPRELLOW"},
+	{19, "R_SW64_GPREL16"},
+	{20, "R_SW64_IMMED_GP_HI32"},
+	{21, "R_SW64_IMMED_SCN_HI32"},
+	{22, "R_SW64_IMMED_BR_HI32"},
+	{23, "R_SW64_IMMED_LO32"},
+	{24, "R_SW64_COPY"},
+	{25, "R_SW64_GLOB_DAT"},
+	{26, "R_SW64_JMP_SLOT"},
+	{27, "R_SW64_RELATIVE"},
+	{28, "R_SW64_BRSGP"},
+	{29, "R_SW64_TLSGD"},
+	{30, "R_SW64_TLSLDM"},
+	{31, "R_SW64_DTPMOD64"},
+	{32, "R_SW64_GOTDTPREL"},
+	{33, "R_SW64_DTPREL64"},
+	{34, "R_SW64_DTPRELHI"},
+	{35, "R_SW64_DTPRELLO"},
+	{36, "R_SW64_DTPREL16"},
+	{37, "R_SW64_GOTTPREL"},
+	{38, "R_SW64_TPREL64"},
+	{39, "R_SW64_TPRELHI"},
+	{40, "R_SW64_TPRELLO"},
+	{41, "R_SW64_TPREL16"},
+	{42, "R_SW64_BR26ADDR"},
+	{43, "R_SW64_LITERAL_GOT"},
+	{45, "R_SW64_ADD_PCREL_HI_13"},
+	{46, "R_SW64_ADD_PCREL_LO_13"},
+	{47, "R_SW64_ADD_ABS_LO_16"},
+}
+
+func (i R_SW64) String() string   { return stringName(uint32(i), rsw64Strings, false) }
+func (i R_SW64) GoString() string { return stringName(uint32(i), rsw64Strings, true) }
+
 // Relocation types for RISC-V processors.
 type R_RISCV int
 
diff --git a/src/debug/elf/elf_test.go b/src/debug/elf/elf_test.go
index 0350d530..81151a20 100644
--- a/src/debug/elf/elf_test.go
+++ b/src/debug/elf/elf_test.go
@@ -32,6 +32,7 @@ var nameTests = []nameTest{
 	{STV_HIDDEN, "STV_HIDDEN"},
 	{R_X86_64_PC32, "R_X86_64_PC32"},
 	{R_ALPHA_OP_PUSH, "R_ALPHA_OP_PUSH"},
+	{R_SW64_OP_PUSH, "R_SW64_OP_PUSH"},
 	{R_ARM_THM_ABS5, "R_ARM_THM_ABS5"},
 	{R_386_GOT32, "R_386_GOT32"},
 	{R_PPC_GOT16_HI, "R_PPC_GOT16_HI"},
diff --git a/src/debug/elf/file.go b/src/debug/elf/file.go
index 7228447c..1cfc554f 100644
--- a/src/debug/elf/file.go
+++ b/src/debug/elf/file.go
@@ -768,6 +768,8 @@ func (f *File) applyRelocations(dst []byte, rels []byte) error {
 		return f.applyRelocationss390x(dst, rels)
 	case f.Class == ELFCLASS64 && f.Machine == EM_SPARCV9:
 		return f.applyRelocationsSPARC64(dst, rels)
+	case f.Class == ELFCLASS64 && f.Machine == EM_SW64:
+                return f.applyRelocationsSW64(dst, rels)
 	default:
 		return errors.New("applyRelocations: not implemented")
 	}
@@ -1321,6 +1323,54 @@ func (f *File) applyRelocationsSPARC64(dst []byte, rels []byte) error {
 	return nil
 }
 
+func (f *File) applyRelocationsSW64(dst []byte, rels []byte) error {
+        // 24 is the size of Rela64.
+        if len(rels)%24 != 0 {
+                return errors.New("length of relocation section is not a multiple of 24")
+        }
+
+        symbols, _, err := f.getSymbols(SHT_SYMTAB)
+        if err != nil {
+                return err
+        }
+
+        b := bytes.NewReader(rels)
+        var rela Rela64
+
+        for b.Len() > 0 {
+                binary.Read(b, f.ByteOrder, &rela)
+                symNo := rela.Info >> 32
+                t := R_SW64(rela.Info & 0xffff)
+
+                if symNo == 0 || symNo > uint64(len(symbols)) {
+                        continue
+                }
+
+		sym := &symbols[symNo-1]
+	        if !canApplyRelocation(sym) {
+	                // We don't handle non-section relocations for now.
+	                continue
+	        }
+	        switch t {
+		case R_SW64_REFQUAD:
+                        if rela.Off+8 >= uint64(len(dst)) || rela.Addend < 0 {
+                                continue
+	                }
+		        val64 := sym.Value + uint64(rela.Addend)
+			f.ByteOrder.PutUint64(dst[rela.Off:rela.Off+8], val64)
+                case R_SW64_REFLONG:
+                        if rela.Off+4 >= uint64(len(dst)) || rela.Addend < 0 {
+                                continue
+                        }
+	                val32 := uint32(sym.Value) + uint32(rela.Addend)
+                        f.ByteOrder.PutUint32(dst[rela.Off:rela.Off+4], val32)
+                }
+        }
+
+        return nil
+}
+
+
 func (f *File) DWARF() (*dwarf.Data, error) {
 	dwarfSuffix := func(s *Section) string {
 		switch {
diff --git a/src/encoding/binary/native_endian_little.go b/src/encoding/binary/native_endian_little.go
index 38d3e9b6..d1ca0721 100644
--- a/src/encoding/binary/native_endian_little.go
+++ b/src/encoding/binary/native_endian_little.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build 386 || amd64 || amd64p32 || alpha || arm || arm64 || loong64 || mipsle || mips64le || mips64p32le || nios2 || ppc64le || riscv || riscv64 || sh || wasm
+//go:build 386 || amd64 || amd64p32 || alpha || arm || arm64 || loong64 || mipsle || mips64le || mips64p32le || nios2 || ppc64le || riscv || riscv64 || sh || wasm || sw64
 
 package binary
 
diff --git a/src/go/build/syslist.go b/src/go/build/syslist.go
index 783bbe69..77305532 100644
--- a/src/go/build/syslist.go
+++ b/src/go/build/syslist.go
@@ -78,4 +78,5 @@ var knownArch = map[string]bool{
 	"sparc":       true,
 	"sparc64":     true,
 	"wasm":        true,
+	"sw64":        true,
 }
diff --git a/src/go/types/gccgosizes.go b/src/go/types/gccgosizes.go
index 9152c811..e74e501a 100644
--- a/src/go/types/gccgosizes.go
+++ b/src/go/types/gccgosizes.go
@@ -40,4 +40,5 @@ var gccgoArchSizes = map[string]*StdSizes{
 	"sparc":       {4, 8},
 	"sparc64":     {8, 8},
 	"wasm":        {8, 8},
+	"sw64":        {8, 8},
 }
diff --git a/src/go/types/sizes.go b/src/go/types/sizes.go
index 12a21401..199ed906 100644
--- a/src/go/types/sizes.go
+++ b/src/go/types/sizes.go
@@ -246,6 +246,7 @@ var gcArchSizes = map[string]*gcSizes{
 	"s390x":    {8, 8},
 	"sparc64":  {8, 8},
 	"wasm":     {8, 8},
+	"sw64":     {8, 8},
 	// When adding more architectures here,
 	// update the doc string of SizesFor below.
 }
@@ -255,7 +256,7 @@ var gcArchSizes = map[string]*gcSizes{
 //
 // Supported architectures for compiler "gc":
 // "386", "amd64", "amd64p32", "arm", "arm64", "loong64", "mips", "mipsle",
-// "mips64", "mips64le", "ppc64", "ppc64le", "riscv64", "s390x", "sparc64", "wasm".
+// "mips64", "mips64le", "ppc64", "ppc64le", "riscv64", "s390x", "sparc64", "wasm", "sw64".
 func SizesFor(compiler, arch string) Sizes {
 	switch compiler {
 	case "gc":
diff --git a/src/hash/crc32/crc32_otherarch.go b/src/hash/crc32/crc32_otherarch.go
index 76251525..d178fa49 100644
--- a/src/hash/crc32/crc32_otherarch.go
+++ b/src/hash/crc32/crc32_otherarch.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !amd64 && !s390x && !ppc64le && !arm64
+//go:build !amd64 && !s390x && !ppc64le && !arm64 && !sw64
 
 package crc32
 
diff --git a/src/hash/crc32/crc32_sw64.go b/src/hash/crc32/crc32_sw64.go
new file mode 100644
index 00000000..92a05a22
--- /dev/null
+++ b/src/hash/crc32/crc32_sw64.go
@@ -0,0 +1,50 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// SW64-specific hardware-assisted CRC32 algorithms. See crc32.go for a
+// description of the interface that each architecture-specific file
+// implements.
+
+package crc32
+
+import "internal/cpu"
+
+func castagnoliUpdate(crc uint32, p []byte) uint32
+func ieeeUpdate(crc uint32, p []byte) uint32
+
+func archAvailableCastagnoli() bool {
+	return cpu.SW64.HasCRC
+}
+
+func archInitCastagnoli() {
+	if !cpu.SW64.HasCRC {
+		panic("arch-specific crc32 instruction for Catagnoli not available")
+	}
+}
+
+func archUpdateCastagnoli(crc uint32, p []byte) uint32 {
+	if !cpu.SW64.HasCRC {
+		panic("arch-specific crc32 instruction for Castagnoli not available")
+	}
+
+	return ^castagnoliUpdate(^crc, p)
+}
+
+func archAvailableIEEE() bool {
+	return cpu.SW64.HasCRC
+}
+
+func archInitIEEE() {
+	if !cpu.SW64.HasCRC {
+		panic("arch-specific crc32 instruction for IEEE not available")
+	}
+}
+
+func archUpdateIEEE(crc uint32, p []byte) uint32 {
+	if !cpu.SW64.HasCRC {
+		panic("arch-specific crc32 instruction for IEEE not available")
+	}
+
+	return ^ieeeUpdate(^crc, p)
+}
diff --git a/src/hash/crc32/crc32_sw64.s b/src/hash/crc32/crc32_sw64.s
new file mode 100644
index 00000000..6580364c
--- /dev/null
+++ b/src/hash/crc32/crc32_sw64.s
@@ -0,0 +1,103 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+#include "textflag.h"
+
+// castagnoliUpdate updates the non-inverted crc with the given data.
+
+// func castagnoliUpdate(crc uint32, p []byte) uint32
+TEXT ·castagnoliUpdate(SB),NOSPLIT,$0-36
+	LDW	R9, crc+0(FP)  // CRC value
+	LDL	 R13, p+8(FP)  // data pointer
+	LDL R11,	p_len+16(FP)  // len(p)
+	ZAPNOT R9, $15, R9
+
+	CMPLT	R11, $8, R8
+	BNE	R8, less_than_8
+
+update:
+	LDLA R10,	8(R13)
+	CRC32CL	R9, R10, R9
+	SUBL	R11, $8, R11
+
+	CMPLT	R11, $8, R8
+	BNE	R8, less_than_8
+
+	JMP	update
+
+less_than_8:
+	AND R11, $4, R8
+	BEQ R8, less_than_4
+
+	LDWA	R10, 4(R13)
+	ZAPNOT R10, $15, R10
+	CRC32CW	R9, R10, R9
+	SUBL	R11, $4, R11
+
+less_than_4:
+	AND R11, $2, R8
+	BEQ	R8, less_than_2
+
+	LDHUA	R10, 2(R13)
+	CRC32CH	R9, R10, R9
+	SUBL	R11, $2, R11
+
+less_than_2:
+	BEQ	R11, done
+
+	LDBU	R10, (R13)
+	CRC32CB	R9, R10, R9
+
+done:
+	STW	R9, ret+32(FP)
+	RET
+
+// ieeeUpdate updates the non-inverted crc with the given data.
+
+// func ieeeUpdate(crc uint32, p []byte) uint32
+TEXT ·ieeeUpdate(SB),NOSPLIT,$0-36
+	LDW	R9, crc+0(FP)  // CRC value
+	LDL	 R13, p+8(FP)  // data pointer
+	LDL R11,	p_len+16(FP)  // len(p)
+	ZAPNOT R9, $15, R9
+
+	CMPLT	R11, $8, R8
+	BNE	R8, less_than_8
+
+update:
+	LDLA R10,	8(R13)
+	CRC32L	R9, R10, R9
+	SUBL	R11, $8, R11
+
+	CMPLT	R11, $8, R8
+	BNE	R8, less_than_8
+
+	JMP	update
+
+less_than_8:
+	CMPLT R11, $4, R8
+	BNE R8, less_than_4
+
+	LDWA	R10, 4(R13)
+	ZAPNOT R10, $15, R10
+	CRC32W	R9, R10, R9
+	SUBL	R11, $4, R11
+
+less_than_4:
+	CMPLT R11, $2, R8
+	BNE	R8, less_than_2
+
+	LDHUA	R10, 2(R13)
+	CRC32H	R9, R10, R9
+	SUBL	R11, $2, R11
+
+less_than_2:
+	BEQ	R11, done
+
+	LDBU	R10, (R13)
+	CRC32B	R9, R10, R9
+
+done:
+	STW	R9, ret+32(FP)
+	RET
diff --git a/src/internal/abi/abi_sw64.go b/src/internal/abi/abi_sw64.go
new file mode 100644
index 00000000..7ecd0b8d
--- /dev/null
+++ b/src/internal/abi/abi_sw64.go
@@ -0,0 +1,19 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.regabiargs && sw64
+
+package abi
+
+const (
+	// See abi_generic.go.
+
+	// R16 - R24.
+	IntArgRegs = 9
+
+	// F16 - F24.
+	FloatArgRegs = 9
+
+	EffectiveFloatRegSize = 8
+)
diff --git a/src/internal/abi/switch.go b/src/internal/abi/switch.go
index 9669fe51..eab8ef8e 100644
--- a/src/internal/abi/switch.go
+++ b/src/internal/abi/switch.go
@@ -36,7 +36,7 @@ func UseInterfaceSwitchCache(goarch string) bool {
 	// We need an atomic load instruction to make the cache multithreaded-safe.
 	// (AtomicLoadPtr needs to be implemented in cmd/compile/internal/ssa/_gen/ARCH.rules.)
 	switch goarch {
-	case "amd64", "arm64", "loong64", "mips", "mipsle", "mips64", "mips64le", "ppc64", "ppc64le", "riscv64", "s390x":
+	case "amd64", "arm64", "loong64", "mips", "mipsle", "mips64", "mips64le", "ppc64", "ppc64le", "riscv64", "s390x", "sw64":
 		return true
 	default:
 		return false
diff --git a/src/internal/buildcfg/cfg.go b/src/internal/buildcfg/cfg.go
index 8b97a653..8feb0ee6 100644
--- a/src/internal/buildcfg/cfg.go
+++ b/src/internal/buildcfg/cfg.go
@@ -31,6 +31,7 @@ var (
 	GOMIPS64 = gomips64()
 	GOPPC64  = goppc64()
 	GOWASM   = gowasm()
+	GOSW64   = gosw64()
 	ToolTags = toolTags()
 	GO_LDSO  = defaultGO_LDSO
 	Version  = version
@@ -157,6 +158,19 @@ func goppc64() int {
 	return int(defaultGOPPC64[len("power")] - '0')
 }
 
+func gosw64() int {
+	switch v := envOr("GOSW64", defaultGOSW64); v {
+	case "swv3":
+		return 3
+	case "swv4":
+		return 4
+	case "swv5":
+		return 5
+	}
+	Error = fmt.Errorf("Invalid SW64 value. Must be swv3 or swv4.")
+	return int(defaultGOSW64[len("swv")] - '0')
+}
+
 type gowasmFeatures struct {
 	SatConv bool
 	SignExt bool
diff --git a/src/internal/buildcfg/exp.go b/src/internal/buildcfg/exp.go
index a45cfaf8..591948fa 100644
--- a/src/internal/buildcfg/exp.go
+++ b/src/internal/buildcfg/exp.go
@@ -65,7 +65,7 @@ func ParseGOEXPERIMENT(goos, goarch, goexp string) (*ExperimentFlags, error) {
 	case "amd64", "arm64", "ppc64le", "ppc64", "riscv64":
 		regabiAlwaysOn = true
 		regabiSupported = true
-	case "loong64":
+	case "loong64", "sw64":
 		regabiSupported = true
 	}
 
diff --git a/src/internal/bytealg/compare_generic.go b/src/internal/bytealg/compare_generic.go
index b04e2750..9b7c7bf4 100644
--- a/src/internal/bytealg/compare_generic.go
+++ b/src/internal/bytealg/compare_generic.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !386 && !amd64 && !s390x && !arm && !arm64 && !loong64 && !ppc64 && !ppc64le && !mips && !mipsle && !wasm && !mips64 && !mips64le && !riscv64
+//go:build !386 && !amd64 && !s390x && !arm && !arm64 && !loong64 && !ppc64 && !ppc64le && !mips && !mipsle && !wasm && !mips64 && !mips64le && !riscv64 && !sw64
 
 package bytealg
 
diff --git a/src/internal/bytealg/compare_native.go b/src/internal/bytealg/compare_native.go
index 34964e28..46aeac7c 100644
--- a/src/internal/bytealg/compare_native.go
+++ b/src/internal/bytealg/compare_native.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build 386 || amd64 || s390x || arm || arm64 || loong64 || ppc64 || ppc64le || mips || mipsle || wasm || mips64 || mips64le || riscv64
+//go:build 386 || amd64 || s390x || arm || arm64 || loong64 || ppc64 || ppc64le || mips || mipsle || wasm || mips64 || mips64le || riscv64 || sw64
 
 package bytealg
 
diff --git a/src/internal/bytealg/compare_sw64.s b/src/internal/bytealg/compare_sw64.s
new file mode 100644
index 00000000..f5b10630
--- /dev/null
+++ b/src/internal/bytealg/compare_sw64.s
@@ -0,0 +1,93 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+// +build sw64
+
+#include "go_asm.h"
+#include "textflag.h"
+
+TEXT ·Compare<ABIInternal>(SB),NOFRAME|NOSPLIT,$0-56
+#ifdef GOEXPERIMENT_regabiargs
+	// R16 = a_base (want in R16)
+	// R17 = a_len  (want in R17)
+	// R18 = a_cap  (unused)
+	// R19 = b_base (want in R18)
+	// R20 = b_len  (want in R19)
+	// R21 = b_cap  (unused)
+	LDI	R18, R19
+	LDI	R19, R20
+#else 
+	LDL	R16, a_base+0(FP)
+	LDL	R17, a_len+8(FP)
+	LDL	R18, b_base+24(FP)
+	LDL	R19, b_len+32(FP)
+#endif
+	CMPEQ	R16, R18, R4
+	BNE	R4, samebytes
+	CMPULT	R17, R19, R4
+	SELEQ	R4, R19, R17, R5    // R5 is min(R0,R1)
+
+	ADDL	R5, R16, R5
+loop:
+	CMPEQ	R5, R16, R8
+	BNE	R8, samebytes   // all compared bytes were the same; compare lengths
+	LDBU	R6, (R16)
+	ADDL	R16, $1, R16
+	LDBU	R7, (R18)
+	ADDL	R18, $1, R18
+	CMPEQ	R6, R7, R8
+	BNE	R8, loop
+	// bytes differed
+	CMPULT	R7, R6, R8
+	LDI	R6, $-1
+	SELEQ	R8, R6, R8, R16
+	JMP	cmp_ret
+samebytes:
+	CMPULT	R19, R17, R6
+	CMPULT	R17, R19, R7
+	SUBL	R6, R7, R16
+cmp_ret:
+#ifndef GOEXPERIMENT_regabiargs
+	STL	R16, ret+48(FP)
+#endif
+	RET
+
+TEXT runtime·cmpstring<ABIInternal>(SB),NOFRAME|NOSPLIT,$0-40
+#ifndef GOEXPERIMENT_regabiargs
+	LDL	R16, a_base+0(FP)
+	LDL	R17, a_len+8(FP)
+	LDL	R18, b_base+16(FP)
+	LDL	R19, b_len+24(FP)
+#endif
+	CMPEQ	R16, R18, R4
+	BNE	R4, samebytes
+	CMPULT	R17, R19, R4
+	SELEQ	R4, R19, R17, R5    // R5 is min(R0,R1)
+
+	ADDL	R5, R16, R5
+loop:
+	CMPEQ	R5, R16, R8
+	BNE	R8, samebytes   // all compared bytes were the same; compare lengths
+
+	LDBU	R6, (R16)
+	ADDL	R16, $1, R16
+	LDBU	R7, (R18)
+	ADDL	R18, $1, R18
+	CMPEQ	R6, R7, R8
+	BNE	R8, loop
+	// bytes differed
+	CMPULT	R7, R6, R8
+	LDI	R6, $-1
+	SELEQ	R8, R6, R8, R16
+	JMP	cmp_ret
+samebytes:
+	CMPULT	R19, R17, R6
+	CMPULT	R17, R19, R7
+	SUBL	R6, R7, R16
+cmp_ret:
+#ifndef GOEXPERIMENT_regabiargs
+	STL	R16, ret+32(FP)
+#endif
+	RET
diff --git a/src/internal/bytealg/count_generic.go b/src/internal/bytealg/count_generic.go
index 932a7c58..1721316f 100644
--- a/src/internal/bytealg/count_generic.go
+++ b/src/internal/bytealg/count_generic.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !amd64 && !arm && !arm64 && !ppc64le && !ppc64 && !riscv64 && !s390x
+//go:build !amd64 && !arm && !arm64 && !ppc64le && !ppc64 && !riscv64 && !s390x && !sw64
 
 package bytealg
 
diff --git a/src/internal/bytealg/count_native.go b/src/internal/bytealg/count_native.go
index 90189c9f..f4971772 100644
--- a/src/internal/bytealg/count_native.go
+++ b/src/internal/bytealg/count_native.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build amd64 || arm || arm64 || ppc64le || ppc64 || riscv64 || s390x
+//go:build amd64 || arm || arm64 || ppc64le || ppc64 || riscv64 || s390x || sw64
 
 package bytealg
 
diff --git a/src/internal/bytealg/count_sw64.s b/src/internal/bytealg/count_sw64.s
new file mode 100644
index 00000000..c67a989a
--- /dev/null
+++ b/src/internal/bytealg/count_sw64.s
@@ -0,0 +1,112 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+// +build sw64
+
+#include "go_asm.h"
+#include "textflag.h"
+
+TEXT ·Count(SB),NOSPLIT,$0-40
+	LDL	R0, b_base+0(FP)
+	LDL	R2, b_len+8(FP)
+	LDBU	R1, c+24(FP)
+	LDI	R8, $ret+32(FP)
+	BR	countbytebody<>(SB)
+
+TEXT ·CountString(SB),NOSPLIT,$0-32
+	LDL	R0, s_base+0(FP)
+	LDL	R2, s_len+8(FP)
+	LDBU	R1, c+16(FP)
+	LDI	R8, $ret+24(FP)
+	BR	countbytebody<>(SB)
+
+// input:
+//   R0: data
+//   R2: data len
+//   R1: byte to find
+//   R8: address to put result
+TEXT countbytebody<>(SB),NOSPLIT,$0-0
+	// R11 = count of byte to search
+	LDI	R11, $0
+	// short path to handle 0-byte case
+	BEQ	R2, done
+	CMPULT	R2, $0x10, R28
+	// jump directly to tail if length < 32
+	BNE	R28, tail
+
+	AND	R0, $0xf, R9
+	BEQ	R9, chunk
+	// Work with not 32-byte aligned head
+	BIC	R0, $0xf, R3
+	ADDL	R3, $0x10, R3
+head_loop:
+	LDBU	R5, (R0)
+	ADDL	R0, $1, R0
+	CMPEQ	R5, R1, R28
+	ADDL	R11, R28, R11
+	SUBL	R2, $1, R2
+	CMPEQ	R0, R3, R28
+	BEQ	R28, head_loop
+	// Work with 32-byte aligned chunks
+chunk:
+	BIC	R2, $0xf, R9
+	// The first chunk can also be the last
+	BEQ	R9, tail
+	// R3 = end of 32-byte chunks
+	ADDL	R0, R9, R3
+	// R2 = length of tail
+	SUBL	R2, R9, R2
+	// Duplicate R1 (byte to search) to 16 1-byte elements of V0
+	XOR R7, R7, R7
+	BIS R1, R7, R7
+	SLL R7, $8, R7
+	BIS R1, R7, R7
+	SLL R7, $8, R7
+	BIS R1, R7, R7
+	SLL R7, $8, R7
+	BIS R1, R7, R7
+	SLL R7, $8, R7
+	BIS R1, R7, R7
+	SLL R7, $8, R7
+	BIS R1, R7, R7
+	SLL R7, $8, R7
+	BIS R1, R7, R7
+	SLL R7, $8, R7
+	BIS R1, R7, R7
+
+	XOR R22, R22, R22
+	// Count the target byte in 32-byte chunk
+chunk_loop:
+	LDL R16, (R0)
+	LDL R17, 8(R0)
+  ADDL R0, $16, R0
+	CMPEQ	R0, R3, R28
+	//VCMPUEQB	V0, V1, V3
+	CMPGEB R7, R16, R18
+	CMPGEB R7, R17, R19
+	CMPGEB R16, R7, R16
+	CMPGEB R17, R7, R17
+	AND R16, R18, R16
+	AND R17, R19, R17
+	// Count lanes match the requested byte
+	CTPOP	R16, R16 // 32B->16B
+	CTPOP R17, R17
+	ADDL	R16, R17, R16
+	ADDL	R16, R22, R22
+	// Accumulate the count in low 64-bit element of V8 when inside the loop
+	BEQ	R28, chunk_loop
+	ADDL	R22, R11, R11
+	BEQ	R2, done
+tail:
+	// Work with tail shorter than 32 bytes
+	LDBU	R5, (R0)
+	ADDL R0, $1, R0
+	SUBL R2, $1, R2
+	CMPEQ	R5, R1, R28
+	ADDL	R11, R28, R11
+	BNE	R2, tail
+done:
+	STL	R11, (R8)
+	RET
diff --git a/src/internal/bytealg/count_sw64_test.s b/src/internal/bytealg/count_sw64_test.s
new file mode 100644
index 00000000..fa8bcfc1
--- /dev/null
+++ b/src/internal/bytealg/count_sw64_test.s
@@ -0,0 +1,88 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build ignore
+// +build ignore
+
+#include "go_asm.h"
+#include "textflag.h"
+
+TEXT ·Count(SB),NOSPLIT,$0-40
+	LDL	R0, b_base+0(FP)
+	LDL	R2, b_len+8(FP)
+	LDBU	R1, c+24(FP)
+	LDI	R8, $ret+32(FP)
+	BR	countbytebody<>(SB)
+
+TEXT ·CountString(SB),NOSPLIT,$0-32
+	LDL	R0, s_base+0(FP)
+	LDL	R2, s_len+8(FP)
+	LDBU	R1, c+16(FP)
+	LDI	R8, $ret+24(FP)
+	BR	countbytebody<>(SB)
+
+// input:
+//   R0: data
+//   R2: data len
+//   R1: byte to find
+//   R8: address to put result
+TEXT countbytebody<>(SB),NOSPLIT,$0-0
+	// R11 = count of byte to search
+	LDI	R11, $0
+	// short path to handle 0-byte case
+	BEQ	R2, done
+	CMPULT	R2, $0x20, R28
+	// jump directly to tail if length < 32
+	BNE	R28, tail
+
+	AND	R0, $0x1f, R9
+	BEQ	R9, chunk
+	// Work with not 32-byte aligned head
+	BIC	R0, $0x1f, R3
+	ADDL	R3, $0x20, R3
+head_loop:
+	LDBUA	R5, 1(R0)
+	CMPEQ	R5, R1, R28
+	ADDL	R11, R28, R11
+	SUBL	R2, $1, R2
+	CMPEQ	R0, R3, R28
+	BEQ	R28, head_loop
+	// Work with 32-byte aligned chunks
+chunk:
+	BIC	R2, $0x1f, R9
+	// The first chunk can also be the last
+	BEQ	R9, tail
+	// R3 = end of 32-byte chunks
+	ADDL	R0, R9, R3
+	IFMOVD R1, F1
+	// R2 = length of tail
+	SUBL	R2, R9, R2
+	// Duplicate R1 (byte to search) to 16 1-byte elements of V0
+	VCPYB	F1, V0
+  VXOR V7, V7// clear V7
+	// Count the target byte in 32-byte chunk
+chunk_loop:
+	VLDD V1, (R0)
+  ADDL R0, $32, R0
+	CMPEQ	R0, R3, R28
+	VCMPUEQB	V0, V1, V3
+	// Count lanes match the requested byte
+	VCTPOP	V3, V6 // 32B->4B
+	FCVTWL  F6, F6
+	VADDL	V6, V7, V7
+	// Accumulate the count in low 64-bit element of V8 when inside the loop
+	BEQ	R28, chunk_loop
+  FIMOVD F7, R6
+	ADDL	R6, R11, R11
+	BEQ	R2, done
+tail:
+	// Work with tail shorter than 32 bytes
+	LDBUA	R5, 1(R0)
+	SUBL R2, $1, R2
+	CMPEQ	R5, R1, R28
+	ADDL	R11, R28, R11
+	BNE	R2, tail
+done:
+	STL	R11, (R8)
+	RET
diff --git a/src/internal/bytealg/equal_sw64.s b/src/internal/bytealg/equal_sw64.s
new file mode 100644
index 00000000..2cba2ea6
--- /dev/null
+++ b/src/internal/bytealg/equal_sw64.s
@@ -0,0 +1,70 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+// +build sw64
+
+#include "go_asm.h"
+#include "textflag.h"
+
+// memequal(a, b unsafe.Pointer, size uintptr) bool
+TEXT runtime·memequal<ABIInternal>(SB),NOSPLIT,$0-25
+#ifndef GOEXPERIMENT_regabiargs
+	LDL	R16, $p+0(FP)
+	LDL	R17, $q+8(FP)
+	LDL     R18, $size+16(FP)
+#endif
+	BEQ     R18, eq
+	CMPEQ	R16, R17, R3
+	BNE	R3, eq
+loop:
+	LDBU	R3, (R16)
+	LDBU	R4, (R17)
+
+	CMPEQ	R3, R4, R3
+	BEQ	R3, ne
+
+	ADDL	R16, $1, R16
+	ADDL	R17, $1, R17
+	SUBL	R18, $1, R18
+	BNE	R18, loop
+eq:
+	LDI	R16, $1
+#ifndef GOEXPERIMENT_regabiargs
+	STB	R16, $ret+24(FP)
+#endif
+	RET
+ne:
+	LDI	R16, ZERO
+#ifndef GOEXPERIMENT_regabiargs
+	STB	R16, $ret+24(FP)
+#endif
+	RET
+
+// memequal_varlen(a, b unsafe.Pointer) bool
+TEXT runtime·memequal_varlen<ABIInternal>(SB),NOSPLIT,$40-17
+#ifndef GOEXPERIMENT_regabiargs
+	LDL	R16, a+0(FP)
+	LDL	R17, b+8(FP)
+#endif
+	CMPEQ	R16, R17, R11
+	BNE	R11, eq
+	LDL	R3, 8(REGCTXT) // compiler stores size at offset 8 in the closure
+	STL	R16, 8(SP)
+	STL	R17, 16(SP)
+	STL	R3, 24(SP)
+
+	CALL	runtime·memequal(SB)
+	LDBU	R16, 32(SP)
+#ifndef GOEXPERIMENT_regabiargs
+	STB 	R16, ret+16(FP)
+#endif
+	RET
+eq:
+	LDI	R16, $1
+#ifndef GOEXPERIMENT_regabiargs
+	STB	R16, ret+16(FP)
+#endif
+	RET
+
diff --git a/src/internal/bytealg/indexbyte_generic.go b/src/internal/bytealg/indexbyte_generic.go
index b7fffcf4..e4a3111d 100644
--- a/src/internal/bytealg/indexbyte_generic.go
+++ b/src/internal/bytealg/indexbyte_generic.go
@@ -6,7 +6,7 @@
 // SSE instructions on x86 machines, and those are classified as
 // floating point instructions, which are illegal in a note handler.
 
-//go:build !386 && (!amd64 || plan9) && !s390x && !arm && !arm64 && !loong64 && !ppc64 && !ppc64le && !mips && !mipsle && !mips64 && !mips64le && !riscv64 && !wasm
+//go:build !386 && (!amd64 || plan9) && !s390x && !arm && !arm64 && !loong64 && !ppc64 && !ppc64le && !mips && !mipsle && !mips64 && !mips64le && !riscv64 && !wasm && !sw64
 
 package bytealg
 
diff --git a/src/internal/bytealg/indexbyte_native.go b/src/internal/bytealg/indexbyte_native.go
index 8e46c31f..bf591bad 100644
--- a/src/internal/bytealg/indexbyte_native.go
+++ b/src/internal/bytealg/indexbyte_native.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build 386 || (amd64 && !plan9) || s390x || arm || arm64 || loong64 || ppc64 || ppc64le || mips || mipsle || mips64 || mips64le || riscv64 || wasm
+//go:build 386 || (amd64 && !plan9) || s390x || arm || arm64 || loong64 || ppc64 || ppc64le || mips || mipsle || mips64 || mips64le || riscv64 || wasm || sw64
 
 package bytealg
 
diff --git a/src/internal/bytealg/indexbyte_sw64.s b/src/internal/bytealg/indexbyte_sw64.s
new file mode 100644
index 00000000..f3b66b54
--- /dev/null
+++ b/src/internal/bytealg/indexbyte_sw64.s
@@ -0,0 +1,63 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+// +build sw64
+
+#include "go_asm.h"
+#include "textflag.h"
+
+TEXT ·IndexByte(SB),NOFRAME|NOSPLIT,$0-40
+	LDL	R1, b_base+0(FP)
+	LDL	R2, b_len+8(FP)
+	BEQ	R2, notfound
+	LDBU	R3, c+24(FP)
+	LDI	R4, R1
+	ADDL	R1, R2, R2 // end
+	SUBL	R1, $1, R1
+
+loop:
+	ADDL	R1, $1, R1
+	CMPEQ	R1, R2, R5
+	BNE	R5, notfound
+
+	LDBU	R6, (R1)
+	CMPEQ	R6, R3, R6
+	BEQ	R6, loop
+
+	SUBL	R1, R4, R1 // remove base
+	STL	R1, ret+32(FP)
+	RET
+
+notfound:
+	LDI	R1, $-1
+	STL	R1, ret+32(FP)
+	RET
+
+TEXT ·IndexByteString(SB),NOFRAME|NOSPLIT,$0-32
+	LDL	R1, s_base+0(FP)
+	LDL	R2, s_len+8(FP)
+	BEQ	R2, notfound
+	LDBU	R3, c+16(FP)
+	LDI	R4, R1
+	ADDL	R1, R2, R2 // end
+	SUBL	R1, $1, R1
+
+loop:
+	ADDL	R1, $1, R1
+	CMPEQ	R1, R2, R5
+	BNE	R5, notfound
+
+	LDBU	R6, (R1)
+	CMPEQ	R6, R3, R6
+	BEQ	R6, loop
+
+	SUBL	R1, R4, R1 // remove base
+	STL	R1, ret+24(FP)
+	RET
+
+notfound:
+	LDI	R1, $-1
+	STL	R1, ret+24(FP)
+	RET
diff --git a/src/internal/bytealg/indexbyte_sw64_prototype.s b/src/internal/bytealg/indexbyte_sw64_prototype.s
new file mode 100644
index 00000000..faada62f
--- /dev/null
+++ b/src/internal/bytealg/indexbyte_sw64_prototype.s
@@ -0,0 +1,130 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build ignore
+// +build ignore
+
+#include "go_asm.h"
+#include "textflag.h"
+
+TEXT ·IndexByte(SB),NOSPLIT,$0-40
+	LDL	R0, b_base+0(FP)
+	LDL	R2, b_len+8(FP)
+	LDBU	R1, c+24(FP)
+	LDI	R8, $ret+32(FP)
+	BR	indexbytebody<>(SB)
+
+TEXT ·IndexByteString(SB),NOSPLIT,$0-32
+	LDL R0,	s_base+0(FP)
+	LDL R2,	s_len+8(FP)
+	LDBU	R1, c+16(FP)
+	LDI	R8, $ret+24(FP)
+	BR	indexbytebody<>(SB)
+
+// input:
+//   R0: data
+//   R1: byte to search
+//   R2: data len
+//   R8: address to put result
+TEXT indexbytebody<>(SB),NOSPLIT,$0
+	BEQ R2, notfound
+	// short path to handle 0-byte case
+	CMPULT	R2, $0x8, R28
+	BIS R0, R0, R16
+	ADDL R2, R0, R3
+	// jump directly to tail if length < 32
+	// mov orignal data ptr to R16
+	// Work with 32-byte aligned chunks
+	XOR R7, R7, R7
+	BIS R1, R7, R7
+	SLL R7, $8, R7
+	BIS R1, R7, R7
+	SLL R7, $8, R7
+	BIS R1, R7, R7
+	SLL R7, $8, R7
+	BIS R1, R7, R7
+	SLL R7, $8, R7
+	BIS R1, R7, R7
+	SLL R7, $8, R7
+	BIS R1, R7, R7
+	SLL R7, $8, R7
+	BIS R1, R7, R7
+	SLL R7, $8, R7
+	BIS R1, R7, R7
+	SLL R7, $8, R7
+	BIS R1, R7, R7
+	BNE	R28, small
+	// select page addr
+	//LDI R28, $8192
+	ADDL R2, R0, R3
+	SUBL R3, $8, R3
+
+chunk_loop:
+	LDL R5, (R0)
+	CMPGEB	R5, R7, R6
+	CMPGEB	R7, R5, R4
+	AND R6, R4, R5
+	// Count lanes match the requested byte
+	BNE R5, found
+	// Accumulate the count in low 64-bit element of V8 when inside the loop
+  ADDL R0, $8, R0
+	CMPLE	R0, R3, R28
+	BNE	R28, chunk_loop
+
+	LDI R0, R3
+	LDL R5, (R3)
+	CMPGEB	R5, R7, R6
+	CMPGEB	R7, R5, R4
+	AND R6, R4, R5
+	// Count lanes match the requested byte
+	BNE R5, found
+
+notfound:
+	LDI R1, -1
+	STL R1, (R8)
+	RET
+
+small:
+	LDI R9, $8184
+	ADDL R0, $8, R6
+	AND R6, R9, R28
+	BEQ R28, endofpage
+	// Work with tail shorter than 32 bytes
+	LDL	R5, (R0)
+	CMPGEB R5, R7, R6
+	CMPGEB R7, R5, R4
+	AND R6, R4, R5
+	BEQ R5, notfound
+	CTTZ R5, R5
+	CMPLT R5, R2, R28
+	BEQ R28, notfound
+	STL R5, (R8)
+	RET
+
+found:
+	//SUBL R0, $8, R0
+	CTTZ R5, R5
+	SUBL R0, R16, R0
+	ADDL R5, R0, R0
+	CMPLT R0, R2, R28
+	BEQ R28, notfound
+	STL	R0, (R8)
+	RET
+
+endofpage:
+	ADDL R0, R2, R3
+	SUBL R3, $8, R3
+	LDL R5, (R3)
+	CMPGEB R5, R7, R6
+	CMPGEB R7, R5, R4
+	AND R6, R4, R5
+	ZAPNOT R2, $1, R9
+	SLL R5, R9, R5
+	SRL R5, $8, R5
+	BEQ R5, notfound
+	CTTZ R5, R5
+	STL R5, (R8)
+	RET
+
+
diff --git a/src/internal/bytealg/indexbyte_sw64_test.s b/src/internal/bytealg/indexbyte_sw64_test.s
new file mode 100644
index 00000000..53fb7370
--- /dev/null
+++ b/src/internal/bytealg/indexbyte_sw64_test.s
@@ -0,0 +1,109 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build ignore
+// +build ignore
+
+#include "go_asm.h"
+#include "textflag.h"
+
+TEXT ·IndexByte(SB),NOSPLIT,$0-40
+	LDL	R0, b_base+0(FP)
+	LDL	R2, b_len+8(FP)
+	LDBU	R1, c+24(FP)
+	LDI	R8, $ret+32(FP)
+	BR	indexbytebody<>(SB)
+
+TEXT ·IndexByteString(SB),NOSPLIT,$0-32
+	LDL R0,	s_base+0(FP)
+	LDL R2,	s_len+8(FP)
+	LDBU	R1, c+16(FP)
+	LDI	R8, $ret+24(FP)
+	BR	indexbytebody<>(SB)
+
+// input:
+//   R0: data
+//   R1: byte to search
+//   R2: data len
+//   R8: address to put result
+TEXT indexbytebody<>(SB),NOSPLIT,$0
+	BEQ R2, notfound
+	IFMOVD R1, F1
+	// short path to handle 0-byte case
+	CMPULT	R2, $0x20, R28
+	BIS R0, R0, R16
+	ADDL R2, R0, R3
+	// jump directly to tail if length < 32
+	// mov orignal data ptr to R16
+	// Work with 32-byte aligned chunks
+	VCPYB F1, V7
+
+	BNE	R28, small
+	// select page addr
+	ADDL R2, R0, R3
+	SUBL R3, $0x20, R3
+
+chunk_loop:
+	VLDD V5, (R0)
+	VCMPUEQB V5, V7, V3
+	// Count lanes match the requested byte
+	FBNE F3, found
+	// Accumulate the count in low 64-bit element of V8 when inside the loop
+  ADDL R0, $0x20, R0
+	CMPLE	R0, R3, R28
+	BNE	R28, chunk_loop
+
+	LDI R0, R3
+	VLDD V5, (R3)
+	VCMPUEQB V5, V7, V3
+	// Count lanes match the requested byte
+	FBNE F3, found
+
+notfound:
+	LDI R1, -1
+	STL R1, (R8)
+	RET
+
+small:
+	LDI R9, $8160
+	ADDL R0, $0x20, R6
+	AND R6, R9, R28
+	BEQ R28, endofpage
+	// Work with tail shorter than 32 bytes
+	VLDD	V5, (R0)
+	VCMPUEQB V5, V7, V3
+	FBEQ F3, notfound
+	FIMOVD F3, R5
+	CTTZ R5, R5
+	CMPLT R5, R2, R28
+	BEQ R28, notfound
+	STL R5, (R8)
+	RET
+
+found:
+	//SUBL R0, $8, R0
+	FIMOVD F3, R5
+	CTTZ R5, R5
+	SUBL R0, R16, R0
+	ADDL R5, R0, R0
+	CMPLT R0, R2, R28
+	BEQ R28, notfound
+	STL	R0, (R8)
+	RET
+
+endofpage:
+	ADDL R0, R2, R3
+	SUBL R3, $0x20, R3
+	VLDD V5, (R3)
+	VCMPUEQB V5, V7, V3
+	FIMOVD F3, R5
+	ZAPNOT R2, $1, R9
+	SLL R5, R9, R5
+	SRL R5, $0x20, R5
+	BEQ R5, notfound
+	CTTZ R5, R5
+	STL R5, (R8)
+	RET
+
+
diff --git a/src/internal/cfg/cfg.go b/src/internal/cfg/cfg.go
index 2af0ec70..347306b1 100644
--- a/src/internal/cfg/cfg.go
+++ b/src/internal/cfg/cfg.go
@@ -59,6 +59,7 @@ const KnownEnv = `
 	GOPROXY
 	GOROOT
 	GOSUMDB
+	GOSW64
 	GOTMPDIR
 	GOTOOLCHAIN
 	GOTOOLDIR
diff --git a/src/internal/cpu/cpu.go b/src/internal/cpu/cpu.go
index d794e53c..b6ded548 100644
--- a/src/internal/cpu/cpu.go
+++ b/src/internal/cpu/cpu.go
@@ -95,6 +95,17 @@ var PPC64 struct {
 	_         CacheLinePad
 }
 
+var SW64 struct {
+	_         CacheLinePad
+	HasCRC    bool // Hardware random number generator (requires kernel enablement)
+	HasSIMDV2 bool // Syscall vectored (requires kernel enablement)
+	HasPCREL  bool // pc rel instruction
+	HasHDIV   bool // hardware div/rem support
+	IsCore3   bool // ISA v3.00 (SW3231)
+	IsCore4   bool // ISA v4.00 (SW6432)
+	_         CacheLinePad
+}
+
 var S390X struct {
 	_         CacheLinePad
 	HasZARCH  bool // z architecture mode is active [mandatory]
diff --git a/src/internal/cpu/cpu_sw64.go b/src/internal/cpu/cpu_sw64.go
new file mode 100644
index 00000000..0f83ffbf
--- /dev/null
+++ b/src/internal/cpu/cpu_sw64.go
@@ -0,0 +1,17 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build sw64
+
+package cpu
+
+const CacheLinePadSize = 128
+
+func doinit() {
+	options = []option{
+		{Name: "crc32", Feature: &SW64.HasCRC},
+	}
+	// TODO: setting SW64 CRC test for now
+	SW64.HasCRC = false
+}
diff --git a/src/internal/goarch/goarch.go b/src/internal/goarch/goarch.go
index 3dda62fa..58800272 100644
--- a/src/internal/goarch/goarch.go
+++ b/src/internal/goarch/goarch.go
@@ -26,6 +26,7 @@ const (
 	RISCV64
 	S390X
 	WASM
+	SW64
 )
 
 // PtrSize is the size of a pointer in bytes - unsafe.Sizeof(uintptr(0)) but as an ideal constant.
diff --git a/src/internal/goarch/goarch_sw64.go b/src/internal/goarch/goarch_sw64.go
new file mode 100644
index 00000000..b8977840
--- /dev/null
+++ b/src/internal/goarch/goarch_sw64.go
@@ -0,0 +1,16 @@
+// Copyright 2014 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+
+package goarch
+
+const (
+	_ArchFamily          = SW64
+	_BigEndian           = false
+	_DefaultPhysPageSize = 8192
+	_PCQuantum           = 4
+	_MinFrameSize        = 8
+	_StackAlign          = PtrSize
+)
diff --git a/src/internal/goarch/zgoarch_386.go b/src/internal/goarch/zgoarch_386.go
index 4a9b0e67..065d6671 100644
--- a/src/internal/goarch/zgoarch_386.go
+++ b/src/internal/goarch/zgoarch_386.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_amd64.go b/src/internal/goarch/zgoarch_amd64.go
index 7926392b..6cfe216b 100644
--- a/src/internal/goarch/zgoarch_amd64.go
+++ b/src/internal/goarch/zgoarch_amd64.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_arm.go b/src/internal/goarch/zgoarch_arm.go
index 6c03b8b0..6900d426 100644
--- a/src/internal/goarch/zgoarch_arm.go
+++ b/src/internal/goarch/zgoarch_arm.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_arm64.go b/src/internal/goarch/zgoarch_arm64.go
index ad342d79..b0be5d8f 100644
--- a/src/internal/goarch/zgoarch_arm64.go
+++ b/src/internal/goarch/zgoarch_arm64.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_arm64be.go b/src/internal/goarch/zgoarch_arm64be.go
index 0f260030..5c8f66ea 100644
--- a/src/internal/goarch/zgoarch_arm64be.go
+++ b/src/internal/goarch/zgoarch_arm64be.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_armbe.go b/src/internal/goarch/zgoarch_armbe.go
index 6092fee7..26640157 100644
--- a/src/internal/goarch/zgoarch_armbe.go
+++ b/src/internal/goarch/zgoarch_armbe.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_loong64.go b/src/internal/goarch/zgoarch_loong64.go
index 21c67e11..5204f28a 100644
--- a/src/internal/goarch/zgoarch_loong64.go
+++ b/src/internal/goarch/zgoarch_loong64.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_mips.go b/src/internal/goarch/zgoarch_mips.go
index 0db19746..43cb637e 100644
--- a/src/internal/goarch/zgoarch_mips.go
+++ b/src/internal/goarch/zgoarch_mips.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_mips64.go b/src/internal/goarch/zgoarch_mips64.go
index 738806f0..67a9ad7d 100644
--- a/src/internal/goarch/zgoarch_mips64.go
+++ b/src/internal/goarch/zgoarch_mips64.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_mips64le.go b/src/internal/goarch/zgoarch_mips64le.go
index 8de5beb8..719aa8c3 100644
--- a/src/internal/goarch/zgoarch_mips64le.go
+++ b/src/internal/goarch/zgoarch_mips64le.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_mips64p32.go b/src/internal/goarch/zgoarch_mips64p32.go
index ea461bed..4ba084f3 100644
--- a/src/internal/goarch/zgoarch_mips64p32.go
+++ b/src/internal/goarch/zgoarch_mips64p32.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_mips64p32le.go b/src/internal/goarch/zgoarch_mips64p32le.go
index 15473ce6..40249552 100644
--- a/src/internal/goarch/zgoarch_mips64p32le.go
+++ b/src/internal/goarch/zgoarch_mips64p32le.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_mipsle.go b/src/internal/goarch/zgoarch_mipsle.go
index 4955142e..b0d61ff7 100644
--- a/src/internal/goarch/zgoarch_mipsle.go
+++ b/src/internal/goarch/zgoarch_mipsle.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_ppc.go b/src/internal/goarch/zgoarch_ppc.go
index ec01763b..afd23b16 100644
--- a/src/internal/goarch/zgoarch_ppc.go
+++ b/src/internal/goarch/zgoarch_ppc.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_ppc64.go b/src/internal/goarch/zgoarch_ppc64.go
index 39be3925..0b516ecf 100644
--- a/src/internal/goarch/zgoarch_ppc64.go
+++ b/src/internal/goarch/zgoarch_ppc64.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_ppc64le.go b/src/internal/goarch/zgoarch_ppc64le.go
index 5f959e0e..95419575 100644
--- a/src/internal/goarch/zgoarch_ppc64le.go
+++ b/src/internal/goarch/zgoarch_ppc64le.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_riscv.go b/src/internal/goarch/zgoarch_riscv.go
index 8d81a14d..bfb753f5 100644
--- a/src/internal/goarch/zgoarch_riscv.go
+++ b/src/internal/goarch/zgoarch_riscv.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_riscv64.go b/src/internal/goarch/zgoarch_riscv64.go
index 1df989c2..fd5c1da2 100644
--- a/src/internal/goarch/zgoarch_riscv64.go
+++ b/src/internal/goarch/zgoarch_riscv64.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_s390.go b/src/internal/goarch/zgoarch_s390.go
index 56815b9f..45c5db44 100644
--- a/src/internal/goarch/zgoarch_s390.go
+++ b/src/internal/goarch/zgoarch_s390.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_s390x.go b/src/internal/goarch/zgoarch_s390x.go
index e61e9bd5..deda7150 100644
--- a/src/internal/goarch/zgoarch_s390x.go
+++ b/src/internal/goarch/zgoarch_s390x.go
@@ -30,3 +30,4 @@ const IsS390x = 1
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_sparc.go b/src/internal/goarch/zgoarch_sparc.go
index ee5b7465..59d5cbaa 100644
--- a/src/internal/goarch/zgoarch_sparc.go
+++ b/src/internal/goarch/zgoarch_sparc.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 1
 const IsSparc64 = 0
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_sparc64.go b/src/internal/goarch/zgoarch_sparc64.go
index 519aaa10..d940eb13 100644
--- a/src/internal/goarch/zgoarch_sparc64.go
+++ b/src/internal/goarch/zgoarch_sparc64.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 1
 const IsWasm = 0
+const IsSw64 = 0
diff --git a/src/internal/goarch/zgoarch_sw64.go b/src/internal/goarch/zgoarch_sw64.go
new file mode 100644
index 00000000..b576c686
--- /dev/null
+++ b/src/internal/goarch/zgoarch_sw64.go
@@ -0,0 +1,33 @@
+// Code generated by gengoarch.go using 'go generate'. DO NOT EDIT.
+
+//go:build sw64
+
+package goarch
+
+const GOARCH = `sw64`
+
+const Is386 = 0
+const IsAmd64 = 0
+const IsAmd64p32 = 0
+const IsArm = 0
+const IsArmbe = 0
+const IsArm64 = 0
+const IsArm64be = 0
+const IsLoong64 = 0
+const IsMips = 0
+const IsMipsle = 0
+const IsMips64 = 0
+const IsMips64le = 0
+const IsMips64p32 = 0
+const IsMips64p32le = 0
+const IsPpc = 0
+const IsPpc64 = 0
+const IsPpc64le = 0
+const IsRiscv = 0
+const IsRiscv64 = 0
+const IsS390 = 0
+const IsS390x = 0
+const IsSparc = 0
+const IsSparc64 = 0
+const IsWasm = 0
+const IsSw64 = 1
diff --git a/src/internal/goarch/zgoarch_wasm.go b/src/internal/goarch/zgoarch_wasm.go
index 25567a1b..15f6c36b 100644
--- a/src/internal/goarch/zgoarch_wasm.go
+++ b/src/internal/goarch/zgoarch_wasm.go
@@ -30,3 +30,4 @@ const IsS390x = 0
 const IsSparc = 0
 const IsSparc64 = 0
 const IsWasm = 1
+const IsSw64 = 0
diff --git a/src/internal/platform/supported.go b/src/internal/platform/supported.go
index 82c66e21..a0341b16 100644
--- a/src/internal/platform/supported.go
+++ b/src/internal/platform/supported.go
@@ -85,7 +85,8 @@ func FuzzInstrumented(goos, goarch string) bool {
 func MustLinkExternal(goos, goarch string, withCgo bool) bool {
 	if withCgo {
 		switch goarch {
-		case "loong64", "mips", "mipsle", "mips64", "mips64le":
+		case "loong64", "mips", "mipsle", "mips64", "mips64le",
+			"sw64":
 			// Internally linking cgo is incomplete on some architectures.
 			// https://go.dev/issue/14449
 			return true
@@ -149,7 +150,7 @@ func BuildModeSupported(compiler, buildmode, goos, goarch string) bool {
 			return true
 		case "linux":
 			switch goarch {
-			case "386", "amd64", "arm", "armbe", "arm64", "arm64be", "loong64", "ppc64le", "riscv64", "s390x":
+			case "386", "amd64", "arm", "armbe", "arm64", "arm64be", "loong64", "ppc64le", "riscv64", "s390x", "sw64":
 				// linux/ppc64 not supported because it does
 				// not support external linking mode yet.
 				return true
@@ -169,7 +170,7 @@ func BuildModeSupported(compiler, buildmode, goos, goarch string) bool {
 
 	case "c-shared":
 		switch platform {
-		case "linux/amd64", "linux/arm", "linux/arm64", "linux/loong64", "linux/386", "linux/ppc64le", "linux/riscv64", "linux/s390x",
+		case "linux/amd64", "linux/arm", "linux/arm64", "linux/loong64", "linux/386", "linux/ppc64le", "linux/riscv64", "linux/s390x", "linux/sw64",
 			"android/amd64", "android/arm", "android/arm64", "android/386",
 			"freebsd/amd64",
 			"darwin/amd64", "darwin/arm64",
@@ -206,7 +207,7 @@ func BuildModeSupported(compiler, buildmode, goos, goarch string) bool {
 
 	case "plugin":
 		switch platform {
-		case "linux/amd64", "linux/arm", "linux/arm64", "linux/386", "linux/loong64", "linux/s390x", "linux/ppc64le",
+		case "linux/amd64", "linux/arm", "linux/arm64", "linux/386", "linux/loong64", "linux/s390x", "linux/ppc64le", "linux/sw64",
 			"android/amd64", "android/386",
 			"darwin/amd64", "darwin/arm64",
 			"freebsd/amd64":
diff --git a/src/internal/platform/zosarch.go b/src/internal/platform/zosarch.go
index 7c3db537..8b814d54 100644
--- a/src/internal/platform/zosarch.go
+++ b/src/internal/platform/zosarch.go
@@ -39,6 +39,7 @@ var List = []OSArch{
 	{"linux", "riscv64"},
 	{"linux", "s390x"},
 	{"linux", "sparc64"},
+	{"linux", "sw64"},
 	{"netbsd", "386"},
 	{"netbsd", "amd64"},
 	{"netbsd", "arm"},
@@ -93,6 +94,7 @@ var distInfo = map[OSArch]osArchInfo{
 	{"linux", "riscv64"}:   {CgoSupported: true},
 	{"linux", "s390x"}:     {CgoSupported: true},
 	{"linux", "sparc64"}:   {CgoSupported: true, Broken: true},
+	{"linux", "sw64"}:      {CgoSupported: true},
 	{"netbsd", "386"}:      {CgoSupported: true},
 	{"netbsd", "amd64"}:    {CgoSupported: true},
 	{"netbsd", "arm"}:      {CgoSupported: true},
diff --git a/src/internal/syscall/unix/at_sysnum_fstatat64_linux.go b/src/internal/syscall/unix/at_sysnum_fstatat64_linux.go
index 445b0c38..cd54066d 100644
--- a/src/internal/syscall/unix/at_sysnum_fstatat64_linux.go
+++ b/src/internal/syscall/unix/at_sysnum_fstatat64_linux.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build arm || mips || mipsle || 386
+//go:build arm || mips || mipsle || 386 || sw64
 
 package unix
 
diff --git a/src/internal/syscall/unix/getrandom_linux_sw64.go b/src/internal/syscall/unix/getrandom_linux_sw64.go
new file mode 100644
index 00000000..bd04bbca
--- /dev/null
+++ b/src/internal/syscall/unix/getrandom_linux_sw64.go
@@ -0,0 +1,9 @@
+// Copyright 2014 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package unix
+
+// Linux getrandom system call number.
+// See GetRandom in getrandom_linux.go.
+const randomTrap uintptr = 511
diff --git a/src/internal/syscall/unix/sysnum_linux_sw64.go b/src/internal/syscall/unix/sysnum_linux_sw64.go
new file mode 100644
index 00000000..0f1c8b12
--- /dev/null
+++ b/src/internal/syscall/unix/sysnum_linux_sw64.go
@@ -0,0 +1,13 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+
+package unix
+
+const (
+	getrandomTrap       uintptr = 511
+	copyFileRangeTrap   uintptr = 515
+	pidfdSendSignalTrap uintptr = 271
+)
diff --git a/src/math/big/arith_sw64.s b/src/math/big/arith_sw64.s
new file mode 100644
index 00000000..cd85f240
--- /dev/null
+++ b/src/math/big/arith_sw64.s
@@ -0,0 +1,35 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64 && !math_big_pure_go
+// +build sw64,!math_big_pure_go
+
+#include "textflag.h"
+
+// This file provides fast assembly versions for the elementary
+// arithmetic operations on vectors implemented in arith.go.
+
+TEXT ·addVV(SB), NOFRAME|NOSPLIT, $0
+	JMP	·addVV_g(SB)
+
+TEXT ·subVV(SB), NOFRAME|NOSPLIT, $0
+	JMP	·subVV_g(SB)
+
+TEXT ·addVW(SB), NOFRAME|NOSPLIT, $0
+	JMP	·addVW_g(SB)
+
+TEXT ·subVW(SB), NOFRAME|NOSPLIT, $0
+	JMP	·subVW_g(SB)
+
+TEXT ·shlVU(SB), NOFRAME|NOSPLIT, $0
+	JMP	·shlVU_g(SB)
+
+TEXT ·shrVU(SB), NOFRAME|NOSPLIT, $0
+	JMP	·shrVU_g(SB)
+
+TEXT ·mulAddVWW(SB), NOFRAME|NOSPLIT, $0
+	JMP	·mulAddVWW_g(SB)
+
+TEXT ·addMulVVW(SB), NOFRAME|NOSPLIT, $0
+	JMP	·addMulVVW_g(SB)
diff --git a/src/os/endian_little.go b/src/os/endian_little.go
index a7cf1cdd..ebf2fd74 100644
--- a/src/os/endian_little.go
+++ b/src/os/endian_little.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 //
-//go:build 386 || amd64 || arm || arm64 || loong64 || ppc64le || mips64le || mipsle || riscv64 || wasm
+//go:build 386 || amd64 || arm || arm64 || loong64 || ppc64le || mips64le || mipsle || riscv64 || wasm || sw64
 
 package os
 
diff --git a/src/reflect/asm_sw64.s b/src/reflect/asm_sw64.s
new file mode 100644
index 00000000..3df30015
--- /dev/null
+++ b/src/reflect/asm_sw64.s
@@ -0,0 +1,77 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+#include "textflag.h"
+#include "funcdata.h"
+
+// The frames of each of the two functions below contain two locals, at offsets
+// that are known to the runtime.
+//
+// The first local is a bool called retValid with a whole pointer-word reserved
+// for it on the stack. The purpose of this word is so that the runtime knows
+// whether the stack-allocated return space contains valid values for stack
+// scanning.
+//
+// The second local is an abi.RegArgs value whose offset is also known to the
+// runtime, so that a stack map for it can be constructed, since it contains
+// pointers visible to the GC.
+#define LOCAL_RETVALID 40
+#define LOCAL_REGARGS 48
+
+// The frame size of the functions below is
+// 32 (args of callReflect/callMethod) + (8 bool with padding) + 224 (abi.RegArgs) = 264.
+
+// makeFuncStub is the code half of the function returned by MakeFunc.
+// See the comment on the declaration of makeFuncStub in makefunc.go
+// for more details.
+// No arg size here, runtime pulls arg map out of the func value.
+//TEXT ·makeFuncStub(SB), (NOSPLIT|WRAPPER), $40
+TEXT ·makeFuncStub(SB), (NOSPLIT|WRAPPER), $264
+	NO_LOCAL_POINTERS
+	ADDL	SP, $LOCAL_REGARGS, R9 // spillArgs using R9
+	CALL    runtime·spillArgs(SB)
+	STL	REGCTXT, 32(SP) // save CTXT > args of moveMakeFuncArgPtrs < LOCAL_REGARGS
+	STL	REGCTXT, 8(SP)
+	STL	R9, 16(SP)
+	CALL	·moveMakeFuncArgPtrs(SB)
+	LDL	REGCTXT, 32(SP) // restore CTXT
+	STL	REGCTXT, 8(SP)
+	LDI	R1, $argframe+0(FP)
+	STL	R1, 16(SP)
+	STB	ZERO, $LOCAL_RETVALID(SP)
+	ADDL	SP, $LOCAL_RETVALID, R1
+	STL	R1, 24(SP)
+	ADDL	SP, $LOCAL_REGARGS, R1
+	STL	R1, 32(SP)
+	CALL	·callReflect(SB)
+	ADDL	SP, $LOCAL_REGARGS, R9 // unspillArgs using R9
+	CALL	runtime·unspillArgs(SB)
+	RET
+
+// methodValueCall is the code half of the function returned by makeMethodValue.
+// See the comment on the declaration of methodValueCall in makefunc.go
+// for more details.
+// No arg size here; runtime pulls arg map out of the func value.
+//TEXT ·methodValueCall(SB), (NOSPLIT|WRAPPER), $40
+TEXT ·methodValueCall(SB), (NOSPLIT|WRAPPER), $264
+	NO_LOCAL_POINTERS
+	ADDL	SP, $LOCAL_REGARGS, R9 // spillArgs using R9
+	CALL	runtime·spillArgs(SB)
+	STL	REGCTXT, 32(SP)  // save CTXT
+	STL	REGCTXT, 8(SP)
+	STL	R9, 16(SP)
+	CALL	·moveMakeFuncArgPtrs(SB)
+	LDL	REGCTXT, 32(SP) // restore CTXT
+	STL	REGCTXT, 8(SP)
+	LDI     R1, $argframe+0(FP)
+	STL     R1, 16(SP)
+	STB     ZERO, $LOCAL_RETVALID(SP)
+	ADDL	SP, $LOCAL_RETVALID, R1
+	STL     R1, 24(SP)
+	ADDL	SP, $LOCAL_REGARGS, R1
+	STL     R1, 32(SP) // frame size to 32+SP as callreflect args
+	CALL	·callMethod(SB)
+	ADDL	SP, $LOCAL_REGARGS, R9 // unspillArgs using R9
+	CALL    runtime·unspillArgs(SB)
+	RET
diff --git a/src/reflect/float32reg_generic.go b/src/reflect/float32reg_generic.go
index 23ad4bf2..2643babd 100644
--- a/src/reflect/float32reg_generic.go
+++ b/src/reflect/float32reg_generic.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !ppc64 && !ppc64le && !riscv64
+//go:build !ppc64 && !ppc64le && !riscv64 && !sw64
 
 package reflect
 
diff --git a/src/reflect/float32reg_sw64.s b/src/reflect/float32reg_sw64.s
new file mode 100644
index 00000000..5168fb19
--- /dev/null
+++ b/src/reflect/float32reg_sw64.s
@@ -0,0 +1,28 @@
+// Copyright 2021 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+#include "textflag.h"
+
+// On SW64, the float32 has 35 valid bits
+// when loaded in a register, different from
+// other platforms. These functions are
+// needed to ensure correct conversions on SW64.
+
+// Convert float32->uint64
+TEXT ·archFloat32ToReg(SB),NOSPLIT,$0-16
+	FLDS	F1, val+0(FP)
+	FSTD	F1, ret+8(FP)
+	RET
+
+// Convert uint64->float32
+TEXT ·archFloat32FromReg(SB),NOSPLIT,$0-12
+	FLDD	F1, reg+0(FP)
+	// Normally a float64->float32 conversion
+	// would need rounding, but that is not needed
+	// here since the uint64 was originally converted
+	// from float32, and should be avoided to
+	// preserve SNaN values.
+	FSTS	F1, ret+8(FP)
+	RET
+
diff --git a/src/reflect/stubs_sw64.go b/src/reflect/stubs_sw64.go
new file mode 100644
index 00000000..a72ebab9
--- /dev/null
+++ b/src/reflect/stubs_sw64.go
@@ -0,0 +1,8 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package reflect
+
+func archFloat32FromReg(reg uint64) float32
+func archFloat32ToReg(val float32) uint64
diff --git a/src/runtime/asm_sw64.s b/src/runtime/asm_sw64.s
new file mode 100644
index 00000000..99c69773
--- /dev/null
+++ b/src/runtime/asm_sw64.s
@@ -0,0 +1,1139 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+#include "go_asm.h"
+#include "go_tls.h"
+#include "funcdata.h"
+#include "textflag.h"
+
+// _rt0_sw64_lib is common startup code for most sw64 systems when
+// using -buildmode=c-archive or -buildmode=c-shared. The linker will
+// arrange to invoke this function as a global constructor (for
+// c-archive) or when the shared library is loaded (for c-shared).
+// We expect argc and argv to be passed in the usual C ABI registers
+// a0 and a1.
+TEXT _rt0_sw64_lib(SB), NOSPLIT, $0x50
+	// 1. SAVE R16, R17
+	STL	R16, _rt0_sw64_lib_argc<>(SB)
+	STL	R17, _rt0_sw64_lib_argv<>(SB)
+
+	// 2. save C ABI registers
+	LDI	SP, $-64(SP)
+	STL	R9, 0*8(SP)
+	STL	R10, 1*8(SP)
+	STL	R11, 2*8(SP)
+	STL	R12, 3*8(SP)
+	STL	R13, 4*8(SP)
+	STL	R14, 5*8(SP)
+	STL	R15, 6*8(SP)
+
+	CALL	runtime·libpreinit(SB)
+	// 3. Create a new thread to finish Go runtime initialization.
+	LDL	R27, _cgo_sys_thread_create(SB)
+	BEQ	R27, nocgo
+
+	SYMADDR	R16, $_rt0_sw64_lib_go(SB)
+	LDI	R17, $0
+	CALL	R26, (R27)
+	JMP	restore
+nocgo:
+	LDI	R16, $0x800000
+	STL	R16, 0(SP)
+	SYMADDR	R17, $_rt0_sw64_lib_go(SB)
+	STL	R17, 8(SP)
+	CALL	runtime·newosproc0(SB)
+restore:
+	LDL	R9, 0*8(SP)
+	LDL	R10, 1*8(SP)
+	LDL	R11, 2*8(SP)
+	LDL	R12, 3*8(SP)
+	LDL	R13, 4*8(SP)
+	LDL	R14, 5*8(SP)
+	LDL	R15, 6*8(SP)
+	LDI	SP, $64(SP)
+	RET
+
+// _rt0_sw64_lib_go initializes the Go runtime.
+// This is started in a separate thread by _rt0_sw64_lib.
+TEXT _rt0_sw64_lib_go(SB),NOSPLIT,$0
+	LDL	R16, _rt0_sw64_lib_argc<>(SB)
+	LDL	R17, _rt0_sw64_lib_argv<>(SB)
+	CALL	runtime·rt0_go(SB)
+	RET
+
+DATA	_rt0_sw64_lib_argc<>(SB)/8, $0
+GLOBL	_rt0_sw64_lib_argc<>(SB),NOPTR, $8
+DATA	_rt0_sw64_lib_argv<>(SB)/8, $0
+GLOBL	_rt0_sw64_lib_argv<>(SB),NOPTR, $8
+
+
+// _rt0_sw64 is common startup code for most sw64 systems when using
+// internal linking. This is the entry point for the program from the
+// kernel for an ordinary -buildmode=exe program. The stack holds the
+// number of arguments and the C-style argv.
+TEXT _rt0_sw64(SB), NOFRAME|NOSPLIT, $0
+	LDL	R16, 0(SP) // argc
+	LDI	R17, 8(SP) // argv
+	JMP	runtime·rt0_go(SB)
+
+TEXT main(SB), NOFRAME|NOSPLIT, $0
+	SETFPEC1
+	JMP	runtime·rt0_go(SB)
+
+TEXT runtime·rt0_go(SB), NOSPLIT|TOPFRAME, $16
+	// copy args
+	STL	R16, $argc-16(SP)
+	STL	R17, $argv-8(SP)
+
+	SYMADDR	g, $runtime·g0(SB)
+	LDI	R1, $-64*1024(SP)
+	STL	R1, g_stackguard0(g)
+	STL	R1, g_stackguard1(g)
+	STL	R1, (g_stack+stack_lo)(g)
+	STL	SP, (g_stack+stack_hi)(g)
+
+	// if there is a _cgo_init, call it using the gcc ABI.
+	LDL	R27, _cgo_init(SB)
+	BEQ	R27, nocgo
+
+	LDI	R16, g
+	SYMADDR	R17, $setg_gcc<>(SB)
+	LDI	R18, ZERO
+	LDI	R19, ZERO
+	CALL	R26, (R27)
+	SETFPEC1
+nocgo:
+	SYMADDR	g, $runtime·g0(SB)
+	SYMADDR	R0, $runtime·m0(SB)
+	STL	g, m_g0(R0)
+	STL	R0,  g_m(g)
+
+	CALL	runtime·check(SB)
+
+	// args are already prepared
+	CALL	runtime·args(SB)
+	CALL	runtime·osinit(SB)
+	CALL	runtime·schedinit(SB)
+	// create a new goroutine to start program
+	SYMADDR	R1, $runtime·mainPC(SB)
+	SUBL	SP, $16, SP
+	STL	R1, 8(SP)
+	STL	ZERO, 0(SP)
+	CALL	runtime·newproc(SB)
+	ADDL	SP, $16, SP
+	CALL	runtime·mstart(SB)
+	RET
+
+DATA	runtime·mainPC+0(SB)/8,$runtime·main<ABIInternal>(SB)
+GLOBL	runtime·mainPC(SB),RODATA,$8
+
+// This is not obey by Go ABI, see SW64Ops.go
+//           R1 R0         R0 R1
+// func udiv(n, d uint64) (q, r uint64) {
+TEXT runtime·udiv(SB), NOSPLIT, $0
+	SUBL	SP, $80, SP
+
+	LDI	R5, ZERO
+	STL	R1, $capn+16(SP)
+
+	LDI 	R3, R1
+	LDI	R2, $0x8000000000000000
+	CMPULE	R2, R3, R3
+	BEQ	R3, l80
+	STL 	R2, $capn+16(SP)
+l80:
+	LDI	R3, ZERO
+	STL	ZERO, $i+8(SP)
+l96:
+	LDL	R4, $capn+16(SP)
+
+	CMPULT	R0, R4, R2
+	BEQ	R2, l184
+	LDI	R2, R0
+
+	SLL	R2, $1, R2
+	LDI	R0, R2
+	LDI	R2, $i+8(SP)
+	LDL	R2, (R2)
+
+	ADDL	R2, $1, R2
+
+	STL	R2, $i+8(SP)
+
+	BR	ZERO, l96
+l184:
+	LDL	R2, $i+8(SP)
+	CMPLE	R3, R2, R2
+	BEQ	R2, l384
+l208:
+	SLL	R5, $1, R5
+	CMPULE	R0, R1, R2
+	BEQ	R2, l316
+	SUBL	R1, R0, R1
+	BIS	R5, $1, R5
+l316:
+	LDI	R2, R0
+	SRL	R2, $1, R2
+	LDI	R0, R2
+	BR	ZERO, l340
+l340:
+	LDL	R2, $i+8(SP)
+	SUBL	R2, $1, R2
+	STL	R2, $i+8(SP)
+	BR	ZERO, l184
+l384:
+	LDI	R0, R5
+	ADDL	SP, $80, SP
+	RET
+
+TEXT runtime·breakpoint(SB), NOFRAME|NOSPLIT, $0
+	SYS_CALL_B	$0x80
+	RET
+
+// Switch to m->g0's stack, call fn(g).
+// Fn must never return. It should gogo(&g->sched)
+// to keep running g.
+
+// func mcall(fn func(*g))
+TEXT runtime·mcall<ABIInternal>(SB), NOFRAME|NOSPLIT, $0-8
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     REGCTXT, R16
+#else
+        LDL     REGCTXT, fn+0(FP)
+#endif
+	// Save caller state in g->sched
+	STL	SP, (g_sched+gobuf_sp)(g)
+	STL	R26, (g_sched+gobuf_pc)(g)
+	STL	ZERO, (g_sched+gobuf_lr)(g)
+
+	// Switch to m->g0 & its stack, call fn.
+	LDI	R1, g
+	LDL	R3, g_m(g)
+	LDL	g, m_g0(R3)
+	CALL	runtime·save_g(SB)
+	CMPEQ	g, R1, R7
+	BEQ	R7, ok
+	CALL	runtime·badmcall(SB)
+ok:
+	LDL	SP, (g_sched+gobuf_sp)(g)
+	SUBL    SP, $16, SP
+	STL     ZERO, 0(SP)     // dummy LR
+#ifdef GOEXPERIMENT_regabiargs
+	LDI	R16, R1         // arg = g
+#else
+	STL   	R1, 8(SP)       // arg = g
+#endif
+	LDL     R27, 0(REGCTXT) // code pointer
+	JMP	(R27)
+	//ADDL	SP, $16, SP
+	CALL	runtime·badmcall2(SB)
+
+// func systemstack(fn func())
+TEXT runtime·systemstack(SB), NOSPLIT, $0-8
+	LDL	R1, fn+0(FP)
+	LDI	REGCTXT, R1
+
+	LDL	R2, g_m(g)
+
+	LDL	R3, m_gsignal(R2)
+	CMPEQ	g, R3, R3
+	BNE	R3, noswitch
+
+	LDL	R3, m_g0(R2) // save g0 in R3
+	CMPEQ	g, R3, R4
+	BNE	R4, noswitch
+
+	LDL	R4, m_curg(R2)
+	CMPEQ	g, R4, R4
+	BNE	R4, switch
+
+	CALL	runtime·badsystemstack(SB)
+	CALL	runtime·abort(SB)
+	RET
+switch:
+	// save our state in g->sched. Pretend to
+	// be systemstack_switch if the G stack is scanned.
+	CALL gosave_systemstack_switch<>(SB)
+	
+	// switch to g0
+	LDI	g, R3
+	CALL	runtime·save_g(SB)
+	LDL	R1, (g_sched+gobuf_sp)(g)
+	LDI	SP, R1
+	
+	LDL	R27, 0(REGCTXT)
+	CALL	(R27)
+	
+	// switch back to g
+	LDL	R1, g_m(g)
+	LDL	g, m_curg(R1)
+	CALL	runtime·save_g(SB)
+	LDL	SP, (g_sched+gobuf_sp)(g)
+	STL	ZERO, (g_sched+gobuf_sp)(g)
+	RET
+noswitch:
+	// already on m stack, just call directly
+	// Using a tail call here cleans up tracebacks since we won't stop
+	// at an intermediate systemstack.
+	LDL	R27, 0(REGCTXT)
+	LDL	R26, 0(SP)
+	ADDL	SP, $8, SP
+	JMP	(R27)
+
+// systemstack_switch is a dummy routine that systemstack leaves at the bottom
+// of the G stack. We need to distinguish the routine that
+// lives at the bottom of the G stack from the one that lives
+// at the top of the system stack because the one at the top of
+// the system stack terminates the stack walk (see topofstack()).
+TEXT runtime·systemstack_switch(SB), NOSPLIT, $0-0
+	UNDEF
+	CALL	(R27)	// make sure this function is not leaf
+	RET
+
+TEXT runtime·asminit(SB), NOFRAME|NOSPLIT, $0-0
+	RET
+
+/*
+ * support for morestack
+ */
+
+// Called during function prolog when more stack is needed.
+//
+// The traceback routines see morestack on a g0 as being
+// the top of a stack (for example, morestack calling newstack
+// calling the scheduler calling newm calling gc), so we must
+// record an argument size. For that purpose, it has no arguments.
+//
+// R2 is return address; R3 is PC
+TEXT runtime·morestack(SB), NOFRAME|NOSPLIT, $0-0
+	// Cannot grow scheduler stack (m->g0).
+	LDL	R7, g_m(g)
+	LDL	R8, m_g0(R7)
+	CMPEQ	g, R8, R1
+	BEQ	R1, 3(PC) // if g != g.m.g0
+	CALL	runtime·badmorestackg0(SB)
+	CALL	runtime·abort(SB)
+
+	// Cannot grow signal stack (m->gsignal).
+	LDL	R8, m_gsignal(R7)
+	CMPEQ	g, R8, R1
+	BEQ	R1, 3(PC) // if g != g.m.gsignal
+	CALL	runtime·badmorestackgsignal(SB)
+	CALL	runtime·abort(SB)
+
+	// Called from f.
+	// Set g->sched to context in f.
+	STL	SP, (g_sched+gobuf_sp)(g)
+	STL	R2, (g_sched+gobuf_pc)(g)
+	STL	R3, (g_sched+gobuf_lr)(g)
+	STL	REGCTXT, (g_sched+gobuf_ctxt)(g)
+
+	// Called from f.
+	// Set m->morebuf to f's caller.
+	STL	R3, (m_morebuf+gobuf_pc)(R7)	// f's caller's PC
+	STL	SP, (m_morebuf+gobuf_sp)(R7)	// f's caller's SP
+	STL	g, (m_morebuf+gobuf_g)(R7)
+
+	// Call newstack on m->g0's stack.
+	LDL	g, m_g0(R7)
+	CALL	runtime·save_g(SB)
+	LDL	SP, (g_sched+gobuf_sp)(g)
+	// Create a stack frame on g0 to call newstack.
+	STL	ZERO, -8(SP)
+	SUBL	SP, $8, SP
+	CALL	runtime·newstack(SB)
+
+	// Not reached, but make sure the return PC from the call to newstack
+	// is still in this function, and not the beginning of the next.
+	UNDEF
+
+
+TEXT runtime·morestack_noctxt(SB), NOFRAME|NOSPLIT, $0-0
+	LDI	REGCTXT, ZERO
+	JMP	runtime·morestack(SB)
+
+#ifdef GOEXPERIMENT_regabiargs
+// spillArgs stores return values from registers to a *internal/abi.RegArgs in R9.
+TEXT ·spillArgs(SB),NOSPLIT,$0-0
+	STL	R16, (0*8)(R9)
+	STL	R17, (1*8)(R9)
+	STL	R18, (2*8)(R9)
+	STL	R19, (3*8)(R9)
+	STL	R20, (4*8)(R9)
+	STL	R21, (5*8)(R9)
+	STL	R22, (6*8)(R9)
+	STL	R23, (7*8)(R9)
+	STL	R24, (8*8)(R9)
+	FSTD	F16, (9*8)(R9)
+	FSTD	F17, (10*8)(R9)
+	FSTD	F18, (11*8)(R9)
+	FSTD	F19, (12*8)(R9)
+	FSTD	F20, (13*8)(R9)
+	FSTD	F21, (14*8)(R9)
+	FSTD	F22, (15*8)(R9)
+	FSTD	F23, (16*8)(R9)
+	FSTD	F24, (17*8)(R9)
+	RET
+
+// unspillArgs loads args into registers from a *internal/abi.RegArgs in R9.
+TEXT ·unspillArgs(SB),NOSPLIT,$0-0
+	LDL	R16, (0*8)(R9)
+	LDL	R17, (1*8)(R9)
+	LDL	R18, (2*8)(R9)
+	LDL	R19, (3*8)(R9)
+	LDL	R20, (4*8)(R9)
+	LDL	R21, (5*8)(R9)
+	LDL	R22, (6*8)(R9)
+	LDL	R23, (7*8)(R9)
+	LDL	R24, (8*8)(R9)
+	FLDD	F16, (9*8)(R9)
+	FLDD	F17, (10*8)(R9)
+	FLDD	F18, (11*8)(R9)
+	FLDD	F19, (12*8)(R9)
+	FLDD	F20, (13*8)(R9)
+	FLDD	F21, (14*8)(R9)
+	FLDD	F22, (15*8)(R9)
+	FLDD	F23, (16*8)(R9)
+	FLDD	F24, (17*8)(R9)
+	RET
+#else
+TEXT ·spillArgs(SB),NOSPLIT,$0-0
+        RET
+
+TEXT ·unspillArgs(SB),NOSPLIT,$0-0
+        RET
+#endif
+
+// void setg(G*); set g. for use by needm.
+TEXT runtime·setg(SB), NOSPLIT, $0-8
+	LDL	g, gg+0(FP)
+	// This only happens if iscgo, so jump straight to save_g
+	CALL	runtime·save_g(SB)
+	RET
+
+
+TEXT runtime·return0(SB), NOSPLIT, $0
+	LDI	R0, $0
+	RET
+
+
+// The top-most function running on a goroutine
+TEXT runtime·goexit(SB), NOFRAME|NOSPLIT|TOPFRAME, $0-0
+	LDI	ZERO, $0
+	JMP	runtime·goexit1(SB)
+	LDI	ZERO, $0
+
+// This is called from .init_array and follows the platform, not Go, ABI
+TEXT runtime·addmoduledata(SB),NOSPLIT,$0-0
+  LDL  R1, runtime·lastmoduledatap(SB)
+  STL  R0, moduledata_next(R1) // local.moduledata passed to R0
+  STL  R0, runtime·lastmoduledatap(SB)
+  RET
+
+// void gogo(Gobuf*)
+// restore state from Gobuf; longjmp
+TEXT runtime·gogo(SB), NOSPLIT|NOFRAME, $0-8
+	LDL	R3, buf+0(FP)
+	LDL R4, gobuf_g(R3)
+	LDL ZERO, 0(R4) // make sure g != nil
+	JMP gogo<>(SB)
+
+TEXT gogo<>(SB), NOSPLIT|NOFRAME, $0
+	LDI g, R4
+	CALL	runtime·save_g(SB)
+
+	LDL	SP, gobuf_sp(R3)
+	LDL	R26, gobuf_lr(R3)
+	LDL	R0, gobuf_ret(R3)
+	LDL	REGCTXT, gobuf_ctxt(R3)
+
+	STL	ZERO, gobuf_sp(R3)
+	STL	ZERO, gobuf_ret(R3)
+	STL	ZERO, gobuf_lr(R3)
+	STL	ZERO, gobuf_ctxt(R3)
+
+	LDL	R27, gobuf_pc(R3)
+	JMP	(R27)
+	RET
+
+TEXT runtime·procyield(SB), NOFRAME|NOSPLIT, $0-0
+	RET
+
+// changed R19 to R1
+#define DISPATCH(NAME, MAXSIZE) \
+	LDI	R0, $MAXSIZE \
+	CMPULT	R0, R1, R0 \
+	BNE	R0, 4(PC) \
+	SYMADDR	R27, $NAME(SB) \
+	JMP	(R27) \
+	RET
+
+TEXT reflect·call(SB), NOFRAME|NOSPLIT, $0-0
+	JMP	·reflectcall(SB)
+
+// func call(stackArgsType *_type, f *FuncVal, stackArgs *byte, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)
+TEXT ·reflectcall(SB), NOFRAME|NOSPLIT, $0-48
+	LDW	R1, frameSize+32(FP) // R1 used in DISPACH macro
+//	LDW     R19, frameSize+32(FP) // R19 used in DISPACH macro
+	DISPATCH(runtime·call32, 32)
+	DISPATCH(runtime·call64, 64)
+	DISPATCH(runtime·call128, 128)
+	DISPATCH(runtime·call256, 256)
+	DISPATCH(runtime·call512, 512)
+	DISPATCH(runtime·call1024, 1024)
+	DISPATCH(runtime·call2048, 2048)
+	DISPATCH(runtime·call4096, 4096)
+	DISPATCH(runtime·call8192, 8192)
+	DISPATCH(runtime·call16384, 16384)
+	DISPATCH(runtime·call32768, 32768)
+	DISPATCH(runtime·call65536, 65536)
+	DISPATCH(runtime·call131072, 131072)
+	DISPATCH(runtime·call262144, 262144)
+	DISPATCH(runtime·call524288, 524288)
+	DISPATCH(runtime·call1048576, 1048576)
+	DISPATCH(runtime·call2097152, 2097152)
+	DISPATCH(runtime·call4194304, 4194304)
+	DISPATCH(runtime·call8388608, 8388608)
+	DISPATCH(runtime·call16777216, 16777216)
+	DISPATCH(runtime·call33554432, 33554432)
+	DISPATCH(runtime·call67108864, 67108864)
+	DISPATCH(runtime·call134217728, 134217728)
+	DISPATCH(runtime·call268435456, 268435456)
+	DISPATCH(runtime·call536870912, 536870912)
+	DISPATCH(runtime·call1073741824, 1073741824)
+
+	CALL	runtime·badreflectcall(SB)
+	RET
+
+#define CALLFN(NAME,MAXSIZE) \
+TEXT NAME(SB), WRAPPER, $MAXSIZE-48 \
+	NO_LOCAL_POINTERS;            \
+	/* copy arguments to stack */        \
+	LDL	R1, stackArgs+16(FP) \
+	LDW	R2, stackArgsSize+24(FP) \
+	LDI	R3, SP \
+	ADDL	R3, $8, R3 \
+	ADDL	R3, R2, R2 \
+loop: \
+	CMPEQ	R3, R2, R0 \
+	BNE	R0, ok \
+	LDBU	R4, (R1) \
+	STB	R4, (R3) \
+	ADDL	R1, $1, R1 \
+	ADDL	R3, $1, R3 \
+	JMP	loop \
+ok: \
+	/* set up argument registers */  \
+	LDL	R9, regArgs+40(FP)  \
+	CALL	·unspillArgs(SB)  \
+	/* call function */  \
+	LDL	REGCTXT, fn+8(FP) \
+	LDL	R27, (REGCTXT) \
+	PCDATA	$PCDATA_StackMapIndex, $0; \
+	CALL	(R27) \
+	/* copy return values back */        \
+	LDL	R9, regArgs+40(FP)  \
+	CALL	·spillArgs(SB)  \
+	LDL	R5, stackArgsType+0(FP) \
+	LDL	R1, stackArgs+16(FP) \
+	LDW	R2, stackArgsSize+24(FP) \
+	LDW	R4, stackRetOffset+28(FP) \
+	ADDL	SP, $8, R3 \
+	ADDL	R4, R3, R3 \
+	ADDL	R4, R1, R1 \
+	SUBL	R2, R4, R2 \
+	CALL	callRet<>(SB) \
+	RET
+
+// callRet copies return values back at the end of call*. This is a
+// separate function so it can allocate stack space for the arguments
+// to reflectcallmove. It does not follow the Go ABI; it expects its
+// arguments in registers.
+TEXT callRet<>(SB), NOSPLIT, $40-0
+	NO_LOCAL_POINTERS	
+	STL	R5, 8(SP) // argtype
+	STL	R1, 16(SP) // dst
+	STL	R3, 24(SP) // src
+	STL	R2, 32(SP) // size
+	STL	R9, 40(SP) // regs
+	// reflectcallmove(typ *_type, dst, src unsafe.Pointer, size uintptr)
+	CALL	runtime·reflectcallmove(SB)
+	RET
+
+CALLFN(·call16, 16)
+CALLFN(·call32, 32)
+CALLFN(·call64, 64)
+CALLFN(·call128, 128)
+CALLFN(·call256, 256)
+CALLFN(·call512, 512)
+CALLFN(·call1024, 1024)
+CALLFN(·call2048, 2048)
+CALLFN(·call4096, 4096)
+CALLFN(·call8192, 8192)
+CALLFN(·call16384, 16384)
+CALLFN(·call32768, 32768)
+CALLFN(·call65536, 65536)
+CALLFN(·call131072, 131072)
+CALLFN(·call262144, 262144)
+CALLFN(·call524288, 524288)
+CALLFN(·call1048576, 1048576)
+CALLFN(·call2097152, 2097152)
+CALLFN(·call4194304, 4194304)
+CALLFN(·call8388608, 8388608)
+CALLFN(·call16777216, 16777216)
+CALLFN(·call33554432, 33554432)
+CALLFN(·call67108864, 67108864)
+CALLFN(·call134217728, 134217728)
+CALLFN(·call268435456, 268435456)
+CALLFN(·call536870912, 536870912)
+CALLFN(·call1073741824, 1073741824)
+
+
+TEXT ·checkASM(SB),NOSPLIT,$0-1
+	LDI	R1, $1
+	STB	R1, ret+0(FP)
+	RET
+
+
+TEXT runtime·abort(SB), NOFRAME|NOSPLIT, $0-0
+	LDW	ZERO,(ZERO)
+	UNDEF
+
+TEXT runtime·mstart(SB),NOSPLIT|TOPFRAME,$0
+ CALL runtime·mstart0(SB)
+ RET // not reached
+
+// Save state of caller into g->sched,
+// but using fake PC from systemstack_switch.
+// Must only be called from functions with no locals ($0)
+// or else unwinding from systemstack_switch is incorrect.
+// Smashes R1.
+TEXT gosave_systemstack_switch<>(SB), NOFRAME|NOSPLIT,$0
+	SYMADDR R1, $runtime·systemstack_switch(SB)
+  ADDL R1, $8, R1
+	STL	R1, (g_sched+gobuf_pc)(g)
+	STL	SP, (g_sched+gobuf_sp)(g)
+	STL	ZERO, (g_sched+gobuf_lr)(g)
+	STL	ZERO, (g_sched+gobuf_ret)(g)
+	// Assert ctxt is zero. See func save.
+	LDL	R1, (g_sched+gobuf_ctxt)(g)
+	BEQ	R1, 2(PC)
+	CALL	runtime·abort(SB)
+	RET
+
+TEXT ·asmcgocall_no_g(SB),NOSPLIT,$0-16
+  LDL R27, fn+0(FP)
+  LDL R16, arg+8(FP)
+  CALL (R27)
+  RET
+
+// func asmcgocall(fn, arg unsafe.Pointer) int32
+// Call fn(arg) on the scheduler stack,
+// aligned appropriately for the gcc ABI.
+// See cgocall.go for more details.
+TEXT ·asmcgocall(SB), NOSPLIT, $0-20
+	LDL	R27, fn+0(FP)
+	LDL	R16, arg+8(FP)
+	
+	LDI	R8, R27
+	LDI	R3, SP
+	LDI	R2, g
+
+	// Figure out if we need to switch to m->g0 stack.
+	// We get called to create new OS threads too, and those
+	// come in on the m->g0 stack already. Or we might already
+	// be on the m->gsignal stack.
+	LDL	R5, g_m(g)
+	LDL	R6, m_gsignal(R5)
+	CMPEQ	R6, g, R0
+	BNE	R0, g0
+
+	LDL	R6, m_g0(R5)
+	CMPEQ	R6, g, R0
+	BNE	R0, g0
+	
+	CALL	gosave_systemstack_switch<>(SB)
+	LDI	g, R6
+	CALL	runtime·save_g(SB)
+	
+	// restore fn value from old SP
+	LDI	R27, R8
+	LDL	SP, (g_sched+gobuf_sp)(g)
+	// Now on a scheduling stack (a pthread-created stack).
+g0:
+	// Save room for two of our pointers.
+	LDI	SP, $-16(SP)
+	STL	R2, 0(SP)
+	LDL	R2, (g_stack+stack_hi)(R2)
+	SUBL	R2, R3, R2
+	STL	R2, 8(SP)
+	CALL	R26, (R27)
+	// Restore g, stack pointer. R2 is return value.
+	LDL	g, 0(SP)
+	CALL	runtime·save_g(SB)
+	LDL	R5, (g_stack+stack_hi)(g)
+	LDL	R6, 8(SP)
+	SUBL	R5, R6, R5
+	LDI	SP, R5
+
+	STW	R0, ret+16(FP)
+	RET
+
+// void setg_gcc(G*); set g in C TLS.
+// Must obey the gcc calling convention.
+TEXT setg_gcc<>(SB), NOSPLIT, $0
+	LDI	g, R16
+	CALL	runtime·save_g(SB)
+	RET
+
+// Called from cgo wrappers, this function returns g->m->curg.stack.hi.
+// Must obey the gcc calling convention.
+TEXT _cgo_topofstack(SB), NOSPLIT, $16
+	// g (R15)  might be clobbered by load_g. They
+	// are callee-save in the gcc calling convention, so save them.
+	STL	R28, savedR28-16(SP)
+	STL	g, savedG-8(SP)
+
+	CALL	runtime·load_g(SB)
+
+	LDL	R1, g_m(g)
+	LDL	R1, m_curg(R1)
+	LDL	R0, (g_stack+stack_hi)(R1) // return value in R0
+
+	LDL	g, savedG-8(SP)
+	LDL	R28, savedR28-16(SP)
+	RET
+
+
+// cgocallback_gofunc(FuncVal*, void *frame, uintptr framesize, uintptr ctxt)
+// See cgocall.go for more details.
+TEXT ·cgocallback(SB), NOSPLIT, $24-24
+	NO_LOCAL_POINTERS
+
+	// Skip cgocallbackg, just dropm when fn is nil, and frame is the saved g.
+	// It is used to dropm while thread is exiting.
+	LDL	R16, fn+0(FP)
+	BNE	R16, loadg
+	// Restore the g from frame.
+	LDL	g, frame+8(FP)
+	JMP	dropm
+
+loadg:
+	// Load m and g from thread-local storage.
+	LDBU	R1, runtime·iscgo(SB)
+	BEQ	R1, nocgo
+	CALL	runtime·load_g(SB)
+nocgo:
+
+	// If g is nil, Go did not create the current thread,
+	// or if this thread never called into Go on pthread platforms.
+	// Call needm to obtain one for temporary use.
+	// In this case, we're running on the thread stack, so there's
+	// lots of space, but the linker doesn't know. Hide the call from
+	// the linker analysis by using an indirect call.
+	BEQ	g, needm
+	LDL	R3, g_m(g)
+	STL	R3, savedm-8(SP)
+	JMP	havem
+
+needm:
+	STL	g, savedm-8(SP) // g is zero, so is m.
+	SYMADDR	R27, $runtime·needAndBindM(SB)
+	CALL	R26, (R27)
+
+	// Set m->sched.sp = SP, so that if a panic happens
+	// during the function we are about to execute, it will
+	// have a valid SP to run on the g0 stack.
+	// The next few lines (after the havem label)
+	// will save this SP onto the stack and then write
+	// the same SP back to m->sched.sp. That seems redundant,
+	// but if an unrecovered panic happens, unwindm will
+	// restore the g->sched.sp from the stack location
+	// and then systemstack will try to use it. If we don't set it here,
+	// that restored SP will be uninitialized (typically 0) and
+	// will not be usable.
+	LDL	R3, g_m(g)
+	LDL	R1, m_g0(R3)
+	STL	SP, (g_sched+gobuf_sp)(R1)
+
+havem:
+	// Now there's a valid m, and we're running on its m->g0.
+	// Save current m->g0->sched.sp on stack and then set it to SP.
+	// Save current sp in m->g0->sched.sp in preparation for
+	// switch back to m->curg stack.
+	// NOTE: unwindm knows that the saved g->sched.sp is at 8(R29) aka savedsp-16(SP).
+
+	LDL	R1, m_g0(R3)
+	LDL	R2, (g_sched+gobuf_sp)(R1)
+	STL	R2, savedsp-24(SP)
+	STL	SP,  (g_sched+gobuf_sp)(R1)
+
+	// Switch to m->curg stack and call runtime.cgocallbackg.
+	// Because we are taking over the execution of m->curg
+	// but *not* resuming what had been running, we need to
+	// save that information (m->curg->sched) so we can restore it.
+	// We can restore m->curg->sched.sp easily, because calling
+	// runtime.cgocallbackg leaves SP unchanged upon return.
+	// To save m->curg->sched.pc, we push it onto the stack.
+	// This has the added benefit that it looks to the traceback
+	// routine like cgocallbackg is going to return to that
+	// PC (because the frame we allocate below has the same
+	// size as cgocallback_gofunc's frame declared above)
+	// so that the traceback will seamlessly trace back into
+	// the earlier calls.
+	//
+	// In the new goroutine, -8(SP) is unused (where SP refers to
+	// m->curg's SP while we're setting it up, before we've adjusted it).
+	LDL	g, m_curg(R3)
+	CALL	runtime·save_g(SB)
+	LDL	R2, (g_sched+gobuf_sp)(g)
+	LDL	R27, (g_sched+gobuf_pc)(g)
+	STL	R27, -32(R2) // save LR
+	//  Gather our arguments into registers.
+	LDL 	R16, fn+0(FP)
+	LDL	R17, frame+8(FP)
+	LDL 	R18, ctxt+16(FP)
+	LDI 	SP, $-32(R2) //switch stack
+	STL 	R16, 8(SP)
+	STL 	R17, 16(SP)
+	STL 	R18, 24(SP)
+	CALL	runtime·cgocallbackg(SB)
+
+	// Restore g->sched (== m->curg->sched) from saved values.
+	LDL	R27, 0(SP)
+	STL	R27, (g_sched+gobuf_pc)(g)
+	LDI	R2, $32(SP)
+	STL	R2, (g_sched+gobuf_sp)(g)
+
+	// Switch back to m->g0's stack and restore m->g0->sched.sp.
+	// (Unlike m->curg, the g0 goroutine never uses sched.pc,
+	// so we do not have to restore it.)
+	LDL	R3, g_m(g)
+	LDL	g, m_g0(R3)
+	CALL	runtime·save_g(SB)
+	LDL	SP, (g_sched+gobuf_sp)(g)
+	LDL	R2, savedsp-24(SP)
+	STL	R2, (g_sched+gobuf_sp)(g)
+
+	// If the m on entry was nil, we called needm above to borrow an m,
+	// 1. for the duration of the call on non-pthread platforms,
+	// 2. or the duration of the C thread alive on pthread platforms.
+	// If the m on entry wasn't nil,
+	// 1. the thread might be a Go thread,
+	// 2. or it's wasn't the first call from a C thread on pthread platforms,
+	//    since the we skip dropm to resue the m in the first call.
+	LDL	R3, savedm-8(SP)
+	BNE	R3, droppedm
+
+	// Skip dropm to reuse it in the next call, when a pthread key has been created.
+	LDL	R3, _cgo_pthread_key_created(SB)
+	// It means cgo is disabled when _cgo_pthread_key_created is a nil pointer, need dropm.
+	BEQ	R3, dropm
+	LDL	R3, (R3)
+	BNE	R3, droppedm
+dropm:
+	SYMADDR	R27, $runtime·dropm(SB)
+	CALL	R26, (R27)
+droppedm:
+	// Done!
+	RET
+
+
+// gcWriteBarrier informs the GC about heap pointer writes.
+//
+// gcWriteBarrier does NOT follow the Go ABI. It accepts the
+// number of bytes of buffer needed in R14, and returns a pointer
+// to the buffer space in R14.
+// It clobbers R28 (the linker temp register).
+// The act of CALLing gcWriteBarrier will clobber R26 (LR).
+// It does not clobber any other general-purpose registers,
+// but may clobber others (e.g., floating point registers).
+TEXT gcWriteBarrier<>(SB),NOSPLIT,$208
+	// Save the registers clobbered by the fast path.
+	STL	R1, 200(SP)
+	STL	R2, 208(SP)
+retry:
+	LDL	R1, g_m(g)
+	LDL	R1, m_p(R1)
+	LDL	R2, (p_wbBuf+wbBuf_next)(R1)
+	LDL	R28, (p_wbBuf+wbBuf_end)(R1)// R28 is linker temp register
+	// Increment wbBuf.next position.
+	ADDL	R2, R14, R2
+	// Is the buffer full?
+	CMPULT  R28, R2, R28
+	BNE	R28, flush
+	// Commit to the larger buffer.
+	STL	R2, (p_wbBuf+wbBuf_next)(R1)
+	// Make return value (the original next position)
+	SUBL	R2, R14, R14
+	LDL	R1, 200(SP)
+	LDL	R2, 208(SP)
+	RET
+
+flush:
+	// Save all general purpose registers since these could be
+	// clobbered by wbBufFlush and were not saved by the caller.
+	STL	R13, 8(SP)
+	STL	R14, 16(SP)
+	STL	R0, 24(SP)
+	// R1 already saved
+	// R2 already saved
+	STL	R3, 32(SP)
+	STL	R4, 40(SP)
+	STL	R5, 48(SP)
+	STL	R6, 56(SP)
+	STL	R7, 64(SP)
+	STL	R8, 72(SP)
+	STL	R9, 80(SP)
+	STL	R10, 88(SP)
+	STL	R11, 96(SP)
+	STL	R12, 104(SP)
+	// R13 already saved
+	// R14 already saved.
+	// R15 is g.
+	STL	R16, 112(SP)
+	STL	R17, 120(SP)
+	STL	R18, 128(SP)
+	STL	R19, 136(SP)
+	STL	R20, 144(SP)
+	STL	R21, 152(SP)
+	STL	R22, 160(SP)
+	STL	R23, 168(SP)
+	STL	R24, 176(SP)
+	STL	R25, 184(SP)
+	// R26 is link register.
+	STL	R27, 192(SP)
+	// R28 is tmp register.
+	// R29 is SB.
+	// R30 is SP.
+	// R31 is ZERO.
+
+	CALL	runtime·wbBufFlush(SB)
+
+	LDL     R13, 8(SP)     
+	LDL     R14, 16(SP)    
+	LDL     R0, 24(SP)
+	LDL     R3, 32(SP)
+	LDL     R4, 40(SP)
+	LDL     R5, 48(SP)
+	LDL     R6, 56(SP)
+	LDL     R7, 64(SP)
+	LDL     R8, 72(SP)
+	LDL     R9, 80(SP)
+	LDL     R10, 88(SP)
+	LDL     R11, 96(SP)
+	LDL     R12, 104(SP)
+	LDL     R16, 112(SP)
+	LDL     R17, 120(SP)
+	LDL     R18, 128(SP)
+	LDL     R19, 136(SP)
+	LDL     R20, 144(SP)
+	LDL     R21, 152(SP)
+	LDL     R22, 160(SP)
+	LDL     R23, 168(SP)
+	LDL     R24, 176(SP)
+	LDL     R25, 184(SP)
+	LDL     R27, 192(SP)
+	JMP	retry
+
+TEXT runtime·gcWriteBarrier1<ABIInternal>(SB),NOSPLIT,$0
+	LDI	R14, $8
+	JMP	gcWriteBarrier<>(SB)
+TEXT runtime·gcWriteBarrier2<ABIInternal>(SB),NOSPLIT,$0
+	LDI	R14, $16
+	JMP	gcWriteBarrier<>(SB)
+TEXT runtime·gcWriteBarrier3<ABIInternal>(SB),NOSPLIT,$0
+	LDI	R14, $24
+	JMP	gcWriteBarrier<>(SB)
+TEXT runtime·gcWriteBarrier4<ABIInternal>(SB),NOSPLIT,$0
+	LDI	R14, $32
+	JMP	gcWriteBarrier<>(SB)
+TEXT runtime·gcWriteBarrier5<ABIInternal>(SB),NOSPLIT,$0
+	LDI	R14, $40
+	JMP	gcWriteBarrier<>(SB)
+TEXT runtime·gcWriteBarrier6<ABIInternal>(SB),NOSPLIT,$0
+	LDI	R14, $48
+	JMP	gcWriteBarrier<>(SB)
+TEXT runtime·gcWriteBarrier7<ABIInternal>(SB),NOSPLIT,$0
+	LDI	R14, $56
+	JMP	gcWriteBarrier<>(SB)
+TEXT runtime·gcWriteBarrier8<ABIInternal>(SB),NOSPLIT,$0
+	LDI	R14, $64
+	JMP	gcWriteBarrier<>(SB)
+
+// func cputicks() int64
+//TEXT runtime·cputicks(SB),NOSPLIT,$0-8
+//	RTC	R0
+//	STL	R0, ret+0(FP)
+//	RET
+
+//zxw new add
+// Note: these functions use a special calling convention to save generated code space.
+// Arguments are passed in registers, but the space for those arguments are allocated
+// in the caller's stack frame. These stubs write the args into that stack space and
+// then tail call to the corresponding runtime handler.
+// The tail call makes these stubs disappear in backtraces.
+TEXT runtime·panicIndex<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     R16, R1
+        LDI     R17, R2
+#else
+	STL	R1, x+0(FP)
+	STL	R2, y+8(FP)
+#endif
+	JMP	runtime·goPanicIndex<ABIInternal>(SB)
+TEXT runtime·panicIndexU<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     R16, R1
+        LDI     R17, R2
+#else
+	STL	R1, x+0(FP)
+	STL	R2, y+8(FP)
+#endif
+	JMP	runtime·goPanicIndexU<ABIInternal>(SB)
+TEXT runtime·panicSliceAlen<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+	LDI	R16, R2
+	LDI	R17, R3
+#else
+	STL	R2, x+0(FP)
+	STL	R3, y+8(FP)
+#endif
+	JMP	runtime·goPanicSliceAlen<ABIInternal>(SB)
+TEXT runtime·panicSliceAlenU<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+	LDI     R16, R2
+	LDI     R17, R3
+#else
+	STL	R2, x+0(FP)
+	STL	R3, y+8(FP)
+#endif
+	JMP	runtime·goPanicSliceAlenU<ABIInternal>(SB)
+TEXT runtime·panicSliceAcap<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     R16, R2
+        LDI     R17, R3
+#else
+	STL	R2, x+0(FP)
+	STL	R3, y+8(FP)
+#endif
+	JMP	runtime·goPanicSliceAcap<ABIInternal>(SB)
+TEXT runtime·panicSliceAcapU<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     R16, R2
+        LDI     R17, R3
+#else
+	STL	R2, x+0(FP)
+	STL	R3, y+8(FP)
+#endif
+	JMP	runtime·goPanicSliceAcapU<ABIInternal>(SB)
+TEXT runtime·panicSliceB<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     R16, R1
+        LDI     R17, R2
+#else
+	STL	R1, x+0(FP)
+	STL	R2, y+8(FP)
+#endif
+	JMP	runtime·goPanicSliceB<ABIInternal>(SB)
+TEXT runtime·panicSliceBU<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     R16, R1
+        LDI     R17, R2
+#else
+	STL	R1, x+0(FP)
+	STL	R2, y+8(FP)
+#endif
+	JMP	runtime·goPanicSliceBU<ABIInternal>(SB)
+TEXT runtime·panicSlice3Alen<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     R16, R3
+        LDI     R17, R4
+#else
+	STL	R3, x+0(FP)
+	STL	R4, y+8(FP)
+#endif
+	JMP	runtime·goPanicSlice3Alen<ABIInternal>(SB)
+TEXT runtime·panicSlice3AlenU<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     R16, R3
+        LDI     R17, R4
+#else
+	STL	R3, x+0(FP)
+	STL	R4, y+8(FP)
+#endif
+	JMP	runtime·goPanicSlice3AlenU<ABIInternal>(SB)
+TEXT runtime·panicSlice3Acap<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     R16, R3
+        LDI     R17, R4
+#else
+	STL	R3, x+0(FP)
+	STL	R4, y+8(FP)
+#endif
+	JMP	runtime·goPanicSlice3Acap<ABIInternal>(SB)
+TEXT runtime·panicSlice3AcapU<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     R16, R3
+        LDI     R17, R4
+#else
+	STL	R3, x+0(FP)
+	STL	R4, y+8(FP)
+#endif
+	JMP	runtime·goPanicSlice3AcapU<ABIInternal>(SB)
+TEXT runtime·panicSlice3B<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     R16, R2
+        LDI     R17, R3
+#else
+	STL	R2, x+0(FP)
+	STL	R3, y+8(FP)
+#endif
+	JMP	runtime·goPanicSlice3B<ABIInternal>(SB)
+TEXT runtime·panicSlice3BU<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     R16, R2
+        LDI     R17, R3
+#else
+	STL	R2, x+0(FP)
+	STL	R3, y+8(FP)
+#endif
+	JMP	runtime·goPanicSlice3BU<ABIInternal>(SB)
+TEXT runtime·panicSlice3C<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     R16, R1
+        LDI     R17, R2
+#else
+	STL	R1, x+0(FP)
+	STL	R2, y+8(FP)
+#endif
+	JMP	runtime·goPanicSlice3C<ABIInternal>(SB)
+TEXT runtime·panicSlice3CU<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     R16, R1
+        LDI     R17, R2
+#else
+	STL	R1, x+0(FP)
+	STL	R2, y+8(FP)
+#endif
+	JMP	runtime·goPanicSlice3CU<ABIInternal>(SB)
+TEXT runtime·panicSliceConvert<ABIInternal>(SB),NOSPLIT,$0-16
+#ifdef GOEXPERIMENT_regabiargs
+        LDI     R16, R3
+        LDI     R17, R4
+#else
+	STL	R3, x+0(FP)
+	STL	R4, y+8(FP)
+#endif
+	JMP	runtime·goPanicSliceConvert<ABIInternal>(SB)
+
+
+TEXT runtime·memhash<ABIInternal>(SB),NOSPLIT|NOFRAME,$0-32
+	JMP	runtime·memhashFallback<ABIInternal>(SB)
+TEXT runtime·strhash<ABIInternal>(SB),NOSPLIT|NOFRAME,$0-24
+	JMP	runtime·strhashFallback<ABIInternal>(SB)
+TEXT runtime·memhash32<ABIInternal>(SB),NOSPLIT|NOFRAME,$0-24
+	JMP	runtime·memhash32Fallback<ABIInternal>(SB)
+TEXT runtime·memhash64<ABIInternal>(SB),NOSPLIT|NOFRAME,$0-24
+	JMP	runtime·memhash64Fallback<ABIInternal>(SB)
diff --git a/src/runtime/atomic_sw64.s b/src/runtime/atomic_sw64.s
new file mode 100644
index 00000000..02698b99
--- /dev/null
+++ b/src/runtime/atomic_sw64.s
@@ -0,0 +1,13 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+// +build sw64
+
+#include "textflag.h"
+
+// func publicationBarrier()
+TEXT ·publicationBarrier(SB),NOSPLIT|NOFRAME,$0-0
+	MEMB
+	RET
diff --git a/src/runtime/cgo/asm_sw64.s b/src/runtime/cgo/asm_sw64.s
new file mode 100644
index 00000000..ef0c6b9f
--- /dev/null
+++ b/src/runtime/cgo/asm_sw64.s
@@ -0,0 +1,80 @@
+// Copyright 2016 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+// +build sw64
+
+#include "textflag.h"
+
+// Set the x_crosscall2_ptr C function pointer variable point to crosscall2.
+// It's such a pointer chain: _crosscall2_ptr -> x_crosscall2_ptr -> crosscall2
+TEXT ·set_crosscall2(SB),NOSPLIT,$0-0
+	LDL	R16, _crosscall2_ptr(SB)
+	SYMADDR	R17, $crosscall2(SB)
+	STL	R17, (R16)
+	RET
+// Called by C code generated by cmd/cgo.
+// func crosscall2(fn, a unsafe.Pointer, n int32, ctxt uintptr)
+// Saves C callee-saved registers and calls cgocallback with three arguments.
+// fn is the PC of a func(a unsafe.Pointer) function.
+TEXT crosscall2(SB), NOFRAME|NOSPLIT, $0
+	/*
+	 * We still need to save all callee save register as before, and then
+	 *  push 3 args for fn (R16, R17, R19), skipping R18.
+	 * Also note that at procedure entry in gc world, 8(SP) will be the
+	 *  first arg.
+	 */
+	LDI	SP, $-8*23(SP)
+
+	STL	R16, (8*1)(SP) // void*
+	STL	R17, (8*2)(SP) // int32
+	STL	R19, (8*3)(SP) // uintptr
+
+	STL	R9, (8*4)(SP)
+	STL	R10, (8*5)(SP)
+	STL	R11, (8*6)(SP)
+	STL	R12, (8*7)(SP)
+	STL	R13, (8*8)(SP)
+	STL	R14, (8*9)(SP)
+
+	STL	RSB, (8*12)(SP)
+	STL	g, (8*13)(SP)
+	STL	R26, (8*14)(SP)
+
+	FSTD	F2, (8*15)(SP)
+	FSTD	F3, (8*16)(SP)
+	FSTD	F4, (8*17)(SP)
+	FSTD	F5, (8*18)(SP)
+	FSTD	F6, (8*19)(SP)
+	FSTD	F7, (8*20)(SP)
+	FSTD	F8, (8*21)(SP)
+	FSTD	F9, (8*22)(SP)
+
+	CALL	runtime·load_g(SB)
+
+	CALL	runtime·cgocallback(SB)
+
+	LDL	R9, (8*4)(SP)
+	LDL	R10, (8*5)(SP)
+	LDL	R11, (8*6)(SP)
+	LDL	R12, (8*7)(SP)
+	LDL	R13, (8*8)(SP)
+	LDL	R14, (8*9)(SP)
+
+	LDL	RSB, (8*12)(SP)
+	LDL	g, (8*13)(SP)
+	LDL	R26, (8*14)(SP)
+
+	FLDD	F2, (8*15)(SP)
+	FLDD	F3, (8*16)(SP)
+	FLDD	F4, (8*17)(SP)
+	FLDD	F5, (8*18)(SP)
+	FLDD	F6, (8*19)(SP)
+	FLDD	F7, (8*20)(SP)
+	FLDD	F8, (8*21)(SP)
+	FLDD	F9, (8*22)(SP)
+
+
+	LDI	SP, $8*23(SP)
+	RET
diff --git a/src/runtime/cgo/gcc_linux_sw64.c b/src/runtime/cgo/gcc_linux_sw64.c
new file mode 100644
index 00000000..b0d1c970
--- /dev/null
+++ b/src/runtime/cgo/gcc_linux_sw64.c
@@ -0,0 +1,82 @@
+// Copyright 2016 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build cgo
+// +build linux
+// +build sw64
+
+#include <assert.h>
+#include <pthread.h>
+#include <string.h>
+#include <stdio.h>
+#include <signal.h>
+#include "libcgo.h"
+#include "libcgo_unix.h"
+
+static void *threadentry(void*);
+
+void (*x_cgo_inittls)(void **tlsg, void **tlsbase);
+//void (*setg_gcc)(void*);
+static void (*setg_gcc)(void*);
+
+void
+_cgo_sys_thread_start(ThreadStart *ts)
+{
+	pthread_attr_t attr;
+	sigset_t ign, oset;
+	pthread_t p;
+	size_t size;
+	int err;
+
+	sigfillset(&ign);
+	pthread_sigmask(SIG_SETMASK, &ign, &oset);
+
+	// Not sure why the memset is necessary here,
+	// but without it, we get a bogus stack size
+	// out of pthread_attr_getstacksize.  C'est la Linux.
+	memset(&attr, 0, sizeof attr);
+	pthread_attr_init(&attr);
+	size = 0;
+	pthread_attr_getstacksize(&attr, &size);
+	// Leave stacklo=0 and set stackhi=size; mstart will do the rest.
+	ts->g->stackhi = size;
+	err = _cgo_try_pthread_create(&p, &attr, threadentry, ts);
+
+	pthread_sigmask(SIG_SETMASK, &oset, nil);
+
+	if (err != 0) {
+		fatalf("pthread_create failed: %s", strerror(err));
+	}
+}
+
+extern void crosscall1(void (*fn)(void), void (*setg_gcc)(void*), void *g);
+static void*
+threadentry(void *v)
+{
+	ThreadStart ts;
+
+	ts = *(ThreadStart*)v;
+    free(v);
+
+    assert(setg_gcc != 0);
+	crosscall1(ts.fn, setg_gcc, (void*)ts.g);
+	return nil;
+}
+
+void
+x_cgo_init(G *g, void (*setg)(void*), void **tlsg, void **tlsbase)
+{
+	pthread_attr_t attr;
+	size_t size;
+
+	setg_gcc = setg;
+	pthread_attr_init(&attr);
+	pthread_attr_getstacksize(&attr, &size);
+	g->stacklo = (uintptr)&attr - size + 4096;
+	pthread_attr_destroy(&attr);
+
+	if (x_cgo_inittls) {
+		x_cgo_inittls(tlsg, tlsbase);
+	}
+}
diff --git a/src/runtime/cgo/gcc_sw64.S b/src/runtime/cgo/gcc_sw64.S
new file mode 100644
index 00000000..3fcff960
--- /dev/null
+++ b/src/runtime/cgo/gcc_sw64.S
@@ -0,0 +1,106 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build sw64
+
+#include <asm/regdef.h>
+/*
+ * void crosscall1(void (*fn)(void), void (*setg_gcc)(void *g), void *g)
+ *
+ * Calling into the gc tool chain, where all registers are caller save.
+ * Called from standard SW_64 ABI, where $9-$14, are callee-save,
+ * so they must be saved explicitly, along with $26 (RA).
+ */
+
+#if defined(__sw_64_sw6__)
+    #define LDD ldt
+    #define STD stt
+    #define CALL jsr
+#else
+    #define LDD fldd
+    #define STD fstd
+    #define CALL call
+#endif
+
+	.set	noat
+	.align	2
+	.globl	crosscall1
+	.ent	crosscall1
+crosscall1:
+
+	.frame	fp, 16, ra, 0
+	.cfi_startproc
+	ldi	sp, -160(sp)
+	.cfi_def_cfa_offset	160
+
+	stl	$26, 0(sp)
+	stl	$15, 56(sp)
+	stl	$29, 64(sp)
+	.cfi_offset	26, -16
+	.cfi_offset	15, -56
+	bis $31,$30,$15
+	.cfi_def_cfa_register	15
+
+	stl	$9, 8(sp)
+	stl	$10, 16(sp)
+	stl	$11, 24(sp)
+	stl	$12, 32(sp)
+	stl	$13, 40(sp)
+	stl	$14, 48(sp)
+
+	STD	$f2, 88 (sp)
+	STD	$f3, 96 (sp)
+	STD	$f4, 104(sp)
+	STD	$f5, 112(sp)
+	STD	$f6, 120(sp)
+	STD	$f7, 128(sp)
+	STD	$f8, 136(sp)
+	STD	$f9, 144(sp)
+
+	#a0=fn, a1=setg_gcc, a2=g
+	stl	a0, 72(sp)
+
+	ldi	$27, 0(a1)
+	ldi	a0, 0(a2)
+	ldi	a1, 0(zero)
+	ldi	a2, 0(zero)
+	CALL	$26, ($27), 0  #call setg_gcc (clobbers A0 ?)
+
+	ldl	$27, 72(sp)
+	ldi	a0, 0(zero)
+	ldi	a1, 0(zero)
+	ldi	a2, 0(zero)
+	CALL	$26, ($27), 0  #call fn
+
+	ldl	$9, 8(sp)
+	ldl	$10, 16(sp)
+	ldl	$11, 24(sp)
+	ldl	$12, 32(sp)
+	ldl	$13, 40(sp)
+	ldl	$14, 48(sp)
+
+	ldl	$15, 56(sp)
+	.cfi_restore	15
+
+	LDD	$f2, 88 (sp)
+	LDD	$f3, 96 (sp)
+	LDD	$f4, 104(sp)
+	LDD	$f5, 112(sp)
+	LDD	$f6, 120(sp)
+	LDD	$f7, 128(sp)
+	LDD	$f8, 136(sp)
+	LDD	$f9, 144(sp)
+
+	ldl	$29, 64(sp)
+
+	ldl	$26, 0(sp)
+	.cfi_restore	26
+
+	ldi	sp, 160(sp)
+	.cfi_def_cfa	30, 0
+
+	ret	$31,($26),1
+	.cfi_endproc
+
+	.end	crosscall1
diff --git a/src/runtime/cpuflags_sw64.go b/src/runtime/cpuflags_sw64.go
new file mode 100644
index 00000000..cd737126
--- /dev/null
+++ b/src/runtime/cpuflags_sw64.go
@@ -0,0 +1,17 @@
+// Copyright 2020 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package runtime
+
+import (
+	"internal/cpu"
+)
+
+var sw64UseSIMDLoads bool
+
+func init() {
+	if cpu.SW64.IsCore4 {
+		sw64UseSIMDLoads = true
+	}
+}
diff --git a/src/runtime/cputicks.go b/src/runtime/cputicks.go
index 2cf32403..9ffed61b 100644
--- a/src/runtime/cputicks.go
+++ b/src/runtime/cputicks.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !arm && !arm64 && !mips64 && !mips64le && !mips && !mipsle && !wasm
+//go:build !arm && !arm64 && !mips64 && !mips64le && !mips && !mipsle && !wasm && !sw64
 
 package runtime
 
diff --git a/src/runtime/defs_linux_amd64.h b/src/runtime/defs_linux_amd64.h
new file mode 100644
index 00000000..e69de29b
diff --git a/src/runtime/defs_linux_sw64.go b/src/runtime/defs_linux_sw64.go
new file mode 100644
index 00000000..e79a7291
--- /dev/null
+++ b/src/runtime/defs_linux_sw64.go
@@ -0,0 +1,225 @@
+//go:build linux && sw64
+
+package runtime
+
+import "unsafe"
+
+const (
+	_EINTR  = 0x4
+	_EAGAIN = 0x23
+	_ENOMEM = 0xc
+	_ENOSYS = 0x59
+
+	_PROT_NONE  = 0x0
+	_PROT_READ  = 0x1
+	_PROT_WRITE = 0x2
+	_PROT_EXEC  = 0x4
+
+	_MAP_ANON    = 0x10
+	_MAP_PRIVATE = 0x2
+	_MAP_FIXED   = 0x100
+
+	_MADV_DONTNEED   = 0x6
+	_MADV_FREE       = 0x8
+	_MADV_HUGEPAGE   = 0xe
+	_MADV_NOHUGEPAGE = 0xf
+	//TODO: support since linux 6.1
+	_MADV_COLLAPSE   = 0x19
+
+	_SA_ONSTACK = 0x1
+	_SA_RESTART = 0x2
+	_SA_SIGINFO = 0x40
+
+	_SI_KERNEL = 0x80
+        _SI_TIMER  = -0x2
+
+	_SIGHUP    = 0x1
+	_SIGINT    = 0x2
+	_SIGQUIT   = 0x3
+	_SIGILL    = 0x4
+	_SIGTRAP   = 0x5
+	_SIGABRT   = 0x6
+	_SIGEMT    = 0x7
+	_SIGFPE    = 0x8
+	_SIGKILL   = 0x9
+	_SIGBUS    = 0xa
+	_SIGSEGV   = 0xb
+	_SIGSYS    = 0xc
+	_SIGPIPE   = 0xd
+	_SIGALRM   = 0xe
+	_SIGTERM   = 0xf
+	_SIGURG    = 0x10
+	_SIGSTOP   = 0x11
+	_SIGTSTP   = 0x12
+	_SIGCONT   = 0x13
+	_SIGCHLD   = 0x14
+	_SIGTTIN   = 0x15
+	_SIGTTOU   = 0x16
+	_SIGIO     = 0x17
+	_SIGXCPU   = 0x18
+	_SIGXFSZ   = 0x19
+	_SIGVTALRM = 0x1a
+	_SIGPROF   = 0x1b
+	_SIGWINCH  = 0x1c
+	_SIGINFO   = 0x1d
+	_SIGUSR1   = 0x1e
+	_SIGUSR2   = 0x1f
+
+	_SIGRTMIN = 0x20
+
+	_FPE_INTDIV = 0x1
+	_FPE_INTOVF = 0x2
+	_FPE_FLTDIV = 0x3
+	_FPE_FLTOVF = 0x4
+	_FPE_FLTUND = 0x5
+	_FPE_FLTRES = 0x6
+	_FPE_FLTINV = 0x7
+	_FPE_FLTSUB = 0x8
+
+	_BUS_ADRALN = 0x1
+	_BUS_ADRERR = 0x2
+	_BUS_OBJERR = 0x3
+
+	_SEGV_MAPERR = 0x1
+	_SEGV_ACCERR = 0x2
+
+	_ITIMER_REAL    = 0x0
+	_ITIMER_VIRTUAL = 0x1
+	_ITIMER_PROF    = 0x2
+
+	_CLOCK_THREAD_CPUTIME_ID = 0x3
+
+	_SIGEV_THREAD_ID = 0x4
+)
+
+type usigset struct {
+	__val [16]uint64
+}
+
+type timespec struct {
+	tv_sec  int64
+	tv_nsec int64
+}
+
+//go:nosplit
+func (ts *timespec) setNsec(ns int64) {
+	ts.tv_sec = ns / 1e9
+	ts.tv_nsec = ns % 1e9
+}
+
+/*
+func (ts *timespec) set_sec(x int64) {
+	ts.tv_sec = x
+}
+
+func (ts *timespec) set_nsec(x int32) {
+	ts.tv_nsec = int64(x)
+}
+*/
+type timeval struct {
+	tv_sec  int64
+	tv_usec int64
+}
+
+func (tv *timeval) set_usec(x int32) {
+	tv.tv_usec = int64(x)
+}
+
+type sigactiont struct {
+	sa_handler uintptr
+	sa_flags   int32
+	sa_mask    [1]uint64
+
+	sa_restorer uintptr //noused
+}
+
+type siginfoFields struct {
+	si_signo   int32
+	si_errno   int32
+	si_code    int32
+	_pad_cgo_0 [4]byte
+
+	si_addr     uint64
+//	_X_sifields [128 - 8*3]byte
+}
+
+type siginfo struct {
+	siginfoFields
+
+	// Pad struct to the max size in the kernel.
+	_ [_si_max_size - unsafe.Sizeof(siginfoFields{})]byte
+}
+
+type itimerspec struct {
+	it_interval timespec
+	it_value    timespec
+}
+
+type itimerval struct {
+	it_interval timeval
+	it_value    timeval
+}
+
+type sigeventFields struct {
+        value  uintptr
+        signo  int32
+        notify int32
+        // below here is a union; sigev_notify_thread_id is the only field we use
+        sigev_notify_thread_id int32
+}
+
+type sigevent struct {
+        sigeventFields
+
+        // Pad struct to the max size in the kernel.
+        _ [_sigev_max_size - unsafe.Sizeof(sigeventFields{})]byte
+}
+
+const (
+	_O_RDONLY    = 0x0
+	_O_WRONLY    = 0x1
+	_O_CREAT     = 0x200
+	_O_TRUNC     = 0x400
+	_O_NONBLOCK  = 0x4
+	_O_CLOEXEC   = 0x200000
+	_SA_RESTORER = 0 //don't set this
+)
+
+type stackt struct {
+	ss_sp      *byte
+	ss_flags   int32
+	_pad_cgo_0 [4]byte
+	ss_size    uintptr
+}
+
+type sigcontext struct {
+	sc_onstack uint64
+	sc_mask    uint64
+	sc_pc      uint64
+	sc_ps      uint64
+	sc_regs    [32]uint64
+	sc_ownedfp int64
+	sc_fpregs  [128]int64 // if not defined CONFIG_SW_SMID
+
+	sc_fpcr            uint64
+	sc_fp_control      uint64
+	sc_reserved1       uint64
+	sc_reserved2       uint64
+	sc_ssize           uint64
+	sc_sbase           *int8
+	sc_traparg_a0      uint64
+	sc_traparg_a1      uint64
+	sc_traparg_a2      uint64
+	sc_fp_trap_pc      uint64
+	sc_fp_trigger_sum  uint64
+	sc_fp_trigger_inst uint64
+}
+
+type ucontext struct {
+	uc_flags         uint64
+	uc_link          *ucontext
+	__uc_osf_sigmask uint64
+	uc_stack         stackt
+	uc_mcontext      sigcontext
+	uc_sigmask       usigset
+}
diff --git a/src/runtime/duff_sw64.s b/src/runtime/duff_sw64.s
new file mode 100644
index 00000000..16a4fbf7
--- /dev/null
+++ b/src/runtime/duff_sw64.s
@@ -0,0 +1,909 @@
+// Code generated by mkduff.go; DO NOT EDIT.
+// Run go generate from src/runtime to update.
+// See mkduff.go for comments.
+
+//go:build sw64
+
+#include "textflag.h"
+
+TEXT runtime·duffzero(SB), NOSPLIT|NOFRAME, $0-0
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	STL	R31, 8(R1)
+	ADDL	R1, $8, R1
+	RET
+
+TEXT runtime·duffcopy(SB), NOSPLIT|NOFRAME, $0-0
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	LDL	R28, (R1)
+	ADDL	R1, $8, R1
+	STL	R28, (R2)
+	ADDL	R2, $8, R2
+
+	RET
diff --git a/src/runtime/gcinfo_test.go b/src/runtime/gcinfo_test.go
index 5f72caf0..5d8dcca2 100644
--- a/src/runtime/gcinfo_test.go
+++ b/src/runtime/gcinfo_test.go
@@ -164,7 +164,7 @@ func infoBigStruct() []byte {
 			typeScalar, typeScalar, typeScalar, typeScalar, // t int; y uint16; u uint64
 			typePointer, typeScalar, // i string
 		}
-	case "arm64", "amd64", "loong64", "mips64", "mips64le", "ppc64", "ppc64le", "riscv64", "s390x", "wasm":
+	case "arm64", "amd64", "loong64", "mips64", "mips64le", "ppc64", "ppc64le", "riscv64", "s390x", "wasm", "sw64":
 		return []byte{
 			typePointer,                        // q *int
 			typeScalar, typeScalar, typeScalar, // w byte; e [17]byte
diff --git a/src/runtime/hash64.go b/src/runtime/hash64.go
index 2864a4b9..71a085b9 100644
--- a/src/runtime/hash64.go
+++ b/src/runtime/hash64.go
@@ -5,7 +5,7 @@
 // Hashing algorithm inspired by
 // wyhash: https://github.com/wangyi-fudan/wyhash
 
-//go:build amd64 || arm64 || loong64 || mips64 || mips64le || ppc64 || ppc64le || riscv64 || s390x || wasm
+//go:build amd64 || arm64 || loong64 || mips64 || mips64le || ppc64 || ppc64le || riscv64 || s390x || wasm || sw64
 
 package runtime
 
diff --git a/src/runtime/internal/atomic/atomic_sw64.go b/src/runtime/internal/atomic/atomic_sw64.go
new file mode 100644
index 00000000..86748b47
--- /dev/null
+++ b/src/runtime/internal/atomic/atomic_sw64.go
@@ -0,0 +1,102 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+// +build sw64
+
+package atomic
+
+import "unsafe"
+
+//go:noescape
+func Xadd(ptr *uint32, delta int32) uint32
+
+//go:noescape
+func Xadd64(ptr *uint64, delta int64) uint64
+
+//go:noescape
+func Xadduintptr(ptr *uintptr, delta uintptr) uintptr
+
+//go:noescape
+func Xchg(ptr *uint32, new uint32) uint32
+
+//go:noescape
+func Xchg64(ptr *uint64, new uint64) uint64
+
+//go:noescape
+func Xchguintptr(ptr *uintptr, new uintptr) uintptr
+
+//go:noescape
+func Load(ptr *uint32) uint32
+
+//go:noescape
+func Load64(ptr *uint64) uint64
+
+// NO go:noescape annotation; *ptr escapes if result escapes (#31525)
+func Loadp(ptr unsafe.Pointer) unsafe.Pointer
+
+//go:noescape
+func And8(ptr *uint8, val uint8)
+
+//go:noescape
+func Or8(ptr *uint8, val uint8)
+
+// NOTE: Do not add atomicxor8 (XOR is not idempotent).
+
+//go:noescape
+func Cas64(ptr *uint64, old, new uint64) bool
+
+//go:noescape
+func Store(ptr *uint32, val uint32)
+
+//go:noescape
+func Store64(ptr *uint64, val uint64)
+
+// NO go:noescape annotation; see atomic_pointer.go.
+func StorepNoWB(ptr unsafe.Pointer, val unsafe.Pointer)
+
+//go:noescape
+func Load8(ptr *uint8) uint8
+
+//go:noescape
+func LoadAcq(ptr *uint32) uint32
+
+//go:noescape
+func LoadAcquintptr(ptr *uintptr) uintptr
+
+//go:noescape
+func CasRel(ptr *uint32, old, new uint32) bool
+
+//go:noescape
+func Store8(ptr *uint8, val uint8)
+
+//go:noescape
+func StoreRel(ptr *uint32, val uint32)
+
+//go:noescape
+func StoreReluintptr(ptr *uintptr, val uintptr)
+
+//go:noescape
+func Or(ptr *uint32, val uint32)
+
+//go:noescape
+func And(ptr *uint32, val uint32)
+
+//go:noescape
+func And32(ptr *uint32, val uint32) uint32
+
+//go:noescape
+func Or32(ptr *uint32, val uint32) uint32
+
+//go:noescape
+func And64(ptr *uint64, val uint64) uint64
+
+//go:noescape
+func Or64(ptr *uint64, val uint64) uint64
+
+//go:noescape
+func Anduintptr(ptr *uintptr, val uintptr) uintptr
+
+//go:noescape
+func Oruintptr(ptr *uintptr, val uintptr) uintptr
diff --git a/src/runtime/internal/atomic/atomic_sw64.s b/src/runtime/internal/atomic/atomic_sw64.s
new file mode 100644
index 00000000..ee2b81ba
--- /dev/null
+++ b/src/runtime/internal/atomic/atomic_sw64.s
@@ -0,0 +1,393 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+
+#include "textflag.h"
+
+// bool Cas(uint32 *ptr, uint32 old, uint32 new)
+// Atomically:
+//	if(*val == old){
+//		*val = new;
+//		return 1;
+//	} else
+//		return 0;
+TEXT ·Cas(SB), NOSPLIT|NOFRAME, $0-17
+	LDL	R3, ptr+0(FP)
+	LDW	R4, old+8(FP)
+	LDW	R5, new+12(FP)
+	
+	MEMB
+	LLDW	R6, 0(R3)
+	CMPEQ	R6, R4, R6
+	WR_F	R6
+	BIS	R5, R31, R7
+	LSTW	R7, 0(R3)
+	RD_F	R7
+	BEQ	R6, 2(PC)
+	BEQ	R7, -7(PC)
+	STB	R7, ret+16(FP)
+	RET
+
+// bool Cas64(uint64 *ptr, uint64 old, uint64 new)
+// Atomically:
+//	if(*val == *old){
+//		*val = new;
+//		return 1;
+//	} else {
+//		return 0;
+//	}
+TEXT ·Cas64(SB), NOFRAME|NOSPLIT, $0-25
+	LDL	R3, ptr+0(FP)
+	LDL	R4, old+8(FP)
+	LDL	R5, new+16(FP)
+	
+	MEMB
+	LLDL	R6, 0(R3)
+	CMPEQ	R6, R4, R6
+	WR_F	R6
+	BIS	R5, R31, R7
+	LSTL	R7, 0(R3)
+	RD_F	R7
+	BEQ	R6, 2(PC)
+	BEQ	R7, -7(PC)
+	STB	R7, ret+24(FP)
+	RET
+
+TEXT ·Casuintptr(SB), NOFRAME|NOSPLIT, $0-25
+	JMP	·Cas64(SB)
+
+TEXT ·Loaduintptr(SB),  NOFRAME|NOSPLIT, $0-16
+	JMP	·Load64(SB)
+
+TEXT ·Loaduint(SB), NOFRAME|NOSPLIT, $0-16
+	JMP	·Load64(SB)
+
+TEXT ·Storeuintptr(SB), NOFRAME|NOSPLIT, $0-16
+	JMP	·Store64(SB)
+
+TEXT ·Xadduintptr(SB), NOFRAME|NOSPLIT, $0-24
+	JMP	·Xadd64(SB)
+
+TEXT ·Loadint64(SB), NOFRAME|NOSPLIT, $0-16
+	JMP	·Load64(SB)
+
+TEXT ·Xaddint64(SB), NOFRAME|NOSPLIT, $0-24
+	JMP	·Xadd64(SB)
+
+// bool casp(void **val, void *old, void *new)
+// Atomically:
+//	if(*val == old){
+//		*val = new;
+//		return 1;
+//	} else
+//		return 0;
+TEXT ·Casp1(SB), NOFRAME|NOSPLIT, $0-25
+	JMP	·Cas64(SB)
+
+// uint32 xadd(uint32 volatile *ptr, int32 delta)
+// Atomically:
+//	*val += delta;
+//	return *val;
+TEXT ·Xadd(SB), NOFRAME|NOSPLIT, $0-20
+	LDL	R4, ptr+0(FP)
+	LDW	R5, delta+8(FP)
+	
+	MEMB
+	LLDW	R6, 0(R4)
+	LDI	R7, 1
+	WR_F	R7
+	ADDW	R6, R5, R7
+	LSTW	R7, 0(R4)
+	RD_F	R7
+	BEQ	R7, -6(PC)
+	
+	ADDW	R6, R5, R7
+	STW	R7, ret+16(FP)
+	RET
+
+TEXT ·Xadd64(SB), NOFRAME|NOSPLIT, $0-24
+	LDL	R4, ptr+0(FP)
+	LDL	R5, delta+8(FP)
+	
+	MEMB
+	LLDL	R6, 0(R4)
+	LDI	R7, 1
+	WR_F	R7
+	ADDL	R6, R5, R7
+	LSTL	R7, 0(R4)
+	RD_F	R7
+	BEQ	R7, -6(PC)
+	
+	ADDL	R6, R5, R7
+	STL	R7, ret+16(FP)
+	RET
+
+TEXT ·Xchg(SB), NOFRAME|NOSPLIT, $0-20
+	LDL	R4, ptr+0(FP)
+	LDW	R5, new+8(FP)
+	
+	MEMB
+	LLDW	R6, 0(R4)
+	LDI	R7, 1
+	WR_F	R7
+	BIS	R5, R31, R7
+	LSTW	R7, 0(R4)
+	RD_F	R7
+	BEQ	R7, -6(PC)
+	
+	STW	R6, ret+16(FP)
+	RET
+
+TEXT ·Xchg64(SB), NOFRAME|NOSPLIT, $0-24
+	LDL	R4, ptr+0(FP)
+	LDL	R5, new+8(FP)
+	
+	MEMB
+	LLDL	R6, 0(R4)
+	LDI	R7, 1
+	WR_F	R7
+	BIS	R5, R31, R7
+	LSTL	R7, 0(R4)
+	RD_F	R7
+	BEQ	R7, -6(PC)
+	
+	STL	R6, ret+16(FP)
+	RET
+
+TEXT ·Xchguintptr(SB), NOFRAME|NOSPLIT, $0-24
+	JMP	·Xchg64(SB)
+
+
+TEXT ·StorepNoWB(SB), NOFRAME|NOSPLIT, $0-16
+	LDL	R3, ptr+0(FP)
+	LDL	R4, val+8(FP)
+	MEMB
+	STL	R4, 0(R3)
+	MEMB
+	RET
+
+TEXT ·Store(SB), NOFRAME|NOSPLIT, $0-12
+	LDL	R3, ptr+0(FP)
+	LDW	R4, val+8(FP)
+	MEMB
+	STW	R4, 0(R3)
+	MEMB
+	RET
+
+TEXT ·Store64(SB), NOFRAME|NOSPLIT, $0-16
+	LDL	R3, ptr+0(FP)
+	LDL	R4, val+8(FP)
+	MEMB
+	STL	R4, 0(R3)
+	MEMB
+	RET
+
+// void ·And8(byte volatile*, byte);
+TEXT ·And8(SB), NOFRAME|NOSPLIT, $0-9
+	LDL	R1, ptr+0(FP)
+	LDBU	R2, val+8(FP)
+	LDI	R3, $-4
+	AND	R3, R1, R3
+	AND	R1, $3, R4
+	SLL	R4, $3, R4
+	LDI	R5, 0xFF
+	SLL	R2, R4, R2
+	SLL	R5, R4, R5
+	ORNOT	R31, R5, R5
+	BIS	R2, R5, R2
+	
+	MEMB
+	LLDW	R4, (R3)
+	LDI	R1, 1
+	WR_F	R1
+	AND	R4, R2, R1
+	LSTW	R1, (R3)
+	RD_F	R1
+	BEQ	R1, -6(PC)
+	RET
+
+// void ·Or8(byte volatile*, byte);
+TEXT ·Or8(SB), NOFRAME|NOSPLIT, $0-9
+	LDL	R1, ptr+0(FP)
+	LDBU	R2, val+8(FP)
+	LDI	R3, $-4
+	AND	R3, R1, R3
+	AND	R1, $3, R4
+	SLL	R4, $3, R4
+	SLL	R2, R4, R2
+	
+	MEMB
+	LLDW	R4, (R3)
+	LDI	R1, 1
+	WR_F	R1
+	BIS	R4, R2, R1
+	LSTW	R1, (R3)
+	RD_F	R1
+	BEQ	R1, -6(PC)
+	RET
+
+// void func And(addr *uint32, v uint32)
+TEXT ·And(SB), NOFRAME|NOSPLIT, $0-12
+	LDL	R1, ptr+0(FP)
+	LDW	R2, val+8(FP)
+
+	MEMB
+	LLDW	R4, (R1)
+	LDI	R3, 1
+	WR_F	R3
+	AND	R4, R2, R4
+	LSTW	R4, (R1)
+	RD_F	R4
+	BEQ	R4, -6(PC)
+	RET
+
+// func Or(addr *uint32, v uint32)
+TEXT ·Or(SB), NOFRAME|NOSPLIT, $0-12
+	LDL	R1, ptr+0(FP)
+	LDW	R2, val+8(FP)
+  
+	MEMB
+	LLDW	R4, (R1)
+	LDI	R3, 1
+	WR_F	R3
+	BIS	R4, R2, R4
+	LSTW	R4, (R1)
+	RD_F	R4
+	BEQ	R4, -6(PC)
+	RET
+
+// func Or32(addr *uint32, v uint32) old uint32
+TEXT ·Or32(SB), NOFRAME|NOSPLIT, $0-20
+	LDL	R1, ptr+0(FP)
+	LDW	R2, val+8(FP)
+  
+	MEMB
+	LLDW	R4, (R1)
+	LDI	R3, 1
+	WR_F	R3
+	BIS	R4, R2, R5
+	LSTW	R5, (R1)
+	RD_F	R5
+	BEQ	R5, -6(PC)
+	STW	R4, ret+16(FP)
+	RET
+
+// func And32(addr *uint32, v uint32) old uint32
+TEXT ·And32(SB), NOFRAME|NOSPLIT, $0-20
+	LDL	R1, ptr+0(FP)
+	LDW	R2, val+8(FP)
+
+	MEMB
+	LLDW	R4, (R1)
+	LDI	R3, 1
+	WR_F	R3
+	AND	R4, R2, R5
+	LSTW	R5, (R1)
+	RD_F	R5
+	BEQ	R5, -6(PC)
+	STW     R4, ret+16(FP)
+	RET
+
+// func Or64(addr *uint64, v uint64) old uint64
+TEXT ·Or64(SB), NOFRAME|NOSPLIT, $0-24
+	LDL	R1, ptr+0(FP)
+	LDL	R2, val+8(FP)
+  
+	MEMB
+	LLDL	R4, (R1)
+	LDI	R3, 1
+	WR_F	R3
+	BIS	R4, R2, R5
+	LSTL	R5, (R1)
+	RD_F	R5
+	BEQ	R5, -6(PC)
+	STL	R4, ret+16(FP)
+	RET
+
+// func And64(addr *uint64, v uint64) old uint64
+TEXT ·And64(SB), NOFRAME|NOSPLIT, $0-24
+	LDL	R1, ptr+0(FP)
+	LDL	R2, val+8(FP)
+
+	MEMB
+	LLDL	R4, (R1)
+	LDI	R3, 1
+	WR_F	R3
+	AND	R4, R2, R5
+	LSTL	R5, (R1)
+	RD_F	R5
+	BEQ	R5, -6(PC)
+	STL     R4, ret+16(FP)
+	RET
+
+// func Anduintptr(addr *uintptr, v uintptr) old uintptr
+TEXT ·Anduintptr(SB), NOSPLIT, $0-24
+        JMP     ·And64(SB)
+
+// func Oruintptr(addr *uintptr, v uintptr) old uintptr
+TEXT ·Oruintptr(SB), NOSPLIT, $0-24
+        JMP     ·Or64(SB)
+
+TEXT ·Store8(SB), NOFRAME|NOSPLIT, $0-9
+	LDL	R3, ptr+0(FP)
+	LDBU	R4, val+8(FP)
+	MEMB
+	STB	R4, 0(R3)
+	MEMB
+	RET
+
+// uint32 ·Load(uint32 volatile* ptr)
+TEXT ·Load(SB), NOFRAME|NOSPLIT, $0-12
+	LDL	R3, ptr+0(FP)
+	MEMB
+	LDW	R3, 0(R3)
+	MEMB
+	STW	R3, ret+8(FP)
+	RET
+
+// uint64 ·Load64(uint64 volatile* ptr)
+TEXT ·Load64(SB), NOFRAME|NOSPLIT, $0-16
+	LDL	R3, ptr+0(FP)
+	MEMB
+	LDL	R3, 0(R3)
+	MEMB
+	STL	R3, ret+8(FP)
+	RET
+
+// void *·Loadp(void *volatile *ptr)
+TEXT ·Loadp(SB), NOFRAME|NOSPLIT, $0-16
+	LDL	R3, ptr+0(FP)
+	MEMB
+	LDL	R3, 0(R3)
+	MEMB
+	STL	R3, ret+8(FP)
+	RET
+
+// uint8 ·Load8(uint8 volatile* ptr)
+TEXT ·Load8(SB), NOFRAME|NOSPLIT, $0-9
+	LDL	R3, ptr+0(FP)
+	MEMB
+	LDBU	R3, 0(R3)
+ 	MEMB
+	STB	R3, ret+8(FP)
+	RET
+
+// uint32 ·LoadAcq(uint32 volatile* ptr)
+TEXT ·LoadAcq(SB),NOSPLIT|NOFRAME,$0-12
+	JMP	·Load(SB)
+
+// uint64 ·LoadAcquintptr(uintptr volatile* ptr)
+TEXT ·LoadAcquintptr(SB),NOSPLIT|NOFRAME,$0-16
+	JMP	·Load64(SB)
+
+
+TEXT ·StoreRel(SB), NOSPLIT|NOFRAME, $0-12
+	JMP	·Store(SB)
+
+TEXT ·CasRel(SB), NOSPLIT|NOFRAME, $0-17
+	JMP	·Cas(SB)
+
+TEXT ·StoreReluintptr(SB), NOSPLIT|NOFRAME, $0-16
+        JMP     ·Store64(SB)
diff --git a/src/runtime/internal/sys/zversion.go b/src/runtime/internal/sys/zversion.go
new file mode 100644
index 00000000..184c2639
--- /dev/null
+++ b/src/runtime/internal/sys/zversion.go
@@ -0,0 +1,3 @@
+// Code generated by go tool dist; DO NOT EDIT.
+
+package sys
diff --git a/src/runtime/internal/syscall/asm_linux_sw64.s b/src/runtime/internal/syscall/asm_linux_sw64.s
new file mode 100644
index 00000000..3da79bc2
--- /dev/null
+++ b/src/runtime/internal/syscall/asm_linux_sw64.s
@@ -0,0 +1,32 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build linux && sw64
+
+#include "textflag.h"
+#define SYSCALL SYS_CALL_B $131
+
+// func Syscall6(num, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, errno uintptr)
+TEXT ·Syscall6(SB), NOSPLIT, $0-80
+	LDL     R0, num+0(FP)
+	LDL	R16, a1+8(FP)
+	LDL	R17, a2+16(FP)
+	LDL	R18, a3+24(FP)
+	LDL	R19, a4+32(FP)
+	LDL	R20, a5+40(FP)
+	LDL	R21, a6+48(FP)
+	SYSCALL
+	BEQ	R19, ok
+
+	LDI	R1, $-1
+	STL	R1, r1+56(FP)
+	STL	ZERO, r2+64(FP)
+	STL	R0, errno+72(FP)
+	RET
+ok:
+	STL	R0, r1+56(FP)
+	STL	R20, r2+64(FP)
+	STL	ZERO, errno+72(FP)
+	RET
+
diff --git a/src/runtime/internal/syscall/defs_linux_sw64.go b/src/runtime/internal/syscall/defs_linux_sw64.go
new file mode 100644
index 00000000..b795c7b0
--- /dev/null
+++ b/src/runtime/internal/syscall/defs_linux_sw64.go
@@ -0,0 +1,33 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build linux && sw64
+
+package syscall
+
+const (
+	SYS_FCNTL         = 92
+	SYS_EPOLL_CTL     = 408
+	SYS_EPOLL_PWAIT   = 474
+	SYS_EPOLL_CREATE1 = 486
+	SYS_EPOLL_PWAIT2  = 541 /* sw64 has not support this 
+so this is just a temp number*/
+
+	EPOLLIN       = 0x1
+	EPOLLOUT      = 0x4
+	EPOLLERR      = 0x8
+	EPOLLHUP      = 0x10
+	EPOLLRDHUP    = 0x2000
+	EPOLLET       = 0x80000000
+	EPOLL_CLOEXEC = 0x200000
+	EPOLL_CTL_ADD = 0x1
+	EPOLL_CTL_DEL = 0x2
+	EPOLL_CTL_MOD = 0x3
+)
+
+type EpollEvent struct {
+	Events    uint32
+	pad_cgo_0 [4]byte
+	Data      uint64
+}
diff --git a/src/runtime/malloc.go b/src/runtime/malloc.go
index e2cb2e45..6d379b8b 100644
--- a/src/runtime/malloc.go
+++ b/src/runtime/malloc.go
@@ -520,6 +520,8 @@ func mallocinit() {
 				p = uintptr(i)<<40 | uintptrMask&(0x0013<<28)
 			case GOARCH == "arm64":
 				p = uintptr(i)<<40 | uintptrMask&(0x0040<<32)
+			case GOARCH == "sw64":
+				p = uintptr(i)<<34 | uintptrMask&(0xc0<<28)
 			case GOOS == "aix":
 				if i == 0 {
 					// We don't use addresses directly after 0x0A00000000000000
diff --git a/src/runtime/memclr_sw64.s b/src/runtime/memclr_sw64.s
new file mode 100644
index 00000000..91b8878d
--- /dev/null
+++ b/src/runtime/memclr_sw64.s
@@ -0,0 +1,49 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+// +build sw64
+
+#include "textflag.h"
+
+// func memclrNoHeapPointers(ptr unsafe.Pointer, n uintptr)
+TEXT runtime·memclrNoHeapPointers<ABIInternal>(SB),NOSPLIT,$0-16
+#ifndef GOEXPERIMENT_regabiargs	
+	LDL	R16, ptr+0(FP)
+	LDL	R17, n+8(FP)
+#endif
+	ADDL	R16, R17, R4
+
+	// if less than 8 bytes, do one byte at a time
+	CMPULT	R17, $8, R3
+	BNE	R3, out
+
+	// do one byte at a time until 8-aligned
+	AND	R16, $7, R3
+	BEQ	R3, words
+
+	STB	R31, (R16)
+	ADDL    R16, $1, R16
+	JMP	-4(PC)
+
+words:
+	// do 8 bytes at a time if there is room
+	ADDL	R4, $-7, R17
+
+	CMPULE	R17, R16, R3
+	BNE	R3, out
+
+	STL	R31, (R16)
+	ADDL	R16, $8, R16
+	JMP	-4(PC)
+
+out:
+	CMPEQ	R16, R4, R3
+	BNE	R3, done
+
+	STB	R31, (R16)
+	ADDL	R16, $1, R16
+	JMP	-4(PC)
+done:
+	RET
diff --git a/src/runtime/memmove_sw64.s b/src/runtime/memmove_sw64.s
new file mode 100644
index 00000000..3ed30490
--- /dev/null
+++ b/src/runtime/memmove_sw64.s
@@ -0,0 +1,114 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+// +build sw64
+
+#include "textflag.h"
+
+// func memmove(to, from unsafe.Pointer, n uintptr)
+TEXT runtime·memmove<ABIInternal>(SB), NOFRAME|NOSPLIT, $0-24
+#ifndef GOEXPERIMENT_regabiargs	
+	LDL	R16, to+0(FP)
+	LDL	R17, from+8(FP)
+	LDL	R18, n+16(FP)
+#endif
+	BNE	R18, check
+	RET
+
+check:
+	CMPULE	R16,R17,R4
+	BEQ	R4,backward
+
+	ADDL	R16,R18,R6 // end pointer
+
+	// if the two pointers are not of same alignments, do byte copying
+	SUBL	R16,R17,R4
+	AND	R4,$7,R4
+	BNE	R4, out
+
+	// if less than 8 bytes, do byte copying
+	CMPULT	R18,$8,R4
+	BNE	R4,out
+	// do one byte at a time until 8-aligned
+	AND	R16,$7,R5
+	BEQ	R5,words
+	LDBU	R3, (R17)
+	ADDL	R17, $1, R17
+
+	STB	R3, (R16)
+	ADDL	R16,$1,R16
+	JMP	-6(PC)
+
+words:
+	// do 8 bytes at a time if there is room
+	SUBL	R6,$7,R7
+	CMPULE	R7,R16,R8
+	BNE	R8,out
+	LDL	R3,(R17)
+	ADDL	R17,$8,R17
+
+	STL	R3,(R16)
+	ADDL	R16,$8,R16
+	JMP	-6(PC)
+
+out:
+	CMPEQ	R16,R6,R8
+	BNE	R8,done
+	LDBU	R3, (R17)
+	ADDL	R17, $1, R17
+
+	STB	R3, (R16)
+	ADDL	R16,$1,R16
+	JMP	-6(PC)
+
+done:
+	RET
+
+backward:
+	ADDL	R17,R18,R4 // from-end pointer
+	ADDL	R16,R18,R5  // to-end pointer
+
+	// if the two pointers are not of same alignments, do byte copying
+	SUBL	R4,R5,R7
+	AND	R7,$7,R7
+	BNE	R7,out1
+
+	// if less than 8 bytes, do byte copying
+	CMPULT	R18,$8,R7
+	BNE	R7,out1
+
+	// do one byte at a time until 8-aligned
+	AND	R5,$7,R6
+	BEQ	R6,words1
+	SUBL	R4,$1,R4
+	LDBU	R3, (R4)
+	SUBL	R5,$1,R5
+	STB	R3,(R5)
+	JMP	-6(PC)
+
+words1:
+	// do 8 bytes at a time if there is room
+	ADDL	R16,$7,R3
+
+	CMPULE	R5,R3,R7
+	BNE	R7,out1
+	SUBL	R4,$8,R4
+	LDL	R7,(R4)
+	SUBL	R5,$8,R5
+	STL	R7,(R5)
+	JMP	-6(PC)
+
+
+out1:
+	CMPEQ	R16,R5,R7
+	BNE	R7,done1
+	SUBL	R4,$1,R4
+	LDBU	R3, (R4)
+	SUBL	R5,$1,R5
+	STB	R3,(R5)
+	JMP	-6(PC)
+
+done1:
+	RET
diff --git a/src/runtime/memmove_sw64_test.s b/src/runtime/memmove_sw64_test.s
new file mode 100644
index 00000000..dd1d2ff9
--- /dev/null
+++ b/src/runtime/memmove_sw64_test.s
@@ -0,0 +1,221 @@
+// Copyright 2014 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build ignore
+// +build ignore
+
+#include "textflag.h"
+
+// See memmove Go doc for important implementation constraints.
+
+// Register map
+//
+// dstin  R0
+// src    R1
+// count  R2
+// dst    R3 (same as R0, but gets modified in unaligned cases)
+// srcend R4
+// dstend R5
+// data   R6-R17
+// tmp1   R14
+
+// Copies are split into 3 main cases: small copies of up to 32 bytes, medium
+// copies of up to 128 bytes, and large copies. The overhead of the overlap
+// check is negligible since it is only required for large copies.
+//
+// Large copies use a software pipelined loop processing 64 bytes per iteration.
+// The destination pointer is 16-byte aligned to minimize unaligned accesses.
+// The loop tail is handled by always copying 64 bytes from the end.
+
+// func memmove(to, from unsafe.Pointer, n uintptr)
+TEXT runtime·memmove(SB), NOSPLIT|NOFRAME, $0-24
+	LDL	R0, to+0(FP)
+	LDL	R1, from+8(FP)
+	LDL	R2, n+16(FP)
+	BEQ	R2, copy0
+
+	// Small copies: 1..16 bytes
+	CMPLE	R2, $16, R28
+	BNE R28,	copy16
+
+	// Large copies
+	CMPLE	R2, $128, R28
+	BEQ R28, copy_long
+	CMPLE	R2, $32, R28
+	BEQ	R28, copy32_128
+
+	// Small copies: 17..32 bytes.
+	LDL R6, 0(R1)
+	LDL R7, 8(R1)
+	ADDL R1, R2, R4
+	LDL R12, -8(R4)
+	LDL R13, -16(R4)
+
+	STL R6, (R0)
+	STL R7, 8(R0)
+	ADDL R0, R2, R5
+	STL R12, -8(R5)
+	STL R13, -16(R5)
+	RET
+
+// Small copies: 1..16 bytes.
+copy16:
+	ADDL	R1, R2, R4 // R4 points just past the last source byte
+	ADDL	R0, R2, R5 // R5 points just past the last destination byte
+	CMPLT	R2, $8, R28
+	BNE R28,	copy7
+	LDL	R6, (R1)
+	LDL	R7, -8(R4)
+	STL	R6, (R0)
+	STL	R7, -8(R5)
+	RET
+
+copy7:
+	CMPLT	R2, $4, R28
+	BNE R28, copy3
+	LDW	R6, (R1)
+	LDW	R7, -4(R4)
+	STW	R6, (R0)
+	STW	R7, -4(R5)
+	RET
+
+copy3:
+	CMPLT	R2, $2, R28
+	BNE R28, copy1
+	LDHU	R6, (R1)
+	LDHU	R7, -2(R4)
+	STH	R6, (R0)
+	STH	R7, -2(R5)
+	RET
+
+copy1:
+	LDBU	R6, (R1)
+	STB	R6, (R0)
+
+copy0:
+	RET
+
+	// Medium copies: 33..128 bytes.
+copy32_128:
+	ADDL	R1, R2, R4          // R4 points just past the last source byte
+	ADDL	R0, R2, R5          // R5 points just past the last destination byte
+	VLDD V7, (R1)
+	VLDD V8, -32(R4)
+	CMPLE R2, $64, R28
+	BEQ R28, copy128
+	VSTD V7, (R0)
+	VSTD V8, -32(R5)
+	RET
+
+	// Copy 65..128 bytes.
+copy128:
+	VLDD V3, 32(R1)
+	CMPLE R2, $96, R28
+	BNE R28, copy96
+	VLDD V1, -64(R4)
+	VSTD V1, -64(R5)
+
+copy96:
+	VSTD V7, (R0)
+	VSTD V3, 32(R0)
+	VSTD V8, -32(R5)
+	RET
+
+	// Copy more than 128 bytes.
+copy_long:
+	ADDL R1, R2, R4 // R4 points just past the last source byte
+	ADDL R0, R2, R5 // R5 points just past the last destination byte
+	LDI	R7, R31
+	LDI	R8, R31
+
+	LDI R28, $1024
+	CMPLT R2, R28, R28
+	BNE R28,backward_check
+	// feature detect to decide how to align
+	LDI	R7, R0
+	LDI R8, R5
+	BR	backward_check
+	// R7 and R8 are used here for the realignment calculation. In
+	// the use_aligned_loads case, R7 is the src pointer and R8 is
+	// srcend pointer, which is used in the backward copy case.
+	// When doing aligned stores, R7 is the dst pointer and R8 is
+	// the dstend pointer.
+
+backward_check:
+	// Use backward copy if there is an overlap.
+	SUBL	R0, R1, R14
+	BEQ	R14, copy0
+	CMPULT	R2, R14, R28
+	BEQ	R28, copy_long_backward
+
+	// Copy 16 bytes and then align src (R1) or dst (R0) to 16-byte alignment.
+	VLDD V1, (R1)    // Load A
+	AND R7, $31, R14
+	SUBL R1, R14, R1
+	SUBL R0, R14, R3
+	ADDL R2, R14, R2
+	VLDD V2, 32(R1) // Load   B
+	VSTD V1, (R0)   // Store A
+	VLDD V1, 64(R1)   // Load     C
+	ADDL R1, $64, R1
+
+	// 96 bytes have been loaded; if less than 96+64 bytes remain, copy from the end
+	SUBL R2, $160, R2
+	BLE R2, copy64_from_end
+
+loop64:
+	VSTD V2, 32(R3)   // Store B
+	VLDD V2, 32(R1)   // Load  B (next)
+	VSTD V1, 64(R3)   // Store  C
+	VLDD V1, 64(R1)   // Load   C (next)
+	ADDL R3, $64, R3
+	ADDL R1, $64, R1
+	SUBL R2, $64, R2
+	BGT R2, loop64
+
+	// Write the last iteration and copy 64 bytes from the end.
+copy64_from_end:
+	VLDD V6, -64(R4) // Load     D
+	VSTD V2, 32(R3)  // Store B
+	VLDD V5, -32(R4) // Load       F
+	VSTD V1, 64(R3) // Store   C
+	VSTD V6, -64(R5)
+	VSTD V5, -32(R5)
+	RET
+
+	// Large backward copy for overlapping copies.
+	// Copy 16 bytes and then align srcend (R4) or dstend (R5) to 16-byte alignment.
+copy_long_backward:
+	VLDD V3, -32(R4) // Load A
+	AND R8, $31, R14
+	SUBL R4, R14, R4
+	SUBL R2, R14, R2
+	VLDD V2, -32(R4) // Load   B
+	VSTD V3, -32(R5) // Store A
+	VLDD V1, -64(R4) // Load     C
+	SUBL R4, $64, R4
+	SUBL R5, R14, R5
+	SUBL R2, $128, R2
+	BLT R2, copy64_from_start
+
+loop64_backward:
+	VSTD V2, -32(R5) // Store B
+	VLDD V2, -32(R4) // Load B(next)
+	VSTD V1, -64(R5) // Store C
+	VLDD V1, -64(R4) // Load C(next)
+	SUBL R5, $64, R5
+	SUBL R4, $64, R4
+	SUBL R2, $64, R2
+	BGT R2, loop64_backward
+
+	// Write the last iteration and copy 64 bytes from the start.
+copy64_from_start:
+	VLDD V5, 32(R1) // Load    D
+	VSTD V2, -32(R5) // Store B
+	VLDD V4, (R1)   // Load      F
+	VSTD V1, -64(R5) // Store C
+	VSTD V5, 32(R0) // Store D
+	VSTD V4, (R0) // Store F
+	RET
+
diff --git a/src/runtime/mkduff.go b/src/runtime/mkduff.go
index b7f07b50..bda6bfd1 100644
--- a/src/runtime/mkduff.go
+++ b/src/runtime/mkduff.go
@@ -3,6 +3,7 @@
 // license that can be found in the LICENSE file.
 
 //go:build ignore
+// +build ignore
 
 // runtime·duffzero is a Duff's device for zeroing memory.
 // The compiler jumps to computed addresses within
@@ -40,6 +41,7 @@ func main() {
 	gen("ppc64x", tagsPPC64x, zeroPPC64x, copyPPC64x)
 	gen("mips64x", tagsMIPS64x, zeroMIPS64x, copyMIPS64x)
 	gen("riscv64", notags, zeroRISCV64, copyRISCV64)
+	gen("sw64", tagsSW64, zeroSW64, copySW64)
 }
 
 func gen(arch string, tags, zero, copy func(io.Writer)) {
@@ -284,3 +286,33 @@ func copyRISCV64(w io.Writer) {
 	}
 	fmt.Fprintln(w, "\tRET")
 }
+
+func tagsSW64(w io.Writer) {
+        fmt.Fprintln(w)
+	fmt.Fprintln(w, "//go:build sw64")
+        fmt.Fprintln(w)
+}
+
+func zeroSW64(w io.Writer) {
+        // R31: always zero
+        // R28 (REGTMP): ptr to memory to be zeroed - 8
+        // On return, R1 points to the last zeroed dword.
+        fmt.Fprintln(w, "TEXT runtime·duffzero(SB), NOSPLIT|NOFRAME, $0-0")
+        for i := 0; i < 128; i++ {
+                fmt.Fprintln(w, "\tSTL\tR31, 8(R1)")
+                fmt.Fprintln(w, "\tADDL\tR1, $8, R1")
+        }
+        fmt.Fprintln(w, "\tRET")
+}
+
+func copySW64(w io.Writer) {
+        fmt.Fprintln(w, "TEXT runtime·duffcopy(SB), NOSPLIT|NOFRAME, $0-0")
+        for i := 0; i < 128; i++ {
+                fmt.Fprintln(w, "\tLDL\tR28, (R1)")
+                fmt.Fprintln(w, "\tADDL\tR1, $8, R1")
+                fmt.Fprintln(w, "\tSTL\tR28, (R2)")
+                fmt.Fprintln(w, "\tADDL\tR2, $8, R2")
+                fmt.Fprintln(w)
+        }
+        fmt.Fprintln(w, "\tRET")
+}
diff --git a/src/runtime/mkpreempt.go b/src/runtime/mkpreempt.go
index 17544d6b..d22ae945 100644
--- a/src/runtime/mkpreempt.go
+++ b/src/runtime/mkpreempt.go
@@ -86,6 +86,7 @@ var arches = map[string]func(){
 	"ppc64x":  genPPC64,
 	"riscv64": genRISCV64,
 	"s390x":   genS390X,
+	"sw64":    genSW64,
 	"wasm":    genWasm,
 }
 var beLe = map[string]bool{"mips64x": true, "mipsx": true, "ppc64x": true}
@@ -619,6 +620,53 @@ func genS390X() {
 	p("JMP (R10)")
 }
 
+func genSW64() {
+	regsize := 8
+	r29 := "RSB"
+	// Add integer registers R0-R14, R16-R25, R27, R29(RSB)
+	// R31 (zero), R28 (REGTMP), R30 (SP), R15 (g), R26 (LR) are special,
+	// and not saved here.
+	var l = layout{sp: "SP", stack: regsize} // add slot to save PC of interrupted instruction (in LR)
+	for i := 0; i <= 27; i++ {
+		if i == 15 || i == 26 {
+			continue // R15 is g, R26 is LR, R28 is REGTMP
+		}
+		reg := fmt.Sprintf("R%d", i)
+		l.addSpecial(
+		"STL " + reg + ", %d(SP)",
+		"LDL " + reg + ", %d(SP)",
+		regsize)
+	}
+	l.addSpecial(
+	"STL " + r29 + ", %d(SP)",
+	"LDL " + r29 + ", %d(SP)",
+	regsize)
+
+	// Add floating point registers F0-F31.
+	var lfp = layout{sp: "SP", stack: l.stack}
+	for i := 0; i <= 31; i++ {
+		reg := fmt.Sprintf("F%d", i)
+		lfp.addSpecial(
+		"FSTD " + reg + ", %d(SP)",
+		"FLDD " + reg + ", %d(SP)",
+		regsize)
+	}
+	// allocate frame, save PC of interrupted instruction (in LR)
+	p("STL R26,-%d(SP)", lfp.stack)
+	p("LDI SP, -%d(SP)", lfp.stack)
+
+	l.save()
+	lfp.save()
+	p("CALL ·asyncPreempt2(SB)")
+	lfp.restore()
+	l.restore()
+
+	p("LDL R26, %d(SP)", lfp.stack)       // sigctxt.pushCall has pushed LR (at interrupt) on stack, restore it
+	p("LDL R28, 0(SP)")                   // load PC to REGTMP
+	p("LDI SP, %d(SP)", lfp.stack+regsize) // pop frame (including the space pushed by sigctxt.pushCall)
+	p("JMP (R28)")
+}
+
 func genWasm() {
 	p("// No async preemption on wasm")
 	p("UNDEF")
diff --git a/src/runtime/mpagealloc_64bit.go b/src/runtime/mpagealloc_64bit.go
index 36cd2223..504d4eaf 100644
--- a/src/runtime/mpagealloc_64bit.go
+++ b/src/runtime/mpagealloc_64bit.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build amd64 || arm64 || loong64 || mips64 || mips64le || ppc64 || ppc64le || riscv64 || s390x
+//go:build amd64 || arm64 || loong64 || mips64 || mips64le || ppc64 || ppc64le || riscv64 || s390x || sw64
 
 package runtime
 
diff --git a/src/runtime/os_linux_generic.go b/src/runtime/os_linux_generic.go
index 15fafc14..35d44f08 100644
--- a/src/runtime/os_linux_generic.go
+++ b/src/runtime/os_linux_generic.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !mips && !mipsle && !mips64 && !mips64le && !s390x && !ppc64 && linux
+//go:build !mips && !mipsle && !mips64 && !mips64le && !s390x && !ppc64 && !sw64 && linux
 
 package runtime
 
diff --git a/src/runtime/os_linux_noauxv.go b/src/runtime/os_linux_noauxv.go
index ff377277..8594e255 100644
--- a/src/runtime/os_linux_noauxv.go
+++ b/src/runtime/os_linux_noauxv.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build linux && !arm && !arm64 && !loong64 && !mips && !mipsle && !mips64 && !mips64le && !s390x && !ppc64 && !ppc64le
+//go:build linux && !arm && !arm64 && !loong64 && !mips && !mipsle && !mips64 && !mips64le && !s390x && !ppc64 && !ppc64le && !sw64
 
 package runtime
 
diff --git a/src/runtime/os_linux_novdso.go b/src/runtime/os_linux_novdso.go
index d7e1ea06..9c65ef8c 100644
--- a/src/runtime/os_linux_novdso.go
+++ b/src/runtime/os_linux_novdso.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build linux && !386 && !amd64 && !arm && !arm64 && !loong64 && !mips64 && !mips64le && !ppc64 && !ppc64le && !riscv64 && !s390x
+//go:build linux && !386 && !amd64 && !arm && !arm64 && !loong64 && !mips64 && !mips64le && !ppc64 && !ppc64le && !riscv64 && !s390x && !sw64
 
 package runtime
 
diff --git a/src/runtime/os_linux_sw64.go b/src/runtime/os_linux_sw64.go
new file mode 100644
index 00000000..866dc9e2
--- /dev/null
+++ b/src/runtime/os_linux_sw64.go
@@ -0,0 +1,56 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build linux && sw64
+
+package runtime
+
+//var randomNumber uint32
+
+func archauxv(tag, val uintptr) {
+	/*	switch tag {
+		case _AT_RANDOM:
+			// sysargs filled in startupRandomData, but that
+			// pointer may not be word aligned, so we must treat
+			// it as a byte array.
+			randomNumber = uint32(startupRandomData[4]) | uint32(startupRandomData[5])<<8 |
+				uint32(startupRandomData[6])<<16 | uint32(startupRandomData[7])<<24
+		}*/
+}
+func osArchInit() {}
+
+func cputicks() int64 {
+	// Currently cputicks() is used in blocking profiler and to seed fastrand().
+	// nanotime() is a poor approximation of CPU ticks that is enough for the profiler.
+	// randomNumber provides better seeding of fastrand.
+	//return nanotime() + int64(randomNumber)
+	return nanotime()
+}
+
+const (
+	_NSIG        = 64
+	_SIG_BLOCK   = 1
+	_SIG_UNBLOCK = 2
+	_SIG_SETMASK = 3
+
+	_SS_DISABLE = 2
+)
+
+type sigset [1]uint64
+
+var sigset_all = sigset{^uint64(0)}
+
+//go:nosplit
+//go:nowritebarrierrec
+func sigaddset(mask *sigset, i int) {
+	(*mask)[(i-1)/64] |= 1 << ((uint32(i) - 1) & 63)
+}
+
+func sigdelset(mask *sigset, i int) {
+	(*mask)[(i-1)/64] &^= 1 << ((uint32(i) - 1) & 63)
+}
+
+func sigfillset(mask *[1]uint64) {
+	(*mask)[0] = ^uint64(0)
+}
diff --git a/src/runtime/pprof/testdata/test32 b/src/runtime/pprof/testdata/test32
old mode 100644
new mode 100755
diff --git a/src/runtime/pprof/testdata/test32be b/src/runtime/pprof/testdata/test32be
old mode 100644
new mode 100755
diff --git a/src/runtime/pprof/testdata/test64 b/src/runtime/pprof/testdata/test64
old mode 100644
new mode 100755
diff --git a/src/runtime/pprof/testdata/test64be b/src/runtime/pprof/testdata/test64be
old mode 100644
new mode 100755
diff --git a/src/runtime/preempt_sw64.s b/src/runtime/preempt_sw64.s
new file mode 100644
index 00000000..a493676c
--- /dev/null
+++ b/src/runtime/preempt_sw64.s
@@ -0,0 +1,131 @@
+// Code generated by mkpreempt.go; DO NOT EDIT.
+
+#include "go_asm.h"
+#include "textflag.h"
+
+TEXT ·asyncPreempt(SB),NOSPLIT|NOFRAME,$0-0
+	STL R26,-480(SP)
+	LDI SP, -480(SP)
+	STL R0, 8(SP)
+	STL R1, 16(SP)
+	STL R2, 24(SP)
+	STL R3, 32(SP)
+	STL R4, 40(SP)
+	STL R5, 48(SP)
+	STL R6, 56(SP)
+	STL R7, 64(SP)
+	STL R8, 72(SP)
+	STL R9, 80(SP)
+	STL R10, 88(SP)
+	STL R11, 96(SP)
+	STL R12, 104(SP)
+	STL R13, 112(SP)
+	STL R14, 120(SP)
+	STL R16, 128(SP)
+	STL R17, 136(SP)
+	STL R18, 144(SP)
+	STL R19, 152(SP)
+	STL R20, 160(SP)
+	STL R21, 168(SP)
+	STL R22, 176(SP)
+	STL R23, 184(SP)
+	STL R24, 192(SP)
+	STL R25, 200(SP)
+	STL R27, 208(SP)
+	STL RSB, 216(SP)
+	FSTD F0, 224(SP)
+	FSTD F1, 232(SP)
+	FSTD F2, 240(SP)
+	FSTD F3, 248(SP)
+	FSTD F4, 256(SP)
+	FSTD F5, 264(SP)
+	FSTD F6, 272(SP)
+	FSTD F7, 280(SP)
+	FSTD F8, 288(SP)
+	FSTD F9, 296(SP)
+	FSTD F10, 304(SP)
+	FSTD F11, 312(SP)
+	FSTD F12, 320(SP)
+	FSTD F13, 328(SP)
+	FSTD F14, 336(SP)
+	FSTD F15, 344(SP)
+	FSTD F16, 352(SP)
+	FSTD F17, 360(SP)
+	FSTD F18, 368(SP)
+	FSTD F19, 376(SP)
+	FSTD F20, 384(SP)
+	FSTD F21, 392(SP)
+	FSTD F22, 400(SP)
+	FSTD F23, 408(SP)
+	FSTD F24, 416(SP)
+	FSTD F25, 424(SP)
+	FSTD F26, 432(SP)
+	FSTD F27, 440(SP)
+	FSTD F28, 448(SP)
+	FSTD F29, 456(SP)
+	FSTD F30, 464(SP)
+	FSTD F31, 472(SP)
+	CALL ·asyncPreempt2(SB)
+	FLDD F31, 472(SP)
+	FLDD F30, 464(SP)
+	FLDD F29, 456(SP)
+	FLDD F28, 448(SP)
+	FLDD F27, 440(SP)
+	FLDD F26, 432(SP)
+	FLDD F25, 424(SP)
+	FLDD F24, 416(SP)
+	FLDD F23, 408(SP)
+	FLDD F22, 400(SP)
+	FLDD F21, 392(SP)
+	FLDD F20, 384(SP)
+	FLDD F19, 376(SP)
+	FLDD F18, 368(SP)
+	FLDD F17, 360(SP)
+	FLDD F16, 352(SP)
+	FLDD F15, 344(SP)
+	FLDD F14, 336(SP)
+	FLDD F13, 328(SP)
+	FLDD F12, 320(SP)
+	FLDD F11, 312(SP)
+	FLDD F10, 304(SP)
+	FLDD F9, 296(SP)
+	FLDD F8, 288(SP)
+	FLDD F7, 280(SP)
+	FLDD F6, 272(SP)
+	FLDD F5, 264(SP)
+	FLDD F4, 256(SP)
+	FLDD F3, 248(SP)
+	FLDD F2, 240(SP)
+	FLDD F1, 232(SP)
+	FLDD F0, 224(SP)
+	LDL RSB, 216(SP)
+	LDL R27, 208(SP)
+	LDL R25, 200(SP)
+	LDL R24, 192(SP)
+	LDL R23, 184(SP)
+	LDL R22, 176(SP)
+	LDL R21, 168(SP)
+	LDL R20, 160(SP)
+	LDL R19, 152(SP)
+	LDL R18, 144(SP)
+	LDL R17, 136(SP)
+	LDL R16, 128(SP)
+	LDL R14, 120(SP)
+	LDL R13, 112(SP)
+	LDL R12, 104(SP)
+	LDL R11, 96(SP)
+	LDL R10, 88(SP)
+	LDL R9, 80(SP)
+	LDL R8, 72(SP)
+	LDL R7, 64(SP)
+	LDL R6, 56(SP)
+	LDL R5, 48(SP)
+	LDL R4, 40(SP)
+	LDL R3, 32(SP)
+	LDL R2, 24(SP)
+	LDL R1, 16(SP)
+	LDL R0, 8(SP)
+	LDL R26, 480(SP)
+	LDL R28, 0(SP)
+	LDI SP, 488(SP)
+	JMP (R28)
diff --git a/src/runtime/rand.go b/src/runtime/rand.go
index 10cd116f..dfb82c3a 100644
--- a/src/runtime/rand.go
+++ b/src/runtime/rand.go
@@ -182,7 +182,7 @@ func cheaprand() uint32 {
 	// by the compiler should be in this list.
 	if goarch.IsAmd64|goarch.IsArm64|goarch.IsPpc64|
 		goarch.IsPpc64le|goarch.IsMips64|goarch.IsMips64le|
-		goarch.IsS390x|goarch.IsRiscv64|goarch.IsLoong64 == 1 {
+		goarch.IsS390x|goarch.IsRiscv64|goarch.IsLoong64|goarch.IsSw64 == 1 {
 		mp.cheaprand += 0xa0761d6478bd642f
 		hi, lo := math.Mul64(mp.cheaprand, mp.cheaprand^0xe7037ed1a0b428db)
 		return uint32(hi ^ lo)
diff --git a/src/runtime/rt0_linux_sw64.s b/src/runtime/rt0_linux_sw64.s
new file mode 100644
index 00000000..f44ae9b0
--- /dev/null
+++ b/src/runtime/rt0_linux_sw64.s
@@ -0,0 +1,16 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build linux && sw64
+// +build linux
+// +build sw64
+
+#include "textflag.h"
+
+TEXT _rt0_sw64_linux(SB), NOFRAME|NOSPLIT, $0
+	JMP	_rt0_sw64(SB)
+
+TEXT _rt0_sw64_linux_lib(SB), NOSPLIT, $0
+	CALL	_rt0_sw64_lib(SB)
+	RET
diff --git a/src/runtime/runtime_test.go b/src/runtime/runtime_test.go
index 0839cd96..885a0416 100644
--- a/src/runtime/runtime_test.go
+++ b/src/runtime/runtime_test.go
@@ -189,6 +189,9 @@ var faultAddrs = []uint64{
 }
 
 func TestSetPanicOnFault(t *testing.T) {
+	if GOARCH == "sw64" {
+                t.Skip("Some machine need upgrade hmcode to 2018-9+")
+        }
 	old := debug.SetPanicOnFault(true)
 	defer debug.SetPanicOnFault(old)
 
diff --git a/src/runtime/signal_linux_sw64.go b/src/runtime/signal_linux_sw64.go
new file mode 100644
index 00000000..74cf98eb
--- /dev/null
+++ b/src/runtime/signal_linux_sw64.go
@@ -0,0 +1,67 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build linux && sw64
+// +build linux,sw64
+
+package runtime
+
+import (
+	"unsafe"
+)
+
+type sigctxt struct {
+	info *siginfo
+	ctxt unsafe.Pointer
+}
+
+//go:nosplit
+//go:nowritebarrierrec
+func (c *sigctxt) regs() *sigcontext { return &(*ucontext)(c.ctxt).uc_mcontext }
+
+func (c *sigctxt) r0() uint64      { return c.regs().sc_regs[0] }
+func (c *sigctxt) r1() uint64      { return c.regs().sc_regs[1] }
+func (c *sigctxt) r2() uint64      { return c.regs().sc_regs[2] }
+func (c *sigctxt) r3() uint64      { return c.regs().sc_regs[3] }
+func (c *sigctxt) r4() uint64      { return c.regs().sc_regs[4] }
+func (c *sigctxt) r5() uint64      { return c.regs().sc_regs[5] }
+func (c *sigctxt) r6() uint64      { return c.regs().sc_regs[6] }
+func (c *sigctxt) r7() uint64      { return c.regs().sc_regs[7] }
+func (c *sigctxt) r8() uint64      { return c.regs().sc_regs[8] }
+func (c *sigctxt) r9() uint64      { return c.regs().sc_regs[9] }
+func (c *sigctxt) r10() uint64     { return c.regs().sc_regs[10] }
+func (c *sigctxt) r11() uint64     { return c.regs().sc_regs[11] }
+func (c *sigctxt) r12() uint64     { return c.regs().sc_regs[12] }
+func (c *sigctxt) r13() uint64     { return c.regs().sc_regs[13] }
+func (c *sigctxt) r14() uint64     { return c.regs().sc_regs[14] }
+func (c *sigctxt) g() uint64       { return c.regs().sc_regs[15] }
+func (c *sigctxt) r16() uint64     { return c.regs().sc_regs[16] }
+func (c *sigctxt) r17() uint64     { return c.regs().sc_regs[17] }
+func (c *sigctxt) r18() uint64     { return c.regs().sc_regs[18] }
+func (c *sigctxt) r19() uint64     { return c.regs().sc_regs[19] }
+func (c *sigctxt) r20() uint64     { return c.regs().sc_regs[20] }
+func (c *sigctxt) r21() uint64     { return c.regs().sc_regs[21] }
+func (c *sigctxt) r22() uint64     { return c.regs().sc_regs[22] }
+func (c *sigctxt) r23() uint64     { return c.regs().sc_regs[23] }
+func (c *sigctxt) r24() uint64     { return c.regs().sc_regs[24] }
+func (c *sigctxt) r25() uint64     { return c.regs().sc_regs[25] }
+func (c *sigctxt) link() uint64    { return c.regs().sc_regs[26] }
+func (c *sigctxt) regctxt() uint64 { return c.regs().sc_regs[27] }
+func (c *sigctxt) rtmp() uint64    { return c.regs().sc_regs[28] }
+func (c *sigctxt) r29() uint64     { return c.regs().sc_regs[29] }
+func (c *sigctxt) sp() uint64      { return c.regs().sc_regs[30] }
+
+func (c *sigctxt) set_sp(x uint64) { c.regs().sc_regs[30] = x }
+
+func (c *sigctxt) sigcode() uint32 { return uint32(c.info.si_code) }
+func (c *sigctxt) sigaddr() uint64 { return c.info.si_addr }
+
+//go:nosplit
+//go:nowritebarrierrec
+func (c *sigctxt) pc() uint64      { return c.regs().sc_pc }
+func (c *sigctxt) set_pc(x uint64) { c.regs().sc_pc = x }
+
+func (c *sigctxt) set_link(x uint64) { c.regs().sc_regs[26] = x }
+
+func (c *sigctxt) set_g(x uint64) { c.regs().sc_regs[15] = x }
diff --git a/src/runtime/signal_sw64.go b/src/runtime/signal_sw64.go
new file mode 100644
index 00000000..d2356fd5
--- /dev/null
+++ b/src/runtime/signal_sw64.go
@@ -0,0 +1,97 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build linux && sw64
+// +build linux
+// +build sw64
+
+package runtime
+
+import (
+	"internal/abi"
+	"internal/goarch"
+	"unsafe"
+)
+
+// snyh_TODO: FIX ALL OF THIS
+
+func dumpregs(c *sigctxt) {
+	println("r0\t", hex(c.r0()))
+	println("r1\t", hex(c.r1()))
+	println("r2\t", hex(c.r2()))
+	println("r3\t", hex(c.r3()))
+	println("r4\t", hex(c.r4()))
+	println("r5\t", hex(c.r5()))
+	println("r6\t", hex(c.r6()))
+	println("r7\t", hex(c.r7()))
+	println("r8\t", hex(c.r8()))
+	println("r9\t", hex(c.r9()))
+	println("r10\t", hex(c.r10()))
+	println("r11\t", hex(c.r11()))
+	println("r12\t", hex(c.r12()))
+	println("r13\t", hex(c.r13()))
+	println("r14\t", hex(c.r14()))
+	println("g\t", hex(c.g()))
+	println("r16\t", hex(c.r16()))
+	println("r17\t", hex(c.r17()))
+	println("r18\t", hex(c.r18()))
+	println("r19\t", hex(c.r19()))
+	println("r20\t", hex(c.r20()))
+	println("r21\t", hex(c.r21()))
+	println("r22\t", hex(c.r22()))
+	println("r23\t", hex(c.r23()))
+	println("r24\t", hex(c.r24()))
+	println("r25\t", hex(c.r25()))
+	println("ra\t", hex(c.link()))
+	println("ctxt\t", hex(c.regctxt()))
+	println("rtmp\t", hex(c.rtmp()))
+	println("r29\t", hex(c.r29()))
+	println("sp\t", hex(c.sp()))
+}
+
+//go:nosplit
+//go:nowritebarrierrec
+func (c *sigctxt) sigpc() uintptr { return uintptr(c.pc()) }
+
+func (c *sigctxt) sigsp() uintptr { return uintptr(c.sp()) }
+func (c *sigctxt) siglr() uintptr { return uintptr(c.link()) }
+func (c *sigctxt) fault() uintptr { return uintptr(c.sigaddr()) }
+
+// preparePanic sets up the stack to look like a call to sigpanic.
+func (c *sigctxt) preparePanic(sig uint32, gp *g) {
+	// We arrange link, and pc to pretend the panicking
+	// function calls sigpanic directly.
+	// Always save LINK to stack so that panics in leaf
+	// functions are correctly handled. This smashes
+	// the stack frame but we're not going back there
+	// anyway.
+	sp := c.sp() - goarch.PtrSize
+	c.set_sp(sp)
+	*(*uint64)(unsafe.Pointer(uintptr(sp))) = c.link()
+
+	pc := gp.sigpc
+
+	if shouldPushSigpanic(gp, pc, uintptr(c.link())) {
+		// Make it look the like faulting PC called sigpanic.
+		c.set_link(uint64(pc))
+	}
+	// In case we are panicking from external C code
+	sigpanicPC := uint64(abi.FuncPCABIInternal(sigpanic))
+	c.set_g(uint64(uintptr(unsafe.Pointer(gp))))
+	c.set_pc(sigpanicPC)
+}
+
+func (c *sigctxt) pushCall(targetPC, resumePC uintptr) {
+	// Push the LR to stack, as we'll clobber it in order to
+	// push the call. The function being pushed is responsible
+	// for restoring the LR and setting the SP back.
+	// This extra slot is known to gentraceback.
+	sp := c.sp() - 8
+	c.set_sp(sp)
+	*(*uint64)(unsafe.Pointer(uintptr(sp))) = c.link()
+	// Set up PC and LR to pretend the function being signaled
+	// calls targetPC at the faulting PC.
+	c.set_link(uint64(resumePC))
+	c.set_pc(uint64(targetPC))
+}
diff --git a/src/runtime/signal_unix.go b/src/runtime/signal_unix.go
index 84391d58..f31ef0df 100644
--- a/src/runtime/signal_unix.go
+++ b/src/runtime/signal_unix.go
@@ -397,7 +397,7 @@ func preemptM(mp *m) {
 //go:nosplit
 func sigFetchG(c *sigctxt) *g {
 	switch GOARCH {
-	case "arm", "arm64", "loong64", "ppc64", "ppc64le", "riscv64", "s390x":
+	case "arm", "arm64", "loong64", "ppc64", "ppc64le", "riscv64", "s390x", "sw64":
 		if !iscgo && inVDSOPage(c.sigpc()) {
 			// When using cgo, we save the g on TLS and load it from there
 			// in sigtramp. Just use that.
diff --git a/src/runtime/sigtab_linux_generic.go b/src/runtime/sigtab_linux_generic.go
index fe93bbaf..671d128d 100644
--- a/src/runtime/sigtab_linux_generic.go
+++ b/src/runtime/sigtab_linux_generic.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !mips && !mipsle && !mips64 && !mips64le && linux
+//go:build !mips && !mipsle && !mips64 && !mips64le && !sw64 && linux 
 
 package runtime
 
diff --git a/src/runtime/sigtab_linux_sw64.go b/src/runtime/sigtab_linux_sw64.go
new file mode 100644
index 00000000..70ccfcc5
--- /dev/null
+++ b/src/runtime/sigtab_linux_sw64.go
@@ -0,0 +1,75 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build sw64
+// +build linux
+
+package runtime
+
+var sigtable = [...]sigTabT{
+	/* 0 */ {0, "SIGNONE: no trap"},
+	/* 1 */ {_SigNotify + _SigKill, "SIGHUP: terminal line hangup"},
+	/* 2 */ {_SigNotify + _SigKill, "SIGINT: interrupt"},
+	/* 3 */ {_SigNotify + _SigThrow, "SIGQUIT: quit"},
+	/* 4 */ {_SigThrow + _SigUnblock, "SIGILL: illegal instruction"},
+	/* 5 */ {_SigThrow + _SigUnblock, "SIGTRAP: trace trap"},
+	/* 6 */ {_SigNotify + _SigThrow, "SIGABRT: abort"},
+	/* 7 */ {_SigThrow, "SIGEMT"},
+	/* 8 */ {_SigPanic + _SigUnblock, "SIGFPE: floating-point exception"},
+	/* 9 */ {0, "SIGKILL: kill"},
+	/* 10 */ {_SigPanic + _SigUnblock, "SIGBUS: bus error"},
+	/* 11 */ {_SigPanic + _SigUnblock, "SIGSEGV: segmentation violation"},
+	/* 12 */ {_SigThrow, "SIGSYS: bad system call"},
+	/* 13 */ {_SigNotify, "SIGPIPE: write to broken pipe"},
+	/* 14 */ {_SigNotify, "SIGALRM: alarm clock"},
+	/* 15 */ {_SigNotify + _SigKill, "SIGTERM: termination"},
+	/* 16 */ {_SigNotify + _SigIgn, "SIGURG: urgent condition on socket"},
+	/* 17 */ {0, "SIGSTOP: stop, unblockable"},
+	/* 18 */ {_SigNotify + _SigDefault + _SigIgn, "SIGTSTP: keyboard stop"},
+	/* 19 */ {_SigNotify + _SigDefault + _SigIgn, "SIGCONT: continue"},
+	/* 20 */ {_SigNotify + _SigUnblock + _SigIgn, "SIGCHLD: child status has changed"},
+	/* 21 */ {_SigNotify + _SigDefault + _SigIgn, "SIGTTIN: background read from tty"},
+	/* 22 */ {_SigNotify + _SigDefault + _SigIgn, "SIGTTOU: background write to tty"},
+	/* 23 */ {_SigNotify, "SIGIO: i/o now possible"},
+	/* 24 */ {_SigNotify, "SIGXCPU: cpu limit exceeded"},
+	/* 25 */ {_SigNotify, "SIGXFSZ: file size limit exceeded"},
+	/* 26 */ {_SigNotify, "SIGVTALRM: virtual alarm clock"},
+	/* 27 */ {_SigNotify + _SigUnblock, "SIGPROF: profiling alarm clock"},
+	/* 28 */ {_SigNotify + _SigIgn, "SIGWINCH: window size change"},
+	/* 29 */ {_SigNotify, "SIGINFO: power failure restart"},
+	/* 30 */ {_SigNotify, "SIGUSR1: user-defined signal 1"},
+	/* 31 */ {_SigNotify, "SIGUSR2: user-defined signal 2"},
+	/* 32 */ {_SigSetStack + _SigUnblock, "signal 32"}, /* SIGCANCEL; see issue 6997 */
+	/* 33 */ {_SigSetStack + _SigUnblock, "signal 33"}, /* SIGSETXID; see issues 3871, 9400, 12498 */
+	/* 34 */ {_SigNotify, "signal 34"},
+	/* 35 */ {_SigNotify, "signal 35"},
+	/* 36 */ {_SigNotify, "signal 36"},
+	/* 37 */ {_SigNotify, "signal 37"},
+	/* 38 */ {_SigNotify, "signal 38"},
+	/* 39 */ {_SigNotify, "signal 39"},
+	/* 40 */ {_SigNotify, "signal 40"},
+	/* 41 */ {_SigNotify, "signal 41"},
+	/* 42 */ {_SigNotify, "signal 42"},
+	/* 43 */ {_SigNotify, "signal 43"},
+	/* 44 */ {_SigNotify, "signal 44"},
+	/* 45 */ {_SigNotify, "signal 45"},
+	/* 46 */ {_SigNotify, "signal 46"},
+	/* 47 */ {_SigNotify, "signal 47"},
+	/* 48 */ {_SigNotify, "signal 48"},
+	/* 49 */ {_SigNotify, "signal 49"},
+	/* 50 */ {_SigNotify, "signal 50"},
+	/* 51 */ {_SigNotify, "signal 51"},
+	/* 52 */ {_SigNotify, "signal 52"},
+	/* 53 */ {_SigNotify, "signal 53"},
+	/* 54 */ {_SigNotify, "signal 54"},
+	/* 55 */ {_SigNotify, "signal 55"},
+	/* 56 */ {_SigNotify, "signal 56"},
+	/* 57 */ {_SigNotify, "signal 57"},
+	/* 58 */ {_SigNotify, "signal 58"},
+	/* 59 */ {_SigNotify, "signal 59"},
+	/* 60 */ {_SigNotify, "signal 60"},
+	/* 61 */ {_SigNotify, "signal 61"},
+	/* 62 */ {_SigNotify, "signal 62"},
+	/* 63 */ {_SigNotify, "signal 63"},
+}
diff --git a/src/runtime/stubs_sw64.go b/src/runtime/stubs_sw64.go
new file mode 100644
index 00000000..acd58fcf
--- /dev/null
+++ b/src/runtime/stubs_sw64.go
@@ -0,0 +1,30 @@
+// Copyright 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+
+package runtime
+
+import "unsafe"
+
+// Called from assembly only; declared for go vet.
+func load_g()
+func save_g()
+
+func udiv()
+func sw_sigreturn()
+
+//go:noescape
+func asmcgocall_no_g(fn, arg unsafe.Pointer)
+
+// Used by reflectcall and the reflect package.
+//
+// Spills/loads arguments in registers to/from an internal/abi.RegArgs
+// respectively. Does not follow the Go ABI.
+func spillArgs()
+func unspillArgs()
+
+// getfp returns the frame pointer register of its caller or 0 if not implemented.
+// TODO: Make this a compiler intrinsic
+func getfp() uintptr { return 0 }
diff --git a/src/runtime/sys_linux_sw64.s b/src/runtime/sys_linux_sw64.s
new file mode 100644
index 00000000..853c8244
--- /dev/null
+++ b/src/runtime/sys_linux_sw64.s
@@ -0,0 +1,615 @@
+#include "go_asm.h"
+#include "go_tls.h"
+#include "funcdata.h"
+#include "textflag.h"
+
+#define SYS_exit 1
+#define SYS_read 3
+#define SYS_write 4
+#define SYS_close 6
+#define SYS_brk 17
+#define SYS_getxpid 20
+#define SYS_kill 37
+#define SYS_pipe 42
+#define SYS_open 45
+#define SYS_mmap 71
+#define SYS_munmap 73
+#define SYS_madvise 75
+#define SYS_sigaltstack 235
+#define SYS_clone 312
+#define SYS_sched_yield 334
+#define SYS_rt_sigreturn 351
+#define SYS_rt_sigaction 352
+#define SYS_rt_sigprocmask 353
+#define SYS_select 358
+#define SYS_setitimer 362
+#define SYS_mincore 375
+#define SYS_gettid 378
+#define SYS_tkill 381
+#define SYS_futex 394
+#define SYS_sched_getaffinity 396
+#define SYS_exit_group 405
+#define SYS_epoll_wait 409
+#define SYS_clock_gettime 420
+#define SYS_tgkill 424
+#define SYS_pipe2 488
+#define SYS_timer_create 414
+#define SYS_timer_settime 415
+#define SYS_timer_delete 418
+
+#define SYSCALL(n) \
+	LDI	R0, $n \
+	SYS_CALL_B	$131
+
+// func exit(code int32)
+TEXT runtime·exit(SB), NOFRAME|NOSPLIT, $0-4
+	LDW	R16, code+0(FP)
+	SYSCALL(SYS_exit_group)
+	RET
+
+// func exitThread(wait *atomic.Uint32)
+TEXT runtime·exitThread(SB), NOFRAME|NOSPLIT, $0-8
+	LDL	R1, wait+0(FP)
+	MEMB
+	STW	ZERO, (R1)
+	MEMB
+
+	LDI	R16, $0
+	SYSCALL(SYS_exit)
+	JMP	0(PC)
+
+// func write(fd uintptr, p unsafe.Pointer, n int32) int32
+TEXT runtime·write1(SB), NOSPLIT, $0-28
+	LDL	R16, fd+0(FP)
+	LDL	R17, p+8(FP)
+	LDW	R18, n+16(FP)
+	SYSCALL(SYS_write)
+	BEQ	R19, ok
+	SUBL	ZERO, R0, R0
+ok:
+	STW	R0, ret+24(FP)
+	RET
+
+// func read(fd int32, p unsafe.Pointer, n int32) int32
+TEXT runtime·read(SB),NOSPLIT,$0-28
+	LDW	R16, fd+0(FP)
+	LDL	R17, p+8(FP)
+	LDW	R18, n+16(FP)
+	SYSCALL(SYS_read)
+
+	BEQ	R19, ok
+	SUBL	ZERO, R0, R0
+ok:
+	STW	R0, ret+24(FP)
+	RET
+
+// func open(name *byte, mode, perm int32) int32
+TEXT runtime·open(SB), NOSPLIT, $0-20
+	LDL	R16, name+0(FP)
+	LDW	R17, mode+8(FP)
+	LDW	R18, perm+12(FP)
+	SYSCALL(SYS_open)
+
+	BEQ	R19, ok
+	LDI	R0, -1
+ok:
+	STW	R0, ret+16(FP)
+	RET
+
+// func closefd(fd int32) int32
+TEXT runtime·closefd(SB), NOSPLIT, $0-12
+	LDW	R16, fd+0(FP)
+	SYSCALL(SYS_close)
+
+	BEQ	R19, ok
+	LDI	R0, $-1
+ok:
+	STW	R0, ret+8(FP)
+	RET
+
+// func mmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uint32) (p unsafe.Pointer, err int)
+TEXT runtime·mmap(SB),NOSPLIT,$0-48
+	LDL	R16, addr+0(FP)
+	LDL	R17, n+8(FP)
+	LDW	R18, prot+16(FP)
+	LDW	R19, flags+20(FP)
+	LDW	R20, fd+24(FP)
+	LDW	R21, off+28(FP)
+
+	SYSCALL(SYS_mmap)
+
+	BEQ	R19, ok
+	STL	ZERO, p+32(FP)
+	STL	R0, err+40(FP)
+	RET
+ok:
+	STL	R0, p+32(FP)
+	STL	ZERO, err+40(FP)
+	RET
+
+// func munmap(addr unsafe.Pointer, n uintptr)
+TEXT runtime·munmap(SB), NOSPLIT, $0-16
+	LDL	R16, addr+0(FP)
+	LDL	R17, n+8(FP)
+	SYSCALL(SYS_munmap)
+	RET
+
+// func mincore(addr unsafe.Pointer, n uintptr, dst *byte) int32
+TEXT runtime·mincore(SB),NOSPLIT,$0-28
+	LDL	R16, addr+0(FP)
+	LDL	R17, n+8(FP)
+	LDL	R18, dst+16(FP)
+	SYSCALL(SYS_mincore)
+	SUBL	ZERO, R0, R0
+	STW	R0, ret+24(FP)
+	RET
+
+// func sched_getaffinity(pid, len uintptr, buf *byte) int32
+TEXT runtime·sched_getaffinity(SB),NOSPLIT,$0-28
+	LDL	R16, pid+0(FP)
+	LDL	R17, len+8(FP)
+	LDL	R18, buf+16(FP)
+	SYSCALL(SYS_sched_getaffinity)
+	BEQ	R19, ok
+	LDI	R0, -1
+ok:
+	STW	R0, ret+24(FP)
+	RET
+
+// func sbrk0() uintptr
+TEXT runtime·sbrk0(SB), NOSPLIT, $0-8
+	// Implemented as brk(NULL).
+	LDI	R16, $0
+	SYSCALL(SYS_brk)
+	BEQ	R19, ok
+	SUBL	ZERO, R0, R0
+ok:
+	STL	R0, ret+0(FP)
+	RET
+
+TEXT runtime·osyield(SB), NOFRAME|NOSPLIT, $0
+	SYSCALL(SYS_sched_yield)
+	RET
+
+TEXT runtime·nanotime1(SB), NOSPLIT, $16-8
+	LDI	R9, R30    // R9 is unchanged by C code
+	LDI	R1, R30
+
+	LDL	R10, g_m(g) // R10 = m
+
+  // Save the old values on stack and restore them on exit.
+  // so this function is reentrant.
+  LDL R16, m_vdsoPC(R10)
+  LDL R17, m_vdsoSP(R10)
+  STL R16, 8(R30)
+  STL R17, 16(R30)
+
+  LDL R16, $ret-8(FP)
+	// Set vdsoPC and vdsoSP for SIGPROF traceback.
+	STL	R26, m_vdsoPC(R10)
+	STL R16, m_vdsoSP(R10)
+
+	LDL	R16, m_curg(R10)
+	LDI	R17, g
+	CMPEQ	R16, R17, R7
+	BEQ	R7, noswitch
+
+	LDL	R16, m_g0(R10)
+	LDL	R1, (g_sched+gobuf_sp)(R16)  // Set SP to g0 stack
+
+noswitch:
+	SUBL	R1, $16, R1
+	AND	R1, $~15, R1  // Align for C code
+	LDI	R30, R1
+
+	LDI	R16, $1  // CLOCK_MONOTONIC
+	LDI	R17, $0(R30)
+
+	LDL	R27, runtime·vdsoClockgettimeSym(SB)
+	BEQ	R27, fallback
+
+	// Store g on gsignal's stack, so if we receive a signal
+	// during VDSO code we can find the g.
+	// If we don't have a signal stack, we won't receive signal,
+	// so don't bother saving g.
+	// When using cgo, we already saved g on TLS, also don't save
+	// g here.
+	// Also don't save g if we are already on the signal stack.
+	// We won't get a nested signal.
+	LDBU R11, runtime·iscgo(SB) //R11 doesn't change by C code
+	BNE R11, nosaveg
+	LDL R11, m_gsignal(R10)
+	BEQ R11, nosaveg
+
+	CMPEQ g, R11, R28
+	BNE R28, nosaveg
+	LDL R11, (g_stack+stack_lo)(R11)
+	STL g, (R11)
+
+	CALL	R26, (R27)
+  STL  R31, 0(R11) // clear g slot
+
+finish:
+	LDL	R0, 0(R30)   // sec
+	LDL	R17, 8(R30)  // nsec
+
+	LDI	R30, R9      // restore SP
+  // Restore vdsoPC, vdsoSP
+  // We don't worry about being signaled between the two stores.
+  // If we are not in a signal handler, we'll restore vdsoSP to 0,
+  // and no one will care about vdsoPC. If we are in a signal handler,
+  // we cannot receive another signal.
+  LDL     R1, 16(R30)
+  STL     R1, m_vdsoSP(R10)
+  LDL     R1, 8(R30)
+  STL     R1, m_vdsoPC(R10)
+
+	// sec is in R3, nsec in R5
+        // return nsec in R3
+	LDI	R16, $1000000000
+	MULL	R0, R16, R0
+	ADDL	R0, R17, R0
+	STL	R0, ret+0(FP)
+	RET
+
+nosaveg:
+	CALL	R26, (R27)
+	JMP finish
+
+fallback:
+	SYSCALL(SYS_clock_gettime)
+	JMP	finish
+
+TEXT runtime·usleep(SB),NOSPLIT,$16-4
+	LDW	R1, usec+0(FP)
+	LDI	R0, $1000000
+	CALL	runtime·udiv(SB)
+	STL	R0, 8(SP)
+	STL	R1, 16(SP)
+
+	// select(0, 0, 0, 0, &tv)
+	LDI	R16, $0
+	LDI	R17, $0
+	LDI	R18, $0
+	LDI	R19, $0
+	LDI	R20, $8(SP)
+	SYSCALL(SYS_select)
+	RET
+
+TEXT runtime·walltime(SB), NOSPLIT, $16-12
+	LDI	R9, R30    // R9 is unchanged by C code
+	LDI	R1, R30
+
+	LDL	R10, g_m(g) // R10 = m
+
+  // Save the old values on stack and restore them on exit.
+  // so this function is reentrant.
+  LDL R16, m_vdsoPC(R10)
+  LDL R17, m_vdsoSP(R10)
+  STL R16, 8(R30)
+  STL R17, 16(R30)
+
+  LDL R16, $ret-8(FP)
+	// Set vdsoPC and vdsoSP for SIGPROF traceback.
+	STL	R26, m_vdsoPC(R10)
+	STL R16, m_vdsoSP(R10)
+
+	LDL	R16, m_curg(R10)
+	LDI	R17, g
+	CMPEQ	R16, R17, R7
+	BEQ	R7, noswitch
+
+	LDL	R16, m_g0(R10)
+	LDL	R1, (g_sched+gobuf_sp)(R16)  // Set SP to g0 stack
+
+noswitch:
+	SUBL	R1, $16, R1
+	AND	R1, $~15, R1  // Align for C code
+	LDI	R30, R1
+
+	LDI	R16, $0  // CLOCK_MONOTONIC
+	LDI	R17, $0(R30)
+
+	LDL	R27, runtime·vdsoClockgettimeSym(SB)
+	BEQ	R27, fallback
+
+	// Store g on gsignal's stack, so if we receive a signal
+	// during VDSO code we can find the g.
+	// If we don't have a signal stack, we won't receive signal,
+	// so don't bother saving g.
+	// When using cgo, we already saved g on TLS, also don't save
+	// g here.
+	// Also don't save g if we are already on the signal stack.
+	// We won't get a nested signal.
+	LDBU R11, runtime·iscgo(SB) //R11 doesn't change by C code
+	BNE R11, nosaveg
+	LDL R11, m_gsignal(R10)
+	BEQ R11, nosaveg
+
+	CMPEQ g, R11, R28
+	BNE R28, nosaveg
+	LDL R11, (g_stack+stack_lo)(R11)
+	STL g, (R11)
+
+	CALL	R26, (R27)
+  STL  R31, 0(R11) // clear g slot
+
+finish:
+	LDL	R0, 0(R30)   // sec
+	LDL	R17, 8(R30)  // nsec
+
+	LDI	R30, R9      // restore SP
+  // Restore vdsoPC, vdsoSP
+  // We don't worry about being signaled between the two stores.
+  // If we are not in a signal handler, we'll restore vdsoSP to 0,
+  // and no one will care about vdsoPC. If we are in a signal handler,
+  // we cannot receive another signal.
+  LDL R1, 16(R30)
+  STL R1, m_vdsoSP(R10)
+  LDL R1, 8(R30)
+  STL R1, m_vdsoPC(R10)
+
+	STL	R0, sec+0(FP)
+	STW	R17, nsec+8(FP)
+	RET
+
+nosaveg:
+	CALL	R26, (R27)
+	JMP finish
+
+fallback:
+	SYSCALL(SYS_clock_gettime)
+	JMP	finish
+
+// func madvise(addr unsafe.Pointer, n uintptr, flags int32)
+TEXT runtime·madvise(SB),NOSPLIT,$0-28
+	LDL	R16, addr+0(FP)
+	LDL	R17, n+8(FP)
+	LDW	R18, flags+16(FP)
+	SYSCALL(SYS_madvise)
+	STW	R0,ret+24(FP)
+	// ignore failure - maybe pages are locked
+	RET
+
+// func rtsigprocmask(how int32, new, old *sigset, size int32)
+TEXT runtime·rtsigprocmask(SB), NOFRAME|NOSPLIT,$0-28
+	LDW	R16, how+0(FP) //there has 4byte pad space
+	LDL	R17, new+8(FP)
+	LDL	R18, old+16(FP)
+	LDW	R19, size+24(FP)
+	SYSCALL(SYS_rt_sigprocmask)
+	BEQ	R19, ok
+	LDL	ZERO, 0xf1(ZERO) //crash
+	LDI	R0, -1
+ok:
+	RET
+
+TEXT glibc_sigreturn<>(SB), NOFRAME|NOSPLIT, $0
+	LDI	R16, SP
+	SYSCALL(SYS_rt_sigreturn)
+
+// func rt_sigaction(sig uintptr, new, old *sigactiont, size uintptr) int32
+TEXT runtime·rt_sigaction(SB), NOFRAME|NOSPLIT, $0-36
+	LDL	R16, sig+0(FP)
+	LDL	R17, new+8(FP)
+	LDL	R18, old+16(FP)
+	LDL	R19, size+24(FP)
+	SYMADDR	R20, glibc_sigreturn<>(SB)
+
+	SYSCALL(SYS_rt_sigaction)
+
+	BEQ	R19, ok
+	STW	R19, ret+32(FP)
+	RET
+ok:
+	STW	ZERO, ret+32(FP)
+	RET
+
+TEXT runtime·cgoSigtramp(SB), NOFRAME|NOSPLIT, $0
+	JMP	runtime·sigtramp(SB)
+
+// void (*sa_sigaction)(int, siginfo_t *, void *);
+TEXT runtime·sigtramp(SB), NOSPLIT|TOPFRAME, $64
+	// initialize REGSB = PC&0xffffffff00000000
+	// BGEZAL	R0, 1(PC)
+	// SRLV	$32, R31, RSB
+	// SLLV	$32, RSB
+
+	// this might be called in external code context,
+	// where g is not set.
+	LDBU	R1, runtime·iscgo(SB)
+	BEQ	R1, ok
+	CALL	runtime·load_g(SB)
+ok:
+	STW	R16, 8(SP) // sig
+	STL	R17, 16(SP) // info
+	STL	R18, 24(SP) // ctx
+	// func sigtrampgo(sig uint32, info *siginfo, ctx unsafe.Pointer)
+	CALL	runtime·sigtrampgo(SB)
+	LDL	R17, 16(SP)
+	STL	R17, 8(SP)
+	CALL	sw_sigreturn(SB)
+	RET
+
+// func sw_sigreturn(rt_sigframe)
+TEXT sw_sigreturn(SB), NOSPLIT, $0-0
+	LDL	R16, $frame+0(FP)
+	SYSCALL(SYS_rt_sigreturn)
+	RET
+
+// func sigfwd(fn uintptr, sig uint32, info *siginfo, ctx unsafe.Pointer)
+TEXT runtime·sigfwd(SB), NOSPLIT, $0-32
+	LDW	R16, sig+8(FP)
+	LDL	R17, info+16(FP)
+	LDL	R18, ctx+24(FP)
+	LDL	R27, fn+0(FP)
+	CALL	(R27)
+	RET
+
+// func futex(addr unsafe.Pointer, op int32, val uint32, ts, addr2 unsafe.Pointer, val3 uint32) int32
+TEXT runtime·futex(SB), NOFRAME|NOSPLIT, $0-44
+	LDL	R16, addr+0(FP)
+	LDW	R17, op+8(FP)
+	LDW	R18, val+12(FP)
+	LDL	R19, ts+16(FP)
+	LDL	R20, addr2+24(FP)
+	LDW	R21, val3+32(FP)
+	SYSCALL(SYS_futex)
+	BEQ	R19, ok
+	SUBL	ZERO, R0, R0
+ok:
+	STW	R0, ret+40(FP)
+	RET
+
+// func sigaltstack(new, old *stackt)
+TEXT runtime·sigaltstack(SB), NOFRAME|NOSPLIT, $0-16
+	LDL	R16, new+0(FP)
+	LDL	R17, old+8(FP)
+	SYSCALL(SYS_sigaltstack)
+	BEQ	R19, ok
+	LDL	R19, (ZERO) // crash
+ok:
+	RET
+
+// func gettid() uint32
+TEXT runtime·gettid(SB), NOFRAME|NOSPLIT, $0-4
+	SYSCALL(SYS_gettid)
+	STW	R0, ret+0(FP)
+	RET
+
+// func clone(flags int32, stk, mp, gp, fn unsafe.Pointer) int32
+TEXT runtime·clone(SB), NOSPLIT, $0-44
+	LDW	R16, flags+0(FP)
+	LDL	R17, stk+8(FP)
+
+	// Copy mp, gp, fn off parent stack for use by child.
+	// Careful: Linux system call clobbers ???.
+	LDL	R1, mp+16(FP)
+	LDL	R2, gp+24(FP)
+	LDL	R3, fn+32(FP)
+
+	STL	R1, -8(R17) // mp
+	STL	R2, -16(R17) // gp
+	STL	R3, -24(R17) // fn
+
+	LDI	R1, $77
+	STL	R1, -32(R17) // guard
+	SYSCALL(SYS_clone)
+	BEQ	R0, child
+	STW	R0, ret+40(FP)  // on parent
+	RET
+child:
+	LDL	R4, -32(SP)     // on child
+	LDI	R5, $77
+	CMPEQ	R4, R5, R5
+	BNE	R5, guard_ok
+	LDL	R5, 0(ZERO)
+guard_ok:
+	// set up new stack
+	LDL	R27, -24(SP) // fn
+	LDL	R2, -16(SP) // g
+	LDL	R1, -8(SP)  // m
+	BEQ	R2, nog
+	BEQ	R1, nog
+
+	SYSCALL(SYS_gettid)
+	STL	R0, m_procid(R1)
+
+	STL	R1, g_m(R2)
+	LDI	g, R2
+	//CALL	runtime·stackcheck(SB)
+nog:
+	// Call fn
+	CALL	(R27)
+
+	// It shouldn't return.	 If it does, exit that thread.
+	LDI	R16, $111
+	SYSCALL(SYS_exit)
+	RET
+
+// func raise(sig uint32)
+TEXT runtime·raise(SB), NOFRAME|NOSPLIT, $0
+	SYSCALL(SYS_getxpid)
+        LDI     R9, R0
+        SYSCALL(SYS_gettid)
+        LDI     R17, R0 // arg 2 tid
+        LDI     R16, R9 // arg 1 pid
+        LDW     R18, sig+0(FP) // arg 3
+        SYSCALL(SYS_tgkill)
+        RET
+
+// func raiseproc(sig uint32)
+TEXT runtime·raiseproc(SB), NOFRAME|NOSPLIT, $0
+	SYSCALL(SYS_getxpid)
+	LDI	R16, R0
+	LDW	R17, sig+0(FP)
+	SYSCALL(SYS_kill)
+	RET
+
+// func setitimer(mode int32, new, old *itimerval)
+TEXT runtime·setitimer(SB), NOFRAME|NOSPLIT, $0-24
+	LDW	R16, mode+0(FP)
+	LDL	R17, new+8(FP)
+	LDL	R18, old+16(FP)
+	SYSCALL(SYS_setitimer)
+	RET
+
+// func timer_create(clockid int32, sevp *sigevent, timerid *int32) int32
+TEXT runtime·timer_create(SB),NOSPLIT,$0-28
+        LDW	R16, clockid+0(FP)
+        LDL	R17, sevp+8(FP)
+        LDL     R18, timerid+16(FP)
+        SYSCALL(SYS_timer_create)
+        STW	R0, ret+24(FP)
+        RET
+
+// func timer_settime(timerid int32, flags int32, new, old *itimerspec) int32
+TEXT runtime·timer_settime(SB),NOSPLIT,$0-28
+        LDW	R16, timerid+0(FP)
+        LDW	R17, flags+4(FP)
+        LDL     R18, new+8(FP)
+        LDL	R19, old+16(FP)
+        SYSCALL(SYS_timer_settime)
+        STW	R0, ret+24(FP)
+        RET
+
+// func timer_delete(timerid int32
+TEXT runtime·timer_delete(SB),NOSPLIT,$0-12
+        LDW	R16, timerid+0(FP)
+        SYSCALL(SYS_timer_delete)
+        STW	R0, ret+8(FP)
+        RET
+
+// func pipe() (r, w int32, errno int32)
+TEXT runtime·pipe(SB),NOSPLIT|NOFRAME,$0-12
+	LDI	R16, $r+0(FP)
+	LDI	R17, ZERO
+	SYSCALL(SYS_pipe2)
+	BEQ	R19, ok
+	SUBL	ZERO, R0, R0
+ok:
+	STW	R0, errno+8(FP)
+	RET
+
+// func pipe2(flags int32) (r, w int32, errno int32)
+TEXT runtime·pipe2(SB),NOSPLIT|NOFRAME,$0-20
+	LDI	R16, $r+8(FP)
+	LDW	R17, flags+0(FP)
+	SYSCALL(SYS_pipe2)
+	BEQ	R19, ok
+	SUBL	ZERO, R0, R0
+ok:
+	STW	R0, errno+16(FP)
+	RET
+
+TEXT ·getpid(SB),NOSPLIT|NOFRAME,$0-8
+	SYSCALL(SYS_getxpid)
+	STL	R0, ret+0(FP)
+	RET
+
+TEXT ·tgkill(SB),NOSPLIT|NOFRAME,$0-24
+	LDL	R16, tgid+0(FP)
+	LDL	R17, tid+8(FP)
+	LDL	R18, sig+16(FP)
+	SYSCALL(SYS_tgkill)
+	RET
diff --git a/src/runtime/sys_sw64.go b/src/runtime/sys_sw64.go
new file mode 100644
index 00000000..0f6a41ff
--- /dev/null
+++ b/src/runtime/sys_sw64.go
@@ -0,0 +1,23 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+// +build sw64
+
+package runtime
+
+// snyh_TODO: FIX ALL OF THIS
+
+import "unsafe"
+
+// adjust Gobuf as if it executed a call to fn with context ctxt
+// and then did an immediate Gosave.
+func gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer) {
+	if buf.lr != 0 {
+		throw("invalid use of gostartcall")
+	}
+	buf.lr = buf.pc
+	buf.pc = uintptr(fn)
+	buf.ctxt = ctxt
+}
diff --git a/src/runtime/tagptr_64bit.go b/src/runtime/tagptr_64bit.go
index 9ff11ccd..5aefc737 100644
--- a/src/runtime/tagptr_64bit.go
+++ b/src/runtime/tagptr_64bit.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build amd64 || arm64 || loong64 || mips64 || mips64le || ppc64 || ppc64le || riscv64 || s390x || wasm
+//go:build amd64 || arm64 || loong64 || mips64 || mips64le || ppc64 || ppc64le || riscv64 || s390x || wasm || sw64
 
 package runtime
 
diff --git a/src/runtime/tls_sw64.s b/src/runtime/tls_sw64.s
new file mode 100644
index 00000000..ba675d28
--- /dev/null
+++ b/src/runtime/tls_sw64.s
@@ -0,0 +1,34 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+// +build sw64
+
+#include "go_asm.h"
+#include "go_tls.h"
+#include "funcdata.h"
+#include "textflag.h"
+
+// If !iscgo, this is a no-op.
+//
+// NOTE: mcall() assumes this clobbers only R28 and R0
+TEXT runtime·save_g(SB), NOFRAME|NOSPLIT, $0-0
+	LDBU	R28, runtime·iscgo(SB)
+	BEQ	R28, nocgo
+
+	LDI	R28, R0
+	STL	g, runtime·tls_g(SB) // TLS relocation clobbers R0
+	LDI	R0, R28
+	SETFPEC1
+nocgo:
+	RET
+
+TEXT runtime·load_g(SB), NOFRAME|NOSPLIT, $0-0
+	LDI	R28, R0
+	LDL	g, runtime·tls_g(SB) // TLS relocation clobbers R0
+	LDI	R0, R28
+	SETFPEC1
+	RET
+
+GLOBL	runtime·tls_g(SB), TLSBSS, $8
diff --git a/src/runtime/vdso_elf64.go b/src/runtime/vdso_elf64.go
index d41d25e7..3cc7b2c5 100644
--- a/src/runtime/vdso_elf64.go
+++ b/src/runtime/vdso_elf64.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build linux && (amd64 || arm64 || loong64 || mips64 || mips64le || ppc64 || ppc64le || riscv64 || s390x)
+//go:build linux && (amd64 || arm64 || loong64 || mips64 || mips64le || ppc64 || ppc64le || riscv64 || s390x || sw64)
 
 package runtime
 
diff --git a/src/runtime/vdso_in_none.go b/src/runtime/vdso_in_none.go
index 3a6ee6f0..6a47908a 100644
--- a/src/runtime/vdso_in_none.go
+++ b/src/runtime/vdso_in_none.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build (linux && !386 && !amd64 && !arm && !arm64 && !loong64 && !mips64 && !mips64le && !ppc64 && !ppc64le && !riscv64 && !s390x) || !linux
+//go:build (linux && !386 && !amd64 && !arm && !arm64 && !loong64 && !mips64 && !mips64le && !ppc64 && !ppc64le && !riscv64 && !s390x && !sw64) || !linux
 
 package runtime
 
diff --git a/src/runtime/vdso_linux.go b/src/runtime/vdso_linux.go
index 45236157..993606bc 100644
--- a/src/runtime/vdso_linux.go
+++ b/src/runtime/vdso_linux.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build linux && (386 || amd64 || arm || arm64 || loong64 || mips64 || mips64le || ppc64 || ppc64le || riscv64 || s390x)
+//go:build linux && (386 || amd64 || arm || arm64 || loong64 || mips64 || mips64le || ppc64 || ppc64le || riscv64 || s390x || sw64)
 
 package runtime
 
diff --git a/src/runtime/vdso_linux_sw64.go b/src/runtime/vdso_linux_sw64.go
new file mode 100644
index 00000000..8c7d2cce
--- /dev/null
+++ b/src/runtime/vdso_linux_sw64.go
@@ -0,0 +1,28 @@
+// Copyright 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build linux && sw64
+// +build linux
+// +build sw64
+
+package runtime
+
+const (
+	// vdsoArrayMax is the byte-size of a maximally sized array on this architecture.
+	// See cmd/compile/internal/sw64/galign.go arch.MAXWIDTH initialization.
+	vdsoArrayMax = 1<<50 - 1
+)
+
+var vdsoLinuxVersion = vdsoVersionKey{"LINUX_2.6.39", 0x75fcb89}
+
+// The symbol name is not __kernel_clock_gettime as suggested by the manpage;
+// according to Linux source code it should be __vdso_clock_gettime instead.
+var vdsoSymbolKeys = []vdsoSymbolKey{
+	{"__vdso_clock_gettime", 0xd35ec75, 0x6e43a318, &vdsoClockgettimeSym},
+}
+
+// initialize to fall back to syscall
+var (
+	vdsoClockgettimeSym uintptr = 0
+)
diff --git a/src/runtime/vlrt.go b/src/runtime/vlrt.go
index 4b12f593..94edd77d 100644
--- a/src/runtime/vlrt.go
+++ b/src/runtime/vlrt.go
@@ -23,7 +23,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-//go:build arm || 386 || mips || mipsle
+//go:build arm || 386 || mips || mipsle || sw64
 
 package runtime
 
diff --git a/src/syscall/asm_linux_sw64.s b/src/syscall/asm_linux_sw64.s
new file mode 100644
index 00000000..f30885e8
--- /dev/null
+++ b/src/syscall/asm_linux_sw64.s
@@ -0,0 +1,49 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build linux && sw64
+
+#include "textflag.h"
+
+//
+// System calls for sw64, Linux
+//
+
+#define SYSCALL SYS_CALL_B $131
+
+TEXT ·rawSyscallNoError(SB),NOSPLIT,$0-48
+	LDL	R16, a1+8(FP)
+	LDL	R17, a2+16(FP)
+	LDL	R18, a3+24(FP)
+	LDI	R19, ZERO
+	LDI	R20, ZERO
+	LDI	R21, ZERO
+	LDL	R0, trap+0(FP)  // syscall entry
+	SYSCALL
+	STL	R0, r1+32(FP)
+	STL	R20, r2+40(FP)
+	RET
+
+// func rawVforkSyscall(trap, a1, a2, a3 uintptr) (r1, err uintptr)
+TEXT ·rawVforkSyscall(SB),NOSPLIT|NOFRAME,$0-48
+	LDL R16, a1+8(FP)
+	LDL R17, a2+16(FP)
+	LDL R18, a3+24(FP)
+	LDI R19, ZERO
+	LDI R20, ZERO
+	LDI R21, ZERO
+	LDL R0, trap+0(FP)  // syscall entry
+	SYSCALL
+	BEQ R19, ok
+	LDI R1, $-1
+	STL R1, r1+32(FP)  // r1
+	STL R0, err+40(FP) // errno
+	RET
+ok:
+	STL R0, r1+32(FP)    // r1
+	STL ZERO, err+40(FP) // errno
+	RET
+
+
+
diff --git a/src/syscall/endian_little.go b/src/syscall/endian_little.go
index f5fcb58d..3cad1a1d 100644
--- a/src/syscall/endian_little.go
+++ b/src/syscall/endian_little.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 //
-//go:build 386 || amd64 || arm || arm64 || loong64 || ppc64le || mips64le || mipsle || riscv64 || wasm
+//go:build 386 || amd64 || arm || arm64 || loong64 || ppc64le || mips64le || mipsle || riscv64 || wasm || sw64
 
 package syscall
 
diff --git a/src/syscall/export_linux_sw64_test.go b/src/syscall/export_linux_sw64_test.go
new file mode 100644
index 00000000..6f3a2cc9
--- /dev/null
+++ b/src/syscall/export_linux_sw64_test.go
@@ -0,0 +1,14 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build sw64
+
+package syscall
+
+var (
+	RawSyscallNoError = rawSyscallNoError
+	ForceClone3       = &forceClone3
+)
+
+const Sys_GETEUID = sys_GETXUID
diff --git a/src/syscall/export_linux_test.go b/src/syscall/export_linux_test.go
index 3aa877cf..97e8adad 100644
--- a/src/syscall/export_linux_test.go
+++ b/src/syscall/export_linux_test.go
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
+//go:build !sw64
+
 package syscall
 
 var (
diff --git a/src/syscall/mkall.sh b/src/syscall/mkall.sh
index a3bc7676..d6059d9e 100755
--- a/src/syscall/mkall.sh
+++ b/src/syscall/mkall.sh
@@ -247,6 +247,13 @@ linux_mips64le)
 	mksysnum="./mksysnum_linux.pl $unistd_h"
 	mktypes="GOARCH=$GOARCH go tool cgo -godefs"
 	;;
+linux_sw64)
+        GOOSARCH_in=syscall_linux_sw64.go
+        unistd_h=/usr/include/asm/unistd.h
+        mkerrors="./mkerrors_sw64.sh"
+        mksysnum="./mksysnum_linux.pl $unistd_h"
+        mktypes="GOARCH=$GOARCH go tool cgo -godefs"
+        ;;
 linux_ppc64)
 	GOOSARCH_in=syscall_linux_ppc64x.go
 	unistd_h=/usr/include/asm/unistd.h
diff --git a/src/syscall/mkerrors_sw64.sh b/src/syscall/mkerrors_sw64.sh
new file mode 100755
index 00000000..83137902
--- /dev/null
+++ b/src/syscall/mkerrors_sw64.sh
@@ -0,0 +1,462 @@
+#!/usr/bin/env bash
+# Copyright 2009 The Go Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+
+# Generate Go code listing errors and other #defined constant
+# values (ENAMETOOLONG etc.), by asking the preprocessor
+# about the definitions.
+
+unset LANG
+export LC_ALL=C
+export LC_CTYPE=C
+
+CC=${CC:-gcc}
+
+if [[ "$GOOS" -eq "solaris" ]]; then
+	# Assumes GNU versions of utilities in PATH.
+	export PATH=/usr/gnu/bin:$PATH
+fi
+
+uname=$(uname)
+
+includes_AIX='
+#include <net/if.h>
+#include <net/netopt.h>
+#include <netinet/ip_mroute.h>
+#include <sys/mman.h>
+#include <sys/protosw.h>
+#include <sys/ptrace.h>
+#include <sys/stropts.h>
+#include <termios.h>
+'
+
+includes_Darwin='
+#define _DARWIN_C_SOURCE
+#define KERNEL
+#define _DARWIN_USE_64_BIT_INODE
+#include <sys/types.h>
+#include <sys/event.h>
+#include <sys/ptrace.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/sysctl.h>
+#include <sys/mman.h>
+#include <sys/wait.h>
+#include <net/bpf.h>
+#include <net/if.h>
+#include <net/if_types.h>
+#include <net/route.h>
+#include <netinet/in.h>
+#include <netinet/ip.h>
+#include <netinet/ip_mroute.h>
+#include <termios.h>
+'
+
+includes_DragonFly='
+#include <sys/types.h>
+#include <sys/event.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/sysctl.h>
+#include <sys/mman.h>
+#include <sys/wait.h>
+#include <sys/ioctl.h>
+#include <net/bpf.h>
+#include <net/if.h>
+#include <net/if_types.h>
+#include <net/route.h>
+#include <netinet/in.h>
+#include <termios.h>
+#include <netinet/ip.h>
+#include <net/ip_mroute/ip_mroute.h>
+'
+
+includes_FreeBSD='
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/event.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/sysctl.h>
+#include <sys/mman.h>
+#include <sys/wait.h>
+#include <sys/ioctl.h>
+#include <net/bpf.h>
+#include <net/if.h>
+#include <net/if_types.h>
+#include <net/route.h>
+#include <netinet/in.h>
+#include <termios.h>
+#include <netinet/ip.h>
+#include <netinet/ip_mroute.h>
+
+#if __FreeBSD__ >= 10
+#define IFT_CARP	0xf8	// IFT_CARP is deprecated in FreeBSD 10
+#undef SIOCAIFADDR
+#define SIOCAIFADDR	_IOW(105, 26, struct oifaliasreq)	// ifaliasreq contains if_data
+#undef SIOCSIFPHYADDR
+#define SIOCSIFPHYADDR	_IOW(105, 70, struct oifaliasreq)	// ifaliasreq contains if_data
+#endif
+'
+
+includes_Linux='
+#define _LARGEFILE_SOURCE
+#define _LARGEFILE64_SOURCE
+#ifndef __LP64__
+#define _FILE_OFFSET_BITS 64
+#endif
+#define _GNU_SOURCE
+
+#include <bits/sockaddr.h>
+#include <sys/epoll.h>
+#include <sys/inotify.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/mount.h>
+#include <sys/prctl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/socket.h>
+#include <linux/if.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/if_tun.h>
+#include <linux/if_packet.h>
+#include <linux/if_addr.h>
+#include <linux/filter.h>
+#include <linux/netlink.h>
+#include <linux/reboot.h>
+#include <linux/rtnetlink.h>
+#include <linux/ptrace.h>
+#include <linux/sched.h>
+#include <linux/serial.h>
+#include <linux/wait.h>
+#include <linux/icmpv6.h>
+#include <net/route.h>
+#include <termios.h>
+
+#ifndef MSG_FASTOPEN
+#define MSG_FASTOPEN    0x20000000
+#endif
+
+#ifndef PTRACE_GETREGS
+#define PTRACE_GETREGS	0xc
+#endif
+
+#ifndef PTRACE_SETREGS
+#define PTRACE_SETREGS	0xd
+#endif
+'
+
+includes_NetBSD='
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/event.h>
+#include <sys/mman.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/sysctl.h>
+#include <sys/termios.h>
+#include <sys/ttycom.h>
+#include <sys/wait.h>
+#include <net/bpf.h>
+#include <net/if.h>
+#include <net/if_types.h>
+#include <net/route.h>
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#include <netinet/ip_mroute.h>
+#include <netinet/if_ether.h>
+
+// Needed since <sys/param.h> refers to it...
+#define schedppq 1
+'
+
+includes_OpenBSD='
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/event.h>
+#include <sys/mman.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/sysctl.h>
+#include <sys/termios.h>
+#include <sys/ttycom.h>
+#include <sys/wait.h>
+#include <net/bpf.h>
+#include <net/if.h>
+#include <net/if_types.h>
+#include <net/if_var.h>
+#include <net/route.h>
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#include <netinet/ip_mroute.h>
+#include <netinet/if_ether.h>
+#include <net/if_bridge.h>
+
+// We keep some constants not supported in OpenBSD 5.5 and beyond for
+// the promise of compatibility.
+#define EMUL_ENABLED		0x1
+#define EMUL_NATIVE		0x2
+#define IPV6_FAITH		0x1d
+#define IPV6_OPTIONS		0x1
+#define IPV6_RTHDR_STRICT	0x1
+#define IPV6_SOCKOPT_RESERVED1	0x3
+#define SIOCGIFGENERIC		0xc020693a
+#define SIOCSIFGENERIC		0x80206939
+#define WALTSIG			0x4
+'
+
+includes_SunOS='
+#include <limits.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/mman.h>
+#include <sys/wait.h>
+#include <sys/ioctl.h>
+#include <net/bpf.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <net/if_types.h>
+#include <net/route.h>
+#include <netinet/in.h>
+#include <termios.h>
+#include <netinet/ip.h>
+#include <netinet/ip_mroute.h>
+'
+
+includes='
+#include <sys/types.h>
+#include <sys/file.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/ip.h>
+#include <netinet/ip6.h>
+#include <netinet/tcp.h>
+#include <errno.h>
+#include <sys/signal.h>
+#include <signal.h>
+#include <sys/resource.h>
+'
+
+ccflags="$@"
+
+# Write go tool cgo -godefs input.
+(
+	echo package syscall
+	echo
+	echo '/*'
+	indirect="includes_$(uname)"
+	echo "${!indirect} $includes"
+	echo '*/'
+	echo 'import "C"'
+	echo
+	echo 'const ('
+
+	# The gcc command line prints all the #defines
+	# it encounters while processing the input
+	echo "${!indirect} $includes" | $CC -x c - -E -dM $ccflags |
+	awk '
+		$1 != "#define" || $2 ~ /\(/ || $3 == "" {next}
+
+		$2 ~ /^E([ABCD]X|[BIS]P|[SD]I|S|FL)$/ {next}  # 386 registers
+		$2 ~ /^(SIGEV_|SIGSTKSZ|SIGRT(MIN|MAX))/ {next}
+		$2 ~ /^(SCM_SRCRT)$/ {next}
+		$2 ~ /^(MAP_FAILED)$/ {next}
+		$2 ~ /^CLONE_[A-Z_]+/ {next} # These are defined in exec_linux.go.
+		$2 ~ /^ELF_.*$/ {next}	# <asm/elf.h> contains ELF_ARCH, etc.
+
+		$2 !~ /^ETH_/ &&
+		$2 !~ /^EPROC_/ &&
+		$2 !~ /^EQUIV_/ &&
+		$2 !~ /^EXPR_/ &&
+		$2 ~ /^E[A-Z0-9_]+$/ ||
+		$2 ~ /^B[0-9_]+$/ ||
+		$2 ~ /^V[A-Z0-9]+$/ ||
+		$2 ~ /^CS[A-Z0-9]/ ||
+		$2 ~ /^I(SIG|CANON|CRNL|EXTEN|MAXBEL|STRIP|UTF8)$/ ||
+		$2 ~ /^IGN/ ||
+		$2 ~ /^IX(ON|ANY|OFF)$/ ||
+		$2 ~ /^IN(LCR|PCK)$/ ||
+		$2 ~ /(^FLU?SH)|(FLU?SH$)/ ||
+		$2 ~ /^C(LOCAL|READ)$/ ||
+		$2 == "BRKINT" ||
+		$2 == "HUPCL" ||
+		$2 == "PENDIN" ||
+		$2 == "TOSTOP" ||
+		$2 ~ /^PAR/ ||
+		$2 ~ /^SIG[^_]/ ||
+		$2 ~ /^O[CNPFP][A-Z]+[^_][A-Z]+$/ ||
+		$2 ~ /^IN_/ ||
+		$2 ~ /^LOCK_(SH|EX|NB|UN)$/ ||
+		$2 ~ /^(AF|SOCK|SO|SOL|IPPROTO|IP|IPV6|ICMP6|TCP|EVFILT|NOTE|EV|SHUT|PROT|MAP|PACKET|MSG|SCM|MCL|DT|MADV|PR)_/ ||
+		$2 == "ICMPV6_FILTER" ||
+		$2 == "SOMAXCONN" ||
+		$2 == "NAME_MAX" ||
+		$2 == "IFNAMSIZ" ||
+		$2 ~ /^CTL_(MAXNAME|NET|QUERY)$/ ||
+		$2 ~ /^SYSCTL_VERS/ ||
+		$2 ~ /^(MS|MNT)_/ ||
+		$2 ~ /^TUN(SET|GET|ATTACH|DETACH)/ ||
+		$2 ~ /^(O|F|FD|NAME|S|PTRACE|PT)_/ ||
+		$2 ~ /^LINUX_REBOOT_CMD_/ ||
+		$2 ~ /^LINUX_REBOOT_MAGIC[12]$/ ||
+		$2 !~ "NLA_TYPE_MASK" &&
+		$2 ~ /^(NETLINK|NLM|NLMSG|NLA|IFA|IFAN|RT|RTCF|RTN|RTPROT|RTNH|ARPHRD|ETH_P)_/ ||
+		$2 ~ /^SIOC/ ||
+		($2 ~ /^TIOC/ && $0 !~ /struct/ && $3 !~ "FIONREAD") ||
+		$2 !~ "RTF_BITS" &&
+		$2 ~ /^(IFF|IFT|NET_RT|RTM|RTF|RTV|RTA|RTAX)_/ ||
+		$2 ~ /^BIOC/ ||
+		$2 ~ /^RUSAGE_(SELF|CHILDREN|THREAD)/ ||
+		$2 ~ /^RLIMIT_(AS|CORE|CPU|DATA|FSIZE|NOFILE|STACK)|RLIM_INFINITY/ ||
+		$2 ~ /^PRIO_(PROCESS|PGRP|USER)/ ||
+		$2 !~ /^(BPF_TIMEVAL)$/ &&
+		$2 ~ /^(BPF|DLT)_/ ||
+		$2 !~ "WMESGLEN" &&
+		$2 ~ /^W[A-Z0-9]+$/ {printf("\t%s = C.%s\n", $2, $2)}
+		$2 ~ /^__WCOREFLAG$/ {next}
+		$2 ~ /^__W[A-Z0-9]+$/ {printf("\t%s = C.%s\n", substr($2,3), $2)}
+
+		{next}
+	' | sort
+
+	echo ')'
+) >_const.go
+
+# Pull out the error names for later.
+errors=$(
+	echo '#include <errno.h>' | $CC -x c - -E -dM $ccflags |
+	awk '$1=="#define" && $2 ~ /^E[A-Z0-9_]+$/ { print $2 }' |
+	sort
+)
+
+# Pull out the signal names for later.
+signals=$(
+	echo '#include <signal.h>' | $CC -x c - -E -dM $ccflags |
+	awk '$1=="#define" && $2 ~ /^SIG[A-Z0-9]+$/ { print $2 }' |
+	grep -v 'SIGSTKSIZE\|SIGSTKSZ\|SIGRT' |
+	sort
+)
+
+# Again, writing regexps to a file.
+echo '#include <errno.h>' | $CC -x c - -E -dM $ccflags |
+	awk '$1=="#define" && $2 ~ /^E[A-Z0-9_]+$/ { print "^\t" $2 "[ \t]*=" }' |
+	sort >_error.grep
+echo '#include <signal.h>' | $CC -x c - -E -dM $ccflags |
+	awk '$1=="#define" && $2 ~ /^SIG[A-Z0-9]+$/ { print "^\t" $2 "[ \t]*=" }' |
+	grep -v 'SIGSTKSIZE\|SIGSTKSZ\|SIGRT' |
+	sort >_signal.grep
+
+echo '// mkerrors.sh' "$@"
+echo '// Code generated by the command above; DO NOT EDIT.'
+echo
+go tool cgo -godefs -- "$@" _const.go >_error.out
+cat _error.out | grep -vf _error.grep | grep -vf _signal.grep
+echo
+echo '// Errors'
+echo 'const ('
+cat _error.out | grep -f _error.grep | sed 's/=\(.*\)/= Errno(\1)/'
+echo ')'
+
+echo
+echo '// Signals'
+echo 'const ('
+cat _error.out | grep -f _signal.grep | sed 's/=\(.*\)/= Signal(\1)/'
+echo ')'
+
+# Run C program to print error and syscall strings.
+(
+	echo -E "
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <ctype.h>
+#include <string.h>
+#include <signal.h>
+
+#define nelem(x) (sizeof(x)/sizeof((x)[0]))
+
+enum { A = 'A', Z = 'Z', a = 'a', z = 'z' }; // avoid need for single quotes below
+
+int errors[] = {
+"
+	for i in $errors
+	do
+		echo -E '	'$i,
+	done
+
+	echo -E "
+};
+
+int signals[] = {
+"
+	for i in $signals
+	do
+		echo -E '	'$i,
+	done
+
+	# Use -E because on some systems bash builtin interprets \n itself.
+	echo -E '
+};
+
+static int
+intcmp(const void *a, const void *b)
+{
+	return *(int*)a - *(int*)b;
+}
+
+int
+main(void)
+{
+	int i, j, e;
+	char buf[1024], *p;
+
+	printf("\n\n// Error table\n");
+	printf("var errors = [...]string {\n");
+	qsort(errors, nelem(errors), sizeof errors[0], intcmp);
+	for(i=0; i<nelem(errors); i++) {
+		e = errors[i];
+		if(i > 0 && errors[i-1] == e)
+			continue;
+		strcpy(buf, strerror(e));
+		// lowercase first letter: Bad -> bad, but STREAM -> STREAM.
+		if(A <= buf[0] && buf[0] <= Z && a <= buf[1] && buf[1] <= z)
+			buf[0] += a - A;
+		printf("\t%d: \"%s\",\n", e, buf);
+	}
+	printf("}\n\n");
+	
+	printf("\n\n// Signal table\n");
+	printf("var signals = [...]string {\n");
+	qsort(signals, nelem(signals), sizeof signals[0], intcmp);
+	for(i=0; i<nelem(signals); i++) {
+		e = signals[i];
+		if(i > 0 && signals[i-1] == e)
+			continue;
+		strcpy(buf, strsignal(e));
+		// lowercase first letter: Bad -> bad, but STREAM -> STREAM.
+		if(A <= buf[0] && buf[0] <= Z && a <= buf[1] && buf[1] <= z)
+			buf[0] += a - A;
+		// cut trailing : number.
+		p = strrchr(buf, ":"[0]);
+		if(p)
+			*p = '\0';
+		printf("\t%d: \"%s\",\n", e, buf);
+	}
+	printf("}\n\n");
+
+	return 0;
+}
+
+'
+) >_errors.c
+
+$CC $ccflags -o _errors _errors.c && $GORUN ./_errors && rm -f _errors.c _errors _const.go _error.grep _signal.grep _error.out
diff --git a/src/syscall/setuidgid_linux.go b/src/syscall/setuidgid_linux.go
index c995d258..eaae3deb 100644
--- a/src/syscall/setuidgid_linux.go
+++ b/src/syscall/setuidgid_linux.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build linux && !386 && !arm
+//go:build linux && !386 && !arm && !sw64
 
 package syscall
 
diff --git a/src/syscall/setuidgid_linux_sw64.go b/src/syscall/setuidgid_linux_sw64.go
new file mode 100644
index 00000000..2424af31
--- /dev/null
+++ b/src/syscall/setuidgid_linux_sw64.go
@@ -0,0 +1,22 @@
+// Copyright 2016 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build linux
+// +build sw64
+
+package syscall
+
+const (
+	sys_GETEUID = SYS_GETXUID
+	sys_GETXUID = SYS_GETXUID
+
+	sys_SETGID = SYS_SETGID
+	sys_SETUID = SYS_SETUID
+
+	sys_SETREGID = SYS_SETREGID
+	sys_SETREUID = SYS_SETREUID
+
+	sys_SETRESGID = SYS_SETRESGID
+	sys_SETRESUID = SYS_SETRESUID
+)
diff --git a/src/syscall/syscall_linux_sw64.go b/src/syscall/syscall_linux_sw64.go
new file mode 100644
index 00000000..dd75ca8a
--- /dev/null
+++ b/src/syscall/syscall_linux_sw64.go
@@ -0,0 +1,188 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build linux && sw64
+
+package syscall
+
+import (
+        "unsafe"
+)
+
+const (
+	//generate by handle
+	//_snyh_TODO: this should be generate by improving build script
+	FIOCLEX    = 0x20006601
+	FIONCLEX   = 0x20006602
+	FIOASYNC   = 0xffffffff8004667d
+	FIONBIO    = 0xffffffff8004667e
+	FIONREAD   = 0x4004667f
+	TIOCINQ    = 0x4004667f
+	FIOQSIZE   = 0x40086680
+	TIOCGETP   = 0x40067408
+	TIOCSETP   = 0xffffffff80067409
+	TIOCSETN   = 0xffffffff8006740a
+	TIOCSETC   = 0xffffffff80067411
+	TIOCGETC   = 0x40067412
+	TCSETSW    = 0xffffffff802c7415
+	TCSETSF    = 0xffffffff802c7416
+	TCGETA     = 0x40127417
+	TCSETA     = 0xffffffff80127418
+	TCSETAW    = 0xffffffff80127419
+	TCSETAF    = 0xffffffff8012741c
+	TIOCSWINSZ = 0xffffffff80087467
+	TIOCGWINSZ = 0x40087468
+	TIOCGLTC   = 0x40067474
+	TIOCSLTC   = 0xffffffff80067475
+)
+
+const (
+	//ALL OF THIS constants are WORKAROUND, and should be removing
+	_SYS_dup       = SYS_DUP2
+	_SYS_setgroups = SYS_SETGROUPS
+
+	_SYS_clone3	= 282
+	_SYS_faccessat2 = 286
+	//TODO: support since linux 6.1
+	_SYS_fchmodat2	= 191
+)
+
+//sysnb getxpid() (pid int, ppid int)
+// TODO(snyh):  correct handle Getppid and Getpid
+// currently manually remove the implements of Getpid and Getppid
+// in zsyscall_linux_sw64.go
+func Getpid() (pid int)   { pid, _ = getxpid(); return }
+func Getppid() (ppid int) { _, ppid = getxpid(); return }
+
+// TODO(snyh):  correct handle Utime
+func Utime(path string, buf *Utimbuf) error {
+	tv := [2]Timeval{
+		{Sec: buf.Actime},
+		{Sec: buf.Modtime},
+	}
+	return utimes(path, &tv)
+}
+
+//sys	Fstat64(fd int, st *Stat_t) (err error)
+//sys	Lstat64(path string, st *Stat_t) (err error)
+//sys	Stat64(path string, st *Stat_t) (err error)
+func Fstat(fd int, st *Stat_t) (err error)      { return Fstat64(fd, st) }
+func Lstat(path string, st *Stat_t) (err error) { return Lstat64(path, st) }
+func Stat(path string, st *Stat_t) (err error)  { return Stat64(path, st) }
+
+//sys getxuid() (uid int, euid int)
+func Getuid() (uid int)   { uid, _ = getxuid(); return }
+func Geteuid() (euid int) { _, euid = getxuid(); return }
+
+//sys getxgid() (gid int, egid int)
+func Getgid() (gid int)   { gid, _ = getxgid(); return }
+func Getegid() (egid int) { _, egid = getxgid(); return }
+
+//sys	Statfs(path string, buf *Statfs_t) (err error)
+//sys	Fstatfs(fd int, buf *Statfs_t) (err error)
+//sys	Dup2(oldfd int, newfd int) (err error)
+//sys	Fchown(fd int, uid int, gid int) (err error)
+//sys	Ftruncate(fd int, length int64) (err error)
+//sysnb	Getrlimit(resource int, rlim *Rlimit) (err error)
+//sysnb	InotifyInit() (fd int, err error)
+//sys	Lchown(path string, uid int, gid int) (err error)
+//sys	Listen(s int, n int) (err error)
+//sys	pread(fd int, p []byte, offset int64) (n int, err error) = SYS_PREAD64
+//sys	pwrite(fd int, p []byte, offset int64) (n int, err error) = SYS_PWRITE64
+//sys	Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK
+//sys	sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)
+//sys	Setfsgid(gid int) (err error)
+//sys	Setfsuid(uid int) (err error)
+//sysnb	setrlimit(resource int, rlim *Rlimit) (err error) = SYS_SETRLIMIT
+//sys	Shutdown(fd int, how int) (err error)
+//sys	Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)
+
+//sys	SyncFileRange(fd int, off int64, n int64, flags int) (err error)
+//sys	Truncate(path string, length int64) (err error)
+//sys	accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)
+//sys	bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)
+//sys	connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)
+//sysnb	getgroups(n int, list *_Gid_t) (nn int, err error)
+//sys	getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)
+//sys	setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)
+//sysnb	socket(domain int, typ int, proto int) (fd int, err error)
+//sysnb	socketpair(domain int, typ int, proto int, fd *[2]int32) (err error)
+//sysnb	getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)
+//sysnb	getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)
+//sys	recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)
+//sys	sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)
+//sys	recvmsg(s int, msg *Msghdr, flags int) (n int, err error)
+//sys	sendmsg(s int, msg *Msghdr, flags int) (n int, err error)
+//sys	mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)
+
+type sigset_t struct {
+	X__val [16]uint64
+}
+
+//sys	pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *sigset_t) (n int, err error) = SYS_PSELECT6
+
+func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {
+	ts := Timespec{Sec: timeout.Sec, Nsec: timeout.Usec * 1000}
+	return pselect(nfd, r, w, e, &ts, nil)
+}
+
+//sysnb	Gettimeofday(tv *Timeval) (err error)
+
+func Time(t *Time_t) (tt Time_t, err error) {
+	var tv Timeval
+	err = Gettimeofday(&tv)
+	if err != nil {
+		return 0, err
+	}
+	if t != nil {
+		*t = Time_t(tv.Sec)
+	}
+	return Time_t(tv.Sec), nil
+}
+
+//go:nosplit
+func rawSetrlimit(resource int, rlim *Rlimit) Errno {
+        _, _, errno := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
+        return errno
+}
+
+func setTimespec(sec, nsec int64) Timespec {
+	return Timespec{Sec: sec, Nsec: nsec}
+}
+
+func setTimeval(sec, usec int64) Timeval {
+	return Timeval{Sec: sec, Usec: usec}
+}
+
+func Ioperm(from int, num int, on int) (err error) {
+	return ENOSYS
+}
+
+func Iopl(level int) (err error) {
+	return ENOSYS
+}
+
+// func (r *PtraceRegs) PC() uint64 { return r.Regs[64] }
+
+// func (r *PtraceRegs) SetPC(pc uint64) { r.Regs[64] = pc }
+
+func (iov *Iovec) SetLen(length int) {
+	iov.Len = uint64(length)
+}
+
+func (msghdr *Msghdr) SetControllen(length int) {
+	msghdr.Controllen = uint64(length)
+}
+
+func (cmsg *Cmsghdr) SetLen(length int) {
+	cmsg.Len = uint64(length)
+}
+
+//zxw new add
+//sys	Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)
+//sys	Ustat(dev int, ubuf *Ustat_t) (err error)
+//sys	futimesat(dirfd int, path string, times *[2]Timeval) (err error)
+//sys	utimes(path string, times *[2]Timeval) (err error)
+//sys   fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_FSTATAT64
+//sys   EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error)
diff --git a/src/syscall/zerrors_linux_sw64.go b/src/syscall/zerrors_linux_sw64.go
new file mode 100644
index 00000000..1a20e3ae
--- /dev/null
+++ b/src/syscall/zerrors_linux_sw64.go
@@ -0,0 +1,2100 @@
+// mkerrors.sh
+// Code generated by the command above; DO NOT EDIT.
+
+// Code generated by cmd/cgo -godefs; DO NOT EDIT.
+// cgo -godefs -- /home/zhangjh/golang/src/syscall/_const.go
+
+package syscall
+
+const (
+	AF_ALG                           = 0x26
+	AF_APPLETALK                     = 0x5
+	AF_ASH                           = 0x12
+	AF_ATMPVC                        = 0x8
+	AF_ATMSVC                        = 0x14
+	AF_AX25                          = 0x3
+	AF_BLUETOOTH                     = 0x1f
+	AF_BRIDGE                        = 0x7
+	AF_CAIF                          = 0x25
+	AF_CAN                           = 0x1d
+	AF_DECnet                        = 0xc
+	AF_ECONET                        = 0x13
+	AF_FILE                          = 0x1
+	AF_IB                            = 0x1b
+	AF_IEEE802154                    = 0x24
+	AF_INET                          = 0x2
+	AF_INET6                         = 0xa
+	AF_IPX                           = 0x4
+	AF_IRDA                          = 0x17
+	AF_ISDN                          = 0x22
+	AF_IUCV                          = 0x20
+	AF_KCM                           = 0x29
+	AF_KEY                           = 0xf
+	AF_LLC                           = 0x1a
+	AF_LOCAL                         = 0x1
+	AF_MAX                           = 0x2d
+	AF_MPLS                          = 0x1c
+	AF_NETBEUI                       = 0xd
+	AF_NETLINK                       = 0x10
+	AF_NETROM                        = 0x6
+	AF_NFC                           = 0x27
+	AF_PACKET                        = 0x11
+	AF_PHONET                        = 0x23
+	AF_PPPOX                         = 0x18
+	AF_QIPCRTR                       = 0x2a
+	AF_RDS                           = 0x15
+	AF_ROSE                          = 0xb
+	AF_ROUTE                         = 0x10
+	AF_RXRPC                         = 0x21
+	AF_SECURITY                      = 0xe
+	AF_SMC                           = 0x2b
+	AF_SNA                           = 0x16
+	AF_TIPC                          = 0x1e
+	AF_UNIX                          = 0x1
+	AF_UNSPEC                        = 0x0
+	AF_VSOCK                         = 0x28
+	AF_WANPIPE                       = 0x19
+	AF_X25                           = 0x9
+	AF_XDP                           = 0x2c
+	ARPHRD_6LOWPAN                   = 0x339
+	ARPHRD_ADAPT                     = 0x108
+	ARPHRD_APPLETLK                  = 0x8
+	ARPHRD_ARCNET                    = 0x7
+	ARPHRD_ASH                       = 0x30d
+	ARPHRD_ATM                       = 0x13
+	ARPHRD_AX25                      = 0x3
+	ARPHRD_BIF                       = 0x307
+	ARPHRD_CAIF                      = 0x336
+	ARPHRD_CAN                       = 0x118
+	ARPHRD_CHAOS                     = 0x5
+	ARPHRD_CISCO                     = 0x201
+	ARPHRD_CSLIP                     = 0x101
+	ARPHRD_CSLIP6                    = 0x103
+	ARPHRD_DDCMP                     = 0x205
+	ARPHRD_DLCI                      = 0xf
+	ARPHRD_ECONET                    = 0x30e
+	ARPHRD_EETHER                    = 0x2
+	ARPHRD_ETHER                     = 0x1
+	ARPHRD_EUI64                     = 0x1b
+	ARPHRD_FCAL                      = 0x311
+	ARPHRD_FCFABRIC                  = 0x313
+	ARPHRD_FCPL                      = 0x312
+	ARPHRD_FCPP                      = 0x310
+	ARPHRD_FDDI                      = 0x306
+	ARPHRD_FRAD                      = 0x302
+	ARPHRD_HDLC                      = 0x201
+	ARPHRD_HIPPI                     = 0x30c
+	ARPHRD_HWX25                     = 0x110
+	ARPHRD_IEEE1394                  = 0x18
+	ARPHRD_IEEE802                   = 0x6
+	ARPHRD_IEEE80211                 = 0x321
+	ARPHRD_IEEE80211_PRISM           = 0x322
+	ARPHRD_IEEE80211_RADIOTAP        = 0x323
+	ARPHRD_IEEE802154                = 0x324
+	ARPHRD_IEEE802154_MONITOR        = 0x325
+	ARPHRD_IEEE802_TR                = 0x320
+	ARPHRD_INFINIBAND                = 0x20
+	ARPHRD_IP6GRE                    = 0x337
+	ARPHRD_IPDDP                     = 0x309
+	ARPHRD_IPGRE                     = 0x30a
+	ARPHRD_IRDA                      = 0x30f
+	ARPHRD_LAPB                      = 0x204
+	ARPHRD_LOCALTLK                  = 0x305
+	ARPHRD_LOOPBACK                  = 0x304
+	ARPHRD_METRICOM                  = 0x17
+	ARPHRD_NETLINK                   = 0x338
+	ARPHRD_NETROM                    = 0x0
+	ARPHRD_NONE                      = 0xfffe
+	ARPHRD_PHONET                    = 0x334
+	ARPHRD_PHONET_PIPE               = 0x335
+	ARPHRD_PIMREG                    = 0x30b
+	ARPHRD_PPP                       = 0x200
+	ARPHRD_PRONET                    = 0x4
+	ARPHRD_RAWHDLC                   = 0x206
+	ARPHRD_RAWIP                     = 0x207
+	ARPHRD_ROSE                      = 0x10e
+	ARPHRD_RSRVD                     = 0x104
+	ARPHRD_SIT                       = 0x308
+	ARPHRD_SKIP                      = 0x303
+	ARPHRD_SLIP                      = 0x100
+	ARPHRD_SLIP6                     = 0x102
+	ARPHRD_TUNNEL                    = 0x300
+	ARPHRD_TUNNEL6                   = 0x301
+	ARPHRD_VOID                      = 0xffff
+	ARPHRD_VSOCKMON                  = 0x33a
+	ARPHRD_X25                       = 0x10f
+	B0                               = 0x0
+	B1000000                         = 0x17
+	B110                             = 0x3
+	B115200                          = 0x11
+	B1152000                         = 0x18
+	B1200                            = 0x9
+	B134                             = 0x4
+	B150                             = 0x5
+	B1500000                         = 0x19
+	B1800                            = 0xa
+	B19200                           = 0xe
+	B200                             = 0x6
+	B2000000                         = 0x1a
+	B230400                          = 0x12
+	B2400                            = 0xb
+	B2500000                         = 0x1b
+	B300                             = 0x7
+	B3000000                         = 0x1c
+	B3500000                         = 0x1d
+	B38400                           = 0xf
+	B4000000                         = 0x1e
+	B460800                          = 0x13
+	B4800                            = 0xc
+	B50                              = 0x1
+	B500000                          = 0x14
+	B57600                           = 0x10
+	B576000                          = 0x15
+	B600                             = 0x8
+	B75                              = 0x2
+	B921600                          = 0x16
+	B9600                            = 0xd
+	BPF_A                            = 0x10
+	BPF_ABS                          = 0x20
+	BPF_ADD                          = 0x0
+	BPF_ALU                          = 0x4
+	BPF_AND                          = 0x50
+	BPF_B                            = 0x10
+	BPF_DIV                          = 0x30
+	BPF_H                            = 0x8
+	BPF_IMM                          = 0x0
+	BPF_IND                          = 0x40
+	BPF_JA                           = 0x0
+	BPF_JEQ                          = 0x10
+	BPF_JGE                          = 0x30
+	BPF_JGT                          = 0x20
+	BPF_JMP                          = 0x5
+	BPF_JSET                         = 0x40
+	BPF_K                            = 0x0
+	BPF_LD                           = 0x0
+	BPF_LDX                          = 0x1
+	BPF_LEN                          = 0x80
+	BPF_LL_OFF                       = -0x200000
+	BPF_LSH                          = 0x60
+	BPF_MAJOR_VERSION                = 0x1
+	BPF_MAXINSNS                     = 0x1000
+	BPF_MEM                          = 0x60
+	BPF_MEMWORDS                     = 0x10
+	BPF_MINOR_VERSION                = 0x1
+	BPF_MISC                         = 0x7
+	BPF_MOD                          = 0x90
+	BPF_MSH                          = 0xa0
+	BPF_MUL                          = 0x20
+	BPF_NEG                          = 0x80
+	BPF_NET_OFF                      = -0x100000
+	BPF_OR                           = 0x40
+	BPF_RET                          = 0x6
+	BPF_RSH                          = 0x70
+	BPF_ST                           = 0x2
+	BPF_STX                          = 0x3
+	BPF_SUB                          = 0x10
+	BPF_TAX                          = 0x0
+	BPF_TXA                          = 0x80
+	BPF_W                            = 0x0
+	BPF_X                            = 0x8
+	BPF_XOR                          = 0xa0
+	BRKINT                           = 0x2
+	CFLUSH                           = 0xf
+	CLOCAL                           = 0x8000
+	CREAD                            = 0x800
+	CS5                              = 0x0
+	CS6                              = 0x100
+	CS7                              = 0x200
+	CS8                              = 0x300
+	CSIGNAL                          = 0xff
+	CSIZE                            = 0x300
+	CSTART                           = 0x11
+	CSTATUS                          = 0x0
+	CSTOP                            = 0x13
+	CSTOPB                           = 0x400
+	CSUSP                            = 0x1a
+	DT_BLK                           = 0x6
+	DT_CHR                           = 0x2
+	DT_DIR                           = 0x4
+	DT_FIFO                          = 0x1
+	DT_LNK                           = 0xa
+	DT_REG                           = 0x8
+	DT_SOCK                          = 0xc
+	DT_UNKNOWN                       = 0x0
+	DT_WHT                           = 0xe
+	ECHO                             = 0x8
+	ECHOCTL                          = 0x40
+	ECHOE                            = 0x2
+	ECHOK                            = 0x4
+	ECHOKE                           = 0x1
+	ECHONL                           = 0x10
+	ECHOPRT                          = 0x20
+	ENCODING_DEFAULT                 = 0x0
+	ENCODING_FM_MARK                 = 0x3
+	ENCODING_FM_SPACE                = 0x4
+	ENCODING_MANCHESTER              = 0x5
+	ENCODING_NRZ                     = 0x1
+	ENCODING_NRZI                    = 0x2
+	EPOLLERR                         = 0x8
+	EPOLLET                          = 0x80000000
+	EPOLLEXCLUSIVE                   = 0x10000000
+	EPOLLHUP                         = 0x10
+	EPOLLIN                          = 0x1
+	EPOLLMSG                         = 0x400
+	EPOLLONESHOT                     = 0x40000000
+	EPOLLOUT                         = 0x4
+	EPOLLPRI                         = 0x2
+	EPOLLRDBAND                      = 0x80
+	EPOLLRDHUP                       = 0x2000
+	EPOLLRDNORM                      = 0x40
+	EPOLLWAKEUP                      = 0x20000000
+	EPOLLWRBAND                      = 0x200
+	EPOLLWRNORM                      = 0x100
+	EPOLL_CLOEXEC                    = 0x200000
+	EPOLL_CTL_ADD                    = 0x1
+	EPOLL_CTL_DEL                    = 0x2
+	EPOLL_CTL_MOD                    = 0x3
+	ETH_P_1588                       = 0x88f7
+	ETH_P_8021AD                     = 0x88a8
+	ETH_P_8021AH                     = 0x88e7
+	ETH_P_8021Q                      = 0x8100
+	ETH_P_80221                      = 0x8917
+	ETH_P_802_2                      = 0x4
+	ETH_P_802_3                      = 0x1
+	ETH_P_802_3_MIN                  = 0x600
+	ETH_P_802_EX1                    = 0x88b5
+	ETH_P_AARP                       = 0x80f3
+	ETH_P_AF_IUCV                    = 0xfbfb
+	ETH_P_ALL                        = 0x3
+	ETH_P_AOE                        = 0x88a2
+	ETH_P_ARCNET                     = 0x1a
+	ETH_P_ARP                        = 0x806
+	ETH_P_ATALK                      = 0x809b
+	ETH_P_ATMFATE                    = 0x8884
+	ETH_P_ATMMPOA                    = 0x884c
+	ETH_P_AX25                       = 0x2
+	ETH_P_BATMAN                     = 0x4305
+	ETH_P_BPQ                        = 0x8ff
+	ETH_P_CAIF                       = 0xf7
+	ETH_P_CAN                        = 0xc
+	ETH_P_CANFD                      = 0xd
+	ETH_P_CONTROL                    = 0x16
+	ETH_P_CUST                       = 0x6006
+	ETH_P_DDCMP                      = 0x6
+	ETH_P_DEC                        = 0x6000
+	ETH_P_DIAG                       = 0x6005
+	ETH_P_DNA_DL                     = 0x6001
+	ETH_P_DNA_RC                     = 0x6002
+	ETH_P_DNA_RT                     = 0x6003
+	ETH_P_DSA                        = 0x1b
+	ETH_P_DSA_8021Q                  = 0xdadb
+	ETH_P_ECONET                     = 0x18
+	ETH_P_EDSA                       = 0xdada
+	ETH_P_ERSPAN                     = 0x88be
+	ETH_P_ERSPAN2                    = 0x22eb
+	ETH_P_FCOE                       = 0x8906
+	ETH_P_FIP                        = 0x8914
+	ETH_P_HDLC                       = 0x19
+	ETH_P_HSR                        = 0x892f
+	ETH_P_IBOE                       = 0x8915
+	ETH_P_IEEE802154                 = 0xf6
+	ETH_P_IEEEPUP                    = 0xa00
+	ETH_P_IEEEPUPAT                  = 0xa01
+	ETH_P_IFE                        = 0xed3e
+	ETH_P_IP                         = 0x800
+	ETH_P_IPV6                       = 0x86dd
+	ETH_P_IPX                        = 0x8137
+	ETH_P_IRDA                       = 0x17
+	ETH_P_LAT                        = 0x6004
+	ETH_P_LINK_CTL                   = 0x886c
+	ETH_P_LLDP                       = 0x88cc
+	ETH_P_LOCALTALK                  = 0x9
+	ETH_P_LOOP                       = 0x60
+	ETH_P_LOOPBACK                   = 0x9000
+	ETH_P_MACSEC                     = 0x88e5
+	ETH_P_MAP                        = 0xf9
+	ETH_P_MOBITEX                    = 0x15
+	ETH_P_MPLS_MC                    = 0x8848
+	ETH_P_MPLS_UC                    = 0x8847
+	ETH_P_MRP                        = 0x88e3
+	ETH_P_MVRP                       = 0x88f5
+	ETH_P_NCSI                       = 0x88f8
+	ETH_P_NSH                        = 0x894f
+	ETH_P_PAE                        = 0x888e
+	ETH_P_PAUSE                      = 0x8808
+	ETH_P_PHONET                     = 0xf5
+	ETH_P_PPPTALK                    = 0x10
+	ETH_P_PPP_DISC                   = 0x8863
+	ETH_P_PPP_MP                     = 0x8
+	ETH_P_PPP_SES                    = 0x8864
+	ETH_P_PREAUTH                    = 0x88c7
+	ETH_P_PRP                        = 0x88fb
+	ETH_P_PUP                        = 0x200
+	ETH_P_PUPAT                      = 0x201
+	ETH_P_QINQ1                      = 0x9100
+	ETH_P_QINQ2                      = 0x9200
+	ETH_P_QINQ3                      = 0x9300
+	ETH_P_RARP                       = 0x8035
+	ETH_P_SCA                        = 0x6007
+	ETH_P_SLOW                       = 0x8809
+	ETH_P_SNAP                       = 0x5
+	ETH_P_TDLS                       = 0x890d
+	ETH_P_TEB                        = 0x6558
+	ETH_P_TIPC                       = 0x88ca
+	ETH_P_TRAILER                    = 0x1c
+	ETH_P_TR_802_2                   = 0x11
+	ETH_P_TSN                        = 0x22f0
+	ETH_P_WAN_PPP                    = 0x7
+	ETH_P_WCCP                       = 0x883e
+	ETH_P_X25                        = 0x805
+	ETH_P_XDSA                       = 0xf8
+	EXTA                             = 0xe
+	EXTB                             = 0xf
+	FD_CLOEXEC                       = 0x1
+	FD_SETSIZE                       = 0x400
+	FLUSHO                           = 0x800000
+	F_ADD_SEALS                      = 0x409
+	F_DUPFD                          = 0x0
+	F_DUPFD_CLOEXEC                  = 0x406
+	F_EXLCK                          = 0x10
+	F_GETFD                          = 0x1
+	F_GETFL                          = 0x3
+	F_GETLEASE                       = 0x401
+	F_GETLK                          = 0x7
+	F_GETLK64                        = 0x7
+	F_GETOWN                         = 0x6
+	F_GETOWN_EX                      = 0x10
+	F_GETPIPE_SZ                     = 0x408
+	F_GETSIG                         = 0xb
+	F_GET_FILE_RW_HINT               = 0x40d
+	F_GET_RW_HINT                    = 0x40b
+	F_GET_SEALS                      = 0x40a
+	F_LOCK                           = 0x1
+	F_NOTIFY                         = 0x402
+	F_OFD_GETLK                      = 0x24
+	F_OFD_SETLK                      = 0x25
+	F_OFD_SETLKW                     = 0x26
+	F_OK                             = 0x0
+	F_RDLCK                          = 0x1
+	F_SEAL_FUTURE_WRITE              = 0x10
+	F_SEAL_GROW                      = 0x4
+	F_SEAL_SEAL                      = 0x1
+	F_SEAL_SHRINK                    = 0x2
+	F_SEAL_WRITE                     = 0x8
+	F_SETFD                          = 0x2
+	F_SETFL                          = 0x4
+	F_SETLEASE                       = 0x400
+	F_SETLK                          = 0x8
+	F_SETLK64                        = 0x8
+	F_SETLKW                         = 0x9
+	F_SETLKW64                       = 0x9
+	F_SETOWN                         = 0x5
+	F_SETOWN_EX                      = 0xf
+	F_SETPIPE_SZ                     = 0x407
+	F_SETSIG                         = 0xa
+	F_SET_FILE_RW_HINT               = 0x40e
+	F_SET_RW_HINT                    = 0x40c
+	F_SHLCK                          = 0x20
+	F_TEST                           = 0x3
+	F_TLOCK                          = 0x2
+	F_ULOCK                          = 0x0
+	F_UNLCK                          = 0x8
+	F_WRLCK                          = 0x2
+	HUPCL                            = 0x4000
+	ICANON                           = 0x100
+	ICMPV6_FILTER                    = 0x1
+	ICRNL                            = 0x100
+	IEXTEN                           = 0x400
+	IFA_F_DADFAILED                  = 0x8
+	IFA_F_DEPRECATED                 = 0x20
+	IFA_F_HOMEADDRESS                = 0x10
+	IFA_F_MANAGETEMPADDR             = 0x100
+	IFA_F_MCAUTOJOIN                 = 0x400
+	IFA_F_NODAD                      = 0x2
+	IFA_F_NOPREFIXROUTE              = 0x200
+	IFA_F_OPTIMISTIC                 = 0x4
+	IFA_F_PERMANENT                  = 0x80
+	IFA_F_SECONDARY                  = 0x1
+	IFA_F_STABLE_PRIVACY             = 0x800
+	IFA_F_TEMPORARY                  = 0x1
+	IFA_F_TENTATIVE                  = 0x40
+	IFA_MAX                          = 0xa
+	IFF_ALLMULTI                     = 0x200
+	IFF_ATTACH_QUEUE                 = 0x200
+	IFF_AUTOMEDIA                    = 0x4000
+	IFF_BROADCAST                    = 0x2
+	IFF_DEBUG                        = 0x4
+	IFF_DETACH_QUEUE                 = 0x400
+	IFF_DORMANT                      = 0x20000
+	IFF_DYNAMIC                      = 0x8000
+	IFF_ECHO                         = 0x40000
+	IFF_LOOPBACK                     = 0x8
+	IFF_LOWER_UP                     = 0x10000
+	IFF_MASTER                       = 0x400
+	IFF_MULTICAST                    = 0x1000
+	IFF_MULTI_QUEUE                  = 0x100
+	IFF_NAPI                         = 0x10
+	IFF_NAPI_FRAGS                   = 0x20
+	IFF_NOARP                        = 0x80
+	IFF_NOFILTER                     = 0x1000
+	IFF_NOTRAILERS                   = 0x20
+	IFF_NO_PI                        = 0x1000
+	IFF_ONE_QUEUE                    = 0x2000
+	IFF_PERSIST                      = 0x800
+	IFF_POINTOPOINT                  = 0x10
+	IFF_PORTSEL                      = 0x2000
+	IFF_PROMISC                      = 0x100
+	IFF_RUNNING                      = 0x40
+	IFF_SLAVE                        = 0x800
+	IFF_TAP                          = 0x2
+	IFF_TUN                          = 0x1
+	IFF_TUN_EXCL                     = 0x8000
+	IFF_UP                           = 0x1
+	IFF_VNET_HDR                     = 0x4000
+	IFF_VOLATILE                     = 0x70c5a
+	IFNAMSIZ                         = 0x10
+	IGNBRK                           = 0x1
+	IGNCR                            = 0x80
+	IGNPAR                           = 0x4
+	IMAXBEL                          = 0x2000
+	INLCR                            = 0x40
+	INPCK                            = 0x10
+	IN_ACCESS                        = 0x1
+	IN_ALL_EVENTS                    = 0xfff
+	IN_ATTRIB                        = 0x4
+	IN_CLASSA_HOST                   = 0xffffff
+	IN_CLASSA_MAX                    = 0x80
+	IN_CLASSA_NET                    = 0xff000000
+	IN_CLASSA_NSHIFT                 = 0x18
+	IN_CLASSB_HOST                   = 0xffff
+	IN_CLASSB_MAX                    = 0x10000
+	IN_CLASSB_NET                    = 0xffff0000
+	IN_CLASSB_NSHIFT                 = 0x10
+	IN_CLASSC_HOST                   = 0xff
+	IN_CLASSC_NET                    = 0xffffff00
+	IN_CLASSC_NSHIFT                 = 0x8
+	IN_CLOEXEC                       = 0x200000
+	IN_CLOSE                         = 0x18
+	IN_CLOSE_NOWRITE                 = 0x10
+	IN_CLOSE_WRITE                   = 0x8
+	IN_CREATE                        = 0x100
+	IN_DELETE                        = 0x200
+	IN_DELETE_SELF                   = 0x400
+	IN_DONT_FOLLOW                   = 0x2000000
+	IN_EXCL_UNLINK                   = 0x4000000
+	IN_IGNORED                       = 0x8000
+	IN_ISDIR                         = 0x40000000
+	IN_LOOPBACKNET                   = 0x7f
+	IN_MASK_ADD                      = 0x20000000
+	IN_MASK_CREATE                   = 0x10000000
+	IN_MODIFY                        = 0x2
+	IN_MOVE                          = 0xc0
+	IN_MOVED_FROM                    = 0x40
+	IN_MOVED_TO                      = 0x80
+	IN_MOVE_SELF                     = 0x800
+	IN_NONBLOCK                      = 0x4
+	IN_ONESHOT                       = 0x80000000
+	IN_ONLYDIR                       = 0x1000000
+	IN_OPEN                          = 0x20
+	IN_Q_OVERFLOW                    = 0x4000
+	IN_UNMOUNT                       = 0x2000
+	IPPROTO_AH                       = 0x33
+	IPPROTO_BEETPH                   = 0x5e
+	IPPROTO_COMP                     = 0x6c
+	IPPROTO_DCCP                     = 0x21
+	IPPROTO_DSTOPTS                  = 0x3c
+	IPPROTO_EGP                      = 0x8
+	IPPROTO_ENCAP                    = 0x62
+	IPPROTO_ESP                      = 0x32
+	IPPROTO_ETHERNET                 = 0x8f
+	IPPROTO_FRAGMENT                 = 0x2c
+	IPPROTO_GRE                      = 0x2f
+	IPPROTO_HOPOPTS                  = 0x0
+	IPPROTO_ICMP                     = 0x1
+	IPPROTO_ICMPV6                   = 0x3a
+	IPPROTO_IDP                      = 0x16
+	IPPROTO_IGMP                     = 0x2
+	IPPROTO_IP                       = 0x0
+	IPPROTO_IPIP                     = 0x4
+	IPPROTO_IPV6                     = 0x29
+	IPPROTO_MH                       = 0x87
+	IPPROTO_MPLS                     = 0x89
+	IPPROTO_MPTCP                    = 0x106
+	IPPROTO_MTP                      = 0x5c
+	IPPROTO_NONE                     = 0x3b
+	IPPROTO_PIM                      = 0x67
+	IPPROTO_PUP                      = 0xc
+	IPPROTO_RAW                      = 0xff
+	IPPROTO_ROUTING                  = 0x2b
+	IPPROTO_RSVP                     = 0x2e
+	IPPROTO_SCTP                     = 0x84
+	IPPROTO_TCP                      = 0x6
+	IPPROTO_TP                       = 0x1d
+	IPPROTO_UDP                      = 0x11
+	IPPROTO_UDPLITE                  = 0x88
+	IPV6_2292DSTOPTS                 = 0x4
+	IPV6_2292HOPLIMIT                = 0x8
+	IPV6_2292HOPOPTS                 = 0x3
+	IPV6_2292PKTINFO                 = 0x2
+	IPV6_2292PKTOPTIONS              = 0x6
+	IPV6_2292RTHDR                   = 0x5
+	IPV6_ADDRFORM                    = 0x1
+	IPV6_ADDR_PREFERENCES            = 0x48
+	IPV6_ADD_MEMBERSHIP              = 0x14
+	IPV6_AUTHHDR                     = 0xa
+	IPV6_AUTOFLOWLABEL               = 0x46
+	IPV6_CHECKSUM                    = 0x7
+	IPV6_DONTFRAG                    = 0x3e
+	IPV6_DROP_MEMBERSHIP             = 0x15
+	IPV6_DSTOPTS                     = 0x3b
+	IPV6_FREEBIND                    = 0x4e
+	IPV6_HDRINCL                     = 0x24
+	IPV6_HOPLIMIT                    = 0x34
+	IPV6_HOPOPTS                     = 0x36
+	IPV6_IPSEC_POLICY                = 0x22
+	IPV6_JOIN_ANYCAST                = 0x1b
+	IPV6_JOIN_GROUP                  = 0x14
+	IPV6_LEAVE_ANYCAST               = 0x1c
+	IPV6_LEAVE_GROUP                 = 0x15
+	IPV6_MINHOPCOUNT                 = 0x49
+	IPV6_MTU                         = 0x18
+	IPV6_MTU_DISCOVER                = 0x17
+	IPV6_MULTICAST_ALL               = 0x1d
+	IPV6_MULTICAST_HOPS              = 0x12
+	IPV6_MULTICAST_IF                = 0x11
+	IPV6_MULTICAST_LOOP              = 0x13
+	IPV6_NEXTHOP                     = 0x9
+	IPV6_ORIGDSTADDR                 = 0x4a
+	IPV6_PATHMTU                     = 0x3d
+	IPV6_PKTINFO                     = 0x32
+	IPV6_PMTUDISC_DO                 = 0x2
+	IPV6_PMTUDISC_DONT               = 0x0
+	IPV6_PMTUDISC_INTERFACE          = 0x4
+	IPV6_PMTUDISC_OMIT               = 0x5
+	IPV6_PMTUDISC_PROBE              = 0x3
+	IPV6_PMTUDISC_WANT               = 0x1
+	IPV6_RECVDSTOPTS                 = 0x3a
+	IPV6_RECVERR                     = 0x19
+	IPV6_RECVERR_RFC4884             = 0x1f
+	IPV6_RECVFRAGSIZE                = 0x4d
+	IPV6_RECVHOPLIMIT                = 0x33
+	IPV6_RECVHOPOPTS                 = 0x35
+	IPV6_RECVORIGDSTADDR             = 0x4a
+	IPV6_RECVPATHMTU                 = 0x3c
+	IPV6_RECVPKTINFO                 = 0x31
+	IPV6_RECVRTHDR                   = 0x38
+	IPV6_RECVTCLASS                  = 0x42
+	IPV6_ROUTER_ALERT                = 0x16
+	IPV6_ROUTER_ALERT_ISOLATE        = 0x1e
+	IPV6_RTHDR                       = 0x39
+	IPV6_RTHDRDSTOPTS                = 0x37
+	IPV6_RTHDR_LOOSE                 = 0x0
+	IPV6_RTHDR_STRICT                = 0x1
+	IPV6_RTHDR_TYPE_0                = 0x0
+	IPV6_RXDSTOPTS                   = 0x3b
+	IPV6_RXHOPOPTS                   = 0x36
+	IPV6_TCLASS                      = 0x43
+	IPV6_TRANSPARENT                 = 0x4b
+	IPV6_UNICAST_HOPS                = 0x10
+	IPV6_UNICAST_IF                  = 0x4c
+	IPV6_V6ONLY                      = 0x1a
+	IPV6_XFRM_POLICY                 = 0x23
+	IP_ADD_MEMBERSHIP                = 0x23
+	IP_ADD_SOURCE_MEMBERSHIP         = 0x27
+	IP_BIND_ADDRESS_NO_PORT          = 0x18
+	IP_BLOCK_SOURCE                  = 0x26
+	IP_CHECKSUM                      = 0x17
+	IP_DEFAULT_MULTICAST_LOOP        = 0x1
+	IP_DEFAULT_MULTICAST_TTL         = 0x1
+	IP_DF                            = 0x4000
+	IP_DROP_MEMBERSHIP               = 0x24
+	IP_DROP_SOURCE_MEMBERSHIP        = 0x28
+	IP_FREEBIND                      = 0xf
+	IP_HDRINCL                       = 0x3
+	IP_IPSEC_POLICY                  = 0x10
+	IP_MAXPACKET                     = 0xffff
+	IP_MAX_MEMBERSHIPS               = 0x14
+	IP_MF                            = 0x2000
+	IP_MINTTL                        = 0x15
+	IP_MSFILTER                      = 0x29
+	IP_MSS                           = 0x240
+	IP_MTU                           = 0xe
+	IP_MTU_DISCOVER                  = 0xa
+	IP_MULTICAST_ALL                 = 0x31
+	IP_MULTICAST_IF                  = 0x20
+	IP_MULTICAST_LOOP                = 0x22
+	IP_MULTICAST_TTL                 = 0x21
+	IP_NODEFRAG                      = 0x16
+	IP_OFFMASK                       = 0x1fff
+	IP_OPTIONS                       = 0x4
+	IP_ORIGDSTADDR                   = 0x14
+	IP_PASSSEC                       = 0x12
+	IP_PKTINFO                       = 0x8
+	IP_PKTOPTIONS                    = 0x9
+	IP_PMTUDISC                      = 0xa
+	IP_PMTUDISC_DO                   = 0x2
+	IP_PMTUDISC_DONT                 = 0x0
+	IP_PMTUDISC_INTERFACE            = 0x4
+	IP_PMTUDISC_OMIT                 = 0x5
+	IP_PMTUDISC_PROBE                = 0x3
+	IP_PMTUDISC_WANT                 = 0x1
+	IP_RECVERR                       = 0xb
+	IP_RECVERR_RFC4884               = 0x1a
+	IP_RECVFRAGSIZE                  = 0x19
+	IP_RECVOPTS                      = 0x6
+	IP_RECVORIGDSTADDR               = 0x14
+	IP_RECVRETOPTS                   = 0x7
+	IP_RECVTOS                       = 0xd
+	IP_RECVTTL                       = 0xc
+	IP_RETOPTS                       = 0x7
+	IP_RF                            = 0x8000
+	IP_ROUTER_ALERT                  = 0x5
+	IP_TOS                           = 0x1
+	IP_TRANSPARENT                   = 0x13
+	IP_TTL                           = 0x2
+	IP_UNBLOCK_SOURCE                = 0x25
+	IP_UNICAST_IF                    = 0x32
+	IP_XFRM_POLICY                   = 0x11
+	ISIG                             = 0x80
+	ISTRIP                           = 0x20
+	IUTF8                            = 0x4000
+	IXANY                            = 0x800
+	IXOFF                            = 0x400
+	IXON                             = 0x200
+	LINUX_REBOOT_CMD_CAD_OFF         = 0x0
+	LINUX_REBOOT_CMD_CAD_ON          = 0x89abcdef
+	LINUX_REBOOT_CMD_HALT            = 0xcdef0123
+	LINUX_REBOOT_CMD_KEXEC           = 0x45584543
+	LINUX_REBOOT_CMD_POWER_OFF       = 0x4321fedc
+	LINUX_REBOOT_CMD_RESTART         = 0x1234567
+	LINUX_REBOOT_CMD_RESTART2        = 0xa1b2c3d4
+	LINUX_REBOOT_CMD_SW_SUSPEND      = 0xd000fce2
+	LINUX_REBOOT_MAGIC1              = 0xfee1dead
+	LINUX_REBOOT_MAGIC2              = 0x28121969
+	LOCK_EX                          = 0x2
+	LOCK_NB                          = 0x4
+	LOCK_SH                          = 0x1
+	LOCK_UN                          = 0x8
+	MADV_COLD                        = 0x14
+	MADV_DODUMP                      = 0x11
+	MADV_DOFORK                      = 0xb
+	MADV_DONTDUMP                    = 0x10
+	MADV_DONTFORK                    = 0xa
+	MADV_DONTNEED                    = 0x6
+	MADV_FREE                        = 0x8
+	MADV_HUGEPAGE                    = 0xe
+	MADV_HWPOISON                    = 0x64
+	MADV_KEEPONFORK                  = 0x13
+	MADV_MERGEABLE                   = 0xc
+	MADV_NOHUGEPAGE                  = 0xf
+	MADV_NORMAL                      = 0x0
+	MADV_PAGEOUT                     = 0x15
+	MADV_RANDOM                      = 0x1
+	MADV_REMOVE                      = 0x9
+	MADV_SEQUENTIAL                  = 0x2
+	MADV_UNMERGEABLE                 = 0xd
+	MADV_WILLNEED                    = 0x3
+	MADV_WIPEONFORK                  = 0x12
+	MAP_ANON                         = 0x10
+	MAP_ANONYMOUS                    = 0x10
+	MAP_DENYWRITE                    = 0x2000
+	MAP_EXECUTABLE                   = 0x4000
+	MAP_FILE                         = 0x0
+	MAP_FIXED                        = 0x100
+	MAP_FIXED_NOREPLACE              = 0x200000
+	MAP_GROWSDOWN                    = 0x1000
+	MAP_HUGETLB                      = 0x100000
+	MAP_HUGE_MASK                    = 0x3f
+	MAP_HUGE_SHIFT                   = 0x1a
+	MAP_LOCKED                       = 0x8000
+	MAP_NONBLOCK                     = 0x40000
+	MAP_NORESERVE                    = 0x10000
+	MAP_POPULATE                     = 0x20000
+	MAP_PRIVATE                      = 0x2
+	MAP_SHARED                       = 0x1
+	MAP_SHARED_VALIDATE              = 0x3
+	MAP_STACK                        = 0x80000
+	MAP_TYPE                         = 0xf
+	MCL_CURRENT                      = 0x2000
+	MCL_FUTURE                       = 0x4000
+	MCL_ONFAULT                      = 0x8000
+	MNT_DETACH                       = 0x2
+	MNT_EXPIRE                       = 0x4
+	MNT_FORCE                        = 0x1
+	MSG_BATCH                        = 0x40000
+	MSG_CMSG_CLOEXEC                 = 0x40000000
+	MSG_CONFIRM                      = 0x800
+	MSG_CTRUNC                       = 0x8
+	MSG_DONTROUTE                    = 0x4
+	MSG_DONTWAIT                     = 0x40
+	MSG_EOR                          = 0x80
+	MSG_ERRQUEUE                     = 0x2000
+	MSG_FASTOPEN                     = 0x20000000
+	MSG_FIN                          = 0x200
+	MSG_MORE                         = 0x8000
+	MSG_NOSIGNAL                     = 0x4000
+	MSG_OOB                          = 0x1
+	MSG_PEEK                         = 0x2
+	MSG_PROXY                        = 0x10
+	MSG_RST                          = 0x1000
+	MSG_SYN                          = 0x400
+	MSG_TRUNC                        = 0x20
+	MSG_TRYHARD                      = 0x4
+	MSG_WAITALL                      = 0x100
+	MSG_WAITFORONE                   = 0x10000
+	MSG_ZEROCOPY                     = 0x4000000
+	MS_ACTIVE                        = 0x40000000
+	MS_ASYNC                         = 0x1
+	MS_BIND                          = 0x1000
+	MS_DIRSYNC                       = 0x80
+	MS_INVALIDATE                    = 0x4
+	MS_I_VERSION                     = 0x800000
+	MS_KERNMOUNT                     = 0x400000
+	MS_LAZYTIME                      = 0x2000000
+	MS_MANDLOCK                      = 0x40
+	MS_MGC_MSK                       = 0xffff0000
+	MS_MGC_VAL                       = 0xc0ed0000
+	MS_MOVE                          = 0x2000
+	MS_NOATIME                       = 0x400
+	MS_NODEV                         = 0x4
+	MS_NODIRATIME                    = 0x800
+	MS_NOEXEC                        = 0x8
+	MS_NOSUID                        = 0x2
+	MS_NOSYMFOLLOW                   = 0x100
+	MS_NOUSER                        = -0x80000000
+	MS_POSIXACL                      = 0x10000
+	MS_PRIVATE                       = 0x40000
+	MS_RDONLY                        = 0x1
+	MS_REC                           = 0x4000
+	MS_RELATIME                      = 0x200000
+	MS_REMOUNT                       = 0x20
+	MS_RMT_MASK                      = 0x2800051
+	MS_SHARED                        = 0x100000
+	MS_SILENT                        = 0x8000
+	MS_SLAVE                         = 0x80000
+	MS_STRICTATIME                   = 0x1000000
+	MS_SYNC                          = 0x2
+	MS_SYNCHRONOUS                   = 0x10
+	MS_UNBINDABLE                    = 0x20000
+	NAME_MAX                         = 0xff
+	NETLINK_ADD_MEMBERSHIP           = 0x1
+	NETLINK_AUDIT                    = 0x9
+	NETLINK_BROADCAST_ERROR          = 0x4
+	NETLINK_CAP_ACK                  = 0xa
+	NETLINK_CONNECTOR                = 0xb
+	NETLINK_CRYPTO                   = 0x15
+	NETLINK_DNRTMSG                  = 0xe
+	NETLINK_DROP_MEMBERSHIP          = 0x2
+	NETLINK_ECRYPTFS                 = 0x13
+	NETLINK_EXT_ACK                  = 0xb
+	NETLINK_FIB_LOOKUP               = 0xa
+	NETLINK_FIREWALL                 = 0x3
+	NETLINK_GENERIC                  = 0x10
+	NETLINK_GET_STRICT_CHK           = 0xc
+	NETLINK_INET_DIAG                = 0x4
+	NETLINK_IP6_FW                   = 0xd
+	NETLINK_ISCSI                    = 0x8
+	NETLINK_KOBJECT_UEVENT           = 0xf
+	NETLINK_LISTEN_ALL_NSID          = 0x8
+	NETLINK_LIST_MEMBERSHIPS         = 0x9
+	NETLINK_NETFILTER                = 0xc
+	NETLINK_NFLOG                    = 0x5
+	NETLINK_NO_ENOBUFS               = 0x5
+	NETLINK_PKTINFO                  = 0x3
+	NETLINK_RDMA                     = 0x14
+	NETLINK_ROUTE                    = 0x0
+	NETLINK_RX_RING                  = 0x6
+	NETLINK_SCSITRANSPORT            = 0x12
+	NETLINK_SELINUX                  = 0x7
+	NETLINK_SMC                      = 0x16
+	NETLINK_SOCK_DIAG                = 0x4
+	NETLINK_TX_RING                  = 0x7
+	NETLINK_UNUSED                   = 0x1
+	NETLINK_USERSOCK                 = 0x2
+	NETLINK_XFRM                     = 0x6
+	NLA_ALIGNTO                      = 0x4
+	NLA_F_NESTED                     = 0x8000
+	NLA_F_NET_BYTEORDER              = 0x4000
+	NLA_HDRLEN                       = 0x4
+	NLMSG_ALIGNTO                    = 0x4
+	NLMSG_DONE                       = 0x3
+	NLMSG_ERROR                      = 0x2
+	NLMSG_HDRLEN                     = 0x10
+	NLMSG_MIN_TYPE                   = 0x10
+	NLMSG_NOOP                       = 0x1
+	NLMSG_OVERRUN                    = 0x4
+	NLM_F_ACK                        = 0x4
+	NLM_F_ACK_TLVS                   = 0x200
+	NLM_F_APPEND                     = 0x800
+	NLM_F_ATOMIC                     = 0x400
+	NLM_F_CAPPED                     = 0x100
+	NLM_F_CREATE                     = 0x400
+	NLM_F_DUMP                       = 0x300
+	NLM_F_DUMP_FILTERED              = 0x20
+	NLM_F_DUMP_INTR                  = 0x10
+	NLM_F_ECHO                       = 0x8
+	NLM_F_EXCL                       = 0x200
+	NLM_F_MATCH                      = 0x200
+	NLM_F_MULTI                      = 0x2
+	NLM_F_NONREC                     = 0x100
+	NLM_F_REPLACE                    = 0x100
+	NLM_F_REQUEST                    = 0x1
+	NLM_F_ROOT                       = 0x100
+	NOFLSH                           = 0x80000000
+	OCRNL                            = 0x8
+	OFDEL                            = 0x80
+	OFILL                            = 0x40
+	ONLCR                            = 0x2
+	ONLRET                           = 0x20
+	ONOCR                            = 0x10
+	OPOST                            = 0x1
+	O_ACCMODE                        = 0x3
+	O_APPEND                         = 0x8
+	O_ASYNC                          = 0x2000
+	O_CLOEXEC                        = 0x200000
+	O_CREAT                          = 0x200
+	O_DIRECT                         = 0x80000
+	O_DIRECTORY                      = 0x8000
+	O_DSYNC                          = 0x4000
+	O_EXCL                           = 0x800
+	O_FSYNC                          = 0x404000
+	O_LARGEFILE                      = 0x0
+	O_NDELAY                         = 0x4
+	O_NOATIME                        = 0x100000
+	O_NOCTTY                         = 0x1000
+	O_NOFOLLOW                       = 0x10000
+	O_NONBLOCK                       = 0x4
+	O_PATH                           = 0x800000
+	O_RDONLY                         = 0x0
+	O_RDWR                           = 0x2
+	O_RSYNC                          = 0x404000
+	O_SYNC                           = 0x404000
+	O_TMPFILE                        = 0x1008000
+	O_TRUNC                          = 0x400
+	O_WRONLY                         = 0x1
+	PACKET_ADD_MEMBERSHIP            = 0x1
+	PACKET_AUXDATA                   = 0x8
+	PACKET_BROADCAST                 = 0x1
+	PACKET_COPY_THRESH               = 0x7
+	PACKET_DROP_MEMBERSHIP           = 0x2
+	PACKET_FANOUT                    = 0x12
+	PACKET_FANOUT_CBPF               = 0x6
+	PACKET_FANOUT_CPU                = 0x2
+	PACKET_FANOUT_DATA               = 0x16
+	PACKET_FANOUT_EBPF               = 0x7
+	PACKET_FANOUT_FLAG_DEFRAG        = 0x8000
+	PACKET_FANOUT_FLAG_ROLLOVER      = 0x1000
+	PACKET_FANOUT_FLAG_UNIQUEID      = 0x2000
+	PACKET_FANOUT_HASH               = 0x0
+	PACKET_FANOUT_LB                 = 0x1
+	PACKET_FANOUT_QM                 = 0x5
+	PACKET_FANOUT_RND                = 0x4
+	PACKET_FANOUT_ROLLOVER           = 0x3
+	PACKET_FASTROUTE                 = 0x6
+	PACKET_HDRLEN                    = 0xb
+	PACKET_HOST                      = 0x0
+	PACKET_IGNORE_OUTGOING           = 0x17
+	PACKET_KERNEL                    = 0x7
+	PACKET_LOOPBACK                  = 0x5
+	PACKET_LOSS                      = 0xe
+	PACKET_MR_ALLMULTI               = 0x2
+	PACKET_MR_MULTICAST              = 0x0
+	PACKET_MR_PROMISC                = 0x1
+	PACKET_MR_UNICAST                = 0x3
+	PACKET_MULTICAST                 = 0x2
+	PACKET_ORIGDEV                   = 0x9
+	PACKET_OTHERHOST                 = 0x3
+	PACKET_OUTGOING                  = 0x4
+	PACKET_QDISC_BYPASS              = 0x14
+	PACKET_RECV_OUTPUT               = 0x3
+	PACKET_RESERVE                   = 0xc
+	PACKET_ROLLOVER_STATS            = 0x15
+	PACKET_RX_RING                   = 0x5
+	PACKET_STATISTICS                = 0x6
+	PACKET_TIMESTAMP                 = 0x11
+	PACKET_TX_HAS_OFF                = 0x13
+	PACKET_TX_RING                   = 0xd
+	PACKET_TX_TIMESTAMP              = 0x10
+	PACKET_USER                      = 0x6
+	PACKET_VERSION                   = 0xa
+	PACKET_VNET_HDR                  = 0xf
+	PARENB                           = 0x1000
+	PARITY_CRC16_PR0                 = 0x2
+	PARITY_CRC16_PR0_CCITT           = 0x4
+	PARITY_CRC16_PR1                 = 0x3
+	PARITY_CRC16_PR1_CCITT           = 0x5
+	PARITY_CRC32_PR0_CCITT           = 0x6
+	PARITY_CRC32_PR1_CCITT           = 0x7
+	PARITY_DEFAULT                   = 0x0
+	PARITY_NONE                      = 0x1
+	PARMRK                           = 0x8
+	PARODD                           = 0x2000
+	PENDIN                           = 0x20000000
+	PRIO_PGRP                        = 0x1
+	PRIO_PROCESS                     = 0x0
+	PRIO_USER                        = 0x2
+	PROT_EXEC                        = 0x4
+	PROT_GROWSDOWN                   = 0x1000000
+	PROT_GROWSUP                     = 0x2000000
+	PROT_NONE                        = 0x0
+	PROT_READ                        = 0x1
+	PROT_WRITE                       = 0x2
+	PR_CAPBSET_DROP                  = 0x18
+	PR_CAPBSET_READ                  = 0x17
+	PR_CAP_AMBIENT                   = 0x2f
+	PR_CAP_AMBIENT_CLEAR_ALL         = 0x4
+	PR_CAP_AMBIENT_IS_SET            = 0x1
+	PR_CAP_AMBIENT_LOWER             = 0x3
+	PR_CAP_AMBIENT_RAISE             = 0x2
+	PR_ENDIAN_BIG                    = 0x0
+	PR_ENDIAN_LITTLE                 = 0x1
+	PR_ENDIAN_PPC_LITTLE             = 0x2
+	PR_FPEMU_NOPRINT                 = 0x1
+	PR_FPEMU_SIGFPE                  = 0x2
+	PR_FP_EXC_ASYNC                  = 0x2
+	PR_FP_EXC_DISABLED               = 0x0
+	PR_FP_EXC_DIV                    = 0x10000
+	PR_FP_EXC_INV                    = 0x100000
+	PR_FP_EXC_NONRECOV               = 0x1
+	PR_FP_EXC_OVF                    = 0x20000
+	PR_FP_EXC_PRECISE                = 0x3
+	PR_FP_EXC_RES                    = 0x80000
+	PR_FP_EXC_SW_ENABLE              = 0x80
+	PR_FP_EXC_UND                    = 0x40000
+	PR_FP_MODE_FR                    = 0x1
+	PR_FP_MODE_FRE                   = 0x2
+	PR_GET_CHILD_SUBREAPER           = 0x25
+	PR_GET_DUMPABLE                  = 0x3
+	PR_GET_ENDIAN                    = 0x13
+	PR_GET_FPEMU                     = 0x9
+	PR_GET_FPEXC                     = 0xb
+	PR_GET_FP_MODE                   = 0x2e
+	PR_GET_IO_FLUSHER                = 0x3a
+	PR_GET_KEEPCAPS                  = 0x7
+	PR_GET_NAME                      = 0x10
+	PR_GET_NO_NEW_PRIVS              = 0x27
+	PR_GET_PDEATHSIG                 = 0x2
+	PR_GET_SECCOMP                   = 0x15
+	PR_GET_SECUREBITS                = 0x1b
+	PR_GET_SPECULATION_CTRL          = 0x34
+	PR_GET_TAGGED_ADDR_CTRL          = 0x38
+	PR_GET_THP_DISABLE               = 0x2a
+	PR_GET_TID_ADDRESS               = 0x28
+	PR_GET_TIMERSLACK                = 0x1e
+	PR_GET_TIMING                    = 0xd
+	PR_GET_TSC                       = 0x19
+	PR_GET_UNALIGN                   = 0x5
+	PR_MCE_KILL                      = 0x21
+	PR_MCE_KILL_CLEAR                = 0x0
+	PR_MCE_KILL_DEFAULT              = 0x2
+	PR_MCE_KILL_EARLY                = 0x1
+	PR_MCE_KILL_GET                  = 0x22
+	PR_MCE_KILL_LATE                 = 0x0
+	PR_MCE_KILL_SET                  = 0x1
+	PR_MPX_DISABLE_MANAGEMENT        = 0x2c
+	PR_MPX_ENABLE_MANAGEMENT         = 0x2b
+	PR_MTE_TAG_MASK                  = 0x7fff8
+	PR_MTE_TAG_SHIFT                 = 0x3
+	PR_MTE_TCF_ASYNC                 = 0x4
+	PR_MTE_TCF_MASK                  = 0x6
+	PR_MTE_TCF_NONE                  = 0x0
+	PR_MTE_TCF_SHIFT                 = 0x1
+	PR_MTE_TCF_SYNC                  = 0x2
+	PR_PAC_APDAKEY                   = 0x4
+	PR_PAC_APDBKEY                   = 0x8
+	PR_PAC_APGAKEY                   = 0x10
+	PR_PAC_APIAKEY                   = 0x1
+	PR_PAC_APIBKEY                   = 0x2
+	PR_PAC_RESET_KEYS                = 0x36
+	PR_SET_CHILD_SUBREAPER           = 0x24
+	PR_SET_DUMPABLE                  = 0x4
+	PR_SET_ENDIAN                    = 0x14
+	PR_SET_FPEMU                     = 0xa
+	PR_SET_FPEXC                     = 0xc
+	PR_SET_FP_MODE                   = 0x2d
+	PR_SET_IO_FLUSHER                = 0x39
+	PR_SET_KEEPCAPS                  = 0x8
+	PR_SET_MM                        = 0x23
+	PR_SET_MM_ARG_END                = 0x9
+	PR_SET_MM_ARG_START              = 0x8
+	PR_SET_MM_AUXV                   = 0xc
+	PR_SET_MM_BRK                    = 0x7
+	PR_SET_MM_END_CODE               = 0x2
+	PR_SET_MM_END_DATA               = 0x4
+	PR_SET_MM_ENV_END                = 0xb
+	PR_SET_MM_ENV_START              = 0xa
+	PR_SET_MM_EXE_FILE               = 0xd
+	PR_SET_MM_MAP                    = 0xe
+	PR_SET_MM_MAP_SIZE               = 0xf
+	PR_SET_MM_START_BRK              = 0x6
+	PR_SET_MM_START_CODE             = 0x1
+	PR_SET_MM_START_DATA             = 0x3
+	PR_SET_MM_START_STACK            = 0x5
+	PR_SET_NAME                      = 0xf
+	PR_SET_NO_NEW_PRIVS              = 0x26
+	PR_SET_PDEATHSIG                 = 0x1
+	PR_SET_PTRACER                   = 0x59616d61
+	PR_SET_PTRACER_ANY               = 0xffffffffffffffff
+	PR_SET_SECCOMP                   = 0x16
+	PR_SET_SECUREBITS                = 0x1c
+	PR_SET_SPECULATION_CTRL          = 0x35
+	PR_SET_TAGGED_ADDR_CTRL          = 0x37
+	PR_SET_THP_DISABLE               = 0x29
+	PR_SET_TIMERSLACK                = 0x1d
+	PR_SET_TIMING                    = 0xe
+	PR_SET_TSC                       = 0x1a
+	PR_SET_UNALIGN                   = 0x6
+	PR_SPEC_DISABLE                  = 0x4
+	PR_SPEC_DISABLE_NOEXEC           = 0x10
+	PR_SPEC_ENABLE                   = 0x2
+	PR_SPEC_FORCE_DISABLE            = 0x8
+	PR_SPEC_INDIRECT_BRANCH          = 0x1
+	PR_SPEC_NOT_AFFECTED             = 0x0
+	PR_SPEC_PRCTL                    = 0x1
+	PR_SPEC_STORE_BYPASS             = 0x0
+	PR_SVE_GET_VL                    = 0x33
+	PR_SVE_SET_VL                    = 0x32
+	PR_SVE_SET_VL_ONEXEC             = 0x40000
+	PR_SVE_VL_INHERIT                = 0x20000
+	PR_SVE_VL_LEN_MASK               = 0xffff
+	PR_TAGGED_ADDR_ENABLE            = 0x1
+	PR_TASK_PERF_EVENTS_DISABLE      = 0x1f
+	PR_TASK_PERF_EVENTS_ENABLE       = 0x20
+	PR_TIMING_STATISTICAL            = 0x0
+	PR_TIMING_TIMESTAMP              = 0x1
+	PR_TSC_ENABLE                    = 0x1
+	PR_TSC_SIGSEGV                   = 0x2
+	PR_UNALIGN_NOPRINT               = 0x1
+	PR_UNALIGN_SIGBUS                = 0x2
+	PTRACE_ATTACH                    = 0x10
+	PTRACE_CONT                      = 0x7
+	PTRACE_DETACH                    = 0x11
+	PTRACE_EVENTMSG_SYSCALL_ENTRY    = 0x1
+	PTRACE_EVENTMSG_SYSCALL_EXIT     = 0x2
+	PTRACE_EVENT_CLONE               = 0x3
+	PTRACE_EVENT_EXEC                = 0x4
+	PTRACE_EVENT_EXIT                = 0x6
+	PTRACE_EVENT_FORK                = 0x1
+	PTRACE_EVENT_SECCOMP             = 0x7
+	PTRACE_EVENT_STOP                = 0x80
+	PTRACE_EVENT_VFORK               = 0x2
+	PTRACE_EVENT_VFORK_DONE          = 0x5
+	PTRACE_GETEVENTMSG               = 0x4201
+	PTRACE_GETREGS                   = 0xc
+	PTRACE_GETREGSET                 = 0x4204
+	PTRACE_GETSIGINFO                = 0x4202
+	PTRACE_GETSIGMASK                = 0x420a
+	PTRACE_GET_SYSCALL_INFO          = 0x420e
+	PTRACE_INTERRUPT                 = 0x4207
+	PTRACE_KILL                      = 0x8
+	PTRACE_LISTEN                    = 0x4208
+	PTRACE_O_EXITKILL                = 0x100000
+	PTRACE_O_MASK                    = 0x3000ff
+	PTRACE_O_SUSPEND_SECCOMP         = 0x200000
+	PTRACE_O_TRACECLONE              = 0x8
+	PTRACE_O_TRACEEXEC               = 0x10
+	PTRACE_O_TRACEEXIT               = 0x40
+	PTRACE_O_TRACEFORK               = 0x2
+	PTRACE_O_TRACESECCOMP            = 0x80
+	PTRACE_O_TRACESYSGOOD            = 0x1
+	PTRACE_O_TRACEVFORK              = 0x4
+	PTRACE_O_TRACEVFORKDONE          = 0x20
+	PTRACE_PEEKDATA                  = 0x2
+	PTRACE_PEEKSIGINFO               = 0x4209
+	PTRACE_PEEKSIGINFO_SHARED        = 0x1
+	PTRACE_PEEKTEXT                  = 0x1
+	PTRACE_PEEKUSR                   = 0x3
+	PTRACE_POKEDATA                  = 0x5
+	PTRACE_POKETEXT                  = 0x4
+	PTRACE_POKEUSR                   = 0x6
+	PTRACE_SECCOMP_GET_FILTER        = 0x420c
+	PTRACE_SECCOMP_GET_METADATA      = 0x420d
+	PTRACE_SEIZE                     = 0x4206
+	PTRACE_SETOPTIONS                = 0x4200
+	PTRACE_SETREGS                   = 0xd
+	PTRACE_SETREGSET                 = 0x4205
+	PTRACE_SETSIGINFO                = 0x4203
+	PTRACE_SETSIGMASK                = 0x420b
+	PTRACE_SINGLESTEP                = 0x9
+	PTRACE_SYSCALL                   = 0x18
+	PTRACE_SYSCALL_INFO_ENTRY        = 0x1
+	PTRACE_SYSCALL_INFO_EXIT         = 0x2
+	PTRACE_SYSCALL_INFO_NONE         = 0x0
+	PTRACE_SYSCALL_INFO_SECCOMP      = 0x3
+	PTRACE_TRACEME                   = 0x0
+	PT_DA_MASK                       = 0xa4
+	PT_DA_MATCH                      = 0xa3
+	PT_DC_CTL                        = 0xa7
+	PT_DV_MASK                       = 0xa6
+	PT_DV_MATCH                      = 0xa5
+	PT_F31_V1                        = 0x62
+	PT_F31_V2                        = 0x82
+	PT_FPCR                          = 0x3f
+	PT_FPREG_BASE                    = 0x20
+	PT_FPREG_END                     = 0x3e
+	PT_PC                            = 0x40
+	PT_REG_BASE                      = 0x0
+	PT_REG_END                       = 0x1d
+	PT_TP                            = 0x41
+	PT_UNIQUE                        = 0x41
+	PT_USP                           = 0x1e
+	PT_VECREG_BASE                   = 0x43
+	PT_VECREG_END                    = 0xa1
+	RLIMIT_AS                        = 0x7
+	RLIMIT_CORE                      = 0x4
+	RLIMIT_CPU                       = 0x0
+	RLIMIT_DATA                      = 0x2
+	RLIMIT_FSIZE                     = 0x1
+	RLIMIT_NOFILE                    = 0x6
+	RLIMIT_STACK                     = 0x3
+	RLIM_INFINITY                    = -0x1
+	RTAX_ADVMSS                      = 0x8
+	RTAX_CC_ALGO                     = 0x10
+	RTAX_CWND                        = 0x7
+	RTAX_FASTOPEN_NO_COOKIE          = 0x11
+	RTAX_FEATURES                    = 0xc
+	RTAX_FEATURE_ALLFRAG             = 0x8
+	RTAX_FEATURE_ECN                 = 0x1
+	RTAX_FEATURE_MASK                = 0xf
+	RTAX_FEATURE_SACK                = 0x2
+	RTAX_FEATURE_TIMESTAMP           = 0x4
+	RTAX_HOPLIMIT                    = 0xa
+	RTAX_INITCWND                    = 0xb
+	RTAX_INITRWND                    = 0xe
+	RTAX_LOCK                        = 0x1
+	RTAX_MAX                         = 0x11
+	RTAX_MTU                         = 0x2
+	RTAX_QUICKACK                    = 0xf
+	RTAX_REORDERING                  = 0x9
+	RTAX_RTO_MIN                     = 0xd
+	RTAX_RTT                         = 0x4
+	RTAX_RTTVAR                      = 0x5
+	RTAX_SSTHRESH                    = 0x6
+	RTAX_UNSPEC                      = 0x0
+	RTAX_WINDOW                      = 0x3
+	RTA_ALIGNTO                      = 0x4
+	RTA_MAX                          = 0x1e
+	RTCF_DIRECTSRC                   = 0x4000000
+	RTCF_DOREDIRECT                  = 0x1000000
+	RTCF_LOG                         = 0x2000000
+	RTCF_MASQ                        = 0x400000
+	RTCF_NAT                         = 0x800000
+	RTCF_VALVE                       = 0x200000
+	RTF_ADDRCLASSMASK                = 0xf8000000
+	RTF_ADDRCONF                     = 0x40000
+	RTF_ALLONLINK                    = 0x20000
+	RTF_BROADCAST                    = 0x10000000
+	RTF_CACHE                        = 0x1000000
+	RTF_DEFAULT                      = 0x10000
+	RTF_DYNAMIC                      = 0x10
+	RTF_FLOW                         = 0x2000000
+	RTF_GATEWAY                      = 0x2
+	RTF_HOST                         = 0x4
+	RTF_INTERFACE                    = 0x40000000
+	RTF_IRTT                         = 0x100
+	RTF_LINKRT                       = 0x100000
+	RTF_LOCAL                        = 0x80000000
+	RTF_MODIFIED                     = 0x20
+	RTF_MSS                          = 0x40
+	RTF_MTU                          = 0x40
+	RTF_MULTICAST                    = 0x20000000
+	RTF_NAT                          = 0x8000000
+	RTF_NOFORWARD                    = 0x1000
+	RTF_NONEXTHOP                    = 0x200000
+	RTF_NOPMTUDISC                   = 0x4000
+	RTF_POLICY                       = 0x4000000
+	RTF_REINSTATE                    = 0x8
+	RTF_REJECT                       = 0x200
+	RTF_STATIC                       = 0x400
+	RTF_THROW                        = 0x2000
+	RTF_UP                           = 0x1
+	RTF_WINDOW                       = 0x80
+	RTF_XRESOLVE                     = 0x800
+	RTM_BASE                         = 0x10
+	RTM_DELACTION                    = 0x31
+	RTM_DELADDR                      = 0x15
+	RTM_DELADDRLABEL                 = 0x49
+	RTM_DELCHAIN                     = 0x65
+	RTM_DELLINK                      = 0x11
+	RTM_DELLINKPROP                  = 0x6d
+	RTM_DELMDB                       = 0x55
+	RTM_DELNEIGH                     = 0x1d
+	RTM_DELNETCONF                   = 0x51
+	RTM_DELNEXTHOP                   = 0x69
+	RTM_DELNSID                      = 0x59
+	RTM_DELQDISC                     = 0x25
+	RTM_DELROUTE                     = 0x19
+	RTM_DELRULE                      = 0x21
+	RTM_DELTCLASS                    = 0x29
+	RTM_DELTFILTER                   = 0x2d
+	RTM_DELVLAN                      = 0x71
+	RTM_F_CLONED                     = 0x200
+	RTM_F_EQUALIZE                   = 0x400
+	RTM_F_FIB_MATCH                  = 0x2000
+	RTM_F_LOOKUP_TABLE               = 0x1000
+	RTM_F_NOTIFY                     = 0x100
+	RTM_F_OFFLOAD                    = 0x4000
+	RTM_F_PREFIX                     = 0x800
+	RTM_F_TRAP                       = 0x8000
+	RTM_GETACTION                    = 0x32
+	RTM_GETADDR                      = 0x16
+	RTM_GETADDRLABEL                 = 0x4a
+	RTM_GETANYCAST                   = 0x3e
+	RTM_GETCHAIN                     = 0x66
+	RTM_GETDCB                       = 0x4e
+	RTM_GETLINK                      = 0x12
+	RTM_GETLINKPROP                  = 0x6e
+	RTM_GETMDB                       = 0x56
+	RTM_GETMULTICAST                 = 0x3a
+	RTM_GETNEIGH                     = 0x1e
+	RTM_GETNEIGHTBL                  = 0x42
+	RTM_GETNETCONF                   = 0x52
+	RTM_GETNEXTHOP                   = 0x6a
+	RTM_GETNSID                      = 0x5a
+	RTM_GETQDISC                     = 0x26
+	RTM_GETROUTE                     = 0x1a
+	RTM_GETRULE                      = 0x22
+	RTM_GETSTATS                     = 0x5e
+	RTM_GETTCLASS                    = 0x2a
+	RTM_GETTFILTER                   = 0x2e
+	RTM_GETVLAN                      = 0x72
+	RTM_MAX                          = 0x73
+	RTM_NEWACTION                    = 0x30
+	RTM_NEWADDR                      = 0x14
+	RTM_NEWADDRLABEL                 = 0x48
+	RTM_NEWCACHEREPORT               = 0x60
+	RTM_NEWCHAIN                     = 0x64
+	RTM_NEWLINK                      = 0x10
+	RTM_NEWLINKPROP                  = 0x6c
+	RTM_NEWMDB                       = 0x54
+	RTM_NEWNDUSEROPT                 = 0x44
+	RTM_NEWNEIGH                     = 0x1c
+	RTM_NEWNEIGHTBL                  = 0x40
+	RTM_NEWNETCONF                   = 0x50
+	RTM_NEWNEXTHOP                   = 0x68
+	RTM_NEWNSID                      = 0x58
+	RTM_NEWNVLAN                     = 0x70
+	RTM_NEWPREFIX                    = 0x34
+	RTM_NEWQDISC                     = 0x24
+	RTM_NEWROUTE                     = 0x18
+	RTM_NEWRULE                      = 0x20
+	RTM_NEWSTATS                     = 0x5c
+	RTM_NEWTCLASS                    = 0x28
+	RTM_NEWTFILTER                   = 0x2c
+	RTM_NR_FAMILIES                  = 0x19
+	RTM_NR_MSGTYPES                  = 0x64
+	RTM_SETDCB                       = 0x4f
+	RTM_SETLINK                      = 0x13
+	RTM_SETNEIGHTBL                  = 0x43
+	RTNH_ALIGNTO                     = 0x4
+	RTNH_COMPARE_MASK                = 0x19
+	RTNH_F_DEAD                      = 0x1
+	RTNH_F_LINKDOWN                  = 0x10
+	RTNH_F_OFFLOAD                   = 0x8
+	RTNH_F_ONLINK                    = 0x4
+	RTNH_F_PERVASIVE                 = 0x2
+	RTNH_F_UNRESOLVED                = 0x20
+	RTN_MAX                          = 0xb
+	RTPROT_BABEL                     = 0x2a
+	RTPROT_BGP                       = 0xba
+	RTPROT_BIRD                      = 0xc
+	RTPROT_BOOT                      = 0x3
+	RTPROT_DHCP                      = 0x10
+	RTPROT_DNROUTED                  = 0xd
+	RTPROT_EIGRP                     = 0xc0
+	RTPROT_GATED                     = 0x8
+	RTPROT_ISIS                      = 0xbb
+	RTPROT_KEEPALIVED                = 0x12
+	RTPROT_KERNEL                    = 0x2
+	RTPROT_MROUTED                   = 0x11
+	RTPROT_MRT                       = 0xa
+	RTPROT_NTK                       = 0xf
+	RTPROT_OSPF                      = 0xbc
+	RTPROT_RA                        = 0x9
+	RTPROT_REDIRECT                  = 0x1
+	RTPROT_RIP                       = 0xbd
+	RTPROT_STATIC                    = 0x4
+	RTPROT_UNSPEC                    = 0x0
+	RTPROT_XORP                      = 0xe
+	RTPROT_ZEBRA                     = 0xb
+	RT_CLASS_DEFAULT                 = 0xfd
+	RT_CLASS_LOCAL                   = 0xff
+	RT_CLASS_MAIN                    = 0xfe
+	RT_CLASS_MAX                     = 0xff
+	RT_CLASS_UNSPEC                  = 0x0
+	RUSAGE_CHILDREN                  = -0x1
+	RUSAGE_SELF                      = 0x0
+	RUSAGE_THREAD                    = 0x1
+	SCM_CREDENTIALS                  = 0x2
+	SCM_RIGHTS                       = 0x1
+	SCM_TIMESTAMP                    = 0x1d
+	SCM_TIMESTAMPING                 = 0x25
+	SCM_TIMESTAMPING_OPT_STATS       = 0x36
+	SCM_TIMESTAMPING_PKTINFO         = 0x3a
+	SCM_TIMESTAMPNS                  = 0x23
+	SCM_TXTIME                       = 0x3d
+	SCM_WIFI_STATUS                  = 0x29
+	SHUT_RD                          = 0x0
+	SHUT_RDWR                        = 0x2
+	SHUT_WR                          = 0x1
+	SIOCADDDLCI                      = 0x8980
+	SIOCADDMULTI                     = 0x8931
+	SIOCADDRT                        = 0x890b
+	SIOCATMARK                       = 0x40047307
+	SIOCBONDCHANGEACTIVE             = 0x8995
+	SIOCBONDENSLAVE                  = 0x8990
+	SIOCBONDINFOQUERY                = 0x8994
+	SIOCBONDRELEASE                  = 0x8991
+	SIOCBONDSETHWADDR                = 0x8992
+	SIOCBONDSLAVEINFOQUERY           = 0x8993
+	SIOCBRADDBR                      = 0x89a0
+	SIOCBRADDIF                      = 0x89a2
+	SIOCBRDELBR                      = 0x89a1
+	SIOCBRDELIF                      = 0x89a3
+	SIOCDARP                         = 0x8953
+	SIOCDELDLCI                      = 0x8981
+	SIOCDELMULTI                     = 0x8932
+	SIOCDELRT                        = 0x890c
+	SIOCDEVPRIVATE                   = 0x89f0
+	SIOCDIFADDR                      = 0x8936
+	SIOCDRARP                        = 0x8960
+	SIOCETHTOOL                      = 0x8946
+	SIOCGARP                         = 0x8954
+	SIOCGHWTSTAMP                    = 0x89b1
+	SIOCGIFADDR                      = 0x8915
+	SIOCGIFBR                        = 0x8940
+	SIOCGIFBRDADDR                   = 0x8919
+	SIOCGIFCONF                      = 0x8912
+	SIOCGIFCOUNT                     = 0x8938
+	SIOCGIFDSTADDR                   = 0x8917
+	SIOCGIFENCAP                     = 0x8925
+	SIOCGIFFLAGS                     = 0x8913
+	SIOCGIFHWADDR                    = 0x8927
+	SIOCGIFINDEX                     = 0x8933
+	SIOCGIFMAP                       = 0x8970
+	SIOCGIFMEM                       = 0x891f
+	SIOCGIFMETRIC                    = 0x891d
+	SIOCGIFMTU                       = 0x8921
+	SIOCGIFNAME                      = 0x8910
+	SIOCGIFNETMASK                   = 0x891b
+	SIOCGIFPFLAGS                    = 0x8935
+	SIOCGIFSLAVE                     = 0x8929
+	SIOCGIFTXQLEN                    = 0x8942
+	SIOCGIFVLAN                      = 0x8982
+	SIOCGMIIPHY                      = 0x8947
+	SIOCGMIIREG                      = 0x8948
+	SIOCGPGRP                        = 0x40047309
+	SIOCGRARP                        = 0x8961
+	SIOCGSKNS                        = 0x894c
+	SIOCGSTAMP                       = 0x8906
+	SIOCGSTAMPNS                     = 0x8907
+	SIOCGSTAMPNS_NEW                 = 0x40108907
+	SIOCGSTAMPNS_OLD                 = 0x8907
+	SIOCGSTAMP_NEW                   = 0x40108906
+	SIOCGSTAMP_OLD                   = 0x8906
+	SIOCINQ                          = 0x4004667f
+	SIOCOUTQ                         = 0x40047473
+	SIOCOUTQNSD                      = 0x894b
+	SIOCPROTOPRIVATE                 = 0x89e0
+	SIOCRTMSG                        = 0x890d
+	SIOCSARP                         = 0x8955
+	SIOCSHWTSTAMP                    = 0x89b0
+	SIOCSIFADDR                      = 0x8916
+	SIOCSIFBR                        = 0x8941
+	SIOCSIFBRDADDR                   = 0x891a
+	SIOCSIFDSTADDR                   = 0x8918
+	SIOCSIFENCAP                     = 0x8926
+	SIOCSIFFLAGS                     = 0x8914
+	SIOCSIFHWADDR                    = 0x8924
+	SIOCSIFHWBROADCAST               = 0x8937
+	SIOCSIFLINK                      = 0x8911
+	SIOCSIFMAP                       = 0x8971
+	SIOCSIFMEM                       = 0x8920
+	SIOCSIFMETRIC                    = 0x891e
+	SIOCSIFMTU                       = 0x8922
+	SIOCSIFNAME                      = 0x8923
+	SIOCSIFNETMASK                   = 0x891c
+	SIOCSIFPFLAGS                    = 0x8934
+	SIOCSIFSLAVE                     = 0x8930
+	SIOCSIFTXQLEN                    = 0x8943
+	SIOCSIFVLAN                      = 0x8983
+	SIOCSMIIREG                      = 0x8949
+	SIOCSPGRP                        = 0x80047308
+	SIOCSRARP                        = 0x8962
+	SIOCWANDEV                       = 0x894a
+	SOCK_CLOEXEC                     = 0x200000
+	SOCK_DCCP                        = 0x6
+	SOCK_DGRAM                       = 0x2
+	SOCK_IOC_TYPE                    = 0x89
+	SOCK_NONBLOCK                    = 0x40000000
+	SOCK_PACKET                      = 0xa
+	SOCK_RAW                         = 0x3
+	SOCK_RDM                         = 0x4
+	SOCK_SEQPACKET                   = 0x5
+	SOCK_STREAM                      = 0x1
+	SOL_AAL                          = 0x109
+	SOL_ALG                          = 0x117
+	SOL_ATM                          = 0x108
+	SOL_BLUETOOTH                    = 0x112
+	SOL_CAIF                         = 0x116
+	SOL_DCCP                         = 0x10d
+	SOL_DECNET                       = 0x105
+	SOL_ICMPV6                       = 0x3a
+	SOL_IP                           = 0x0
+	SOL_IPV6                         = 0x29
+	SOL_IRDA                         = 0x10a
+	SOL_IUCV                         = 0x115
+	SOL_KCM                          = 0x119
+	SOL_LLC                          = 0x10c
+	SOL_NETBEUI                      = 0x10b
+	SOL_NETLINK                      = 0x10e
+	SOL_NFC                          = 0x118
+	SOL_PACKET                       = 0x107
+	SOL_PNPIPE                       = 0x113
+	SOL_PPPOL2TP                     = 0x111
+	SOL_RAW                          = 0xff
+	SOL_RDS                          = 0x114
+	SOL_RXRPC                        = 0x110
+	SOL_SOCKET                       = 0xffff
+	SOL_TCP                          = 0x6
+	SOL_TIPC                         = 0x10f
+	SOL_TLS                          = 0x11a
+	SOL_X25                          = 0x106
+	SOL_XDP                          = 0x11b
+	SOMAXCONN                        = 0x1000
+	SO_ACCEPTCONN                    = 0x1014
+	SO_ATTACH_BPF                    = 0x32
+	SO_ATTACH_FILTER                 = 0x1a
+	SO_ATTACH_REUSEPORT_CBPF         = 0x33
+	SO_ATTACH_REUSEPORT_EBPF         = 0x34
+	SO_BINDTODEVICE                  = 0x19
+	SO_BINDTOIFINDEX                 = 0x3e
+	SO_BPF_EXTENSIONS                = 0x30
+	SO_BROADCAST                     = 0x20
+	SO_BSDCOMPAT                     = 0xe
+	SO_BUSY_POLL                     = 0x2e
+	SO_CNX_ADVICE                    = 0x35
+	SO_COOKIE                        = 0x39
+	SO_DEBUG                         = 0x1
+	SO_DETACH_BPF                    = 0x1b
+	SO_DETACH_FILTER                 = 0x1b
+	SO_DETACH_REUSEPORT_BPF          = 0x44
+	SO_DOMAIN                        = 0x1029
+	SO_DONTROUTE                     = 0x10
+	SO_ERROR                         = 0x1007
+	SO_GET_FILTER                    = 0x1a
+	SO_INCOMING_CPU                  = 0x31
+	SO_INCOMING_NAPI_ID              = 0x38
+	SO_KEEPALIVE                     = 0x8
+	SO_LINGER                        = 0x80
+	SO_LOCK_FILTER                   = 0x2c
+	SO_MARK                          = 0x24
+	SO_MAX_PACING_RATE               = 0x2f
+	SO_MEMINFO                       = 0x37
+	SO_NOFCS                         = 0x2b
+	SO_NO_CHECK                      = 0xb
+	SO_OOBINLINE                     = 0x100
+	SO_PASSCRED                      = 0x11
+	SO_PASSSEC                       = 0x22
+	SO_PEEK_OFF                      = 0x2a
+	SO_PEERCRED                      = 0x12
+	SO_PEERGROUPS                    = 0x3b
+	SO_PEERNAME                      = 0x1c
+	SO_PEERSEC                       = 0x1e
+	SO_PRIORITY                      = 0xc
+	SO_PROTOCOL                      = 0x1028
+	SO_RCVBUF                        = 0x1002
+	SO_RCVBUFFORCE                   = 0x100b
+	SO_RCVLOWAT                      = 0x1010
+	SO_RCVTIMEO                      = 0x1012
+	SO_RCVTIMEO_NEW                  = 0x42
+	SO_RCVTIMEO_OLD                  = 0x1012
+	SO_REUSEADDR                     = 0x4
+	SO_REUSEPORT                     = 0x200
+	SO_RXQ_OVFL                      = 0x28
+	SO_SECURITY_AUTHENTICATION       = 0x13
+	SO_SECURITY_ENCRYPTION_NETWORK   = 0x15
+	SO_SECURITY_ENCRYPTION_TRANSPORT = 0x14
+	SO_SELECT_ERR_QUEUE              = 0x2d
+	SO_SNDBUF                        = 0x1001
+	SO_SNDBUFFORCE                   = 0x100a
+	SO_SNDLOWAT                      = 0x1011
+	SO_SNDTIMEO                      = 0x1013
+	SO_SNDTIMEO_NEW                  = 0x43
+	SO_SNDTIMEO_OLD                  = 0x1013
+	SO_TIMESTAMP                     = 0x1d
+	SO_TIMESTAMPING                  = 0x25
+	SO_TIMESTAMPING_NEW              = 0x41
+	SO_TIMESTAMPING_OLD              = 0x25
+	SO_TIMESTAMPNS                   = 0x23
+	SO_TIMESTAMPNS_NEW               = 0x40
+	SO_TIMESTAMPNS_OLD               = 0x23
+	SO_TIMESTAMP_NEW                 = 0x3f
+	SO_TIMESTAMP_OLD                 = 0x1d
+	SO_TXTIME                        = 0x3d
+	SO_TYPE                          = 0x1008
+	SO_WIFI_STATUS                   = 0x29
+	SO_ZEROCOPY                      = 0x3c
+	S_BLKSIZE                        = 0x200
+	S_IEXEC                          = 0x40
+	S_IFBLK                          = 0x6000
+	S_IFCHR                          = 0x2000
+	S_IFDIR                          = 0x4000
+	S_IFIFO                          = 0x1000
+	S_IFLNK                          = 0xa000
+	S_IFMT                           = 0xf000
+	S_IFREG                          = 0x8000
+	S_IFSOCK                         = 0xc000
+	S_IREAD                          = 0x100
+	S_IRGRP                          = 0x20
+	S_IROTH                          = 0x4
+	S_IRUSR                          = 0x100
+	S_IRWXG                          = 0x38
+	S_IRWXO                          = 0x7
+	S_IRWXU                          = 0x1c0
+	S_ISGID                          = 0x400
+	S_ISUID                          = 0x800
+	S_ISVTX                          = 0x200
+	S_IWGRP                          = 0x10
+	S_IWOTH                          = 0x2
+	S_IWRITE                         = 0x80
+	S_IWUSR                          = 0x80
+	S_IXGRP                          = 0x8
+	S_IXOTH                          = 0x1
+	S_IXUSR                          = 0x40
+	TCFLSH                           = 0x2000741f
+	TCIFLUSH                         = 0x0
+	TCIOFLUSH                        = 0x2
+	TCOFLUSH                         = 0x1
+	TCP_CC_INFO                      = 0x1a
+	TCP_CM_INQ                       = 0x24
+	TCP_CONGESTION                   = 0xd
+	TCP_COOKIE_IN_ALWAYS             = 0x1
+	TCP_COOKIE_MAX                   = 0x10
+	TCP_COOKIE_MIN                   = 0x8
+	TCP_COOKIE_OUT_NEVER             = 0x2
+	TCP_COOKIE_PAIR_SIZE             = 0x20
+	TCP_COOKIE_TRANSACTIONS          = 0xf
+	TCP_CORK                         = 0x3
+	TCP_DEFER_ACCEPT                 = 0x9
+	TCP_FASTOPEN                     = 0x17
+	TCP_FASTOPEN_CONNECT             = 0x1e
+	TCP_FASTOPEN_KEY                 = 0x21
+	TCP_FASTOPEN_NO_COOKIE           = 0x22
+	TCP_INFO                         = 0xb
+	TCP_INQ                          = 0x24
+	TCP_KEEPCNT                      = 0x6
+	TCP_KEEPIDLE                     = 0x4
+	TCP_KEEPINTVL                    = 0x5
+	TCP_LINGER2                      = 0x8
+	TCP_MAXSEG                       = 0x2
+	TCP_MAXWIN                       = 0xffff
+	TCP_MAX_WINSHIFT                 = 0xe
+	TCP_MD5SIG                       = 0xe
+	TCP_MD5SIG_EXT                   = 0x20
+	TCP_MD5SIG_FLAG_PREFIX           = 0x1
+	TCP_MD5SIG_MAXKEYLEN             = 0x50
+	TCP_MSS                          = 0x200
+	TCP_MSS_DEFAULT                  = 0x218
+	TCP_MSS_DESIRED                  = 0x4c4
+	TCP_NODELAY                      = 0x1
+	TCP_NOTSENT_LOWAT                = 0x19
+	TCP_QUEUE_SEQ                    = 0x15
+	TCP_QUICKACK                     = 0xc
+	TCP_REPAIR                       = 0x13
+	TCP_REPAIR_OFF                   = 0x0
+	TCP_REPAIR_OFF_NO_WP             = -0x1
+	TCP_REPAIR_ON                    = 0x1
+	TCP_REPAIR_OPTIONS               = 0x16
+	TCP_REPAIR_QUEUE                 = 0x14
+	TCP_REPAIR_WINDOW                = 0x1d
+	TCP_SAVED_SYN                    = 0x1c
+	TCP_SAVE_SYN                     = 0x1b
+	TCP_SYNCNT                       = 0x7
+	TCP_S_DATA_IN                    = 0x4
+	TCP_S_DATA_OUT                   = 0x8
+	TCP_THIN_DUPACK                  = 0x11
+	TCP_THIN_LINEAR_TIMEOUTS         = 0x10
+	TCP_TIMESTAMP                    = 0x18
+	TCP_TX_DELAY                     = 0x25
+	TCP_ULP                          = 0x1f
+	TCP_USER_TIMEOUT                 = 0x12
+	TCP_WINDOW_CLAMP                 = 0xa
+	TCP_ZEROCOPY_RECEIVE             = 0x23
+	TCSAFLUSH                        = 0x2
+	TIOCCBRK                         = 0x5428
+	TIOCCONS                         = 0x541d
+	TIOCEXCL                         = 0x540c
+	TIOCGDEV                         = 0x40045432
+	TIOCGETD                         = 0x5424
+	TIOCGEXCL                        = 0x40045440
+	TIOCGICOUNT                      = 0x545d
+	TIOCGLCKTRMIOS                   = 0x5456
+	TIOCGPGRP                        = 0x40047477
+	TIOCGPKT                         = 0x40045438
+	TIOCGPTLCK                       = 0x40045439
+	TIOCGPTN                         = 0x40045430
+	TIOCGPTPEER                      = 0x20005441
+	TIOCGSERIAL                      = 0x541e
+	TIOCGSID                         = 0x5429
+	TIOCGSOFTCAR                     = 0x5419
+	TIOCLINUX                        = 0x541c
+	TIOCMBIC                         = 0x5417
+	TIOCMBIS                         = 0x5416
+	TIOCMGET                         = 0x5415
+	TIOCMIWAIT                       = 0x545c
+	TIOCMSET                         = 0x5418
+	TIOCM_CAR                        = 0x40
+	TIOCM_CD                         = 0x40
+	TIOCM_CTS                        = 0x20
+	TIOCM_DSR                        = 0x100
+	TIOCM_DTR                        = 0x2
+	TIOCM_LE                         = 0x1
+	TIOCM_LOOP                       = 0x8000
+	TIOCM_OUT1                       = 0x2000
+	TIOCM_OUT2                       = 0x4000
+	TIOCM_RI                         = 0x80
+	TIOCM_RNG                        = 0x80
+	TIOCM_RTS                        = 0x4
+	TIOCM_SR                         = 0x10
+	TIOCM_ST                         = 0x8
+	TIOCNOTTY                        = 0x5422
+	TIOCNXCL                         = 0x540d
+	TIOCOUTQ                         = 0x40047473
+	TIOCPKT                          = 0x5420
+	TIOCPKT_DATA                     = 0x0
+	TIOCPKT_DOSTOP                   = 0x20
+	TIOCPKT_FLUSHREAD                = 0x1
+	TIOCPKT_FLUSHWRITE               = 0x2
+	TIOCPKT_IOCTL                    = 0x40
+	TIOCPKT_NOSTOP                   = 0x10
+	TIOCPKT_START                    = 0x8
+	TIOCPKT_STOP                     = 0x4
+	TIOCSBRK                         = 0x5427
+	TIOCSCTTY                        = 0x540e
+	TIOCSERCONFIG                    = 0x5453
+	TIOCSERGETLSR                    = 0x5459
+	TIOCSERGETMULTI                  = 0x545a
+	TIOCSERGSTRUCT                   = 0x5458
+	TIOCSERGWILD                     = 0x5454
+	TIOCSERSETMULTI                  = 0x545b
+	TIOCSERSWILD                     = 0x5455
+	TIOCSER_TEMT                     = 0x1
+	TIOCSETD                         = 0x5423
+	TIOCSIG                          = 0x80045436
+	TIOCSLCKTRMIOS                   = 0x5457
+	TIOCSPGRP                        = 0x80047476
+	TIOCSPTLCK                       = 0x80045431
+	TIOCSSERIAL                      = 0x541f
+	TIOCSSOFTCAR                     = 0x541a
+	TIOCSTART                        = 0x2000746e
+	TIOCSTI                          = 0x5412
+	TIOCSTOP                         = 0x2000746f
+	TIOCVHANGUP                      = 0x5437
+	TOSTOP                           = 0x400000
+	TUNATTACHFILTER                  = 0x801054d5
+	TUNDETACHFILTER                  = 0x801054d6
+	TUNGETDEVNETNS                   = 0x200054e3
+	TUNGETFEATURES                   = 0x400454cf
+	TUNGETFILTER                     = 0x401054db
+	TUNGETIFF                        = 0x400454d2
+	TUNGETSNDBUF                     = 0x400454d3
+	TUNGETVNETBE                     = 0x400454df
+	TUNGETVNETHDRSZ                  = 0x400454d7
+	TUNGETVNETLE                     = 0x400454dd
+	TUNSETCARRIER                    = 0x800454e2
+	TUNSETDEBUG                      = 0x800454c9
+	TUNSETFILTEREBPF                 = 0x400454e1
+	TUNSETGROUP                      = 0x800454ce
+	TUNSETIFF                        = 0x800454ca
+	TUNSETIFINDEX                    = 0x800454da
+	TUNSETLINK                       = 0x800454cd
+	TUNSETNOCSUM                     = 0x800454c8
+	TUNSETOFFLOAD                    = 0x800454d0
+	TUNSETOWNER                      = 0x800454cc
+	TUNSETPERSIST                    = 0x800454cb
+	TUNSETQUEUE                      = 0x800454d9
+	TUNSETSNDBUF                     = 0x800454d4
+	TUNSETSTEERINGEBPF               = 0x400454e0
+	TUNSETTXFILTER                   = 0x800454d1
+	TUNSETVNETBE                     = 0x800454de
+	TUNSETVNETHDRSZ                  = 0x800454d8
+	TUNSETVNETLE                     = 0x800454dc
+	VDISCARD                         = 0xf
+	VEOF                             = 0x0
+	VEOL                             = 0x1
+	VEOL2                            = 0x2
+	VERASE                           = 0x3
+	VINTR                            = 0x8
+	VKILL                            = 0x5
+	VLNEXT                           = 0xe
+	VMIN                             = 0x10
+	VQUIT                            = 0x9
+	VREPRINT                         = 0x6
+	VSTART                           = 0xc
+	VSTOP                            = 0xd
+	VSUSP                            = 0xa
+	VSWTC                            = 0x7
+	VT0                              = 0x0
+	VT1                              = 0x10000
+	VTDLY                            = 0x10000
+	VTIME                            = 0x11
+	VWERASE                          = 0x4
+	WALL                             = 0x40000000
+	WCLONE                           = 0x80000000
+	WCONTINUED                       = 0x8
+	WEXITED                          = 0x4
+	WNOHANG                          = 0x1
+	WNOTHREAD                        = 0x20000000
+	WNOWAIT                          = 0x1000000
+	WORDSIZE                         = 0x40
+	WSTOPPED                         = 0x2
+	WUNTRACED                        = 0x2
+)
+
+// Errors
+const (
+	E2BIG           = Errno(0x7)
+	EACCES          = Errno(0xd)
+	EADDRINUSE      = Errno(0x30)
+	EADDRNOTAVAIL   = Errno(0x31)
+	EADV            = Errno(0x6b)
+	EAFNOSUPPORT    = Errno(0x2f)
+	EAGAIN          = Errno(0x23)
+	EALREADY        = Errno(0x25)
+	EBADE           = Errno(0x61)
+	EBADF           = Errno(0x9)
+	EBADFD          = Errno(0x72)
+	EBADMSG         = Errno(0x54)
+	EBADR           = Errno(0x62)
+	EBADRQC         = Errno(0x65)
+	EBADSLT         = Errno(0x66)
+	EBFONT          = Errno(0x68)
+	EBUSY           = Errno(0x10)
+	ECANCELED       = Errno(0x83)
+	ECHILD          = Errno(0xa)
+	ECHRNG          = Errno(0x58)
+	ECOMM           = Errno(0x6d)
+	ECONNABORTED    = Errno(0x35)
+	ECONNREFUSED    = Errno(0x3d)
+	ECONNRESET      = Errno(0x36)
+	EDEADLK         = Errno(0xb)
+	EDEADLOCK       = Errno(0xb)
+	EDESTADDRREQ    = Errno(0x27)
+	EDOM            = Errno(0x21)
+	EDOTDOT         = Errno(0x6f)
+	EDQUOT          = Errno(0x45)
+	EEXIST          = Errno(0x11)
+	EFAULT          = Errno(0xe)
+	EFBIG           = Errno(0x1b)
+	EHOSTDOWN       = Errno(0x40)
+	EHOSTUNREACH    = Errno(0x41)
+	EHWPOISON       = Errno(0x8b)
+	EIDRM           = Errno(0x51)
+	EILSEQ          = Errno(0x74)
+	EINPROGRESS     = Errno(0x24)
+	EINTR           = Errno(0x4)
+	EINVAL          = Errno(0x16)
+	EIO             = Errno(0x5)
+	EISCONN         = Errno(0x38)
+	EISDIR          = Errno(0x15)
+	EISNAM          = Errno(0x78)
+	EKEYEXPIRED     = Errno(0x85)
+	EKEYREJECTED    = Errno(0x87)
+	EKEYREVOKED     = Errno(0x86)
+	EL2HLT          = Errno(0x60)
+	EL2NSYNC        = Errno(0x59)
+	EL3HLT          = Errno(0x5a)
+	EL3RST          = Errno(0x5b)
+	ELIBACC         = Errno(0x7a)
+	ELIBBAD         = Errno(0x7b)
+	ELIBEXEC        = Errno(0x7e)
+	ELIBMAX         = Errno(0x7d)
+	ELIBSCN         = Errno(0x7c)
+	ELNRNG          = Errno(0x5d)
+	ELOOP           = Errno(0x3e)
+	EMEDIUMTYPE     = Errno(0x82)
+	EMFILE          = Errno(0x18)
+	EMLINK          = Errno(0x1f)
+	EMSGSIZE        = Errno(0x28)
+	EMULTIHOP       = Errno(0x6e)
+	ENAMETOOLONG    = Errno(0x3f)
+	ENAVAIL         = Errno(0x77)
+	ENETDOWN        = Errno(0x32)
+	ENETRESET       = Errno(0x34)
+	ENETUNREACH     = Errno(0x33)
+	ENFILE          = Errno(0x17)
+	ENOANO          = Errno(0x64)
+	ENOBUFS         = Errno(0x37)
+	ENOCSI          = Errno(0x5f)
+	ENODATA         = Errno(0x56)
+	ENODEV          = Errno(0x13)
+	ENOENT          = Errno(0x2)
+	ENOEXEC         = Errno(0x8)
+	ENOKEY          = Errno(0x84)
+	ENOLCK          = Errno(0x4d)
+	ENOLINK         = Errno(0x6a)
+	ENOMEDIUM       = Errno(0x81)
+	ENOMEM          = Errno(0xc)
+	ENOMSG          = Errno(0x50)
+	ENONET          = Errno(0x69)
+	ENOPKG          = Errno(0x5c)
+	ENOPROTOOPT     = Errno(0x2a)
+	ENOSPC          = Errno(0x1c)
+	ENOSR           = Errno(0x52)
+	ENOSTR          = Errno(0x57)
+	ENOSYS          = Errno(0x4e)
+	ENOTBLK         = Errno(0xf)
+	ENOTCONN        = Errno(0x39)
+	ENOTDIR         = Errno(0x14)
+	ENOTEMPTY       = Errno(0x42)
+	ENOTNAM         = Errno(0x76)
+	ENOTRECOVERABLE = Errno(0x89)
+	ENOTSOCK        = Errno(0x26)
+	ENOTSUP         = Errno(0x2d)
+	ENOTTY          = Errno(0x19)
+	ENOTUNIQ        = Errno(0x71)
+	ENXIO           = Errno(0x6)
+	EOPNOTSUPP      = Errno(0x2d)
+	EOVERFLOW       = Errno(0x70)
+	EOWNERDEAD      = Errno(0x88)
+	EPERM           = Errno(0x1)
+	EPFNOSUPPORT    = Errno(0x2e)
+	EPIPE           = Errno(0x20)
+	EPROTO          = Errno(0x55)
+	EPROTONOSUPPORT = Errno(0x2b)
+	EPROTOTYPE      = Errno(0x29)
+	ERANGE          = Errno(0x22)
+	EREMCHG         = Errno(0x73)
+	EREMOTE         = Errno(0x47)
+	EREMOTEIO       = Errno(0x79)
+	ERESTART        = Errno(0x7f)
+	ERFKILL         = Errno(0x8a)
+	EROFS           = Errno(0x1e)
+	ESHUTDOWN       = Errno(0x3a)
+	ESOCKTNOSUPPORT = Errno(0x2c)
+	ESPIPE          = Errno(0x1d)
+	ESRCH           = Errno(0x3)
+	ESRMNT          = Errno(0x6c)
+	ESTALE          = Errno(0x46)
+	ESTRPIPE        = Errno(0x80)
+	ETIME           = Errno(0x53)
+	ETIMEDOUT       = Errno(0x3c)
+	ETOOMANYREFS    = Errno(0x3b)
+	ETXTBSY         = Errno(0x1a)
+	EUCLEAN         = Errno(0x75)
+	EUNATCH         = Errno(0x5e)
+	EUSERS          = Errno(0x44)
+	EWOULDBLOCK     = Errno(0x23)
+	EXDEV           = Errno(0x12)
+	EXFULL          = Errno(0x63)
+)
+
+// Signals
+const (
+	SIGABRT   = Signal(0x6)
+	SIGALRM   = Signal(0xe)
+	SIGBUS    = Signal(0xa)
+	SIGCHLD   = Signal(0x14)
+	SIGCLD    = Signal(0x14)
+	SIGCONT   = Signal(0x13)
+	SIGEMT    = Signal(0x7)
+	SIGFPE    = Signal(0x8)
+	SIGHUP    = Signal(0x1)
+	SIGILL    = Signal(0x4)
+	SIGINFO   = Signal(0x1d)
+	SIGINT    = Signal(0x2)
+	SIGIO     = Signal(0x17)
+	SIGIOT    = Signal(0x6)
+	SIGKILL   = Signal(0x9)
+	SIGPIPE   = Signal(0xd)
+	SIGPOLL   = Signal(0x17)
+	SIGPROF   = Signal(0x1b)
+	SIGPWR    = Signal(0x1d)
+	SIGQUIT   = Signal(0x3)
+	SIGSEGV   = Signal(0xb)
+	SIGSTOP   = Signal(0x11)
+	SIGSYS    = Signal(0xc)
+	SIGTERM   = Signal(0xf)
+	SIGTRAP   = Signal(0x5)
+	SIGTSTP   = Signal(0x12)
+	SIGTTIN   = Signal(0x15)
+	SIGTTOU   = Signal(0x16)
+	SIGURG    = Signal(0x10)
+	SIGUSR1   = Signal(0x1e)
+	SIGUSR2   = Signal(0x1f)
+	SIGVTALRM = Signal(0x1a)
+	SIGWINCH  = Signal(0x1c)
+	SIGXCPU   = Signal(0x18)
+	SIGXFSZ   = Signal(0x19)
+)
+
+// Error table
+var errors = [...]string{
+	1:   "operation not permitted",
+	2:   "no such file or directory",
+	3:   "no such process",
+	4:   "interrupted system call",
+	5:   "input/output error",
+	6:   "no such device or address",
+	7:   "argument list too long",
+	8:   "exec format error",
+	9:   "bad file descriptor",
+	10:  "no child processes",
+	11:  "resource deadlock avoided",
+	12:  "cannot allocate memory",
+	13:  "permission denied",
+	14:  "bad address",
+	15:  "block device required",
+	16:  "device or resource busy",
+	17:  "file exists",
+	18:  "invalid cross-device link",
+	19:  "no such device",
+	20:  "not a directory",
+	21:  "is a directory",
+	22:  "invalid argument",
+	23:  "too many open files in system",
+	24:  "too many open files",
+	25:  "inappropriate ioctl for device",
+	26:  "text file busy",
+	27:  "file too large",
+	28:  "no space left on device",
+	29:  "illegal seek",
+	30:  "read-only file system",
+	31:  "too many links",
+	32:  "broken pipe",
+	33:  "numerical argument out of domain",
+	34:  "numerical result out of range",
+	35:  "resource temporarily unavailable",
+	36:  "operation now in progress",
+	37:  "operation already in progress",
+	38:  "socket operation on non-socket",
+	39:  "destination address required",
+	40:  "message too long",
+	41:  "protocol wrong type for socket",
+	42:  "protocol not available",
+	43:  "protocol not supported",
+	44:  "socket type not supported",
+	45:  "operation not supported",
+	46:  "protocol family not supported",
+	47:  "address family not supported by protocol",
+	48:  "address already in use",
+	49:  "cannot assign requested address",
+	50:  "network is down",
+	51:  "network is unreachable",
+	52:  "network dropped connection on reset",
+	53:  "software caused connection abort",
+	54:  "connection reset by peer",
+	55:  "no buffer space available",
+	56:  "transport endpoint is already connected",
+	57:  "transport endpoint is not connected",
+	58:  "cannot send after transport endpoint shutdown",
+	59:  "too many references: cannot splice",
+	60:  "connection timed out",
+	61:  "connection refused",
+	62:  "too many levels of symbolic links",
+	63:  "file name too long",
+	64:  "host is down",
+	65:  "no route to host",
+	66:  "directory not empty",
+	68:  "too many users",
+	69:  "disk quota exceeded",
+	70:  "stale file handle",
+	71:  "object is remote",
+	77:  "no locks available",
+	78:  "function not implemented",
+	80:  "no message of desired type",
+	81:  "identifier removed",
+	82:  "out of streams resources",
+	83:  "timer expired",
+	84:  "bad message",
+	85:  "protocol error",
+	86:  "no data available",
+	87:  "device not a stream",
+	88:  "channel number out of range",
+	89:  "level 2 not synchronized",
+	90:  "level 3 halted",
+	91:  "level 3 reset",
+	92:  "package not installed",
+	93:  "link number out of range",
+	94:  "protocol driver not attached",
+	95:  "no CSI structure available",
+	96:  "level 2 halted",
+	97:  "invalid exchange",
+	98:  "invalid request descriptor",
+	99:  "exchange full",
+	100: "no anode",
+	101: "invalid request code",
+	102: "invalid slot",
+	104: "bad font file format",
+	105: "machine is not on the network",
+	106: "link has been severed",
+	107: "advertise error",
+	108: "srmount error",
+	109: "communication error on send",
+	110: "multihop attempted",
+	111: "RFS specific error",
+	112: "value too large for defined data type",
+	113: "name not unique on network",
+	114: "file descriptor in bad state",
+	115: "remote address changed",
+	116: "invalid or incomplete multibyte or wide character",
+	117: "structure needs cleaning",
+	118: "not a XENIX named type file",
+	119: "no XENIX semaphores available",
+	120: "is a named type file",
+	121: "remote I/O error",
+	122: "can not access a needed shared library",
+	123: "accessing a corrupted shared library",
+	124: ".lib section in a.out corrupted",
+	125: "attempting to link in too many shared libraries",
+	126: "cannot exec a shared library directly",
+	127: "interrupted system call should be restarted",
+	128: "streams pipe error",
+	129: "no medium found",
+	130: "wrong medium type",
+	131: "operation canceled",
+	132: "required key not available",
+	133: "key has expired",
+	134: "key has been revoked",
+	135: "key was rejected by service",
+	136: "owner died",
+	137: "state not recoverable",
+	138: "operation not possible due to RF-kill",
+	139: "memory page has hardware error",
+}
+
+// Signal table
+var signals = [...]string{
+	1:  "hangup",
+	2:  "interrupt",
+	3:  "quit",
+	4:  "illegal instruction",
+	5:  "trace/breakpoint trap",
+	6:  "aborted",
+	7:  "EMT trap",
+	8:  "floating point exception",
+	9:  "killed",
+	10: "bus error",
+	11: "segmentation fault",
+	12: "bad system call",
+	13: "broken pipe",
+	14: "alarm clock",
+	15: "terminated",
+	16: "urgent I/O condition",
+	17: "stopped (signal)",
+	18: "stopped",
+	19: "continued",
+	20: "child exited",
+	21: "stopped (tty input)",
+	22: "stopped (tty output)",
+	23: "I/O possible",
+	24: "CPU time limit exceeded",
+	25: "file size limit exceeded",
+	26: "virtual timer expired",
+	27: "profiling timer expired",
+	28: "window changed",
+	29: "power failure",
+	30: "user defined signal 1",
+	31: "user defined signal 2",
+}
diff --git a/src/syscall/zsyscall_linux_sw64.go b/src/syscall/zsyscall_linux_sw64.go
new file mode 100644
index 00000000..1d3df481
--- /dev/null
+++ b/src/syscall/zsyscall_linux_sw64.go
@@ -0,0 +1,1652 @@
+// mksyscall.pl -tags linux,sw64 syscall_linux.go syscall_linux_sw64.go
+// Code generated by the command above; DO NOT EDIT.
+
+//go:build linux && sw64
+
+package syscall
+
+import "unsafe"
+
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func faccessat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func faccessat2(dirfd int, path string, mode uint32, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(_SYS_faccessat2, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func fchmodat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func fchmodat2(dirfd int, path string, mode uint32, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(_SYS_fchmodat2, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(oldpath)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(newpath)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func pipe2(p *[2]_C_int, flags int) (err error) {
+	_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func readlinkat(dirfd int, path string, buf []byte) (n int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 unsafe.Pointer
+	if len(buf) > 0 {
+		_p1 = unsafe.Pointer(&buf[0])
+	} else {
+		_p1 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func symlinkat(oldpath string, newdirfd int, newpath string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(oldpath)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(newpath)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func unlinkat(dirfd int, path string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func utimensat(dirfd int, path string, times *[2]Timespec, flag int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flag), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getcwd(buf []byte) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(buf) > 0 {
+		_p0 = unsafe.Pointer(&buf[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) {
+	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)
+	wpid = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func ptrace(request int, pid int, addr uintptr, data uintptr) (err error) {
+	_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func ptracePtr(request int, pid int, addr uintptr, data unsafe.Pointer) (err error) {
+	_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(arg)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(source)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(target)
+	if err != nil {
+		return
+	}
+	var _p2 *byte
+	_p2, err = BytePtrFromString(fstype)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Acct(path string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Adjtimex(buf *Timex) (state int, err error) {
+	r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)
+	state = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Chdir(path string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Chroot(path string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Close(fd int) (err error) {
+	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Dup(oldfd int) (fd int, err error) {
+	r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Dup3(oldfd int, newfd int, flags int) (err error) {
+	_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func EpollCreate1(flag int) (fd int, err error) {
+	r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) {
+	_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fallocate(fd int, mode uint32, off int64, len int64) (err error) {
+	_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fchdir(fd int) (err error) {
+	_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fchmod(fd int, mode uint32) (err error) {
+	_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func fcntl(fd int, cmd int, arg int) (val int, err error) {
+	r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))
+	val = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fdatasync(fd int) (err error) {
+	_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Flock(fd int, how int) (err error) {
+	_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fsync(fd int) (err error) {
+	_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getdents(fd int, buf []byte) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(buf) > 0 {
+		_p0 = unsafe.Pointer(&buf[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getpgid(pid int) (pgid int, err error) {
+	r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)
+	pgid = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getpriority(which int, who int) (prio int, err error) {
+	r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)
+	prio = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getrusage(who int, rusage *Rusage) (err error) {
+	_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Gettid() (tid int) {
+	r0, _ := rawSyscallNoError(SYS_GETTID, 0, 0, 0)
+	tid = int(r0)
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getxattr(path string, attr string, dest []byte) (sz int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(attr)
+	if err != nil {
+		return
+	}
+	var _p2 unsafe.Pointer
+	if len(dest) > 0 {
+		_p2 = unsafe.Pointer(&dest[0])
+	} else {
+		_p2 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)
+	sz = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(pathname)
+	if err != nil {
+		return
+	}
+	r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))
+	watchdesc = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func InotifyInit1(flags int) (fd int, err error) {
+	r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) {
+	r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)
+	success = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Kill(pid int, sig Signal) (err error) {
+	_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Klogctl(typ int, buf []byte) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(buf) > 0 {
+		_p0 = unsafe.Pointer(&buf[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Listxattr(path string, dest []byte) (sz int, err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 unsafe.Pointer
+	if len(dest) > 0 {
+		_p1 = unsafe.Pointer(&dest[0])
+	} else {
+		_p1 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))
+	sz = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Mkdirat(dirfd int, path string, mode uint32) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Mknodat(dirfd int, path string, mode uint32, dev int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Nanosleep(time *Timespec, leftover *Timespec) (err error) {
+	_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func PivotRoot(newroot string, putold string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(newroot)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(putold)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func prlimit1(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) {
+	_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func read(fd int, p []byte) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(p) > 0 {
+		_p0 = unsafe.Pointer(&p[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(_p0), uintptr(len(p)))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Removexattr(path string, attr string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(attr)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Setdomainname(p []byte) (err error) {
+	var _p0 unsafe.Pointer
+	if len(p) > 0 {
+		_p0 = unsafe.Pointer(&p[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Sethostname(p []byte) (err error) {
+	var _p0 unsafe.Pointer
+	if len(p) > 0 {
+		_p0 = unsafe.Pointer(&p[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Setpgid(pid int, pgid int) (err error) {
+	_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Setsid() (pid int, err error) {
+	r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)
+	pid = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Settimeofday(tv *Timeval) (err error) {
+	_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Setpriority(which int, who int, prio int) (err error) {
+	_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Setxattr(path string, attr string, data []byte, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(attr)
+	if err != nil {
+		return
+	}
+	var _p2 unsafe.Pointer
+	if len(data) > 0 {
+		_p2 = unsafe.Pointer(&data[0])
+	} else {
+		_p2 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Sync() {
+	Syscall(SYS_SYNC, 0, 0, 0)
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Sysinfo(info *Sysinfo_t) (err error) {
+	_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Tee(rfd int, wfd int, len int, flags int) (n int64, err error) {
+	r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)
+	n = int64(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Tgkill(tgid int, tid int, sig Signal) (err error) {
+	_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Times(tms *Tms) (ticks uintptr, err error) {
+	r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)
+	ticks = uintptr(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Umask(mask int) (oldmask int) {
+	r0, _ := rawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)
+	oldmask = int(r0)
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Uname(buf *Utsname) (err error) {
+	_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Unmount(target string, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(target)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Unshare(flags int) (err error) {
+	_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func write(fd int, p []byte) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(p) > 0 {
+		_p0 = unsafe.Pointer(&p[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func exitThread(code int) (err error) {
+	_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func readlen(fd int, p *byte, np int) (n int, err error) {
+	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func munmap(addr uintptr, length uintptr) (err error) {
+	_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Madvise(b []byte, advice int) (err error) {
+	var _p0 unsafe.Pointer
+	if len(b) > 0 {
+		_p0 = unsafe.Pointer(&b[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Mprotect(b []byte, prot int) (err error) {
+	var _p0 unsafe.Pointer
+	if len(b) > 0 {
+		_p0 = unsafe.Pointer(&b[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Mlock(b []byte) (err error) {
+	var _p0 unsafe.Pointer
+	if len(b) > 0 {
+		_p0 = unsafe.Pointer(&b[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Munlock(b []byte) (err error) {
+	var _p0 unsafe.Pointer
+	if len(b) > 0 {
+		_p0 = unsafe.Pointer(&b[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Mlockall(flags int) (err error) {
+	_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Munlockall() (err error) {
+	_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getxpid() (pid int, ppid int) {
+	r0, r1 := rawSyscallNoError(SYS_GETXPID, 0, 0, 0)
+	pid = int(r0)
+	ppid = int(r1)
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fstat64(fd int, st *Stat_t) (err error) {
+	_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(st)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Lstat64(path string, st *Stat_t) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Stat64(path string, st *Stat_t) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getxuid() (uid int, euid int) {
+	r0, r1, _ := Syscall(SYS_GETXUID, 0, 0, 0)
+	uid = int(r0)
+	euid = int(r1)
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getxgid() (gid int, egid int) {
+	r0, r1, _ := Syscall(SYS_GETXGID, 0, 0, 0)
+	gid = int(r0)
+	egid = int(r1)
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Statfs(path string, buf *Statfs_t) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fstatfs(fd int, buf *Statfs_t) (err error) {
+	_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Dup2(oldfd int, newfd int) (err error) {
+	_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Fchown(fd int, uid int, gid int) (err error) {
+	_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Ftruncate(fd int, length int64) (err error) {
+	_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Getrlimit(resource int, rlim *Rlimit) (err error) {
+	_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func InotifyInit() (fd int, err error) {
+	r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Lchown(path string, uid int, gid int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Listen(s int, n int) (err error) {
+	_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func pread(fd int, p []byte, offset int64) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(p) > 0 {
+		_p0 = unsafe.Pointer(&p[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func pwrite(fd int, p []byte, offset int64) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(p) > 0 {
+		_p0 = unsafe.Pointer(&p[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Seek(fd int, offset int64, whence int) (off int64, err error) {
+	r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))
+	off = int64(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
+	r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)
+	written = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Setfsgid(gid int) (err error) {
+	_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Setfsuid(uid int) (err error) {
+	_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func setrlimit(resource int, rlim *Rlimit) (err error) {
+	_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Shutdown(fd int, how int) (err error) {
+	_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) {
+	r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))
+	n = int64(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func SyncFileRange(fd int, off int64, n int64, flags int) (err error) {
+	_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Truncate(path string, length int64) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) {
+	r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
+	_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
+	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getgroups(n int, list *_Gid_t) (nn int, err error) {
+	r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)
+	nn = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) {
+	_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) {
+	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func socket(domain int, typ int, proto int) (fd int, err error) {
+	r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
+	fd = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) {
+	_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
+	_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
+	_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(p) > 0 {
+		_p0 = unsafe.Pointer(&p[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) {
+	var _p0 unsafe.Pointer
+	if len(buf) > 0 {
+		_p0 = unsafe.Pointer(&buf[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func recvmsg(s int, msg *Msghdr, flags int) (n int, err error) {
+	r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func sendmsg(s int, msg *Msghdr, flags int) (n int, err error) {
+	r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) {
+	r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))
+	xaddr = uintptr(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *sigset_t) (n int, err error) {
+	r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Gettimeofday(tv *Timeval) (err error) {
+	_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(oldpath)
+	if err != nil {
+		return
+	}
+	var _p1 *byte
+	_p1, err = BytePtrFromString(newpath)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func Ustat(dev int, ubuf *Ustat_t) (err error) {
+	_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func futimesat(dirfd int, path string, times *[2]Timeval) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func utimes(path string, times *[2]Timeval) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) {
+	var _p0 *byte
+	_p0, err = BytePtrFromString(path)
+	if err != nil {
+		return
+	}
+	_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
+
+// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
+
+func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error) {
+	var _p0 unsafe.Pointer
+	if len(events) > 0 {
+		_p0 = unsafe.Pointer(&events[0])
+	} else {
+		_p0 = unsafe.Pointer(&_zero)
+	}
+	r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)
+	n = int(r0)
+	if e1 != 0 {
+		err = errnoErr(e1)
+	}
+	return
+}
diff --git a/src/syscall/zsysnum_linux_sw64.go b/src/syscall/zsysnum_linux_sw64.go
new file mode 100644
index 00000000..ab5bc966
--- /dev/null
+++ b/src/syscall/zsysnum_linux_sw64.go
@@ -0,0 +1,370 @@
+// mksysnum_linux.pl /usr/include/asm/unistd.h
+// Code generated by the command above; DO NOT EDIT.
+
+package syscall
+
+const (
+	SYS_EXIT                   = 1
+	SYS_FORK                   = 2
+	SYS_READ                   = 3
+	SYS_WRITE                  = 4
+	SYS_CLOSE                  = 6
+	SYS_LINK                   = 9
+	SYS_UNLINK                 = 10
+	SYS_CHDIR                  = 12
+	SYS_FCHDIR                 = 13
+	SYS_MKNOD                  = 14
+	SYS_CHMOD                  = 15
+	SYS_CHOWN                  = 16
+	SYS_BRK                    = 17
+	SYS_LSEEK                  = 19
+	SYS_GETXPID                = 20
+	SYS_UMOUNT2                = 22
+	SYS_SETUID                 = 23
+	SYS_GETXUID                = 24
+	SYS_PTRACE                 = 26
+	SYS_ACCESS                 = 33
+	SYS_SYNC                   = 36
+	SYS_KILL                   = 37
+	SYS_SETPGID                = 39
+	SYS_DUP                    = 41
+	SYS_PIPE                   = 42
+	SYS_OPEN                   = 45
+	SYS_GETXGID                = 47
+	SYS_ODD_SIGPROCMASK        = 48
+	SYS_ACCT                   = 51
+	SYS_SIGPENDING             = 52
+	SYS_IOCTL                  = 54
+	SYS_SYMLINK                = 57
+	SYS_READLINK               = 58
+	SYS_EXECVE                 = 59
+	SYS_UMASK                  = 60
+	SYS_CHROOT                 = 61
+	SYS_GETPGRP                = 63
+	SYS_VFORK                  = 66
+	SYS_STAT                   = 67
+	SYS_LSTAT                  = 68
+	SYS_MMAP                   = 71
+	SYS_MUNMAP                 = 73
+	SYS_MPROTECT               = 74
+	SYS_MADVISE                = 75
+	SYS_VHANGUP                = 76
+	SYS_GETGROUPS              = 79
+	SYS_SETGROUPS              = 80
+	SYS_SETPGRP                = 82
+	SYS_GETHOSTNAME            = 87
+	SYS_SETHOSTNAME            = 88
+	SYS_DUP2                   = 90
+	SYS_FSTAT                  = 91
+	SYS_FCNTL                  = 92
+	SYS_POLL                   = 94
+	SYS_FSYNC                  = 95
+	SYS_SETPRIORITY            = 96
+	SYS_SOCKET                 = 97
+	SYS_CONNECT                = 98
+	SYS_ACCEPT                 = 99
+	SYS_ODD_GETPRIORITY        = 100
+	SYS_SEND                   = 101
+	SYS_RECV                   = 102
+	SYS_SIGRETURN              = 103
+	SYS_BIND                   = 104
+	SYS_SETSOCKOPT             = 105
+	SYS_LISTEN                 = 106
+	SYS_SIGSUSPEND             = 111
+	SYS_RECVMSG                = 113
+	SYS_SENDMSG                = 114
+	SYS_GETSOCKOPT             = 118
+	SYS_SOCKETCALL             = 119
+	SYS_READV                  = 120
+	SYS_WRITEV                 = 121
+	SYS_FCHOWN                 = 123
+	SYS_FCHMOD                 = 124
+	SYS_RECVFROM               = 125
+	SYS_SETREUID               = 126
+	SYS_SETREGID               = 127
+	SYS_RENAME                 = 128
+	SYS_TRUNCATE               = 129
+	SYS_FTRUNCATE              = 130
+	SYS_FLOCK                  = 131
+	SYS_SETGID                 = 132
+	SYS_SENDTO                 = 133
+	SYS_SHUTDOWN               = 134
+	SYS_SOCKETPAIR             = 135
+	SYS_MKDIR                  = 136
+	SYS_RMDIR                  = 137
+	SYS_GETPEERNAME            = 141
+	SYS_GETRLIMIT              = 144
+	SYS_SETRLIMIT              = 145
+	SYS_SETSID                 = 147
+	SYS_QUOTACTL               = 148
+	SYS_GETSOCKNAME            = 150
+	SYS_SIGACTION              = 156
+	SYS_SETDOMAINNAME          = 166
+	SYS_BPF                    = 170
+	SYS_USERFAULTFD            = 171
+	SYS_MEMBARRIER             = 172
+	SYS_MLOCK2                 = 173
+	SYS_GETPID                 = 174
+	SYS_GETPPID                = 175
+	SYS_GETUID                 = 176
+	SYS_GETEUID                = 177
+	SYS_GETGID                 = 178
+	SYS_GETEGID                = 179
+	SYS_MSGCTL                 = 200
+	SYS_MSGGET                 = 201
+	SYS_MSGRCV                 = 202
+	SYS_MSGSND                 = 203
+	SYS_SEMCTL                 = 204
+	SYS_SEMGET                 = 205
+	SYS_SEMOP                  = 206
+	SYS_LCHOWN                 = 208
+	SYS_SHMAT                  = 209
+	SYS_SHMCTL                 = 210
+	SYS_SHMDT                  = 211
+	SYS_SHMGET                 = 212
+	SYS_MSYNC                  = 217
+	SYS_STATFS64               = 229
+	SYS_FSTATFS64              = 230
+	SYS_GETPGID                = 233
+	SYS_GETSID                 = 234
+	SYS_SIGALTSTACK            = 235
+	SYS_SYSFS                  = 254
+	SYS_GETSYSINFO             = 256
+	SYS_SETSYSINFO             = 257
+	SYS_PIDFD_SEND_SIGNAL      = 271
+	SYS_IO_URING_SETUP         = 272
+	SYS_IO_URING_ENTER         = 273
+	SYS_IO_URING_REGISTER      = 274
+	SYS_OPEN_TREE              = 275
+	SYS_MOVE_MOUNT             = 276
+	SYS_FSOPEN                 = 277
+	SYS_FSCONFIG               = 278
+	SYS_FSMOUNT                = 279
+	SYS_FSPICK                 = 280
+	SYS_PIDFD_OPEN             = 281
+	SYS_CLONE3                 = 282
+	SYS_CLOSE_RANGE            = 283
+	SYS_OPENAT2                = 284
+	SYS_PIDFD_GETFD            = 285
+	SYS_FACCESSAT2             = 286
+	SYS_PROCESS_MADVISE        = 287
+	SYS_PKEY_MPROTECT          = 288
+	SYS_PKEY_ALLOC             = 289
+	SYS_PKEY_FREE              = 290
+	SYS_GETPRIORITY            = 298
+	SYS_SIGPROCMASK            = 299
+	SYS_BDFLUSH                = 300
+	SYS_MOUNT                  = 302
+	SYS_SWAPOFF                = 304
+	SYS_GETDENTS               = 305
+	SYS_CREATE_MODULE          = 306
+	SYS_INIT_MODULE            = 307
+	SYS_DELETE_MODULE          = 308
+	SYS_GET_KERNEL_SYMS        = 309
+	SYS_SYSLOG                 = 310
+	SYS_REBOOT                 = 311
+	SYS_CLONE                  = 312
+	SYS_USELIB                 = 313
+	SYS_MLOCK                  = 314
+	SYS_MUNLOCK                = 315
+	SYS_MLOCKALL               = 316
+	SYS_MUNLOCKALL             = 317
+	SYS_SYSINFO                = 318
+	SYS_OLDUMOUNT              = 321
+	SYS_SWAPON                 = 322
+	SYS_TIMES                  = 323
+	SYS_PERSONALITY            = 324
+	SYS_SETFSUID               = 325
+	SYS_SETFSGID               = 326
+	SYS_USTAT                  = 327
+	SYS_STATFS                 = 328
+	SYS_FSTATFS                = 329
+	SYS_SCHED_SETPARAM         = 330
+	SYS_SCHED_GETPARAM         = 331
+	SYS_SCHED_SETSCHEDULER     = 332
+	SYS_SCHED_GETSCHEDULER     = 333
+	SYS_SCHED_YIELD            = 334
+	SYS_SCHED_GET_PRIORITY_MAX = 335
+	SYS_SCHED_GET_PRIORITY_MIN = 336
+	SYS_SCHED_RR_GET_INTERVAL  = 337
+	SYS_AFS_SYSCALL            = 338
+	SYS_UNAME                  = 339
+	SYS_NANOSLEEP              = 340
+	SYS_MREMAP                 = 341
+	SYS_NFSSERVCTL             = 342
+	SYS_SETRESUID              = 343
+	SYS_GETRESUID              = 344
+	SYS_PCICONFIG_READ         = 345
+	SYS_PCICONFIG_WRITE        = 346
+	SYS_QUERY_MODULE           = 347
+	SYS_PRCTL                  = 348
+	SYS_PREAD64                = 349
+	SYS_PWRITE64               = 350
+	SYS_RT_SIGRETURN           = 351
+	SYS_RT_SIGACTION           = 352
+	SYS_RT_SIGPROCMASK         = 353
+	SYS_RT_SIGPENDING          = 354
+	SYS_RT_SIGTIMEDWAIT        = 355
+	SYS_RT_SIGQUEUEINFO        = 356
+	SYS_RT_SIGSUSPEND          = 357
+	SYS_SELECT                 = 358
+	SYS_GETTIMEOFDAY           = 359
+	SYS_SETTIMEOFDAY           = 360
+	SYS_GETITIMER              = 361
+	SYS_SETITIMER              = 362
+	SYS_UTIMES                 = 363
+	SYS_GETRUSAGE              = 364
+	SYS_WAIT4                  = 365
+	SYS_ADJTIMEX               = 366
+	SYS_GETCWD                 = 367
+	SYS_CAPGET                 = 368
+	SYS_CAPSET                 = 369
+	SYS_SENDFILE               = 370
+	SYS_SETRESGID              = 371
+	SYS_GETRESGID              = 372
+	SYS_DIPC                   = 373
+	SYS_PIVOT_ROOT             = 374
+	SYS_MINCORE                = 375
+	SYS_PCICONFIG_IOBASE       = 376
+	SYS_GETDENTS64             = 377
+	SYS_GETTID                 = 378
+	SYS_READAHEAD              = 379
+	SYS_TKILL                  = 381
+	SYS_SETXATTR               = 382
+	SYS_LSETXATTR              = 383
+	SYS_FSETXATTR              = 384
+	SYS_GETXATTR               = 385
+	SYS_LGETXATTR              = 386
+	SYS_FGETXATTR              = 387
+	SYS_LISTXATTR              = 388
+	SYS_LLISTXATTR             = 389
+	SYS_FLISTXATTR             = 390
+	SYS_REMOVEXATTR            = 391
+	SYS_LREMOVEXATTR           = 392
+	SYS_FREMOVEXATTR           = 393
+	SYS_FUTEX                  = 394
+	SYS_SCHED_SETAFFINITY      = 395
+	SYS_SCHED_GETAFFINITY      = 396
+	SYS_TUXCALL                = 397
+	SYS_IO_SETUP               = 398
+	SYS_IO_DESTROY             = 399
+	SYS_IO_GETEVENTS           = 400
+	SYS_IO_SUBMIT              = 401
+	SYS_IO_CANCEL              = 402
+	SYS_IO_PGETEVENTS          = 403
+	SYS_RSEQ                   = 404
+	SYS_EXIT_GROUP             = 405
+	SYS_LOOKUP_DCOOKIE         = 406
+	SYS_EPOLL_CREATE           = 407
+	SYS_EPOLL_CTL              = 408
+	SYS_EPOLL_WAIT             = 409
+	SYS_REMAP_FILE_PAGES       = 410
+	SYS_SET_TID_ADDRESS        = 411
+	SYS_RESTART_SYSCALL        = 412
+	SYS_FADVISE64              = 413
+	SYS_TIMER_CREATE           = 414
+	SYS_TIMER_SETTIME          = 415
+	SYS_TIMER_GETTIME          = 416
+	SYS_TIMER_GETOVERRUN       = 417
+	SYS_TIMER_DELETE           = 418
+	SYS_CLOCK_SETTIME          = 419
+	SYS_CLOCK_GETTIME          = 420
+	SYS_CLOCK_GETRES           = 421
+	SYS_CLOCK_NANOSLEEP        = 422
+	SYS_SEMTIMEDOP             = 423
+	SYS_TGKILL                 = 424
+	SYS_STAT64                 = 425
+	SYS_LSTAT64                = 426
+	SYS_FSTAT64                = 427
+	SYS_VSERVER                = 428
+	SYS_MBIND                  = 429
+	SYS_GET_MEMPOLICY          = 430
+	SYS_SET_MEMPOLICY          = 431
+	SYS_MQ_OPEN                = 432
+	SYS_MQ_UNLINK              = 433
+	SYS_MQ_TIMEDSEND           = 434
+	SYS_MQ_TIMEDRECEIVE        = 435
+	SYS_MQ_NOTIFY              = 436
+	SYS_MQ_GETSETATTR          = 437
+	SYS_WAITID                 = 438
+	SYS_ADD_KEY                = 439
+	SYS_REQUEST_KEY            = 440
+	SYS_KEYCTL                 = 441
+	SYS_IOPRIO_SET             = 442
+	SYS_IOPRIO_GET             = 443
+	SYS_INOTIFY_INIT           = 444
+	SYS_INOTIFY_ADD_WATCH      = 445
+	SYS_INOTIFY_RM_WATCH       = 446
+	SYS_FDATASYNC              = 447
+	SYS_KEXEC_LOAD             = 448
+	SYS_MIGRATE_PAGES          = 449
+	SYS_OPENAT                 = 450
+	SYS_MKDIRAT                = 451
+	SYS_MKNODAT                = 452
+	SYS_FCHOWNAT               = 453
+	SYS_FUTIMESAT              = 454
+	SYS_FSTATAT64              = 455
+	SYS_UNLINKAT               = 456
+	SYS_RENAMEAT               = 457
+	SYS_LINKAT                 = 458
+	SYS_SYMLINKAT              = 459
+	SYS_READLINKAT             = 460
+	SYS_FCHMODAT               = 461
+	SYS_FACCESSAT              = 462
+	SYS_PSELECT6               = 463
+	SYS_PPOLL                  = 464
+	SYS_UNSHARE                = 465
+	SYS_SET_ROBUST_LIST        = 466
+	SYS_GET_ROBUST_LIST        = 467
+	SYS_SPLICE                 = 468
+	SYS_SYNC_FILE_RANGE        = 469
+	SYS_TEE                    = 470
+	SYS_VMSPLICE               = 471
+	SYS_MOVE_PAGES             = 472
+	SYS_GETCPU                 = 473
+	SYS_EPOLL_PWAIT            = 474
+	SYS_UTIMENSAT              = 475
+	SYS_SIGNALFD               = 476
+	SYS_TIMERFD                = 477
+	SYS_EVENTFD                = 478
+	SYS_RECVMMSG               = 479
+	SYS_FALLOCATE              = 480
+	SYS_TIMERFD_CREATE         = 481
+	SYS_TIMERFD_SETTIME        = 482
+	SYS_TIMERFD_GETTIME        = 483
+	SYS_SIGNALFD4              = 484
+	SYS_EVENTFD2               = 485
+	SYS_EPOLL_CREATE1          = 486
+	SYS_DUP3                   = 487
+	SYS_PIPE2                  = 488
+	SYS_INOTIFY_INIT1          = 489
+	SYS_PREADV                 = 490
+	SYS_PWRITEV                = 491
+	SYS_RT_TGSIGQUEUEINFO      = 492
+	SYS_PERF_EVENT_OPEN        = 493
+	SYS_FANOTIFY_INIT          = 494
+	SYS_FANOTIFY_MARK          = 495
+	SYS_PRLIMIT64              = 496
+	SYS_NAME_TO_HANDLE_AT      = 497
+	SYS_OPEN_BY_HANDLE_AT      = 498
+	SYS_CLOCK_ADJTIME          = 499
+	SYS_SYNCFS                 = 500
+	SYS_SETNS                  = 501
+	SYS_ACCEPT4                = 502
+	SYS_SENDMMSG               = 503
+	SYS_PROCESS_VM_READV       = 504
+	SYS_PROCESS_VM_WRITEV      = 505
+	SYS_KCMP                   = 506
+	SYS_FINIT_MODULE           = 507
+	SYS_SCHED_SETATTR          = 508
+	SYS_SCHED_GETATTR          = 509
+	SYS_RENAMEAT2              = 510
+	SYS_GETRANDOM              = 511
+	SYS_MEMFD_CREATE           = 512
+	SYS_EXECVEAT               = 513
+	SYS_SECCOMP                = 514
+	SYS_COPY_FILE_RANGE        = 515
+	SYS_PREADV2                = 516
+	SYS_PWRITEV2               = 517
+	SYS_STATX                  = 518
+)
diff --git a/src/syscall/ztypes_linux_sw64.go b/src/syscall/ztypes_linux_sw64.go
new file mode 100644
index 00000000..7b353127
--- /dev/null
+++ b/src/syscall/ztypes_linux_sw64.go
@@ -0,0 +1,628 @@
+// Code generated by cmd/cgo -godefs; DO NOT EDIT.
+// cgo -godefs /home/zhangjh/golang/src/syscall/types_linux.go
+
+package syscall
+
+const (
+	sizeofPtr      = 0x8
+	sizeofShort    = 0x2
+	sizeofInt      = 0x4
+	sizeofLong     = 0x8
+	sizeofLongLong = 0x8
+	PathMax        = 0x1000
+)
+
+type (
+	_C_short     int16
+	_C_int       int32
+	_C_long      int64
+	_C_long_long int64
+)
+
+type Timespec struct {
+	Sec  int64
+	Nsec int64
+}
+
+type Timeval struct {
+	Sec  int64
+	Usec int64
+}
+
+type Timex struct {
+	Modes     uint32
+	Offset    int64
+	Freq      int64
+	Maxerror  int64
+	Esterror  int64
+	Status    int32
+	Constant  int64
+	Precision int64
+	Tolerance int64
+	Time      Timeval
+	Tick      int64
+	Ppsfreq   int64
+	Jitter    int64
+	Shift     int32
+	Stabil    int64
+	Jitcnt    int64
+	Calcnt    int64
+	Errcnt    int64
+	Stbcnt    int64
+	Tai       int32
+	Pad_cgo_0 [44]byte
+}
+
+type Time_t int64
+
+type Tms struct {
+	Utime  int64
+	Stime  int64
+	Cutime int64
+	Cstime int64
+}
+
+type Utimbuf struct {
+	Actime  int64
+	Modtime int64
+}
+
+type Rusage struct {
+	Utime    Timeval
+	Stime    Timeval
+	Maxrss   int64
+	Ixrss    int64
+	Idrss    int64
+	Isrss    int64
+	Minflt   int64
+	Majflt   int64
+	Nswap    int64
+	Inblock  int64
+	Oublock  int64
+	Msgsnd   int64
+	Msgrcv   int64
+	Nsignals int64
+	Nvcsw    int64
+	Nivcsw   int64
+}
+
+type Rlimit struct {
+	Cur uint64
+	Max uint64
+}
+
+type _Gid_t uint32
+
+type Stat_t struct {
+	Dev               uint64
+	Ino               uint64
+	Rdev              uint64
+	Size              int64
+	Blocks            int64
+	Mode              uint32
+	Uid               uint32
+	Gid               uint32
+	Blksize           uint32
+	Nlink             uint32
+	X__pad2           int32
+	Atim              Timespec
+	Mtim              Timespec
+	Ctim              Timespec
+	X__glibc_reserved [3]int64
+}
+
+type statxTimestamp struct {
+	Sec         int64
+	Nsec        uint32
+	X__reserved int32
+}
+
+type statx_t struct {
+	Mask            uint32
+	Blksize         uint32
+	Attributes      uint64
+	Nlink           uint32
+	Uid             uint32
+	Gid             uint32
+	Mode            uint16
+	X__spare0       [1]uint16
+	Ino             uint64
+	Size            uint64
+	Blocks          uint64
+	Attributes_mask uint64
+	Atime           statxTimestamp
+	Btime           statxTimestamp
+	Ctime           statxTimestamp
+	Mtime           statxTimestamp
+	Rdev_major      uint32
+	Rdev_minor      uint32
+	Dev_major       uint32
+	Dev_minor       uint32
+	Mnt_id          uint64
+	X__spare2       uint64
+	X__spare3       [12]uint64
+}
+
+type Statfs_t struct {
+	Type    int64
+	Bsize   int64
+	Blocks  uint64
+	Bfree   uint64
+	Bavail  uint64
+	Files   uint64
+	Ffree   uint64
+	Fsid    Fsid
+	Namelen int64
+	Frsize  int64
+	Flags   int64
+	Spare   [4]int64
+}
+
+type Dirent struct {
+	Ino       uint64
+	Off       int64
+	Reclen    uint16
+	Type      uint8
+	Name      [256]int8
+	Pad_cgo_0 [5]byte
+}
+
+type Fsid struct {
+	X__val [2]int32
+}
+
+type Flock_t struct {
+	Type      int16
+	Whence    int16
+	Start     int64
+	Len       int64
+	Pid       int32
+	Pad_cgo_0 [4]byte
+}
+
+type RawSockaddrInet4 struct {
+	Family uint16
+	Port   uint16
+	Addr   [4]byte /* in_addr */
+	Zero   [8]uint8
+}
+
+type RawSockaddrInet6 struct {
+	Family   uint16
+	Port     uint16
+	Flowinfo uint32
+	Addr     [16]byte /* in6_addr */
+	Scope_id uint32
+}
+
+type RawSockaddrUnix struct {
+	Family uint16
+	Path   [108]int8
+}
+
+type RawSockaddrLinklayer struct {
+	Family   uint16
+	Protocol uint16
+	Ifindex  int32
+	Hatype   uint16
+	Pkttype  uint8
+	Halen    uint8
+	Addr     [8]uint8
+}
+
+type RawSockaddrNetlink struct {
+	Family uint16
+	Pad    uint16
+	Pid    uint32
+	Groups uint32
+}
+
+type RawSockaddr struct {
+	Family uint16
+	Data   [14]int8
+}
+
+type RawSockaddrAny struct {
+	Addr RawSockaddr
+	Pad  [96]int8
+}
+
+type _Socklen uint32
+
+type Linger struct {
+	Onoff  int32
+	Linger int32
+}
+
+type Iovec struct {
+	Base *byte
+	Len  uint64
+}
+
+type IPMreq struct {
+	Multiaddr [4]byte /* in_addr */
+	Interface [4]byte /* in_addr */
+}
+
+type IPMreqn struct {
+	Multiaddr [4]byte /* in_addr */
+	Address   [4]byte /* in_addr */
+	Ifindex   int32
+}
+
+type IPv6Mreq struct {
+	Multiaddr [16]byte /* in6_addr */
+	Interface uint32
+}
+
+type Msghdr struct {
+	Name       *byte
+	Namelen    uint32
+	Iov        *Iovec
+	Iovlen     uint64
+	Control    *byte
+	Controllen uint64
+	Flags      int32
+	Pad_cgo_0  [4]byte
+}
+
+type Cmsghdr struct {
+	Len   uint64
+	Level int32
+	Type  int32
+}
+
+type Inet4Pktinfo struct {
+	Ifindex  int32
+	Spec_dst [4]byte /* in_addr */
+	Addr     [4]byte /* in_addr */
+}
+
+type Inet6Pktinfo struct {
+	Addr    [16]byte /* in6_addr */
+	Ifindex uint32
+}
+
+type IPv6MTUInfo struct {
+	Addr RawSockaddrInet6
+	Mtu  uint32
+}
+
+type ICMPv6Filter struct {
+	Data [8]uint32
+}
+
+type Ucred struct {
+	Pid int32
+	Uid uint32
+	Gid uint32
+}
+
+type TCPInfo struct {
+	State          uint8
+	Ca_state       uint8
+	Retransmits    uint8
+	Probes         uint8
+	Backoff        uint8
+	Options        uint8
+	Rto            uint32
+	Ato            uint32
+	Snd_mss        uint32
+	Rcv_mss        uint32
+	Unacked        uint32
+	Sacked         uint32
+	Lost           uint32
+	Retrans        uint32
+	Fackets        uint32
+	Last_data_sent uint32
+	Last_ack_sent  uint32
+	Last_data_recv uint32
+	Last_ack_recv  uint32
+	Pmtu           uint32
+	Rcv_ssthresh   uint32
+	Rtt            uint32
+	Rttvar         uint32
+	Snd_ssthresh   uint32
+	Snd_cwnd       uint32
+	Advmss         uint32
+	Reordering     uint32
+	Rcv_rtt        uint32
+	Rcv_space      uint32
+	Total_retrans  uint32
+}
+
+const (
+	SizeofSockaddrInet4     = 0x10
+	SizeofSockaddrInet6     = 0x1c
+	SizeofSockaddrAny       = 0x70
+	SizeofSockaddrUnix      = 0x6e
+	SizeofSockaddrLinklayer = 0x14
+	SizeofSockaddrNetlink   = 0xc
+	SizeofLinger            = 0x8
+	SizeofIPMreq            = 0x8
+	SizeofIPMreqn           = 0xc
+	SizeofIPv6Mreq          = 0x14
+	SizeofMsghdr            = 0x38
+	SizeofCmsghdr           = 0x10
+	SizeofInet4Pktinfo      = 0xc
+	SizeofInet6Pktinfo      = 0x14
+	SizeofIPv6MTUInfo       = 0x20
+	SizeofICMPv6Filter      = 0x20
+	SizeofUcred             = 0xc
+	SizeofTCPInfo           = 0x68
+)
+
+const (
+	IFA_UNSPEC          = 0x0
+	IFA_ADDRESS         = 0x1
+	IFA_LOCAL           = 0x2
+	IFA_LABEL           = 0x3
+	IFA_BROADCAST       = 0x4
+	IFA_ANYCAST         = 0x5
+	IFA_CACHEINFO       = 0x6
+	IFA_MULTICAST       = 0x7
+	IFLA_UNSPEC         = 0x0
+	IFLA_ADDRESS        = 0x1
+	IFLA_BROADCAST      = 0x2
+	IFLA_IFNAME         = 0x3
+	IFLA_MTU            = 0x4
+	IFLA_LINK           = 0x5
+	IFLA_QDISC          = 0x6
+	IFLA_STATS          = 0x7
+	IFLA_COST           = 0x8
+	IFLA_PRIORITY       = 0x9
+	IFLA_MASTER         = 0xa
+	IFLA_WIRELESS       = 0xb
+	IFLA_PROTINFO       = 0xc
+	IFLA_TXQLEN         = 0xd
+	IFLA_MAP            = 0xe
+	IFLA_WEIGHT         = 0xf
+	IFLA_OPERSTATE      = 0x10
+	IFLA_LINKMODE       = 0x11
+	IFLA_LINKINFO       = 0x12
+	IFLA_NET_NS_PID     = 0x13
+	IFLA_IFALIAS        = 0x14
+	IFLA_MAX            = 0x37
+	RT_SCOPE_UNIVERSE   = 0x0
+	RT_SCOPE_SITE       = 0xc8
+	RT_SCOPE_LINK       = 0xfd
+	RT_SCOPE_HOST       = 0xfe
+	RT_SCOPE_NOWHERE    = 0xff
+	RT_TABLE_UNSPEC     = 0x0
+	RT_TABLE_COMPAT     = 0xfc
+	RT_TABLE_DEFAULT    = 0xfd
+	RT_TABLE_MAIN       = 0xfe
+	RT_TABLE_LOCAL      = 0xff
+	RT_TABLE_MAX        = 0xffffffff
+	RTA_UNSPEC          = 0x0
+	RTA_DST             = 0x1
+	RTA_SRC             = 0x2
+	RTA_IIF             = 0x3
+	RTA_OIF             = 0x4
+	RTA_GATEWAY         = 0x5
+	RTA_PRIORITY        = 0x6
+	RTA_PREFSRC         = 0x7
+	RTA_METRICS         = 0x8
+	RTA_MULTIPATH       = 0x9
+	RTA_FLOW            = 0xb
+	RTA_CACHEINFO       = 0xc
+	RTA_TABLE           = 0xf
+	RTN_UNSPEC          = 0x0
+	RTN_UNICAST         = 0x1
+	RTN_LOCAL           = 0x2
+	RTN_BROADCAST       = 0x3
+	RTN_ANYCAST         = 0x4
+	RTN_MULTICAST       = 0x5
+	RTN_BLACKHOLE       = 0x6
+	RTN_UNREACHABLE     = 0x7
+	RTN_PROHIBIT        = 0x8
+	RTN_THROW           = 0x9
+	RTN_NAT             = 0xa
+	RTN_XRESOLVE        = 0xb
+	RTNLGRP_NONE        = 0x0
+	RTNLGRP_LINK        = 0x1
+	RTNLGRP_NOTIFY      = 0x2
+	RTNLGRP_NEIGH       = 0x3
+	RTNLGRP_TC          = 0x4
+	RTNLGRP_IPV4_IFADDR = 0x5
+	RTNLGRP_IPV4_MROUTE = 0x6
+	RTNLGRP_IPV4_ROUTE  = 0x7
+	RTNLGRP_IPV4_RULE   = 0x8
+	RTNLGRP_IPV6_IFADDR = 0x9
+	RTNLGRP_IPV6_MROUTE = 0xa
+	RTNLGRP_IPV6_ROUTE  = 0xb
+	RTNLGRP_IPV6_IFINFO = 0xc
+	RTNLGRP_IPV6_PREFIX = 0x12
+	RTNLGRP_IPV6_RULE   = 0x13
+	RTNLGRP_ND_USEROPT  = 0x14
+	SizeofNlMsghdr      = 0x10
+	SizeofNlMsgerr      = 0x14
+	SizeofRtGenmsg      = 0x1
+	SizeofNlAttr        = 0x4
+	SizeofRtAttr        = 0x4
+	SizeofIfInfomsg     = 0x10
+	SizeofIfAddrmsg     = 0x8
+	SizeofRtMsg         = 0xc
+	SizeofRtNexthop     = 0x8
+)
+
+type NlMsghdr struct {
+	Len   uint32
+	Type  uint16
+	Flags uint16
+	Seq   uint32
+	Pid   uint32
+}
+
+type NlMsgerr struct {
+	Error int32
+	Msg   NlMsghdr
+}
+
+type RtGenmsg struct {
+	Family uint8
+}
+
+type NlAttr struct {
+	Len  uint16
+	Type uint16
+}
+
+type RtAttr struct {
+	Len  uint16
+	Type uint16
+}
+
+type IfInfomsg struct {
+	Family     uint8
+	X__ifi_pad uint8
+	Type       uint16
+	Index      int32
+	Flags      uint32
+	Change     uint32
+}
+
+type IfAddrmsg struct {
+	Family    uint8
+	Prefixlen uint8
+	Flags     uint8
+	Scope     uint8
+	Index     uint32
+}
+
+type RtMsg struct {
+	Family   uint8
+	Dst_len  uint8
+	Src_len  uint8
+	Tos      uint8
+	Table    uint8
+	Protocol uint8
+	Scope    uint8
+	Type     uint8
+	Flags    uint32
+}
+
+type RtNexthop struct {
+	Len     uint16
+	Flags   uint8
+	Hops    uint8
+	Ifindex int32
+}
+
+const (
+	SizeofSockFilter = 0x8
+	SizeofSockFprog  = 0x10
+)
+
+type SockFilter struct {
+	Code uint16
+	Jt   uint8
+	Jf   uint8
+	K    uint32
+}
+
+type SockFprog struct {
+	Len    uint16
+	Filter *SockFilter
+}
+
+type InotifyEvent struct {
+	Wd     int32
+	Mask   uint32
+	Cookie uint32
+	Len    uint32
+}
+
+const SizeofInotifyEvent = 0x10
+
+type PtraceRegs struct{}
+
+type ptracePsw struct {
+}
+
+type ptraceFpregs struct {
+}
+
+type ptracePer struct {
+}
+
+type FdSet struct {
+	Bits [16]int64
+}
+
+type Sysinfo_t struct {
+	Uptime    int64
+	Loads     [3]uint64
+	Totalram  uint64
+	Freeram   uint64
+	Sharedram uint64
+	Bufferram uint64
+	Totalswap uint64
+	Freeswap  uint64
+	Procs     uint16
+	Pad       uint16
+	Totalhigh uint64
+	Freehigh  uint64
+	Unit      uint32
+	X_f       [0]int8
+	Pad_cgo_0 [4]byte
+}
+
+type Utsname struct {
+	Sysname    [65]int8
+	Nodename   [65]int8
+	Release    [65]int8
+	Version    [65]int8
+	Machine    [65]int8
+	Domainname [65]int8
+}
+
+type Ustat_t struct {
+	Tfree     int32
+	Tinode    uint64
+	Fname     [6]int8
+	Fpack     [6]int8
+	Pad_cgo_0 [4]byte
+}
+
+type EpollEvent struct {
+	Events uint32
+	_      int32
+	Fd     int32
+	Pad    int32
+}
+
+const (
+	_AT_FDCWD            = -0x64
+	_AT_REMOVEDIR        = 0x200
+	_AT_SYMLINK_NOFOLLOW = 0x100
+	_AT_EACCESS          = 0x200
+	_AT_EMPTY_PATH       = 0x1000
+	_AT_NO_AUTOMOUNT     = 0x800
+	_STATX_BASIC_STATS   = 0x7ff
+)
+
+type pollFd struct {
+	Fd      int32
+	Events  int16
+	Revents int16
+}
+
+type Termios struct {
+	Iflag  uint32
+	Oflag  uint32
+	Cflag  uint32
+	Lflag  uint32
+	Cc     [32]uint8
+	Line   uint8
+	Ispeed uint32
+	Ospeed uint32
+}
+
+const (
+	IUCLC  = 0x1000
+	OLCUC  = 0x4
+	TCGETS = 0x402c7413
+	TCSETS = 0x802c7414
+	XCASE  = 0x4000
+)
diff --git a/src/vendor/golang.org/x/sys/cpu/byteorder.go b/src/vendor/golang.org/x/sys/cpu/byteorder.go
index 271055be..a1d69f2a 100644
--- a/src/vendor/golang.org/x/sys/cpu/byteorder.go
+++ b/src/vendor/golang.org/x/sys/cpu/byteorder.go
@@ -51,7 +51,8 @@ func hostByteOrder() byteOrder {
 		"nios2",
 		"ppc64le",
 		"riscv", "riscv64",
-		"sh":
+		"sh",
+		"sw64":
 		return littleEndian{}
 	case "armbe", "arm64be",
 		"m68k",
diff --git a/src/vendor/golang.org/x/sys/cpu/cpu_linux_noinit.go b/src/vendor/golang.org/x/sys/cpu/cpu_linux_noinit.go
index cd63e733..463a2f3b 100644
--- a/src/vendor/golang.org/x/sys/cpu/cpu_linux_noinit.go
+++ b/src/vendor/golang.org/x/sys/cpu/cpu_linux_noinit.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build linux && !arm && !arm64 && !mips64 && !mips64le && !ppc64 && !ppc64le && !s390x
+//go:build linux && !arm && !arm64 && !mips64 && !mips64le && !ppc64 && !ppc64le && !s390x && !sw64
 
 package cpu
 
diff --git a/src/vendor/golang.org/x/sys/cpu/cpu_linux_sw64.go b/src/vendor/golang.org/x/sys/cpu/cpu_linux_sw64.go
new file mode 100644
index 00000000..5ba384ef
--- /dev/null
+++ b/src/vendor/golang.org/x/sys/cpu/cpu_linux_sw64.go
@@ -0,0 +1,12 @@
+// Copyright 2020 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build linux && sw64
+// +build linux
+// +build sw64
+
+package cpu
+
+func doinit() {
+}
diff --git a/src/vendor/golang.org/x/sys/cpu/cpu_sw64.go b/src/vendor/golang.org/x/sys/cpu/cpu_sw64.go
new file mode 100644
index 00000000..e4c24c99
--- /dev/null
+++ b/src/vendor/golang.org/x/sys/cpu/cpu_sw64.go
@@ -0,0 +1,13 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build linux && sw64
+// +build sw64
+
+package cpu
+
+const cacheLineSize = 128
+
+func initOptions() {
+}
diff --git a/src/vendor/golang.org/x/sys/cpu/endian_little.go b/src/vendor/golang.org/x/sys/cpu/endian_little.go
index 48eccc4c..182c3f46 100644
--- a/src/vendor/golang.org/x/sys/cpu/endian_little.go
+++ b/src/vendor/golang.org/x/sys/cpu/endian_little.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build 386 || amd64 || amd64p32 || alpha || arm || arm64 || loong64 || mipsle || mips64le || mips64p32le || nios2 || ppc64le || riscv || riscv64 || sh || wasm
+//go:build 386 || amd64 || amd64p32 || alpha || arm || arm64 || loong64 || mipsle || mips64le || mips64p32le || nios2 || ppc64le || riscv || riscv64 || sh || wasm || sw64
 
 package cpu
 
diff --git a/test/nosplit.go b/test/nosplit.go
index e171d1da..ccf2ed3d 100644
--- a/test/nosplit.go
+++ b/test/nosplit.go
@@ -165,7 +165,7 @@ start 108 nosplit call f; f 0 nosplit; REJECT ppc64 ppc64le
 start 112 nosplit call f; f 0 nosplit; REJECT ppc64 ppc64le amd64 arm64
 start 116 nosplit call f; f 0 nosplit; REJECT ppc64 ppc64le amd64
 start 120 nosplit call f; f 0 nosplit; REJECT ppc64 ppc64le amd64 arm64
-start 124 nosplit call f; f 0 nosplit; REJECT ppc64 ppc64le amd64 386
+start 124 nosplit call f; f 0 nosplit; REJECT ppc64 ppc64le amd64 386 sw64
 start 128 nosplit call f; f 0 nosplit; REJECT
 start 132 nosplit call f; f 0 nosplit; REJECT
 start 136 nosplit call f; f 0 nosplit; REJECT
@@ -305,6 +305,9 @@ TestCases:
 		case "s390x":
 			ptrSize = 8
 			fmt.Fprintf(&buf, "#define REGISTER R10\n")
+		case "sw64":
+			ptrSize = 8
+			fmt.Fprintf(&buf, "#define REGISTER (R27)\n")
 		default:
 			fmt.Fprintf(&buf, "#define REGISTER AX\n")
 		}
-- 
2.50.0

